include struct.h
include enums.h
include macros.h

; TODO
;
;


; Still Testing
;

; DONE
;
; Make monster breathe
; Fix monster special attack
; Divine intervention doesn't convert illusion to real monster
; Make the Up Arrow act like it should.
; Fix a bug where if a monster's attack priority is lower than all of the party's attack priorities the monster can't attack.
; Fix Horn of Gods and Wand of Fury.
; Set a maximum negative AC of -50 to match Apple II. Otherwise it can wrap.
; Fix the incorrect saving throw values for monsters in _savingThrowCheck
; Fix the groupSize when a new monster group is created by summoning
; Clear the monHostile flag after the check.
; Fix the dun_monHostile function to affect the party only when there is a monster in the party.
; Call doSummon() with 15h (Black Slayer) 10 times as Tarjan's only attack.
; COSMETIC: Print a blank line between attacks from a breath attack 
; COSMETIC: Print an '!' after the kill string
; COSMETIC: Fix the output of get_Reward if you leave the chest. It skipped over "you recieved 0 pieces of gold"
; Add text casting of spells
; Lights now stay on when hitting an anti-magic square. 
; Fixed Sorcerer Sight spell to detect more than just trap squares.
; Fixed monster rosters for levels. 
; Fizzle spells when cast on an anti-magic square like BT1 and BT2.
; Print full spell name under "Known Spells" screen of a magic user
; Removed wait4IO from dunsq_doTrap
; Made the outdoor levels outdoor. Basically just call a different setBG routine and make lightDistance 4 in dun_buildView
; COSMETIC: Clear the screen after certain actions in dunMainLoop and wildMainLoop. Messages would linger and be confusing.
; COSMETIC: Fixed the spacing of "XX points of damage" in a breath attack
; Add poison damage check to the periodic check loop
; Fixed the drop rate for Harmonic Gems
; Fix HP Regen squares
; Fixed the level of chest traps
; Fix a bug in tavern_talkToBarkeep where the top 16 bits of the gold donated were
;   ignored. So if you tipped 65537, only 1 gold was removed.

.486
;.mmx
.model large

; Segment type: Pure code
seg000 segment byte public 'CODE' use16
        assume cs:seg000
        assume es:nothing, ss:nothing, ds:dseg, fs:nothing, gs:seg027
        ; Attributes: bp-based frame

_main proc far
	var_6= word ptr	-6
	var_4= word ptr	-4
	var_2= word ptr	-2
	arg_0= word ptr	 6
	arg_2= word ptr	 8
	arg_4= word ptr	 0Ah
	arg_27=	word ptr  2Dh

	push	bp
	mov	bp, sp
	mov	ax, 6
	call	someStackOperation

	mov	ax, 55h
	push	ax
	call	bigpic_initBuffers
	add	sp, 2

	sub	ax, ax
	push	ax
	mov	ax, offset s_thiefCfg
	push	ds
	push	ax
	call	open
	add	sp, 6
	mov	[bp+var_4], ax

	inc	ax
	jnz	short loc_10039
	mov	ax, 4
	push	ax
	call	far ptr sub_28424
	add	sp, 2

loc_10039:
	mov	ax, 6
	push	ax
	mov	ax, offset word_4243A
	mov	dx, seg	seg027
	push	dx
	push	ax
	push	[bp+var_4]
	call	read
	add	sp, 8
	push	[bp+var_4]
	call	close
	add	sp, 2
	mov	gs, seg027_x
	push	gs:word_4243E
	call	disk1Swap
	add	sp, 2
	cmp	[bp+arg_0], 1
	jg	short loc_1007E
	cmp	gs:word_4243A, 0
	jnz	short loc_100E7
loc_1007E:
	mov	gs:word_4243A, 1
	push	[bp+arg_4]
	push	[bp+arg_2]
	push	[bp+arg_0]
	call	configureBT3
	add	sp, 6
	mov	gs:word_4243C, ax
	mov	ax, 2
	push	ax
	mov	ax, offset s_thiefCfg
	push	ds
	push	ax
	call	open
	add	sp, 6
	mov	[bp+var_4], ax
	inc	ax
	jnz	short loc_100C5
	mov	ax, 4
	push	ax
	call	far ptr	sub_28424
	add	sp, 2
loc_100C5:
	mov	ax, 4
	push	ax
	mov	ax, offset word_4243A
	mov	dx, seg	seg027
	push	dx
	push	ax
	push	[bp+var_4]
	call	write
	add	sp, 8
	push	[bp+var_4]
	call	close
	add	sp, 2
loc_100E7:
	sub	ax, ax
	push	ax
	mov	bx, gs:word_4243C
	and	bx, 0Fh
	shl	bx, 1
	shl	bx, 1
	push	word ptr (graphicsDrivers+2)[bx]
	push	word ptr graphicsDrivers[bx]
	call	open
	add	sp, 6
	mov	[bp+var_4], ax
	inc	ax
	jnz	short loc_1011C
	mov	ax, 4
	push	ax
	call	far ptr	sub_28424
	add	sp, 2
loc_1011C:
	mov	ax, 18h
	push	ax
	mov	ax, offset monsterBuf
	mov	dx, seg	seg023
	push	dx
	push	ax
	push	[bp+var_4]
	call	read
	add	sp, 8
	mov	ax, 1068h
	push	ax
	mov	ax, offset vid_setMode
	mov	dx, seg	seg024
	push	dx
	push	ax
	push	[bp+var_4]
	call	read
	add	sp, 8
	push	[bp+var_4]
	call	close
	add	sp, 2
	mov	ax, 1
	push	ax
	call	far ptr	vid_setMode
	add	sp, 2
	sub	ax, ax
	push	ax
	call	far ptr j_nullsub_2
	add	sp, 2
	sub	ax, ax
	push	ax
	mov	ax, offset s_firstTitle
	push	ds
	push	ax
	call	open
	add	sp, 6
	mov	[bp+var_4], ax
	inc	ax
	jnz	short loc_1018E
	mov	ax, 4
	push	ax
	call	far ptr	sub_28424
	add	sp, 2
loc_1018E:
	mov	ax, 33000
	push	ax
	mov	ax, offset g_rosterCharacterBuffer
	mov	dx, seg	seg022
	push	dx
	push	ax
	push	[bp+var_4]
	call	read
	add	sp, 8
	push	[bp+var_4]
	call	close
	add	sp, 2
	mov	[bp+var_6], 0
	jmp	short loc_101BD
loc_101BA:
	inc	[bp+var_6]
loc_101BD:
	cmp	[bp+var_6], 8
	jge	short loc_101E6
	mov	ax, 3200
	push	ax
	call	_mallocMaybe
	add	sp, 2
	mov	bx, [bp+var_6]
	shl	bx, 1
	shl	bx, 1
	mov	word ptr gs:musicBufs._offset[bx], ax
	mov	gs:musicBufs._segment[bx], dx
	jmp	short loc_101BA
loc_101E6:
	mov	ax, 33000
	push	ax
	call	_mallocMaybe
	add	sp, 2
	mov	gs:word_42562, ax
	mov	gs:word_42564, dx
	push	dx
	push	ax
	mov	ax, offset g_rosterCharacterBuffer
	mov	dx, seg	seg022
	push	dx
	push	ax
	call	d3cmp_flate
	add	sp, 8
	mov	ax, offset g_rosterCharacterBuffer
	mov	dx, seg	seg022
	push	dx
	push	ax
	mov	ax, gs:word_42562
	mov	dx, gs:word_42564
	add	ax, 0Dh
	push	dx
	push	ax
	call	far ptr	sub_3E97D
	add	sp, 8
	sub	ax, ax
	push	ax
	mov	ax, offset s_titleScreen
	push	ds
	push	ax
	call	open
	add	sp, 6
	mov	[bp+var_4], ax
	inc	ax
	jnz	short loc_10266
	push	gs:word_42564
	push	gs:word_42562
	call	_freeMaybe
	add	sp, 4
	push	cs
	call	near ptr cleanupAndExit
loc_10266:
	mov	ax, 33000
	push	ax
	mov	ax, offset g_rosterCharacterBuffer
	mov	dx, seg	seg022
	push	dx
	push	ax
	push	[bp+var_4]
	call	read
	add	sp, 8
	push	[bp+var_4]
	call	close
	add	sp, 2
	push	gs:word_42564
	push	gs:word_42562
	mov	ax, offset g_rosterCharacterBuffer
	mov	dx, seg	seg022
	push	dx
	push	ax
	call	d3cmp_flate
	add	sp, 8
	mov	ax, offset g_rosterCharacterBuffer
	mov	dx, seg	seg022
	push	dx
	push	ax
	mov	ax, gs:word_42562
	mov	dx, gs:word_42564
	add	ax, 0Dh
	push	dx
	push	ax
	call	far ptr	sub_3E97D
	add	sp, 8
	sub	ax, ax
	push	ax
	mov	ax, offset s_musicAll
	push	ds
	push	ax
	call	open
	add	sp, 6
	mov	[bp+var_4], ax
	inc	ax
	jnz	short loc_102FB
	push	gs:word_42564
	push	gs:word_42562
	call	_freeMaybe
	add	sp, 4
	push	cs
	call	near ptr cleanupAndExit
loc_102FB:
	mov	ax, 0FFFFh
	push	ax
	mov	ax, gs:word_4243C
	mov	cl, 7
	sar	ax, cl
	add	ax, 10h
	cwd
	push	dx
	push	ax
	push	[bp+var_4]
	call	lseek
	add	sp, 8
	mov	ax, 2
	push	ax
	lea	ax, [bp+var_2]
	push	ss
	push	ax
	push	[bp+var_4]
	call	read
	add	sp, 8
	mov	ax, 0FFFFh
	push	ax
	mov	ax, [bp+var_2]
	cwd
	push	dx
	push	ax
	push	[bp+var_4]
	call	lseek
	add	sp, 8
	mov	ax, 9C4h
	push	ax
	mov	ax, 0
	mov	dx, seg	seg025
	push	dx
	push	ax
	push	[bp+var_4]
	call	read
	add	sp, 8
	mov	[bp+var_6], 0
	jmp	short loc_10366
loc_10363:
	inc	[bp+var_6]
loc_10366:
	cmp	[bp+var_6], 8
	jge	short loc_103D4
	mov	ax, 0FFFFh
	push	ax
	mov	ax, [bp+var_6]
	cwd
	shl	ax, 1
	rcl	dx, 1
	push	dx
	push	ax
	push	[bp+var_4]
	call	lseek
	add	sp, 8
	mov	ax, 2
	push	ax
	lea	ax, [bp+var_2]
	push	ss
	push	ax
	push	[bp+var_4]
	call	read
	add	sp, 8
	mov	ax, 0FFFFh
	push	ax
	mov	ax, [bp+var_2]
	cwd
	push	dx
	push	ax
	push	[bp+var_4]
	call	lseek
	add	sp, 8
	mov	ax, 3200
	push	ax
	mov	bx, [bp+var_6]
	shl	bx, 1
	shl	bx, 1
	push	gs:musicBufs._segment[bx]
	push	word ptr gs:musicBufs._offset[bx]
	push	[bp+var_4]
	call	read
	add	sp, 8
	jmp	short loc_10363
loc_103D4:
	push	[bp+var_4]
	call	close
	add	sp, 2
	call	sub_27F63
	mov	ax, 7
	push	ax
	mov	ax, 0FFh
	push	ax
	call	song_playSong
	add	sp, 4
	call	icons_read
	call	far ptr j_nullsub_3
	mov	ax, offset s_titleText
	push	ds
	push	ax
	call	intro_scrollText
	add	sp, 4
	sub	ax, ax
	push	ax
	mov	ax, offset s_bardscr
	push	ds
	push	ax
	call	open
	add	sp, 6
	mov	[bp+var_4], ax
	inc	ax
	jnz	short loc_1043E
	push	gs:word_42564
	push	gs:word_42562
	call	_freeMaybe
	add	sp, 4
	push	cs
	call	near ptr cleanupAndExit
loc_1043E:
	mov	ax, 80E8h
	push	ax
	mov	ax, offset g_rosterCharacterBuffer
	mov	dx, seg	seg022
	push	dx
	push	ax
	push	[bp+var_4]
	call	read
	add	sp, 8
	push	[bp+var_4]
	call	close
	add	sp, 2
	push	gs:word_42564
	push	gs:word_42562
	mov	ax, offset g_rosterCharacterBuffer
	mov	dx, seg	seg022
	push	dx
	push	ax
	call	d3cmp_flate
	add	sp, 8
	mov	ax, offset g_rosterCharacterBuffer
	mov	dx, seg	seg022
	push	dx
	push	ax
	mov	ax, gs:word_42562
	mov	dx, gs:word_42564
	add	ax, 0Dh
	push	dx
	push	ax
	call	far ptr	sub_3E97D
	add	sp, 8
	push	gs:word_42564
	push	gs:word_42562
	call	_freeMaybe
	add	sp, 4
	mov	ax, 4D0Ah
	push	ax
	call	_mallocMaybe
	add	sp, 2
	mov	gs:bigpicCellData_off, ax
	mov	gs:bigpicCellData_seg, dx
	push	cs
	call	near ptr map_resetLocation
	call	restoreGame
	push	g_mapRval
	push	cs
	call	near ptr gameLoop
	add	sp, 2
	push	cs
	call	near ptr cleanupAndExit
	mov	sp, bp
	pop	bp
	retf
_main endp

; Attributes: bp-based frame
;

cleanupAndExit proc far
	musicBufferP= word ptr	-4
	loopCounter= word ptr	-2

	push	bp
	mov	bp, sp
	mov	ax, 6
	call	someStackOperation
	call	sound_stop
	call	sub_2800B
	sub	ax, ax
	push	ax
	call	far ptr vid_setMode
	add	sp, 2

	mov	[bp+loopCounter], 0
l_freeMusicLoop:
	mov	bx, [bp+loopCounter]
	shl	bx, 1
	shl	bx, 1
	mov	ax, word ptr gs:musicBufs._offset[bx]
	mov	dx, gs:musicBufs._segment[bx]
	mov	[bp+musicBufferP], ax
	or	ax, dx
	jz	short l_freeMusicLoopNext

	push	dx
	push	[bp+musicBufferP]
	call	_freeMaybe
	add	sp, 4

l_freeMusicLoopNext:
	inc	[bp+loopCounter]
	cmp	[bp+loopCounter], 8
	jl	short l_freeMusicLoop

loc_10550:
	mov	ax, 1
	push	ax
	call	far ptr sub_28424
	add	sp, 2
	mov	sp, bp
	pop	bp
	retf
cleanupAndExit endp

; Attributes: bp-based frame

gameLoop proc far
	currentState= word ptr	 6

	push	bp
	mov	bp, sp
	call	far ptr j_nullsub_3

l_loop:
	cmp	[bp+currentState], 0FFh		; 0FFh - Exit game
	jz	short l_return

	mov	g_mapRval, 0
	mov	ax, [bp+currentState]

	cmp	ax, gameState_inCamp
	jz	short l_enterCamp

	cmp	ax, gameState_inWilderness
	jz	short l_enterWild

	cmp	ax, gameState_inDungeon
	jz	short l_enterDungeon

	cmp	ax, gameState_partyDied
	jz	short l_party_died

	jmp	short l_return

l_enterCamp:
	call	camp_enter
	mov	[bp+currentState], ax
	jmp	short l_loop

l_enterWild:
	push	cs
	call	near ptr wild_main
	mov	[bp+currentState], ax
	jmp	short l_loop

l_enterDungeon:
	mov	inDungeonMaybe, 1
	push	cs
	call	near ptr dun_main
	mov	[bp+currentState], ax
	mov	inDungeonMaybe, 0
	jmp	short l_loop

l_party_died:
	call	party_died
	mov	[bp+currentState], ax
	jmp	short l_loop

l_return:
	mov	sp, bp
	pop	bp
	retf
gameLoop endp

; Attributes: bp-based frame

dun_main proc far

	var_26=	dword ptr -24h
	var_20=	word ptr -20h
	dungeonName=	word ptr -1Eh
	var_E= word ptr	-0Eh
	var_C= word ptr	-0Ch
	var_A= word ptr	-0Ah
	var_8= word ptr	-8
	inKey= word ptr	-6
	levP= dword ptr	-4

	push	bp
	mov	bp, sp
	mov	ax, 24h
	call	someStackOperation
	push	si

	mov	word ptr [bp+levP], offset g_rosterCharacterBuffer
	mov	word ptr [bp+levP+2], seg seg022

	mov	ax, offset g_rosterCharacterBuffer
	mov	dx, seg	seg022
	push	dx
	push	ax
	mov	ax, dunLevelIndex
	add	ax, 10
	push	ax
	call	map_read
	add	sp, 6

	lfs	bx, [bp+levP]
	mov	al, fs:[bx+dun_t.levFlags]
	sub	ah, ah
	mov	cl, 6
	shr	ax, cl
	and	ax, 3
	add	ax, 3
	push	ax
	call	map_readGraphics
	add	sp, 2

	lfs	bx, [bp+levP]
	mov	al, fs:[bx+dun_t.monIndex]
	sub	ah, ah
	push	ax
	call	map_readMonsters
	add	sp, 2

	lea	ax, [bp+dungeonName]
	push	ss
	push	ax
	push	word ptr [bp+levP+2]
	push	word ptr [bp+levP]
	call	unmaskString
	add	sp, 8

	lfs	bx, [bp+levP]
	mov	al, fs:[bx+dun_t._width]
	mov	g_dunWidth, al
	mov	al, fs:[bx+dun_t._height]
	mov	g_dunHeight, al
	mov	al, fs:[bx+dun_t.levelNum]
	sub	ah, ah
	mov	g_dunLevelNum,	ax
	mov	al, fs:[bx+dun_t.levFlags]
	mov	g_levelFlags, al
	and	al, 7
	mov	g_levelNumber, al

	cmp	gs:levelChangedFlag, 0
	jz	short l_skipDeltaSQEN

	; Add deltaSqN and deltaSqE to sq_north and sq_east
	mov	al, fs:[bx+dun_t.deltaSqN]
	cbw
	sub	sq_north, ax
	mov	al, fs:[bx+dun_t.deltaSqE]
	cbw
	sub	sq_east, ax
	mov	gs:levelChangedFlag, 0

l_skipDeltaSQEN:
	mov	ax, bx
	mov	dx, word ptr [bp+levP+2]
	add	ax, 24h	
	mov	gs:mapDataOff, ax
	mov	gs:mapDataSeg, dx
	mov	[bp+var_C], 0
	mov	dl, g_dunHeight
	sub	dh, dh

l_popRowLoop_enter:
	cmp	dx, [bp+var_C]
	jbe	short l_popRowLoop_exit
	mov	ax, [bp+var_C]
	shl	ax, 1
	add	ax, gs:mapDataOff
	mov	word ptr [bp+var_26], ax
	mov	ax, gs:mapDataSeg
	mov	word ptr [bp+var_26+2],	ax
	lfs	bx, [bp+var_26]
	mov	ah, fs:[bx+1]
	sub	al, al
	mov	cl, fs:[bx]
	sub	ch, ch
	add	ax, cx
	add	ax, 0
	mov	bx, [bp+var_C]
	shl	bx, 1
	shl	bx, 1
	mov	word ptr gs:rowOffset[bx], ax
	mov	word ptr gs:(rowOffset+2)[bx], seg seg022
	inc	[bp+var_C]
	jmp	short l_popRowLoop_enter

l_popRowLoop_exit::
	mov	ax, word ptr [bp+levP]
	mov	dx, word ptr [bp+levP+2]
	add	ax, 22h	
	mov	gs:mapDataOff, ax
	mov	gs:mapDataSeg, dx

l_wander_check:
	call	random
	test	al, 0FCh
	jnz	short l_battleCheck
	call	dun_wanderingCreature

l_battleCheck:
	cmp	g_partyAttackFlag, 0
	jnz	short l_doBattle

	cmp	byte_4EECC, 0
	jnz	short l_doBattle

	call	random
	test	al, 3Fh
	jnz	short loc_107BE

	cmp	gs:byte_42296, 0FFh
	jz	short loc_107BE

	cmp	gs:songAntiMonster, 0
	jnz	short loc_107BE

l_doBattle:
	call	bat_init
	or	ax, ax
	jnz	l_returnPartyDied
	call	text_clear

loc_107BE:
	push	sq_north
	push	sq_east
	push	seg027_x
	push	offset rowOffset
	call	dun_doSpecialSquare
	add	sp, 8

	push	seg023_x
	push	offset graphicsBuf
	push	sq_north
	push	sq_east
	call	dun_buildView
	add	sp, 8
	mov	[bp+var_E], ax

	push	g_direction
	mov	al, g_dunHeight
	sub	ah, ah
	push	ax
	mov	al, g_dunWidth
	push	ax
	push	sq_north
	push	sq_east
	push	seg027_x
	push	offset rowOffset
	call	dun_setSquareField4
	add	sp, 0Eh

	push	g_direction
	push	sq_north
	push	sq_east
	call	dun_detectSquares
	add	sp, 6

	lea	ax, [bp+dungeonName]
	push	ss
	push	ax
	call	setTitle
	add	sp, 4

	sub	ax, ax
	push	ax
	push	gs:mapDataSeg
	push	gs:mapDataOff
	call	vm_execute
	add	sp, 6

l_ioLoop:
	cmp	g_mapRval, 0
	jnz	l_returnMapValue

	mov	ax, 0A000h
	push	ax
	call	getKey
	add	sp, 2
	mov	[bp+inKey], ax

	push	ax
	call	executeKeyboardCommand
	add	sp, 2
	mov	[bp+var_20], ax

	or	ax, ax
	jz	short loc_1090B

	mov	byte ptr g_printPartyFlag,	0

	cmp	g_mapRval, 0
	jnz	l_returnMapValue

loc_108D5:
	push	seg023_x
	mov	ax, offset graphicsBuf
	push	ax
	push	sq_north
	push	sq_east
	call	dun_buildView
	add	sp, 8
	mov	[bp+var_E], ax

	lea	ax, [bp+dungeonName]
	push	ss
	push	ax
	call	setTitle
	add	sp, 4
	call	text_clear

loc_1090B:
	cmp	[bp+var_20], 0
	jnz	short l_ioLoop
	mov	ax, [bp+inKey]

l_checkQuitKey:
	cmp	ax, 'Q'
	jnz	l_checkKeySplit

	call	quitGame
	or	ax, ax
	jz	l_checkMapValue

	mov	ax, gameState_quit
	jmp	l_return

l_checkKeySplit:
	jg	short l_checkDescendKey

l_checkMinimapKey:
	cmp	ax, '?'
	jnz	l_checkAscendKey

	mov	al, g_dunHeight
	sub	ah, ah
	push	ax
	mov	al, g_dunWidth
	push	ax
	push	sq_north
	push	sq_east
	push	seg027_x
	push	offset rowOffset
	call	minimap_show
	add	sp, 0Ch
	jmp	l_checkMapValue

l_checkAscendKey:
	cmp	ax, 'E'
	jnz	l_checkKickKey

	push	sq_north
	push	sq_east
	call	dun_ascendPortal
	add	sp, 4
	jmp	l_checkMapValue

l_checkKickKey:
	cmp	ax, 'K'
	jnz	l_checkMapValue
	jmp	l_moveForward
	
l_checkDescendKey:
	cmp	ax, 'W'
	jnz	l_checkForwardKey

	push	sq_north
	push	sq_east
	call	dun_descendPortal
	add	sp, 4
	jmp	l_checkMapValue

l_checkForwardKey:
	cmp	ax, dosKeys_upArrow
	jnz	l_checkLeftArrowKey
	
l_moveForward:
	push_imm	1
	push	[bp+var_E]
	call	dun_canAdvance
	add	sp, 4
	or	ax, ax
	jz	l_checkMapValue

	call	text_clear
	mov	si, g_direction
	shl	si, 1
	mov	ax, sq_north
	sub	ax, dirDeltaN[si]
	mov	[bp+var_8], ax
	mov	ax, dirDeltaE[si]
	add	ax, sq_east
	mov	[bp+var_A], ax

	mov	al, g_dunHeight
	sub	ah, ah
	push	ax
	push	[bp+var_8]
	call	wrapNumber
	add	sp, 4

	mov	sq_north, ax
	mov	al, g_dunWidth
	sub	ah, ah
	push	ax
	push	[bp+var_A]
	call	wrapNumber
	add	sp, 4
	mov	sq_east, ax
	mov	gs:wallIsPhased, 0
	jmp	l_checkMapValue

l_checkLeftArrowKey:
	cmp	ax, dosKeys_leftArrow
	jnz	l_checkRightArrowKey
	mov	bx, 3
	jmp	l_incDirFacing

l_checkRightArrowKey:
	cmp	ax, dosKeys_rightArrow
	jnz	l_checkDownArrowKey
	mov	bx, 1
	jmp	l_incDirFacing

l_checkDownArrowKey:
	cmp	ax, dosKeys_downArrow
	jnz	l_checkMapValue
	mov	bx, 2

l_incDirFacing:
	mov	ax, g_direction
	add	ax, bx
	and	ax, 3
	mov	g_direction, ax
	mov	gs:wallIsPhased, 0
	call	text_clear

l_checkMapValue:
	cmp	g_mapRval, 0
	jz	l_wander_check

l_returnMapValue:
	mov	ax, g_mapRval
	jmp	short l_return

l_returnPartyDied:
	mov	ax, gameState_partyDied

l_return:
	pop	si
	mov	sp, bp
	pop	bp
	retf
dun_main endp

; Attributes: bp-based frame

dun_setSquareField4 proc far

	var_6= word ptr	-6
	var_4= word ptr	-4
	var_2= word ptr	-2
	rowBuf=	dword ptr  6
	sqE= word ptr  0Ah
	sqN= word ptr  0Ch
	_width=	word ptr  0Eh
	_height= word ptr  10h
	direction= word ptr  12h

	push	bp
	mov	bp, sp
	mov	ax, 6
	call	someStackOperation
	push	si

	; sqE * 5
	mov	bx, [bp+sqE]
	mov	ax, bx
	shl	bx, 1
	shl	bx, 1
	add	bx, ax
	mov	ax, bx				; ax = sqE * 5

	mov	bx, [bp+sqN]
	shl	bx, 1
	shl	bx, 1				; bx = sqN * 4
	lfs	si, [bp+rowBuf]
	lfs	si, fs:[bx+si]
	mov	bx, ax
	or	byte ptr fs:[bx+si+4], 9

	mov	[bp+var_6], 0
	jmp	short loc_10B74
loc_10B71:
	inc	[bp+var_6]
loc_10B74:
	mov	al, lightDistance
	sub	ah, ah
	cmp	ax, [bp+var_6]
	ja	short loc_10B86
	jmp	loc_10C1E
loc_10B86:
	push	[bp+sqN]
	push	[bp+sqE]
	push	cs
	call	near ptr dun_getWalls
	add	sp, 4
	mov	[bp+var_2], ax
	mov	ax, [bp+direction]
	dec	ax
	push	ax
	push	[bp+var_2]
	call	dungeon_getWallInDirection
	add	sp, 4
	mov	[bp+var_4], ax
	mov	bx, ax
	and	bx, 0Fh
	cmp	byte_44354[bx], 0
	jz	short loc_10BBC
	jmp	short loc_10C1E
loc_10BBC:
	push	[bp+_width]
	mov	bx, [bp+direction]
	shl	bx, 1
	mov	ax, dirDeltaE[bx]
	add	ax, [bp+sqE]
	push	ax
	push	cs
	call	near ptr wrapNumber
	add	sp, 4
	mov	[bp+sqE], ax

	push	[bp+_height]
	mov	ax, [bp+sqN]
	mov	bx, [bp+direction]
	shl	bx, 1
	sub	ax, dirDeltaN[bx]
	push	ax
	call	wrapNumber
	add	sp, 4
	mov	[bp+sqN], ax

	mov	bx, [bp+sqE]
	mov	ax, bx
	shl	bx, 1
	shl	bx, 1
	add	bx, ax
	mov	ax, bx
	mov	bx, [bp+sqN]
	shl	bx, 1
	shl	bx, 1
	lfs	si, [bp+rowBuf]
	lfs	si, fs:[bx+si]
	mov	bx, ax
	or	byte ptr fs:[bx+si+4], 1
	jmp	loc_10B71

loc_10C1E:
	pop	si
	mov	sp, bp
	pop	bp
	retf
dun_setSquareField4 endp

; Attributes: bp-based frame

dun_canAdvance proc far

	arg_0= word ptr	 6
	arg_2= word ptr	 8

	push	bp
	mov	bp, sp

	cmp	gs:stuckFlag, 0
	jz	short l_notStuck
	call	text_clear
	mov	ax, offset s_stuckEllipsis
	push	ds
	push	ax
	call	printString
	add	sp, 4
	jmp	l_returnZero

l_notStuck:
	mov	ax, [bp+arg_0]
	mov	cl, 4
	shr	ax, cl
	and	ax, 0Fh
	mov	bx, ax
	mov	al, byte_44344[bx]
	sub	ah, ah

	or	ax, ax
	jz	l_success

	cmp	ax, 1
	jb	l_returnZero

	cmp	ax, 2
	jg	l_returnZero

	cmp	[bp+arg_2], 0
	jz	l_returnZero

l_success:
	mov	g_sameSquareFlag, 0
	call	text_clear
	mov	ax, 1
	jmp	l_return
	
l_returnZero:
	xor	ax, ax

l_return:
	mov	sp, bp
	pop	bp
	retf
dun_canAdvance endp

; Attributes: bp-based frame

wild_main proc far

	var_4A=	dword ptr -48h
	inKey=	word ptr -44h
	levelName= word	ptr -42h
	square=	word ptr -32h
	levelP=	dword ptr -30h
	var_2C=	word ptr -2Ch
	var_2A=	word ptr -2Ah
	var_28=	word ptr -28h
	var_8= word ptr	-8
	var_6= word ptr	-6
	var_4= word ptr	-4
	var_2= word ptr	-2

	push	bp
	mov	bp, sp
	mov	ax, 48h
	call	someStackOperation
	push	si

	mov	word ptr [bp+levelP], offset g_rosterCharacterBuffer
	mov	word ptr [bp+levelP+2],	seg seg022

	call	far ptr j_nullsub_3

	mov	ax, offset g_rosterCharacterBuffer
	mov	dx, seg	seg022
	push	dx
	push	ax
	push	g_locationNumber
	call	map_read
	add	sp, 6

	lfs	bx, [bp+levelP]
	mov	al, fs:[bx+map_t.levFlags]
	sub	ah, ah
	mov	cl, 6
	shr	ax, cl
	and	ax, 3
	push	ax
	call	map_readGraphics
	add	sp, 2

	lfs	bx, [bp+levelP]
	mov	al, fs:[bx+map_t.monsterIndex]
	sub	ah, ah
	push	ax
	call	map_readMonsters
	add	sp, 2

	lea	ax, [bp+levelName]
	push	ss
	push	ax
	push	word ptr [bp+levelP+2]
	push	word ptr [bp+levelP]
	call	unmaskString
	add	sp, 8

	lfs	bx, [bp+levelP]
	mov	al, fs:[bx+map_t.levFlags]
	and	al, 7
	mov	g_levelNumber, al
	mov	al, fs:[bx+map_t._width]
	mov	gs:mapWidth, al
	mov	al, fs:[bx+map_t._height]
	mov	gs:mapHeight, al
	mov	al, fs:[bx+map_t.wrapFlag]
	and	al, 2
	mov	gs:g_wildWrapFlag, al
	mov	gs:mapDataOff, map_t.rowOffset
	mov	gs:mapDataSeg, seg seg022
	mov	[bp+var_2C], 0
	mov	dl, mapHeight
	sub	dh, dh

l_rowPopLoop_start:
	cmp	dx, [bp+var_2C]
	jbe	short l_rowPopLoop_exit
	mov	ax, [bp+var_2C]
	shl	ax, 1
	add	ax, gs:mapDataOff
	mov	word ptr [bp+var_4A], ax
	mov	ax, gs:mapDataSeg
	mov	word ptr [bp+var_4A+2],	ax
	lfs	bx, [bp+var_4A]
	mov	ah, fs:[bx+1]
	sub	al, al
	mov	cl, fs:[bx]
	sub	ch, ch
	add	ax, cx
	add	ax, 0
	mov	bx, [bp+var_2C]
	shl	bx, 1
	shl	bx, 1
	mov	word ptr gs:rowOffset[bx], ax
	mov	word ptr gs:(rowOffset+2)[bx], seg seg022
	inc	[bp+var_2C]
	jmp	short l_rowPopLoop_start

l_rowPopLoop_exit:
	mov	gs:mapDataOff, map_t.dataOffset
	mov	gs:mapDataSeg, seg seg022

l_loopStart:
	cmp	g_partyAttackFlag, 0
	jnz	short l_battleCheck

	lfs	bx, [bp+levelP]
	test	byte ptr fs:[bx+12h], 1
	jz	short l_mapExecute

	call	random
	test	al, 1Fh
	jnz	short l_mapExecute

	cmp	gs:songAntiMonster, 0
	jnz	short l_mapExecute

l_battleCheck:
	call	bat_init
	or	ax, ax
	jnz	l_returnPartyDied
	call	text_clear

l_mapExecute:
	sub	ax, ax
	push	ax
	push	gs:mapDataSeg
	push	gs:mapDataOff
	call	vm_execute
	add	sp, 6

loc_10E48:
	cmp	g_mapRval, 0
	jnz	l_returnMapValue

loc_10E5B:
	lea	ax, [bp+levelName]
	push	ss
	push	ax
	call	setTitle
	add	sp, 4

	push	sq_north
	push	sq_east
	call	wild_buildView
	add	sp, 4
	mov	[bp+square], ax

	mov	ax, 0A000h
	push	ax
	call	getKey
	add	sp, 2
	mov	[bp+var_2], ax

	push	ax
	call	executeKeyboardCommand
	add	sp, 2
	mov	[bp+inKey], ax
	or	ax, ax
	jz	short loc_10EEE

	mov	byte ptr g_printPartyFlag, 0
	cmp	g_mapRval, 0
	jnz	l_returnMapValue

loc_10EC0:
	push	sq_north
	push	sq_east
	call	wild_buildView
	add	sp, 4
	mov	[bp+square], ax

	lea	ax, [bp+levelName]
	push	ss
	push	ax
	call	setTitle
	add	sp, 4
	call	text_clear

loc_10EEE:
	cmp	[bp+inKey], 0
	jnz	loc_10E48

	mov	ax, [bp+var_2]

l_key_upArrow:
	cmp	ax, dosKeys_upArrow
	jnz	l_key_split

l_goForward:
	push	[bp+square]
	call	wild_enterBuilding
	add	sp, 2
	or	ax, ax
	jz	l_noBuilding

	cmp	g_mapRval, 0
	jnz	l_returnMapValue

l_noBuilding:
	push	[bp+square]
	call	wild_canAdvance
	add	sp, 2
	or	ax, ax
	jz	l_loopStart

	call	text_clear
	mov	si, g_direction
	shl	si, 1
	mov	ax, sq_north
	sub	ax, dirDeltaN[si]
	mov	[bp+var_8], ax
	mov	ax, sq_east
	add	ax, dirDeltaE[si]
	mov	[bp+var_2A], ax

	test	g_wildWrapFlag, 2
	jz	l_forwardNoWrap

	mov	al, mapHeight
	sub	ah, ah
	push	ax
	push	[bp+var_8]
	call	wrapNumber
	add	sp, 4
	mov	sq_north, ax

	mov	al, mapWidth
	sub	ah, ah
	push	ax
	push	[bp+var_2A]
	call	wrapNumber
	add	sp, 4
	mov	sq_east, ax
	jmp	l_loopStart

l_forwardNoWrap:
	cmp	[bp+var_8], 0
	jl	l_loopStart

	mov	al, mapHeight
	sub	ah, ah
	cmp	ax, [bp+var_8]
	jbe	l_loopStart

	cmp	[bp+var_2A], 0
	jl	l_loopStart

	mov	al, mapWidth
	cmp	ax, [bp+var_2A]
	jbe	l_loopStart

	mov	ax, [bp+var_8]
	mov	sq_north, ax
	mov	ax, [bp+var_2A]
	mov	sq_east, ax
	jmp	l_loopStart

l_key_split:
	jg	l_checkCenterKey

l_checkLocationKey:
	cmp	ax, '?'
	jnz	l_checkKickKey

	call	printLocation
	jmp	l_loopStart

l_checkKickKey:
	cmp	ax, 'K'
	jz	l_goForward

l_checkQuitKey:
	cmp	ax, 'Q'
	jnz	l_loopStart

	call	quitGame
	or	ax, ax
	jz	l_loopStart
	mov	ax, gameState_quit
	jmp	l_return

l_checkCenterKey:
	cmp	ax, dosKeys_center
	jz	l_goForward

l_checkLeftArrowKey:
	cmp	ax, dosKeys_leftArrow
	jnz	l_checkRightArrowKey
	mov	bx, 3
	jmp	l_incDirFacing

l_checkRightArrowKey:
	cmp	ax, dosKeys_rightArrow
	jnz	l_checkDownArrowKey
	mov	bx, 1
	jmp	l_incDirFacing

l_checkDownArrowKey:
	cmp	ax, dosKeys_downArrow
	jnz	l_loopStart
	mov	bx, 2

l_incDirFacing:
	mov	ax, g_direction
	add	ax, bx
	and	ax, 3
	mov	g_direction, ax

	mov	ax, offset s_facing
	push	ds
	push	ax
	lea	ax, [bp+var_28]
	push	ss
	push	ax
	call	strcat
	add	sp, 8

	mov	bx, g_direction
	shl	bx, 1
	shl	bx, 1
	push	word ptr (dirStringList+2)[bx]
	push	word ptr (dirStringList)[bx]
	push	dx
	push	ax
	call	strcat
	add	sp, 8

	lea	ax, [bp+var_28]
	push	ss
	push	ax
	call	printStringWClear
	add	sp, 4
	jmp	l_loopStart

l_returnMapValue:
	mov	ax, g_mapRval
	jmp	short l_return

l_returnPartyDied:
	mov	ax, gameState_partyDied

l_return:
	pop	si
	mov	sp, bp
	pop	bp
	retf
wild_main endp

; Attributes: bp-based frame

wild_canAdvance proc far

	arg_0= byte ptr	 6

	push	bp
	mov	bp, sp

	test	[bp+arg_0], 0F0h
	jz	l_returnOne

	mov	al, [bp+arg_0]
	and	al, 0F0h
	cmp	al, 0E0h
	jz	l_returnZero

	mov	al, [bp+arg_0]
	and	al, 0F0h
	cmp	al, 0F0h
	jz	l_returnOne

	mov	al, [bp+arg_0]
	and	al, 0Fh
	mov	cx, ax
	cmp	cl, 1
	sbb	ax, ax
	neg	ax
	jmp	l_return

l_returnZero:
	xor	ax, ax
	jmp	l_return

l_returnOne:
	mov	ax, 1

l_return:
	mov	sp, bp
	pop	bp
	retf

wild_canAdvance endp

; Attributes: bp-based frame

wild_enterBuilding proc far

	square=	word ptr  6

	push	bp
	mov	bp, sp

	mov	ax, [bp+square]
	mov	cl, 4
	sar	ax, cl
	and	ax, 0Fh

	sub	ax, 1
	cmp	ax, 8
	ja	l_returnZero
	add	ax, ax
	xchg	ax, bx
	jmp	cs:buildingOffsets[bx]

buildingOffsets dw offset l_camp ; 0x10
		dw offset l_tavern	; 0x20
		dw offset l_temple	; 0x30
		dw offset l_normalBuilding ; 0x40
		dw offset l_returnZero	; 0x50
		dw offset l_storageBuilding ; 0x60
		dw offset l_reviewBoard	; 0x70
		dw offset l_hallOfWizards	; 0x80
		dw offset l_bards		; 0x90

l_camp:
	call	camp_enter
	jmp	l_turnAround

l_tavern:
	call	tavern_enter
	jmp	l_turnAround

l_temple:
	call	temple_enter
	jmp	l_turnAround

l_normalBuilding:
	call	empty_enter
	jmp	l_turnAround

l_storageBuilding:
	call	storage_enter
	jmp	l_turnAround

l_reviewBoard:
	call	review_enter
	jmp	l_turnAround

l_hallOfWizards:
	call	wizardHall_enter
	jmp	l_turnAround

l_bards:
	call	bards_enter
	jmp	l_turnAround

l_returnZero:
	sub	ax, ax
	jmp	short l_return

l_turnAround:
	mov	g_mapRval, ax
	call	map_turnAround
	mov	ax, 1

l_return:
	mov	sp, bp
	pop	bp
	retf
wild_enterBuilding endp


; Attributes: bp-based frame
;

wild_buildView proc far

	viewStructP=	dword ptr -3Ch
	directionDeltaP=	dword ptr -38h
	counter= word ptr -34h
	deltaNorth= word ptr -32h
	squareList= byte	ptr -30h
	var_22=	byte ptr -20h
	deltaEast= word	ptr -1Ah
	graphicsBufferP= dword ptr -18h
	sqEast=	word ptr  6
	sqNorth= word ptr  8

	push	bp
	mov	bp, sp
	mov	ax, 3Ch
	call	someStackOperation
	push	si

	mov	word ptr [bp+graphicsBufferP], offset graphicsBuf
	mov	word ptr [bp+graphicsBufferP+2], seg seg023
	mov	bx, g_direction
	shl	bx, 1
	shl	bx, 1
	mov	ax, word ptr g_wild_deltaList[bx]
	mov	dx, word ptr (g_wild_deltaList+2)[bx]
	mov	word ptr [bp+directionDeltaP], ax
	mov	word ptr [bp+directionDeltaP+2], dx

	mov	[bp+counter], 20
l_getSquaresLoop:
	mov	ax, [bp+counter]
	shl	ax, 1
	add	ax, word ptr [bp+directionDeltaP]
	mov	dx, word ptr [bp+directionDeltaP+2]

	mov	word ptr [bp+viewStructP], ax
	mov	word ptr [bp+viewStructP+2],	dx
	lfs	bx, [bp+viewStructP]
	mov	al, fs:[bx+viewStruct.deltaEast]
	cbw
	add	ax, [bp+sqEast]
	mov	[bp+deltaEast],	ax

	mov	al, fs:[bx+viewStruct.deltaNorth]
	cbw
	add	ax, [bp+sqNorth]
	mov	[bp+deltaNorth], ax
	push	ax
	push	[bp+deltaEast]
	push	cs
	call	near ptr wild_getSquare
	add	sp, 4
	mov	si, [bp+counter]
	mov	[bp+si+squareList], al
	dec	[bp+counter]
	cmp	[bp+counter], 0
	jge	short l_getSquaresLoop

	mov	ax, 44h
	push	ax
	mov	ax, 0BBBBh
	push	ax
	mov	ax, offset bigpicBuf
	mov	dx, seg	seg021
	push	dx
	push	ax
	call	bigpic_memcpy
	add	sp, 8

	mov	[bp+counter], 0
l_drawTopologyLoop:
	mov	bx, [bp+counter]
	mov	al, g_wild_viewSquareIndexList[bx]
	cbw
	mov	si, ax
	mov	al, [bp+si+squareList]
	sub	ah, ah
	and	ax, 0Fh
	or	ax, ax
	jz	short l_drawTopologyNext

	push	[bp+graphicsBufferP+2]
	push	[bp+graphicsBufferP]
	dec	ax
	push	ax
	mov	al, g_wild_squareTopologyIndex[bx]
	cbw
	push	ax
	call	bigpic_drawTopology
	add	sp, 8

l_drawTopologyNext:
	inc	[bp+counter]
	cmp	[bp+counter], 17
	jl	short l_drawTopologyLoop

	mov	gs:byte_422A0, 0
	cmp	gs:isNight, 0
	jz	short l_return
	mov	ax, offset bigpicBuf
	mov	dx, seg	seg021
	push	dx
	push	ax
	call	bigpic_makeNight
	add	sp, 4

l_return:
	push	gs:bigpicCellData_seg
	push	gs:bigpicCellData_off
	mov	ax, offset bigpicBuf
	mov	dx, seg	seg021
	push	dx
	push	ax
	call	far ptr vid_drawBigpic
	add	sp, 8
	mov	al, [bp+var_22]
	sub	ah, ah

	pop	si
	mov	sp, bp
	pop	bp
	retf
wild_buildView endp

; Attributes: bp-based frame

dun_buildView proc far

	viewStructP=	dword ptr -56h
	directionDeltaP=	dword ptr -52h
	counter= word ptr -4Eh
	deltaSqN= word ptr -4Ch
	squareList=	word ptr -4Ah
	var_1E=	word ptr -1Ch
	deltaSqE= word ptr -6
	sqE= word ptr  6
	sqN= word ptr  8
	gbufOff= word ptr  0Ah
	gbufSeg= word ptr  0Ch

	push	bp
	mov	bp, sp
	mov	ax, 56h
	call	someStackOperation
	push	si

	mov	bx, g_direction
	shl	bx, 1
	shl	bx, 1
	mov	ax, word ptr g_dun_deltaList[bx]
	mov	dx, word ptr (g_dun_deltaList+2)[bx]
	mov	word ptr [bp+directionDeltaP], ax
	mov	word ptr [bp+directionDeltaP+2],	dx

	mov	[bp+counter], 24
l_getSquaresLoop:
	mov	ax, [bp+counter]
	shl	ax, 1
	add	ax, word ptr [bp+directionDeltaP]
	mov	dx, word ptr [bp+directionDeltaP+2]
	mov	word ptr [bp+viewStructP], ax
	mov	word ptr [bp+viewStructP+2],	dx
	lfs	bx, [bp+viewStructP]
	mov	al, fs:[bx+viewStruct.deltaEast]
	cbw
	add	ax, [bp+sqE]
	mov	[bp+deltaSqE], ax
	mov	al, fs:[bx+viewStruct.deltaNorth]
	cbw
	add	ax, [bp+sqN]
	mov	[bp+deltaSqN], ax
	push	ax
	push	[bp+deltaSqE]
	push	cs
	call	near ptr dun_getWalls
	add	sp, 4

	push	g_direction
	push	ax
	call	dungeon_getWallInDirection
	add	sp, 4

	mov	si, [bp+counter]
	shl	si, 1
	mov	[bp+si+squareList], ax
	dec	[bp+counter]
	cmp	[bp+counter], 0
	jge	short l_getSquaresLoop

	mov	[bp+counter], 33
loc_113D2:
	mov	si, [bp+counter]
	shl	si, 1
	lfs	bx, [bp+directionDeltaP]
	mov	al, fs:[bx+si]
	cbw
	add	ax, [bp+sqE]
	mov	[bp+deltaSqE], ax
	mov	al, fs:[bx+si+1]
	cbw
	add	ax, [bp+sqN]
	mov	[bp+deltaSqN], ax

	mov	al, g_dunHeight
	sub	ah, ah
	push	ax
	mov	al, g_dunWidth
	push	ax
	push	[bp+deltaSqN]
	push	[bp+deltaSqE]
	mov	ax, offset rowOffset
	mov	dx, seg	seg027
	push	dx
	push	ax
	push	cs
	call	near ptr sub_1156E
	add	sp, 0Ch
	mov	[bp+si+squareList], ax
	dec	[bp+counter]
	cmp	[bp+counter], 24
	jg	short loc_113D2

	push	[bp+gbufSeg]
	push	[bp+gbufOff]
	call	bigpic_setBackground
	add	sp, 4
	cmp	gs:wallIsPhased, 0
	jz	short loc_11444
	and	byte ptr [bp+var_1E], 0Fh
loc_11444:
	test	g_levelFlags, 20h
	jz	loc_dun_buildView_inDungeon

	mov	ax, 4
	jmp	loc_dun_buildView_loop_preamble

loc_dun_buildView_inDungeon:
	mov	bl, lightDistance
	sub	bh, bh

loc_dun_buildView_loop_preamble:
	mov	al, byte_44494[bx]
	sub	ah, ah
	mov	[bp+counter], ax
	jmp	short loc_11462
loc_1145F:
	inc	[bp+counter]
loc_11462:
	cmp	[bp+counter], 61
	jge	short loc_114C4
	mov	bx, [bp+counter]
	cmp	byte_4460C[bx], 0
	jz	short loc_114C2
	mov	al, byte_44516[bx]
	cbw
	mov	si, ax
	shl	si, 1
	mov	ax, [bp+si+squareList]
	mov	cl, byte_44554[bx]
	sar	ax, cl
	and	ax, 0Fh
	mov	bx, ax
	mov	al, byte_44484[bx]
	cbw
	or	ax, ax
	jz	short loc_114C2
	push	[bp+gbufSeg]
	push	[bp+gbufOff]
	dec	ax
	push	ax
	push	[bp+counter]
	call	bigpic_drawTopology
	add	sp, 8
loc_114C2:
	jmp	short loc_1145F
loc_114C4:
	mov	gs:byte_422A0, 0
	push	gs:bigpicCellData_seg
	push	gs:bigpicCellData_off
	mov	ax, offset bigpicBuf
	mov	dx, seg	seg021
	push	dx
	push	ax
	call	far ptr vid_drawBigpic
	add	sp, 8
	mov	ax, [bp+var_1E]
	pop	si
	mov	sp, bp
	pop	bp
	retf
dun_buildView endp


; Attributes: bp-based frame

dun_getWalls proc far

	var_4= dword ptr -4
	sqE= word ptr  6
	sqN= word ptr  8

	push	bp
	mov	bp, sp
	mov	ax, 4
	call	someStackOperation
	mov	al, g_dunWidth
	sub	ah, ah
	push	ax
	push	[bp+sqE]
	push	cs
	call	near ptr wrapNumber
	add	sp, 4
	mov	[bp+sqE], ax
	mov	al, g_dunHeight
	sub	ah, ah
	push	ax
	push	[bp+sqN]
	push	cs
	call	near ptr wrapNumber
	add	sp, 4
	mov	[bp+sqN], ax
	mov	bx, ax
	shl	bx, 1
	shl	bx, 1
	mov	ax, word ptr gs:rowOffset[bx]
	mov	dx, word ptr gs:(rowOffset+2)[bx]
	mov	cx, [bp+sqE]
	mov	bx, cx
	shl	cx, 1
	shl	cx, 1
	add	cx, bx
	add	ax, cx
	mov	word ptr [bp+var_4], ax
	mov	word ptr [bp+var_4+2], dx
	lfs	bx, [bp+var_4]
	mov	ah, fs:[bx+1]
	sub	al, al
	mov	cl, fs:[bx]
	sub	ch, ch
	add	ax, cx

	mov	sp, bp
	pop	bp
	retf
dun_getWalls endp

; Attributes: bp-based frame

sub_1156E proc far

	rowOffsetP= dword ptr  6
	sqE= word ptr	 0Ah
	sqN= word ptr	 0Ch
	dunWidth= word ptr	 0Eh
	dunHeight= word ptr	 10h

	push	bp
	mov	bp, sp
	push	si

	push	[bp+dunWidth]
	push	[bp+sqE]
	push	cs
	call	near ptr wrapNumber
	add	sp, 4
	mov	[bp+sqE], ax

	push	[bp+dunHeight]
	push	[bp+sqN]
	push	cs
	call	near ptr wrapNumber
	add	sp, 4
	mov	[bp+sqN], ax

	mov	bx, [bp+sqE]
	mov	ax, bx
	shl	bx, 1
	shl	bx, 1
	add	bx, ax
	mov	ax, bx			; ax = sqE * 5
	mov	bx, [bp+sqN]
	shl	bx, 1
	shl	bx, 1			; bx = sqN * 4
	lfs	si, [bp+rowOffsetP]	; fs:si = sqN row pointer
	lfs	si, fs:[bx+si]		; fs:si = sqN row
	mov	bx, ax
	mov	al, fs:[bx+si+2]	; al = flags for (sqN, sqE)
	sub	ah, ah
	mov	bx, ax
	mov	cl, 5
	shr	bx, cl
	and	bx, 3
	mov	al, byte_42716[bx]
	cbw

	pop	si
	mov	sp, bp
	pop	bp
	retf
sub_1156E endp

; Returns the value at (sqNorth, sqEast)
; This is only called in the wilderness. The dungeon
; levels have 5	bytes per square, this assumes one
; byte.
; Attributes: bp-based frame

wild_getSquare proc far

	sqEast=	word ptr  6
	sqNorth= word ptr  8

	push	bp
	mov	bp, sp
	push	si

	cmp	gs:g_wildWrapFlag, 0
	jz	short l_noWrap

	mov	al, gs:mapWidth
	sub	ah, ah
	push	ax
	push	[bp+sqEast]
	push	cs
	call	near ptr wrapNumber
	add	sp, 4
	mov	[bp+sqEast], ax

	mov	al, gs:mapHeight
	sub	ah, ah
	push	ax
	push	[bp+sqNorth]
	push	cs
	call	near ptr wrapNumber
	add	sp, 4
	mov	[bp+sqNorth], ax
	jmp	short loc_11649

l_noWrap:
	cmp	[bp+sqEast], 0
	jl	short l_returnZero
	mov	al, gs:mapWidth
	sub	ah, ah
	cmp	ax, [bp+sqEast]
	jbe	short l_returnZero
	cmp	[bp+sqNorth], 0
	jl	short l_returnZero
	mov	al, gs:mapHeight
	cmp	ax, [bp+sqNorth]
	ja	short loc_11649

l_returnZero:
	sub	ax, ax
	jmp	short l_return

loc_11649:
	mov	bx, [bp+sqNorth]
	shl	bx, 1
	shl	bx, 1
	lfs	bx, gs:rowOffset[bx]
	mov	si, [bp+sqEast]
	mov	al, fs:[bx+si]
	sub	ah, ah

l_return:
	pop	si
	mov	sp, bp
	pop	bp
	retf
wild_getSquare endp

; This function	returns	arg_0 mod to be between
; 0 and	arg_2. This handles negative numbers
; intuitively.
; Attributes: bp-based frame
wrapNumber proc	far

	arg_0= word ptr	 6
	arg_2= byte ptr	 8

	push	bp
	mov	bp, sp
	push	si

loc_11673:
	cmp	[bp+arg_0], 0
	jge	short loc_11682
	mov	al, [bp+arg_2]
	cbw
	add	[bp+arg_0], ax
	jmp	short loc_11673

loc_11682:
	mov	al, [bp+arg_2]
	cbw
	mov	si, ax
	cmp	[bp+arg_0], si
	jl	short l_return
	sub	[bp+arg_0], si
	jmp	short loc_11682

l_return:
	mov	ax, [bp+arg_0]
	pop	si
	mov	sp, bp
	pop	bp
	retf
wrapNumber endp

; This function	returns	the memory address of the
; map data at *membuf.
; Attributes: bp-based frame
map_getDataOffsetP proc	far

	memBuf=	dword ptr  6

	push	bp
	mov	bp, sp
	push	si

	lfs	bx, [bp+memBuf]
	mov	bl, fs:[bx]
	sub	bh, bh
	mov	si, word ptr [bp+memBuf]
	mov	si, fs:[si+1]
	and	si, 0FFh
	mov	cl, 8
	shl	si, cl
	lea	ax, g_rosterCharacterBuffer[bx+si]
	mov	dx, seg	seg022
	pop	si
	mov	sp, bp
	pop	bp
	retf
map_getDataOffsetP endp

; Reset location variables to initial state (in camp)
;
map_resetLocation proc far
	push	bp
	mov	bp, sp
	mov	sq_north, 0Bh
	mov	sq_east, 0Fh
	mov	g_direction, 0
	mov	g_locationNumber, 0
	mov	sp, bp
	pop	bp
	retf
map_resetLocation endp


seg000 ends

; Segment type: Pure code
seg001 segment word public 'CODE' use16
        assume cs:seg001
;org 0Bh
        assume es:nothing, ss:nothing, ds:dseg, fs:nothing, gs:seg027
align 2

; Attributes: bp-based frame

text_castSpell proc far

	_instr = word ptr -7
	counter = word ptr -2
	arg_0 = word ptr 6

	push	bp
	mov	bp, sp
	mov	ax, 7
	call	someStackOperation
	push	si

	call	text_clear

	mov	ax, offset s_spellToCast
	push	ds
	push	ax
	call	printString
	add	sp, 4

	mov	ax, 4
	push	ax
	lea	ax, [bp+_instr]
	push	ss
	push	ax
	call	readString
	add	sp, 6

	lea	ax, [bp+_instr]
	push	ss
	push	ax
	call	_strlen
	add	sp, 4
	cmp	ax, 4
	jl	l_fail_no_print

	lea	si, [bp+_instr]
	mov	[bp+counter], 0

l_toupper_start:
	cmp	[bp+counter], 4
	jge	l_toupper_exit
	mov	bx, [bp+counter]
	mov	al, ss:[si+bx]
	sub	ah, ah
	push	ax
	call	toUpper
	add	sp, 2

	mov	bx, [bp+counter]
	mov	ss:[si+bx], al
	inc	[bp+counter]
	jmp	l_toupper_start

l_toupper_exit:
	mov	[bp+counter], 0

l_spellCmp_start:
	cmp	[bp+counter], 7Eh
	jge	l_spellNotFound

	mov	bx, [bp+counter]
	shl	bx, 1
	shl	bx, 1
	shl	bx, 1
	mov	si, word ptr spellString.abbreviation[bx]
	lea	di, [bp+_instr]
	push	ss
	pop	es
	mov	cx, 4
	repe	cmpsb
	jz	l_spellFound

	inc	[bp+counter]
	jmp	l_spellCmp_start

l_spellNotFound:
	mov	ax, offset s_noSpellByThatName
	push	ds
	push	ax
	jmp	l_fail

l_spellFound:
	push	[bp+counter]
	push	[bp+arg_0]
	call	character_learnedSpell
	add	sp, 4
	or	ax, ax
	jz	l_notLearned
	
	mov	ax, [bp+counter]
	jmp	l_return

l_notLearned:
	mov	ax, offset s_dontKnowThatSpell
	push	ds
	push	ax

l_fail:
	call	printString
	add	sp, 4
	mov	ax, 2
	push	ax
	call	text_delayNoTable
	add	sp, 2

l_fail_no_print:
	mov	ax, 0FFFFh

l_return:
	pop	si
	mov	sp, bp
	pop	bp
	retf
text_castSpell endp

executeKeyboardCommand proc far

	arg_0= word ptr	 6

	push	bp
	mov	bp, sp

	cmp	[bp+arg_0], dosKeys_F1
	jl	short l_notFunctionKeySpell
	cmp	[bp+arg_0], dosKeys_F7
	jg	short l_notFunctionKeySpell
	push	[bp+arg_0]
	call	noncombatCast
	add	sp, 2
	jmp	l_success

l_notFunctionKeySpell:
	cmp	[bp+arg_0], '1'
	jl	short l_notPrintCharacter
	cmp	[bp+arg_0], '7'
	jg	short l_notPrintCharacter
	mov	ax, [bp+arg_0]
	sub	ax, '1'
	push	ax
	call	character_print
	add	sp, 2
	jmp	l_success
	
l_notPrintCharacter:
	mov	ax, [bp+arg_0]
	jmp	l_keySwitch

l_printHelp:
	push	cs
	call	near ptr printCommandHelp
	jmp	l_success

l_castSpell:
	sub	ax, ax
	push	ax
	call	noncombatCast
	add	sp, 2
	jmp	l_success
	
l_reorderParty:
	call	party_reorder
	jmp	l_success
	
l_saveGame:
	call	saveGame
	jmp	l_success
	
l_singBardSong:
	call	song_singNonCombat
	jmp	l_success

l_dropMember:
	call	dropPartyMember
	jmp	l_success

l_pauseGame:
	cmp	gs:byte_42296, 0FFh
	jz	l_fail
	mov	gs:advanceTimeFlag, 1
	mov	ax, offset s_pausing
	push	ds
	push	ax
	call	printStringWithWait
	add	sp, 4
	mov	gs:advanceTimeFlag, 0
	jmp	l_success

l_partyAttack:
	mov	g_partyAttackFlag, 1
	jmp	l_fail

l_useItem:
	call	useItem
	jmp	l_success

l_toggleSound:
	call	snd_toggle
	jmp	l_success

l_keySwitch:
	sub	ax, 'B'
	cmp	ax, 14h
	ja	short l_fail
	add	ax, ax
	xchg	ax, bx
	jmp	cs:keyJumpTable[bx]
keyJumpTable	dw offset l_singBardSong 
		dw offset l_castSpell	
		dw offset l_dropMember	
		dw offset l_fail	
		dw offset l_fail	
		dw offset l_fail	
		dw offset l_printHelp	
		dw offset l_fail	
		dw offset l_fail	
		dw offset l_fail	
		dw offset l_fail	
		dw offset l_fail	
		dw offset l_reorderParty	
		dw offset l_fail	
		dw offset l_partyAttack	
		dw offset l_fail	
		dw offset l_fail	
		dw offset l_saveGame	
		dw offset l_pauseGame	
		dw offset l_useItem	
		dw offset l_toggleSound	

l_fail:
	xor	ax, ax
	jmp	l_exit

l_success:
	mov	ax, 1

l_exit:
	mov	sp, bp
	pop	bp
	retf
executeKeyboardCommand endp


; DWORD - arg_0 & arg_2

; Attributes: bp-based frame
printStringWithWait proc	far

	arg_0= word ptr	 6
	arg_2= word ptr	 8

	push	bp
	mov	bp, sp

	call	text_clear
	push	[bp+arg_2]
	push	[bp+arg_0]
	call	printString
	add	sp, 4
	mov	ax, 4000h
	push	ax
	call	getKey
	add	sp, 2

	mov	sp, bp
	pop	bp
	retf
printStringWithWait endp

; Attributes: bp-based frame

printCommandHelp proc far
	push	bp
	mov	bp, sp

	call	text_clear
	mov	ax, offset s_helpMessage1
	push	ds
	push	ax
	call	printString
	add	sp, 4
	mov	ax, 4000h
	push	ax
	call	getKey
	add	sp, 2
	call	text_clear
	mov	ax, offset s_helpMessage2
	push	ds
	push	ax
	call	printString
	add	sp, 4
	mov	ax, 4000h
	push	ax
	call	getKey
	add	sp, 2

	mov	sp, bp
	pop	bp
	retf
printCommandHelp endp

; Attributes: bp-based frame

party_reorder proc far

	emptySlot=	word ptr -24h
	var_22=	word ptr -22h
	var_14=	word ptr -14h
	loopCounter=	word ptr -12h
	slotNumberRead=	word ptr -10h
	var_E= word ptr	-0Eh

	push	bp
	mov	bp, sp
	mov	ax, 24h
	call	someStackOperation
	push	di
	push	si

	call	party_findEmptySlot
	mov	[bp+emptySlot], ax
	cmp	ax, 1
	jle	l_return

l_reorderEntry:
	call	text_clear
	mov	[bp+loopCounter], 0

; Initialize arrays:
;   var_E is initialized with 0
;   var_22 is initialized with 0FFFFh
l_listInitialization:
	mov	si, [bp+loopCounter]
	shl	si, 1
	mov	[bp+si+var_E], 0
	mov	si, [bp+loopCounter]
	shl	si, 1
	mov	[bp+si+var_22],	0FFFFh
	inc	[bp+loopCounter]
	cmp	[bp+loopCounter], 7
	jl	l_listInitialization

	mov	ax, offset s_newOrder
	push	ds
	push	ax
	call	printString
	add	sp, 4
	mov	[bp+loopCounter], 0

l_newOrderIoEntry:
	mov	al, byte ptr [bp+loopCounter]
	add	al, '1'
	mov	byte_42AF5, al
	mov	ax, offset s_gtChar
	push	ds
	push	ax
	call	text_nlWriteString
	add	sp, 4

l_retryReadSlot:
	call	readSlotNumber
	mov	[bp+slotNumberRead], ax
	or	ax, ax
	jl	l_return

	mov	ax, [bp+emptySlot]
	cmp	[bp+slotNumberRead], ax
	jge	short l_retryReadSlot

	mov	si, [bp+slotNumberRead]
	shl	si, 1
	cmp	[bp+si+var_E], 0
	jnz	short l_retryReadSlot

	mov	si, [bp+slotNumberRead]
	shl	si, 1
	mov	[bp+si+var_E], 1
	mov	si, [bp+loopCounter]
	shl	si, 1
	mov	ax, [bp+slotNumberRead]
	mov	[bp+si+var_22],	ax
	mov	ax, charSize
	imul	[bp+slotNumberRead]
	mov	bx, ax
	lea	ax, party._name[bx]
	mov	dx, seg	seg027
	push	dx
	push	ax
	call	text_writeString
	add	sp, 4
	inc	[bp+loopCounter]
	mov	ax, [bp+emptySlot]
	dec	ax
	cmp	ax, [bp+loopCounter]
	jg	short l_newOrderIoEntry

	mov	[bp+var_14], 0
l_var_EcomparisonLoopEntry:
	mov	si, [bp+var_14]
	shl	si, 1
	cmp	[bp+si+var_E], 0
	jz	short loc_119C9
	inc	[bp+var_14]
	jmp	short l_var_EcomparisonLoopEntry

loc_119C9:
	mov	si, [bp+emptySlot]
	shl	si, 1
	mov	ax, [bp+var_14]
	mov	[bp+si+emptySlot], ax
	mov	al, byte ptr [bp+emptySlot]
	add	al, '0'
	mov	byte_42AF5, al
	mov	ax, offset s_gtChar
	push	ds
	push	ax
	call	text_nlWriteString
	add	sp, 4
	mov	ax, charSize
	imul	[bp+var_14]
	mov	bx, ax
	lea	ax, party._name[bx]
	mov	dx, seg	seg027
	push	dx
	push	ax
	call	text_writeString
	add	sp, 4
	mov	ax, offset s_useThisOrder
	push	ds
	push	ax
	call	printString
	add	sp, 4
	call	getYesNo
	or	ax, ax
	jz	l_reorderEntry

	mov	[bp+loopCounter], 0
	jmp	short loc_11A27
loc_11A24:
	inc	[bp+loopCounter]
loc_11A27:
	mov	ax, [bp+emptySlot]
	dec	ax
	cmp	ax, [bp+loopCounter]
	jle	short l_updateAndReturn
	mov	di, [bp+loopCounter]
	shl	di, 1
	mov	si, [bp+di+var_22]
	cmp	[bp+loopCounter], si
	jz	short loc_11A7D
	push	si
	push	[bp+loopCounter]
	push	cs
	call	near ptr party_swapMembers
	add	sp, 4
	mov	ax, [bp+loopCounter]
	inc	ax
	mov	[bp+var_14], ax
	jmp	short loc_11A54
loc_11A51:
	inc	[bp+var_14]
loc_11A54:
	mov	ax, [bp+emptySlot]
	cmp	[bp+var_14], ax
	jge	short loc_11A6D
	mov	si, [bp+var_14]
	shl	si, 1
	mov	ax, [bp+loopCounter]
	cmp	[bp+si+var_22],	ax
	jnz	short loc_11A6B
	jmp	short loc_11A6D
loc_11A6B:
	jmp	short loc_11A51
loc_11A6D:
	mov	si, [bp+loopCounter]
	shl	si, 1
	mov	ax, [bp+si+var_22]
	mov	si, [bp+var_14]
	shl	si, 1
	mov	[bp+si+var_22],	ax
loc_11A7D:
	jmp	short loc_11A24
l_updateAndReturn:
	mov	byte ptr g_printPartyFlag,	0
l_return:
	pop	si
	pop	di
	mov	sp, bp
	pop	bp
	retf
party_reorder endp

; Attributes: bp-based frame

party_swapMembers proc far

	arg_0= word ptr	 6
	arg_2= word ptr	 8

	push	bp
	mov	bp, sp

	mov	ax, offset newCharBuffer
	mov	dx, seg	seg027
	push	dx
	push	ax
	mov	ax, charSize
	imul	[bp+arg_0]
	mov	bx, ax
	lea	ax, party._name[bx]
	mov	dx, seg	seg027
	push	dx
	push	ax
	call	copyCharacterBuf
	add	sp, 8

	mov	ax, charSize
	imul	[bp+arg_0]
	mov	bx, ax
	lea	ax, party._name[bx]
	mov	dx, seg	seg027
	push	dx
	push	ax
	mov	ax, charSize
	imul	[bp+arg_2]
	mov	bx, ax
	lea	ax, party._name[bx]
	mov	dx, seg	seg027
	push	dx
	push	ax
	call	copyCharacterBuf
	add	sp, 8

	mov	ax, charSize
	imul	[bp+arg_2]
	mov	bx, ax
	lea	ax, party._name[bx]
	mov	dx, seg	seg027
	push	dx
	push	ax
	mov	ax, offset newCharBuffer
	push	dx
	push	ax
	call	copyCharacterBuf
	add	sp, 8

	mov	sp, bp
	pop	bp
	retf
party_swapMembers endp

; Attributes: bp-based frame

saveGame proc far

	fd= word ptr	-2

	push	bp
	mov	bp, sp
	mov	ax, 2
	call	someStackOperation

	mov	ax, offset s_confirmSave
	push	ds
	push	ax
	call	printStringWClear
	add	sp, 4
	call	getYesNo
	or	ax, ax
	jz	l_return
loc_11B2A:
	cmp	inDungeonMaybe, 0
	jz	short loc_11B3B
	mov	ax, 4
	jmp	short loc_11B3E
loc_11B3B:
	mov	ax, 2
loc_11B3E:
	mov	g_mapRval, ax
	mov	ax, 2
	push	ax
	mov	ax, offset s_gameSav
	push	ds
	push	ax
	call	open
	add	sp, 6
	mov	[bp+fd], ax
	inc	ax
	jnz	short l_doSave
	call	text_clear
	mov	ax, offset s_cantOpenGameSave
	push	ds
	push	ax
	call	printString
	add	sp, 4
	mov	ax, 4000h
	push	ax
	call	getKey
	add	sp, 2
	mov	g_mapRval, 0
	jmp	short l_return

l_doSave:
	mov	ax, offset s_savingTheGame
	push	ds
	push	ax
	call	printStringWClear
	add	sp, 4

	mov	ax, 348h
	push	ax
	mov	ax, offset party
	mov	dx, seg	seg027
	push	dx
	push	ax
	push	[bp+fd]
	call	write
	add	sp, 8

	mov	ax, offset byte_4EECC
	mov	cx, offset g_locationNumber
	mov	bx, seg	dseg
	sub	ax, cx
	push	ax
	mov	ax, cx
	mov	dx, bx
	push	dx
	push	ax
	push	[bp+fd]
	call	write
	add	sp, 8

	push	[bp+fd]
	call	close
	add	sp, 2

	mov	ax, offset s_gameHasBeenSaved
	push	ds
	push	ax
	call	printStringWClear
	add	sp, 4
	call	getYesNo
	or	ax, ax
	jz	short loc_11BEF
	mov	ax, 0FFh
	jmp	short loc_11BF1
loc_11BEF:
	sub	ax, ax
loc_11BF1:
	mov	g_mapRval, ax
l_return:
	mov	sp, bp
	pop	bp
	retf
saveGame endp

; Attributes: bp-based frame

restoreGame proc far

	var_4= word ptr	-4
	fd= word ptr	-2

	push	bp
	mov	bp, sp
	mov	ax, 4
	call	someStackOperation

	mov	g_mapRval, 1
	mov	ax, offset s_confirmRestore
	push	ds
	push	ax
	call	printStringWClear
	add	sp, 4
	call	getYesNo
	or	ax, ax
	jz	l_return

	call	endNoncombatSong
	mov	ax, offset s_gameSav
	push	ds
	push	ax
	call	openFile
	add	sp, 4
	mov	[bp+fd], ax
	mov	ax, 348h
	push	ax
	mov	ax, offset party
	mov	dx, seg	seg027
	push	dx
	push	ax
	push	[bp+fd]
	call	read
	add	sp, 8

	mov	ax, offset byte_4EECC
	mov	cx, offset g_locationNumber
	mov	bx, seg	dseg
	sub	ax, cx
	push	ax
	mov	ax, cx
	mov	dx, bx
	push	dx
	push	ax
	push	[bp+fd]
	call	read
	add	sp, 8

	push	[bp+fd]
	call	close
	add	sp, 2

	mov	[bp+var_4], 0

l_durationSpellLoopEntry:
	mov	bx, [bp+var_4]
	cmp	lightDuration[bx], 0
	jz	short l_doNotActivate
	push	bx
	call	icon_activate
	add	sp, 2
l_doNotActivate:
	inc	[bp+var_4]
	cmp	[bp+var_4], 5
	jl	l_durationSpellLoopEntry

	cmp	g_currentHour, 6
	jb	short l_isNight
	cmp	g_currentHour, 12h
	jbe	short l_isDay
l_isNight:
	mov	al, 1
	jmp	short l_setIsNight
l_isDay:
	sub	al, al
l_setIsNight:
	mov	gs:isNight, al
	mov	byte ptr g_printPartyFlag,	0
l_return:
	mov	sp, bp
	pop	bp
	retf
restoreGame endp

; Attributes: bp-based frame

useItem	proc far

	var_FA=	word ptr -0F8h
	targetSlotNumber=	word ptr -38h
	itemSlotNumber=	word ptr -34h
	var_32=	word ptr -32h
	userSlotNumber= word ptr	-2

	push	bp
	mov	bp, sp
	mov	ax, 0F8h
	call	someStackOperation

	mov	ax, offset s_whoUsesItem
	push	ds
	push	ax
	call	printStringWClear
	add	sp, 4
	call	readSlotNumber
	mov	[bp+userSlotNumber], ax
	or	ax, ax
	jl	l_return

	mov	ax, charSize
	imul	[bp+userSlotNumber]
	mov	bx, ax
	test	gs:party.status[bx], stat_dead	or stat_stoned or stat_paralyzed
	jnz	l_return

	mov	ax, charSize
	imul	[bp+userSlotNumber]
	mov	bx, ax
	cmp	gs:party.class[bx], class_monster
	jnb	l_return

	lea	ax, [bp+var_32]
	push	ss
	push	ax
	lea	ax, [bp+var_FA]
	push	ss
	push	ax
	push	[bp+userSlotNumber]
	call	inventory_getItemList
	add	sp, 0Ah

	or	ax, ax
	jz	l_emptyPockets
loc_11D4B:
	push	ax
	lea	ax, [bp+var_32]
	push	ss
	push	ax
	mov	ax, offset s_whichItem
	push	ds
	push	ax
	call	text_scrollingWindow
	add	sp, 0Ah

	mov	[bp+itemSlotNumber], ax
	or	ax, ax
	jl	l_return

	push	[bp+itemSlotNumber]
	push	[bp+userSlotNumber]
	call	inventory_canBeUsed
	add	sp, 4
	or	ax, ax
	jz	short l_powerless
	mov	bx, g_curSpellNumber
	mov	al, spellCastFlags[bx]
	sub	ah, ah
	and	ax, 7
	mov	[bp+targetSlotNumber], ax
	cmp	ax, 4
	jge	short l_doUse
	mov	ax, offset s_UseOn
	push	ds
	push	ax
	push	[bp+targetSlotNumber]
	call	bat_charGetActionTarget
	add	sp, 6
	mov	[bp+targetSlotNumber], ax
	or	ax, ax
	jl	short l_return

l_doUse:
	call	text_clear
	sub	ax, ax
	push	ax
	push	g_curSpellNumber
	push	[bp+targetSlotNumber]
	push	[bp+itemSlotNumber]
	push	[bp+userSlotNumber]
	push	cs
	call	near ptr item_doSpell
	add	sp, 0Ah
	jmp	short l_waitAndReturn

l_powerless:
	mov	ax, offset s_powerless
	push	ds
	push	ax
	call	printStringWClear
	add	sp, 4
	jmp	short l_waitAndReturn
l_emptyPockets:
	mov	ax, offset s_pocketsAreEmpty
	push	ds
	push	ax
	call	printStringWClear
	add	sp, 4
l_waitAndReturn:
	mov	ax, 4000h
	push	ax
	call	getKey
	add	sp, 2
l_return:
	mov	sp, bp
	pop	bp
	retf
useItem	endp

; Attributes: bp-based frame

item_doSpell proc far

	userSlotNumber=	word ptr  6
	itemSlotNumber= word ptr	 8
	targetSlotNumber= byte ptr	 0Ah
	spellNumber= word ptr	 0Ch
	arg_8= word ptr	 0Eh

	push	bp
	mov	bp, sp

	mov	ax, [bp+itemSlotNumber]
	mov	cx, ax
	shl	ax, 1
	add	ax, cx
	mov	gs:g_usedItemSlotNumber, al
	mov	al, byte ptr [bp+userSlotNumber]
	mov	gs:g_userSlotNumber, al
	mov	al, [bp+targetSlotNumber]
	mov	gs:bat_curTarget, al
	sub	ax, ax
	push	ax
	push	[bp+arg_8]
	push	[bp+spellNumber]
	push	[bp+userSlotNumber]
	call	doCastSpell
	add	sp, 8
	push	[bp+itemSlotNumber]
	push	[bp+userSlotNumber]
	push	cs
	call	near ptr item_useCharge
	add	sp, 4

	mov	sp, bp
	pop	bp
	retf
item_doSpell endp

; Attributes: bp-based frame

item_useCharge proc far

	var_4= dword ptr -4
	userSlotNumber= word ptr	 6
	itemSlotNumber= word ptr	 8

	push	bp
	mov	bp, sp

	mov	ax, charSize
	imul	[bp+userSlotNumber]
	mov	bx, [bp+itemSlotNumber]
	mov	cx, bx
	shl	bx, 1
	add	bx, cx
	add	bx, ax
	cmp	gs:party.inventory.itemCount[bx], 0FFh
	jz	l_returnOne
	mov	ax, charSize
	imul	[bp+userSlotNumber]
	mov	cx, [bp+itemSlotNumber]
	mov	dx, cx
	shl	cx, 1
	add	cx, dx
	add	cx, ax
	add	cx, 64h	
	mov	word ptr [bp+var_4], cx
	mov	word ptr [bp+var_4+2], seg seg027
	lfs	bx, [bp+var_4]
	dec	byte ptr fs:[bx]
	lfs	bx, [bp+var_4]
	cmp	byte ptr fs:[bx], 0
	jnz	l_returnOne
loc_11EBC:
	mov	ax, [bp+itemSlotNumber]
	mov	cx, ax
	shl	ax, 1
	add	ax, cx
	mov	gs:g_inventoryPackStart, ax
	mov	ax, [bp+userSlotNumber]
	mov	gs:g_inventoryPackTarget, ax
	call	inventory_pack
	mov	al, gs:g_currentSinger
	sub	ah, ah
	cmp	ax, [bp+userSlotNumber]
	jnz	short l_return

	; If the item used up belongs to the current singer and
	; the current singer no longer has an instrument equipped,
	; then the instrument is the item used up. Stop songs.
	mov	ax, itType_instrument
	push	ax
	push	[bp+userSlotNumber]
	call	character_hasTypeEquipped
	add	sp, 4
	or	ax, ax
	jnz	short l_return
	cmp	gs:byte_422A4, 0
	jz	short loc_11F12
	call	bat_endCombatSong
	jmp	short l_return
loc_11F12:
	call	endNoncombatSong
	jmp	short l_return
l_returnOne:
	mov	ax, 1
l_return:
	mov	sp, bp
	pop	bp
	retf
item_useCharge endp

; Attributes: bp-based frame
snd_toggle proc	far
	push	bp
	mov	bp, sp

	cmp	g_soundActiveFlag, 1
	sbb	ax, ax
	neg	ax
	mov	g_soundActiveFlag, ax
	push	ax
	call	sub_27E05
	add	sp, 2

	mov	sp, bp
	pop	bp
	retf
snd_toggle endp

; This function	prints a string	based on a structure
; that is passed to it.	The optional lines are prefaced
; with a '@'
; Attributes: bp-based frame

printVarString proc far

	stringBuffer= word ptr -10Ah
	mouseBitmask= word ptr	-0Ah
	currentOptionIndex= word ptr	-8
	currentChar= word ptr	-6
	stringBufferP= dword ptr -4
	inString= dword	ptr  6
	optionList= dword ptr  0Ah
	validOptionCharacters= dword ptr  0Eh
	validOptionMouse= dword ptr  12h

	push	bp
	mov	bp, sp
	mov	ax, 10Ah
	call	someStackOperation
	push	si

	sub	ax, ax
	mov	[bp+currentOptionIndex], ax
	mov	[bp+mouseBitmask], ax
	lea	ax, [bp+stringBuffer]
	mov	word ptr [bp+stringBufferP], ax
	mov	word ptr [bp+stringBufferP+2], ss
l_stringCopyLoopEntry:
	lfs	bx, [bp+inString]			; Get next char from inString
	inc	word ptr [bp+inString]
	mov	al, fs:[bx]
	sub	ah, ah
	mov	[bp+currentChar], ax

	lfs	bx, [bp+stringBufferP]			; Write it to stringBuffer
	inc	word ptr [bp+stringBufferP]
	mov	al, byte ptr [bp+currentChar]
	mov	fs:[bx], al

	cmp	[bp+currentChar], 0
	jz	short l_nullOrAt
	cmp	[bp+currentChar], '@'
	jnz	short l_stringCopyLoopEntry
l_nullOrAt:
	dec	word ptr [bp+stringBufferP]
	lfs	bx, [bp+stringBufferP]
	mov	byte ptr fs:[bx], 0			; Replace '@' with 0
	lea	ax, [bp+stringBuffer]
	push	ss
	push	ax
	call	printString
	add	sp, 4				; and print the strint

	lea	ax, [bp+stringBuffer]			; Reset the buffer pointer to the
	mov	word ptr [bp+stringBufferP], ax		; beginning of the string buffer
	mov	word ptr [bp+stringBufferP+2], ss

	cmp	[bp+currentChar], 0
	jnz	short l_notNull
	mov	bx, [bp+currentOptionIndex]
	lfs	si, [bp+validOptionCharacters]
	mov	byte ptr fs:[bx+si], 0
	mov	ax, [bp+mouseBitmask]
	jmp	l_return
l_notNull:
	cmp	[bp+currentChar], '@'
	jnz	short l_nullOrAt

	mov	bx, [bp+currentOptionIndex]
	lfs	si, [bp+optionList]
	cmp	byte ptr fs:[bx+si], 0		; Check the current option
	jz	short loc_1204B

	lfs	bx, [bp+inString]		; Save the first character after '@'
	mov	al, fs:[bx]			; as the key the player can type to
	mov	bx, [bp+currentOptionIndex]	; activate the option
	lfs	si, [bp+validOptionCharacters]
	mov	fs:[bx+si], al

	cmp	gs:g_currentCharPosition, 0
	jz	short l_noNewline
	call	txt_newLine
l_noNewline:
	mov	al, gs:txt_numLines
	sub	ah, ah
	add	ax, 10Eh
	mov	bx, [bp+currentOptionIndex]
	inc	[bp+currentOptionIndex]
	shl	bx, 1
	lfs	si, [bp+validOptionMouse]
	mov	fs:[bx+si], ax			; Add the option to the list of mouse
	mov	bl, gs:txt_numLines		; menu items
	sub	bh, bh
	shl	bx, 1
	mov	ax, bitMask16bit[bx]
	or	[bp+mouseBitmask], ax

l_copyStringAfterAt:
	lfs	bx, [bp+inString]
	inc	word ptr [bp+inString]
	mov	al, fs:[bx]
	sub	ah, ah
	mov	[bp+currentChar], ax
	lfs	bx, [bp+stringBufferP]
	inc	word ptr [bp+stringBufferP]
	mov	al, byte ptr [bp+currentChar]
	mov	fs:[bx], al
	cmp	[bp+currentChar], 0
	jz	l_nullOrAt
	cmp	[bp+currentChar], '@'
	jnz	short l_copyStringAfterAt
	jmp	l_nullOrAt

loc_1204B:
	mov	bx, [bp+currentOptionIndex]
	lfs	si, [bp+validOptionCharacters]
	mov	byte ptr fs:[bx+si], 0FFh		; Mark option as invalid
	mov	bx, [bp+currentOptionIndex]
	inc	[bp+currentOptionIndex]
	shl	bx, 1
	lfs	si, [bp+validOptionMouse]		; Mark mouse option as invalid
	mov	word ptr fs:[bx+si], 0
l_skipString:
	lfs	bx, [bp+inString]
	inc	word ptr [bp+inString]
	mov	al, fs:[bx]
	sub	ah, ah
	mov	[bp+currentChar], ax
	or	ax, ax
	jz	short loc_1207C
	cmp	ax, 40h	
	jnz	short l_skipString
loc_1207C:
	inc	word ptr [bp+stringBufferP]
loc_1207F:
	jmp	l_nullOrAt
l_return:
	pop	si
	mov	sp, bp
	pop	bp
	retf
printVarString endp

; DWORD - var_108 & var_10A, var_10E & var_10C
; Attributes: bp-based frame

printLocation proc far

	pacesNorth= word ptr -126h
	unmaskedLocationName= word ptr -124h
	var_110= word ptr -110h
	var_10E= word ptr -10Eh
	var_10C= word ptr -10Ch
	var_10A= word ptr -10Ah
	var_108= word ptr -108h
	var_106= word ptr -106h
	var_104= word ptr -104h
	pacesEast= word ptr -102h
	stringBuffer= word ptr -100h

	push	bp
	mov	bp, sp
	mov	ax, 126h
	call	someStackOperation

	mov	[bp+var_10E], offset g_rosterCharacterBuffer
	mov	[bp+var_10C], seg seg022
	mov	ax, offset s_youreIn
	push	ds
	push	ax
	lea	ax, [bp+stringBuffer]
	push	ss
	push	ax
	call	strcat
	add	sp, 8
	mov	[bp+var_10A], ax
	mov	[bp+var_108], dx

	cmp	g_locationNumber, 0
	jnz	short l_skipThe

	mov	ax, offset s_the
	push	ds
	push	ax
	push	dx
	push	[bp+var_10A]
	call	strcat
	add	sp, 8
	mov	[bp+var_10A], ax
	mov	[bp+var_108], dx

l_skipThe:
	lea	ax, [bp+unmaskedLocationName]
	push	ss
	push	ax
	push	[bp+var_10C]
	push	[bp+var_10E]
	call	unmaskString
	add	sp, 8

	lea	ax, [bp+unmaskedLocationName]
	push	ss
	push	ax
	push	[bp+var_108]
	push	[bp+var_10A]
	call	strcat
	add	sp, 8
	mov	[bp+var_10A], ax
	mov	[bp+var_108], dx

	mov	bx, g_locationNumber
	mov	al, byte_428A6[bx]
	cbw
	mov	cx, sq_north
	sub	cx, ax
	mov	[bp+pacesNorth], cx
	or	cx, cx
	jz	loc_121CD

	mov	ax, offset s_spAndsp
	push	ds
	push	ax
	push	dx
	push	[bp+var_10A]
	call	strcat
	add	sp, 8
	mov	[bp+var_10A], ax
	mov	[bp+var_108], dx
	cmp	[bp+pacesNorth], 0
	jge	short loc_1216A

	mov	ax, [bp+pacesNorth]
	neg	ax
	mov	[bp+pacesNorth], ax
	mov	[bp+var_106], 1
	jmp	short loc_12170
loc_1216A:
	mov	[bp+var_106], 0
loc_12170:
	sub	ax, ax
	push	ax
	mov	ax, [bp+pacesNorth]
	cwd
	push	dx
	push	ax
	push	[bp+var_108]
	push	[bp+var_10A]
	call	itoa
	add	sp, 0Ah
	mov	[bp+var_10A], ax
	mov	[bp+var_108], dx

	mov	ax, [bp+pacesNorth]
	dec	ax
	push	ax
	push	dx
	push	[bp+var_10A]
	mov	ax, offset s_paces
	push	ds
	push	ax
	call	str_pluralize
	add	sp, 0Ah

	mov	[bp+var_10A], ax
	mov	[bp+var_108], dx
	push	[bp+var_106]
	push	dx
	push	ax
	mov	ax, offset s_northSouth
	push	ds
	push	ax
	call	str_pluralize
	add	sp, 0Ah
	mov	[bp+var_10A], ax
	mov	[bp+var_108], dx

loc_121CD:
	mov	bx, g_locationNumber
	mov	al, byte_428B0[bx]
	cbw
	mov	cx, sq_east
	sub	cx, ax
	mov	[bp+pacesEast], cx
	or	cx, cx
	jz	loc_1228A

	mov	ax, offset s_spAndsp
	push	ds
	push	ax
	push	[bp+var_108]
	push	[bp+var_10A]
	call	strcat
	add	sp, 8
	mov	[bp+var_10A], ax
	mov	[bp+var_108], dx
	cmp	[bp+pacesEast], 0
	jge	short loc_12227
	mov	ax, [bp+pacesEast]
	neg	ax
	mov	[bp+pacesEast], ax
	mov	[bp+var_106], 1
	jmp	short loc_1222D
loc_12227:
	mov	[bp+var_106], 0
loc_1222D:
	sub	ax, ax
	push	ax
	mov	ax, [bp+pacesEast]
	cwd
	push	dx
	push	ax
	push	[bp+var_108]
	push	[bp+var_10A]
	call	itoa
	add	sp, 0Ah
	mov	[bp+var_10A], ax
	mov	[bp+var_108], dx
	mov	ax, [bp+pacesEast]
	dec	ax
	push	ax
	push	dx
	push	[bp+var_10A]
	mov	ax, offset s_paces
	push	ds
	push	ax
	call	str_pluralize
	add	sp, 0Ah
	mov	[bp+var_10A], ax
	mov	[bp+var_108], dx
	push	[bp+var_106]
	push	dx
	push	ax
	mov	ax, offset s_eastWest
	push	ds
	push	ax
	call	str_pluralize
	add	sp, 0Ah
	mov	[bp+var_10A], ax
	mov	[bp+var_108], dx
loc_1228A:
	mov	bx, g_locationNumber
	mov	al, byte_428BA[bx]
	cbw
	mov	[bp+var_110], ax
	mov	bl, g_currentHour
	sub	bh, bh
	mov	al, byte_428C4[bx]
	cbw
	mov	[bp+var_104], ax
	mov	ax, [bp+pacesEast]
	or	ax, [bp+pacesNorth]
	cmp	ax, 1
	sbb	cx, cx
	neg	cx
	push	cx
	push	[bp+var_108]
	push	[bp+var_10A]
	mov	ax, offset s_ofAtThe
	push	ds
	push	ax
	call	str_pluralize
	add	sp, 0Ah
	mov	[bp+var_10A], ax
	mov	[bp+var_108], dx
	mov	bx, [bp+var_110]
	shl	bx, 1
	shl	bx, 1
	push	word ptr (locationString+2)[bx]
	push	word ptr locationString[bx]
	push	dx
	push	ax
	call	strcat
	add	sp, 8
	mov	[bp+var_10A], ax
	mov	[bp+var_108], dx
	mov	ax, offset s_itsNow
	push	ds
	push	ax
	push	dx
	push	[bp+var_10A]
	call	strcat
	add	sp, 8
	mov	[bp+var_10A], ax
	mov	[bp+var_108], dx
	mov	bx, [bp+var_104]
	shl	bx, 1
	shl	bx, 1
	push	word ptr (timeOfDay+2)[bx]
	push	word ptr timeOfDay[bx]
	push	dx
	push	ax
	call	strcat
	add	sp, 8
	mov	[bp+var_10A], ax
	mov	[bp+var_108], dx
	lea	ax, [bp+stringBuffer]
	push	ss
	push	ax
	call	printStringWClear
	add	sp, 4
	mov	ax, 4000h
	push	ax
	call	getKey
	add	sp, 2

	mov	sp, bp
	pop	bp
	retf
printLocation endp

; Attributes: bp-based frame

dropPartyMember	proc far

	slotNumber= word ptr	-2

	push	bp
	mov	bp, sp
	mov	ax, 2
	call	someStackOperation

	mov	ax, offset s_whoToDrop
	push	ds
	push	ax
	call	printStringWClear
	add	sp, 4
	call	readSlotNumber
	mov	[bp+slotNumber], ax
	or	ax, ax
	jl	short l_returnZero

	mov	ax, charSize
	imul	[bp+slotNumber]
	mov	bx, ax
	cmp	gs:party.class[bx], class_monster
	jnb	short l_doDrop
	mov	ax, offset s_cantDropCharacter
	push	ds
	push	ax
	call	printStringWClear
	add	sp, 4
	mov	ax, 4000h
	push	ax
	call	getKey
	add	sp, 2
	jmp	l_returnZero

l_doDrop:
	push	[bp+slotNumber]
	call	party_pack
	add	sp, 2
	mov	ax, 1
	jmp	short l_return
l_returnZero:
	sub	ax, ax
l_return:
	mov	sp, bp
	pop	bp
	retf
dropPartyMember	endp

; Attributes: bp-based frame

quitGame proc far
	push	bp
	mov	bp, sp

	mov	ax, offset s_confirmQuit
	push	ds
	push	ax
	call	printStringWClear
	add	sp, 4

	call	getYesNo
	or	ax, ax
	jz	short l_returnZero
	mov	ax, offset s_loseProgressConfirm
	push	ds
	push	ax
	call	printStringWClear
	add	sp, 4
	call	getYesNo
	jmp	short l_return
l_returnZero:
	sub	ax, ax
l_return:
	mov	sp, bp
	pop	bp
	retf
quitGame endp




seg001 ends

; Segment type: Pure code
seg002 segment byte public 'CODE' use16
        assume cs:seg002
;org 6
        assume es:nothing, ss:nothing, ds:dseg, fs:nothing, gs:seg027

camp_addMember proc far

	var_15C= word ptr -15Ch
	var_15A= word ptr -15Ah
	var_158= word ptr -158h
	var_156= word ptr -156h
	savedList= dword	ptr -154h

	push	bp
	mov	bp, sp
	mov	ax, 15Ch
	call	someStackOperation
	push	si

	call	text_clear
	push	cs
	call	near ptr roster_countCharacters
	or	ax, ax
	jz	l_noSavedCharacters
	mov	[bp+var_15A], 0
	mov	[bp+var_15C], 0
loc_12428:
	cmp	[bp+var_15A], 10
	jge	l_addCharacters
	mov	si, [bp+var_15C]
	shl	si, 1
	shl	si, 1
	mov	ax, [bp+var_15C]
	mov	cl, 7
	shl	ax, cl
	add	ax, offset g_rosterPartyBuffer
	mov	word ptr [bp+si+savedList], ax
	mov	word ptr [bp+si+savedList+2], seg seg022
	mov	si, [bp+var_15C]
	inc	[bp+var_15C]
	inc	[bp+var_15A]
	shl	si, 1
	shl	si, 1
	lfs	bx, [bp+si+savedList]
	cmp	byte ptr fs:[bx], 0
	jnz	short loc_12428
l_addCharacters:
	dec	[bp+var_15C]
	mov	ax, [bp+var_15C]
	mov	[bp+var_156], ax
	mov	[bp+var_15A], 0
l_nextCharacter:
	cmp	[bp+var_15A], 75
	jge	l_savedListComplete
	mov	ax, [bp+var_15C]
	sub	ax, [bp+var_156]
	mov	cx, charSize
	imul	cx
	add	ax, 0
	mov	si, [bp+var_15C]
	shl	si, 1
	shl	si, 1
	mov	word ptr [bp+si+savedList], ax
	mov	word ptr [bp+si+savedList+2], seg seg022
	mov	si, [bp+var_15C]
	inc	[bp+var_15C]
	inc	[bp+var_15A]
	shl	si, 1
	shl	si, 1
	lfs	bx, [bp+si+savedList]
	cmp	byte ptr fs:[bx], 0
	jnz	short l_nextCharacter
l_savedListComplete:
	dec	[bp+var_15C]

l_ioLoopEnter:
	push	[bp+var_15C]
	lea	ax, [bp+savedList]
	push	ss
	push	ax
	mov	ax, offset s_whoJoins
	push	ds
	push	ax
	call	text_scrollingWindow
	add	sp, 0Ah
	mov	[bp+var_15A], ax
	or	ax, ax
	jl	l_return
	mov	ax, [bp+var_156]
	cmp	[bp+var_15A], ax
	jge	short l_addCharacter
	push	[bp+var_15A]
	push	cs
	call	near ptr camp_insertParty
	add	sp, 2
	jmp	l_return
l_addCharacter:
	mov	si, [bp+var_15A]
	shl	si, 1
	shl	si, 1
	push	word ptr [bp+si+savedList+2]
	push	word ptr [bp+si+savedList]
	push	cs
	call	near ptr party_nameExists
	add	sp, 4
	or	ax, ax
	jl	short l_loopContinue
	mov	si, [bp+var_15A]
	shl	si, 1
	shl	si, 1
	push	word ptr [bp+si+savedList+2]
	push	word ptr [bp+si+savedList]
	call	printStringWClear
	add	sp, 4
	mov	ax, offset s_alreadyInParty
	push	ds
	push	ax
	call	printString
	add	sp, 4
	mov	ax, 4000h
	push	ax
	call	getKey
	add	sp, 2
	mov	[bp+var_158], 1
	jmp	short l_loopComparison
l_loopContinue:
	mov	[bp+var_158], 0
l_loopComparison:
	cmp	[bp+var_158], 0
	jnz	l_ioLoopEnter
	push	cs
	call	near ptr party_findEmptySlot
	mov	[bp+var_158], ax
	cmp	ax, 7
	jge	short l_shortReturnLabel
	mov	ax, charSize
	imul	[bp+var_158]
	mov	bx, ax
	lea	ax, party._name[bx]
	mov	dx, seg	seg027
	push	dx
	push	ax
	mov	ax, [bp+var_15A]
	sub	ax, [bp+var_156]
	mov	cx, charSize
	imul	cx
	mov	bx, ax
	lea	ax, g_rosterCharacterBuffer[bx]
	mov	dx, seg	seg022
	push	dx
	push	ax
	push	cs
	call	near ptr copyCharacterBuf
	add	sp, 8
	push	cs
	call	near ptr party_addCharacter
	mov	byte ptr g_printPartyFlag,	0
l_shortReturnLabel:
	jmp	short l_return
l_noSavedCharacters:
	mov	ax, offset s_noCharsOnDisk
	push	ds
	push	ax
	call	printString
	add	sp, 4
	mov	ax, 4000h
	push	ax
	call	getKey
	add	sp, 2
l_return:
	pop	si
	mov	sp, bp
	pop	bp
	retf
camp_addMember endp

; Attributes: bp-based frame

camp_insertParty proc far

	loopCounter= word ptr	-0Ah
	savedPartiesP= dword ptr -8
	var_4= word ptr	-4
	var_2= word ptr	-2
	savedPartyNumber= word ptr	 6

	push	bp
	mov	bp, sp
	mov	ax, 0Ah
	call	someStackOperation
	push	si

	mov	ax, [bp+savedPartyNumber]
	mov	cl, 7
	shl	ax, cl
	add	ax, offset g_rosterPartyBuffer
	mov	word ptr [bp+savedPartiesP], ax
	mov	word ptr [bp+savedPartiesP+2], seg seg022
	call	text_clear
	mov	[bp+loopCounter], 0
	jmp	short l_loopComparison
l_incrementCounter:
	inc	[bp+loopCounter]
l_loopComparison:
	cmp	[bp+loopCounter], 7
	jge	l_return

	mov	si, [bp+loopCounter]
	mov	cl, 4
	shl	si, cl
	lfs	bx, [bp+savedPartiesP]
	cmp	byte ptr fs:[bx+si+10h], 0
	jz	l_return
	mov	ax, [bp+loopCounter]
	mov	cl, 4
	shl	ax, cl
	add	ax, bx
	mov	dx, fs
	add	ax, 10h
	push	dx
	push	ax
	push	cs
	call	near ptr party_nameExists
	add	sp, 4
	or	ax, ax
	jl	short l_findEmptySlot
	mov	cl, 4
	shl	ax, cl
	add	ax, word ptr [bp+savedPartiesP]
	mov	dx, word ptr [bp+savedPartiesP+2]
	add	ax, 10h
	push	dx
	push	ax
	call	printString
	add	sp, 4
	mov	ax, offset s_alreadyInParty
	push	ds
	push	ax
	call	printString
	add	sp, 4
	mov	ax, 2
	push	ax
	call	text_delayNoTable
	add	sp, 2
	jmp	short l_incrementCounter
l_findEmptySlot:
	push	cs
	call	near ptr party_findEmptySlot
	mov	[bp+var_2], ax
	cmp	ax, 7
	jge	l_rosterFull

	; Check that the character named in the party is in the
	; list of saved characters
	mov	ax, [bp+loopCounter]
	mov	cl, 4
	shl	ax, cl
	add	ax, word ptr [bp+savedPartiesP]
	mov	dx, word ptr [bp+savedPartiesP+2]
	add	ax, 10h
	push	dx
	push	ax
	push	cs
	call	near ptr roster_nameExists
	add	sp, 4
	mov	[bp+var_4], ax
	or	ax, ax
	jge	short l_addCharacter
	mov	ax, [bp+loopCounter]
	mov	cl, 4
	shl	ax, cl
	add	ax, word ptr [bp+savedPartiesP]
	mov	dx, word ptr [bp+savedPartiesP+2]
	add	ax, 10h
	push	dx
	push	ax
	call	printString
	add	sp, 4
	mov	ax, offset s_noOneHereNamedThat
	push	ds
	push	ax
	call	printString
	add	sp, 4
	mov	ax, 2
	push	ax
	call	text_delayNoTable
	add	sp, 2
	jmp	l_incrementCounter
l_addCharacter:
	mov	ax, charSize
	imul	[bp+var_2]
	mov	bx, ax
	lea	ax, party._name[bx]
	mov	dx, seg	seg027
	push	dx
	push	ax
	mov	ax, charSize
	imul	[bp+var_4]
	mov	bx, ax
	lea	ax, g_rosterCharacterBuffer[bx]
	mov	dx, seg	seg022
	push	dx
	push	ax
	push	cs
	call	near ptr copyCharacterBuf
	add	sp, 8
	push	cs
	call	near ptr party_addCharacter
	mov	byte ptr g_printPartyFlag,	0
	jmp	l_incrementCounter
l_rosterFull:
	mov	ax, offset s_rosterIsFull
	push	ds
	push	ax
	call	printString
	add	sp, 4
	mov	ax, 2
	push	ax
	call	text_delayNoTable
	add	sp, 2
	jmp	l_incrementCounter
l_return:
	pop	si
	mov	sp, bp
	pop	bp
	retf
camp_insertParty endp

; Attributes: bp-based frame

camp_removeMember proc far

	loopCounter=	word ptr -24h
	slotToRemove=	word ptr -22h
	partyMemberList=	word ptr -20h
	var_1E=	word ptr -1Eh
	var_1C=	word ptr -1Ch
	var_1A=	word ptr -1Ah

	push	bp
	mov	bp, sp
	mov	ax, 24h
	call	someStackOperation
	push	si

	mov	[bp+loopCounter], 0
	mov	ax, offset s_removeAll
	mov	[bp+partyMemberList], ax
	mov	[bp+var_1E], ds
loc_12723:
	cmp	[bp+loopCounter], 7
	jge	short loc_1275A
	mov	ax, charSize
	imul	[bp+loopCounter]
	mov	bx, ax
	cmp	byte ptr gs:party._name[bx], 0
	jz	short loc_1275A
	mov	ax, charSize
	imul	[bp+loopCounter]
	add	ax, offset party
	mov	si, [bp+loopCounter]
	shl	si, 1
	shl	si, 1
	mov	[bp+si+var_1C],	ax
	mov	[bp+si+var_1A],	seg seg027
	inc	[bp+loopCounter]
	jmp	short loc_12723
loc_1275A:
	mov	ax, [bp+loopCounter]
	inc	ax
	push	ax
	lea	ax, [bp+partyMemberList]
	push	ss
	push	ax
	mov	ax, offset s_whichPartyMemberToRemove
	push	ds
	push	ax
	call	text_scrollingWindow
	add	sp, 0Ah

	mov	[bp+slotToRemove], ax
	or	ax, ax
	jl	l_return
l_removeAll:
	cmp	[bp+slotToRemove], 0
	jnz	short l_removeOneCharacter
	push	cs
	call	near ptr party_clear
	jmp	short l_saveAndReturn
l_removeOneCharacter:
	mov	ax, [bp+slotToRemove]
	dec	ax
	push	ax
	call	roster_writeCharacter
	add	sp, 2

	mov	ax, [bp+slotToRemove]
	dec	ax
	push	ax
	push	cs
	call	near ptr party_pack
	add	sp, 2
l_saveAndReturn:
	call	roster_countCharacters
	push	ax
	call	writeCharacterFile
	add	sp, 2
	mov	byte ptr g_printPartyFlag,	0
l_return:
	pop	si
	mov	sp, bp
	pop	bp
	retf
camp_removeMember endp


; This function	moves all of the roster	slots below
; partySlotNumber up one slot. It then zeroes the tail of the
; party. This effectively removes the character from
; the party.
; Attributes: bp-based frame

party_pack proc far

	partySlotNumber=	word ptr  6

	push	bp
	mov	bp, sp
	push	si

loc_127AE:
	cmp	[bp+partySlotNumber], 6
	jge	short l_return
	mov	ax, charSize
	imul	[bp+partySlotNumber]
	mov	si, ax
	lea	ax, party._name[si]
	mov	dx, seg	seg027
	push	dx
	push	ax
	lea	ax, partySecondSlot._name[si]
	push	dx
	push	ax
	push	cs
	call	near ptr copyCharacterBuf
	add	sp, 8
	inc	[bp+partySlotNumber]
	jmp	short loc_127AE
l_return:
	mov	gs:partyTail._name, 0
	pop	si
	mov	sp, bp
	pop	bp
	retf
party_pack endp

; Attributes: bp-based frame

party_clear proc far

	slotNo=	word ptr -2

	push	bp
	mov	bp, sp
	mov	ax, 2
	call	someStackOperation

	call	roster_writeParty
	mov	[bp+slotNo], 0
l_loopEnter:
	mov	ax, charSize
	imul	[bp+slotNo]
	mov	bx, ax
	mov	byte ptr gs:party._name[bx], 0
	inc	[bp+slotNo]
	cmp	[bp+slotNo], 7
	jl	short l_loopEnter
	mov	sp, bp
	pop	bp
	retf
party_clear endp


; Attributes: bp-based frame

camp_renameMember proc far

	var_25E= word ptr -25Eh
	var_25C= word ptr -25Ch
	loopCounter= word ptr -25Ah
	nameSelected= word ptr -258h
	nameBuf= word ptr -254h
	characterNameList= dword ptr -22Ch
	var_100= word ptr -100h

	push	bp
	mov	bp, sp
	mov	ax, 25Eh
	call	someStackOperation
	push	si

	call	text_clear
	push	cs
	call	near ptr roster_countCharacters
	or	ax, ax
	jz	l_noSavedCharacters
loc_12835:
	mov	[bp+loopCounter], 0
	mov	[bp+nameSelected], 0
l_createListLoopEntry:
	cmp	[bp+nameSelected], 75
	jge	l_selectFromList
	mov	ax, charSize
	imul	[bp+loopCounter]
	add	ax, 0
	mov	si, [bp+loopCounter]
	shl	si, 1
	shl	si, 1
	mov	word ptr [bp+si+characterNameList], ax
	mov	word ptr [bp+si+characterNameList+2], seg	seg022
	mov	si, [bp+loopCounter]
	inc	[bp+loopCounter]
	inc	[bp+nameSelected]
	shl	si, 1
	shl	si, 1
	lfs	bx, [bp+si+characterNameList]
	cmp	byte ptr fs:[bx], 0
	jnz	short l_createListLoopEntry
l_selectFromList:
	dec	[bp+loopCounter]
	push	[bp+loopCounter]
	lea	ax, [bp+characterNameList]
	push	ss
	push	ax
	mov	ax, offset s_renameWho
	push	ds
	push	ax
	call	text_scrollingWindow
	add	sp, 0Ah
	mov	[bp+nameSelected], ax
	or	ax, ax
	jl	l_return

	mov	ax, offset s_whatIs
	push	ds
	push	ax
	lea	ax, [bp+var_100]
	push	ss
	push	ax
	call	strcat
	add	sp, 8
	mov	[bp+var_25E], ax
	mov	[bp+var_25C], dx
	mov	si, [bp+nameSelected]
	shl	si, 1
	shl	si, 1
	push	word ptr [bp+si+characterNameList+2]
	push	word ptr [bp+si+characterNameList]
	push	dx
	push	ax
	call	strcat
	add	sp, 8
	mov	[bp+var_25E], ax
	mov	[bp+var_25C], dx
	mov	ax, offset s_newName
	push	ds
	push	ax
	push	dx
	push	[bp+var_25E]
	call	strcat
	add	sp, 8
	mov	[bp+var_25E], ax
	mov	[bp+var_25C], dx
	lea	ax, [bp+var_100]
	push	ss
	push	ax
	call	printStringWClear
	add	sp, 4
	mov	[bp+loopCounter], 0

l_clearNameLoopEntry:
	mov	si, [bp+loopCounter]
	mov	byte ptr [bp+si+nameBuf], 0
	inc	[bp+loopCounter]
	cmp	[bp+loopCounter], 10h
	jl	short l_clearNameLoopEntry
	mov	ax, 0Eh
	push	ax
	lea	ax, [bp+nameBuf]
	push	ss
	push	ax
	call	readString
	add	sp, 6
	or	ax, ax
	jz	short l_return
	lea	ax, [bp+nameBuf]
	push	ss
	push	ax
	push	cs
	call	near ptr roster_nameExists
	add	sp, 4
	or	ax, ax
	jl	short l_renameCharacter
	mov	ax, offset s_nameAlreadyExists
	push	ds
	push	ax
	call	printStringWClear
	add	sp, 4
	jmp	short l_return
l_renameCharacter:
	mov	[bp+loopCounter], 0
l_renameLoopEntry:
	mov	si, [bp+loopCounter]
	mov	al, byte ptr [bp+si+nameBuf]
	mov	si, [bp+nameSelected]
	shl	si, 1
	shl	si, 1
	lfs	bx, [bp+si+characterNameList]
	mov	si, [bp+loopCounter]
	mov	fs:[bx+si], al
	inc	[bp+loopCounter]
	cmp	[bp+loopCounter], 10h
	jl	short l_renameLoopEntry
	jmp	short l_return
l_noSavedCharacters:
	mov	ax, offset s_noCharsOnDisk
	push	ds
	push	ax
	call	printString
	add	sp, 4
	mov	ax, 4000h
	push	ax
	call	getKey
	add	sp, 2
l_return:
	pop	si
	mov	sp, bp
	pop	bp
	retf
camp_renameMember endp


; Attributes: bp-based frame

camp_createMember proc far

	var_23A= byte ptr -23Ah
	var_EC=	byte ptr -0ECh
	var_EA=	word ptr -0EAh
	var_E8=	word ptr -0E8h
	var_7E=	byte ptr -7Eh
	var_34=	word ptr -34h
	counter= word ptr -32h
	var_30=	word ptr -30h
	var_2E=	word ptr -2Eh
	var_24=	word ptr -24h
	var_22=	word ptr -22h
	var_20=	dword ptr -20h
	var_1C=	word ptr -1Ch
	var_8= word ptr	-8
	raceGenderValue= word ptr -6
	var_4= word ptr	-4
	var_2= word ptr	-2

	push	bp
	mov	bp, sp
	mov	ax, 0ECh
	call	someStackOperation
	push	di
	push	si
	mov	word ptr [bp+var_20], offset newCharBuffer
	mov	word ptr [bp+var_20+2],	seg seg027
loc_129B3:
	mov	[bp+counter], 0
	jmp	short loc_129BD
loc_129BA:
	inc	[bp+counter]
loc_129BD:
	cmp	[bp+counter], 78h 
	jge	short loc_129CF
	mov	bx, [bp+counter]
	lfs	si, [bp+var_20]
	mov	byte ptr fs:[bx+si], 0
	jmp	short loc_129BA
loc_129CF:
	push	cs
	call	near ptr getCharacterGender
	mov	gs:newCharBuffer.gender, al
	cmp	al, 0FFh
	jnz	short loc_129E4
	sub	ax, ax
	jmp	loc_12DAE
loc_129E4:
	push	cs
	call	near ptr getCharacterRace
	mov	gs:newCharBuffer.race, al
	cmp	al, 0FFh
	jnz	short loc_129F9
	sub	ax, ax
	jmp	loc_12DAE
loc_129F9:
	mov	al, gs:newCharBuffer.race
	sub	ah, ah
	shl	ax, 1
	mov	cl, gs:newCharBuffer.gender
	sub	ch, ch
	add	ax, cx
	mov	cx, ax
	shl	ax, 1
	shl	ax, 1
	add	ax, cx
	mov	[bp+raceGenderValue], ax
	mov	[bp+counter], 0
	jmp	short loc_12A1F
loc_12A1C:
	inc	[bp+counter]
loc_12A1F:
	cmp	[bp+counter], 5
	jge	short loc_12A5A
	call	random
	and	ax, 7
	mov	si, [bp+raceGenderValue]
	mov	bx, [bp+counter]
	mov	cx, ax
	mov	al, byte ptr baseAttributes.male_st[bx+si]
	cbw
	add	ax, cx
	mov	si, bx
	shl	si, 1
	mov	[bp+si+var_2E],	ax
	mov	si, [bp+counter]
	shl	si, 1
	cmp	[bp+si+var_2E],	1Eh
	jle	short loc_12A58
	mov	si, [bp+counter]
	shl	si, 1
	mov	[bp+si+var_2E],	1Eh
loc_12A58:
	jmp	short loc_12A1C
loc_12A5A:
	call	random
	and	ax, 0Fh
	add	ax, 13
	mov	[bp+var_30], ax
	mov	gs:newCharBuffer.currentHP, ax
	mov	gs:newCharBuffer.maxHP,	ax
	mov	[bp+var_24], ax
	call	text_clear
	mov	ax, 5
	push	ax
	lea	ax, [bp+var_E8]
	push	ss
	push	ax
	lea	ax, [bp+var_2E]
	push	ss
	push	ax
	call	getAttributeString
	add	sp, 0Ah

	lea	ax, [bp+var_E8]
	push	ss
	push	ax
	call	printString
	add	sp, 4
	mov	al, gs:newCharBuffer.race
	sub	ah, ah
	mov	cx, ax
	shl	ax, 1
	shl	ax, 1
	add	ax, cx
	shl	ax, 1
	mov	[bp+raceGenderValue], ax
	sub	ax, ax
	mov	[bp+var_EA], ax
	mov	[bp+var_2], ax
	mov	al, gs:txt_numLines
	sub	ah, ah
	mov	[bp+var_8], ax
	mov	[bp+counter], 0
	jmp	short loc_12AD8
loc_12AD5:
	inc	[bp+counter]
loc_12AD8:
	cmp	[bp+counter], 10
	jge	short loc_12B30
	mov	si, [bp+raceGenderValue]
	mov	bx, [bp+counter]
	cmp	byte ptr startingClasses.canBeWarrior[bx+si], 0
	jz	short loc_12B2E
	mov	bl, gs:txt_numLines
	sub	bh, bh
	shl	bx, 1
	mov	ax, (bitMask16bit+2)[bx]
	or	[bp+var_2], ax
	mov	bx, [bp+counter]
	shl	bx, 1
	shl	bx, 1
	push	word ptr (g_classString+2)[bx]
	push	word ptr g_classString[bx]
	push	[bp+var_EA]
	push	cs
	call	near ptr printListItem
	add	sp, 6
	mov	si, [bp+var_EA]
	inc	[bp+var_EA]
	shl	si, 1
	mov	ax, [bp+counter]
	mov	[bp+si+var_1C],	ax
loc_12B2E:
	jmp	short loc_12AD5
loc_12B30:
	mov	[bp+var_4], 0
	mov	[bp+var_34], 1
loc_12B3A:
	push	[bp+var_2]
	call	getKey
	add	sp, 2
	mov	[bp+var_22], ax
	mov	ax, [bp+var_8]
	add	ax, 10Eh
	cmp	ax, [bp+var_22]
	jg	short loc_12B7B
	mov	ax, [bp+var_EA]
	add	ax, [bp+var_8]
	add	ax, 10Eh
	cmp	ax, [bp+var_22]
	jl	short loc_12B7B
	mov	si, [bp+var_22]
	sub	si, [bp+var_8]
	shl	si, 1
	mov	al, [bp+si+var_23A]
	mov	gs:newCharBuffer.class,	al
	mov	[bp+var_34], 0
loc_12B7B:
	cmp	[bp+var_22], 30h 
	jle	short loc_12BA4
	mov	ax, [bp+var_EA]
	add	ax, 30h	
	cmp	ax, [bp+var_22]
	jl	short loc_12BA4
	mov	si, [bp+var_22]
	shl	si, 1
	mov	al, [bp+si+var_7E]
	mov	gs:newCharBuffer.class,	al
	mov	[bp+var_34], 0
	jmp	short loc_12BB4
loc_12BA4:
	cmp	[bp+var_22], 1Bh
	jnz	short loc_12BB4
	mov	[bp+var_34], 0
	mov	[bp+var_4], 1
loc_12BB4:
	cmp	[bp+var_34], 0
	jz	short loc_12BBD
	jmp	loc_12B3A
loc_12BBD:
	cmp	[bp+var_4], 0
	jz	short loc_12BC6
	jmp	loc_129B3
loc_12BC6:
	mov	al, gs:newCharBuffer.class
	sub	ah, ah
	mov	si, ax
	mov	di, word ptr gs:newCharBuffer.gender
	and	di, 0FFh
	mov	bx, si
	shl	bx, 1
	mov	al, g_classPictureNumber[bx+di]
	mov	gs:newCharBuffer.picIndex, al
	mov	ax, si
	jmp	short loc_12C3B
loc_12BEB:
	mov	gs:newCharBuffer.spells, 0E0h ;	''
	jmp	short loc_12C56
loc_12BF7:
	mov	gs:newCharBuffer.spells+2, 1Ch
	jmp	short loc_12C56
loc_12C03:
	mov	gs:newCharBuffer.specAbil, 14h
	mov	gs:newCharBuffer.specAbil+1, 14h
	mov	gs:newCharBuffer.specAbil+2, 14h
	jmp	short loc_12C56
loc_12C1B:
	mov	gs:newCharBuffer.specAbil, 1
	mov	gs:newCharBuffer.specAbil+1, 0FCh 
	jmp	short loc_12C56
loc_12C2D:
	mov	gs:newCharBuffer.specAbil, 5
	jmp	short loc_12C56
	jmp	short loc_12C56
loc_12C3B:
	cmp	ax, class_conjurer
	jz	short loc_12BEB
	cmp	ax, class_magician
	jz	short loc_12BF7
	cmp	ax, class_rogue
	jz	short loc_12C03
	cmp	ax, class_bard
	jz	short loc_12C1B
	cmp	ax, class_hunter
	jz	short loc_12C2D
	jmp	short $+2
loc_12C56:
	mov	bl, gs:newCharBuffer.class
	sub	bh, bh
	mov	al, byte_4302E[bx]
	cbw
	mov	[bp+raceGenderValue], ax
	mov	[bp+counter], 0
loc_12C6E:
	mov	si, [bp+raceGenderValue]
	mov	bx, [bp+counter]
	mov	al, startingInventory[bx+si]
	mov	[bp+var_EC], al
	cmp	al, 0FEh 
	jz	short loc_12C8A
	mov	gs:newCharBuffer.inventory.itemFlags[bx], al
	inc	[bp+counter]
	jmp	short loc_12C6E
loc_12C8A:
	mov	word ptr [bp+var_20], offset newCharBuffer.strength
	mov	word ptr [bp+var_20+2],	seg seg027
	mov	[bp+counter], 0
	jmp	short loc_12C9E
loc_12C9B:
	inc	[bp+counter]
loc_12C9E:
	cmp	[bp+counter], 5
	jge	short loc_12CB7
	mov	si, [bp+counter]
	shl	si, 1
	mov	al, byte ptr [bp+si+var_2E]
	mov	bx, [bp+counter]
	lfs	si, [bp+var_20]
	mov	fs:[bx+si], al
	jmp	short loc_12C9B
loc_12CB7:
	mov	gs:newCharBuffer.level,	1
	mov	gs:newCharBuffer.maxLevel, 1
	cmp	gs:newCharBuffer.class,	class_warrior
	jz	short loc_12CEE
	cmp	gs:newCharBuffer.class,	class_rogue
	jnb	short loc_12CEE
	call	random
	and	ax, 0Fh
	add	ax, 8
	mov	gs:newCharBuffer.currentSppt, ax
	jmp	short loc_12CF5
loc_12CEE:
	mov	gs:newCharBuffer.currentSppt, 0
loc_12CF5:
	mov	ax, gs:newCharBuffer.currentSppt
	mov	gs:newCharBuffer.maxSppt, ax
loc_12CFD:
	mov	ax, offset s_nameYourCharacter
	push	ds
	push	ax
	call	printStringWClear
	add	sp, 4
	mov	ax, 0Eh
	push	ax
	mov	ax, offset newCharBuffer
	mov	dx, seg	seg027
	push	dx
	push	ax
	call	readString
	add	sp, 6
	or	ax, ax
	jnz	short loc_12D25
	jmp	loc_12DAE
loc_12D25:
	cmp	gs:newCharBuffer._name,	2Ah 
	jnz	short loc_12D37
	mov	gs:newCharBuffer._name,	58h 
loc_12D37:
	mov	ax, offset newCharBuffer
	mov	dx, seg	seg027
	push	dx
	push	ax
	push	cs
	call	near ptr roster_nameExists
	add	sp, 4
	or	ax, ax
	jl	short loc_12D6A
	mov	ax, offset s_nameAlreadyExists
	push	ds
	push	ax
	call	printStringWClear
	add	sp, 4
	mov	ax, 4000h
	push	ax
	call	getKey
	add	sp, 2
	mov	[bp+var_4], 1
	jmp	short loc_12D6F
loc_12D6A:
	mov	[bp+var_4], 0
loc_12D6F:
	cmp	[bp+var_4], 0
	jnz	short loc_12CFD
	push	cs
	call	near ptr roster_countCharacters
	mov	[bp+var_30], ax
	mov	ax, charSize
	imul	[bp+var_30]
	mov	bx, ax
	lea	ax, g_rosterCharacterBuffer[bx]
	mov	dx, seg	seg022
	push	dx
	push	ax
	mov	ax, offset newCharBuffer
	mov	dx, seg	seg027
	push	dx
	push	ax
	push	cs
	call	near ptr copyCharacterBuf
	add	sp, 8
	mov	ax, charSize
	imul	[bp+var_30]
	mov	bx, ax
	mov	fs, seg022_x
	assume fs:seg022
	mov	fs:(g_rosterCharacterBuffer+78h)[bx], 0
loc_12DAE:
	pop	si
	pop	di
	mov	sp, bp
	pop	bp
	retf
camp_createMember endp

; Attributes: bp-based frame
getCharacterGender proc	far

	push	bp
	mov	bp, sp

loc_loop_start:
	mov	ax, offset s_genderOptions
	push	ds
	push	ax
	call	printStringWClear
	add	sp, 4

	mov	ax, 0Ch
	push	ax
	call	getKey
	add	sp, 2

	cmp	ax, 1Bh
	jz	loc_return_ff

	cmp	ax, 'F'
	jz	loc_return_one
	cmp	ax, 111h
	jz	loc_return_one

	cmp	ax, 'M'
	jz	loc_return_zero
	cmp	ax, 110h
	jnz	loc_loop_start
	
loc_return_zero:
	xor	ax, ax
	jmp	loc_exit

loc_return_one:
	mov	ax, 1
	jmp	loc_exit

loc_return_ff:
	mov	ax, 0FFh

loc_exit:
	mov	sp, bp
	pop	bp
	retf
getCharacterGender endp

; Attributes: bp-based frame

getCharacterRace proc far

	var_2= word ptr	-2

	push	bp
	mov	bp, sp
	mov	ax, 2
	call	someStackOperation

l_ioLoopEntry:
	mov	ax, offset s_raceOptions
	push	ds
	push	ax
	call	printStringWClear
	add	sp, 4
	mov	ax, 1FCh
	push	ax
	call	getKey
	add	sp, 2
	mov	[bp+var_2], ax
	cmp	ax, 1Bh
	jnz	short l_checkMouse
	mov	ax, 0FFh
	jmp	short l_return
l_checkMouse:
	cmp	[bp+var_2], 10Fh
	jle	short l_checkKey
	cmp	[bp+var_2], 117h
	jge	short l_checkKey
	mov	ax, [bp+var_2]
	sub	ax, 110h
	jmp	short l_return
l_checkKey:
	cmp	[bp+var_2], 30h	
	jle	short l_ioLoopEntry
	cmp	[bp+var_2], 38h	
	jge	short l_ioLoopEntry
	mov	ax, [bp+var_2]
	sub	ax, 31h	
l_return:
	mov	sp, bp
	pop	bp
	retf
getCharacterRace endp

; Returns the character	number of the character	name.
; Returns -1 if	there is no character by the provided
; name in the party
;
; DWORD - _offset & _segment
;

; Attributes: bp-based frame

party_nameExists	proc far

	loopCounter= word ptr	-2
	_offset= word ptr  6
	_segment= word ptr  8

	push	bp
	mov	bp, sp
	mov	ax, 2
	call	someStackOperation

	mov	[bp+loopCounter], 0
l_loopEntry:
	mov	ax, charSize
	imul	[bp+loopCounter]
	mov	bx, ax
	lea	ax, party._name[bx]
	mov	dx, seg	seg027
	push	dx
	push	ax
	push	[bp+_segment]
	push	[bp+_offset]
	call	strcmp
	add	sp, 8
	or	ax, ax
	jz	l_returnValue
	inc	[bp+loopCounter]
	cmp	[bp+loopCounter], 7
	jl	l_loopEntry
	mov	ax, 0FFFFh
	jmp	l_return
l_returnValue:
	mov	ax, [bp+loopCounter]
l_return:
	mov	sp, bp
	pop	bp
	retf
party_nameExists	endp

; This function	returns	the index of the character
; in the saved character list matching "name". If the
; name is not found it returns 0xffff
; Attributes: bp-based frame

roster_nameExists proc far

	counter= word ptr -2
	nameOffset= word ptr  6
	nameString= word ptr  8

	push	bp
	mov	bp, sp
	mov	ax, 2
	call	someStackOperation

	mov	[bp+counter], 0
l_loopEntry:
	mov	ax, charSize
	imul	[bp+counter]
	mov	bx, ax
	lea	ax, g_rosterCharacterBuffer[bx]
	mov	dx, seg	seg022
	push	dx
	push	ax
	push	[bp+nameString]
	push	[bp+nameOffset]
	call	strcmp
	add	sp, 8
	or	ax, ax
	jz	short l_returnValue
	inc	[bp+counter]
	cmp	[bp+counter], 75
	jl	short l_loopEntry
	mov	ax, 0FFFFh
	jmp	short l_return

l_returnValue:
	mov	ax, [bp+counter]
l_return:
	mov	sp, bp
	pop	bp
	retf
roster_nameExists endp


; This function	prints a string	with a number in
; front	of it. e.g. 1) Wizard
; Attributes: bp-based frame

printListItem proc far

	stringBuf=	word ptr -2Ch
	stringBufP= dword ptr -4
	indexNumber= byte ptr	 6
	arg_2= word ptr	 8
	arg_4= word ptr	 0Ah

	push	bp
	mov	bp, sp
	mov	ax, 2Ch
	call	someStackOperation

	lea	ax, [bp+stringBuf]
	mov	word ptr [bp+stringBufP], ax
	mov	word ptr [bp+stringBufP+2], ss
	lfs	bx, [bp+stringBufP]
	inc	word ptr [bp+stringBufP]
	mov	al, [bp+indexNumber]
	add	al, '1'
	mov	fs:[bx], al
	lfs	bx, [bp+stringBufP]
	inc	word ptr [bp+stringBufP]
	mov	byte ptr fs:[bx], ')'
	push	[bp+arg_4]
	push	[bp+arg_2]
	push	word ptr [bp+stringBufP+2]
	push	word ptr [bp+stringBufP]
	call	strcat
	add	sp, 8
	lea	ax, [bp+stringBuf]
	push	ss
	push	ax
	call	printString
	add	sp, 4
	mov	sp, bp
	pop	bp
	retf
printListItem endp

; Attributes: bp-based frame

camp_deleteMember proc far

	counter= word ptr -15Ch
	nameToDelete= word ptr -15Ah
	var_158= word ptr -158h
	var_156= word ptr -156h
	var_154= dword ptr -154h
	var_150= word ptr -150h
	var_14E= word ptr -14Eh

	push	bp
	mov	bp, sp
	mov	ax, 15Ch
	call	someStackOperation
	push	si

	call	text_clear
	push	cs
	call	near ptr roster_countCharacters
	or	ax, ax
	jz	l_noSavedCharacters
	mov	[bp+counter], 0
	mov	[bp+nameToDelete], 0
l_partyLoopEntry:
	cmp	[bp+nameToDelete], 10
	jge	l_partyLoopExit
	mov	si, [bp+counter]
	shl	si, 1
	shl	si, 1
	mov	ax, [bp+counter]
	mov	cl, 7
	shl	ax, cl
	add	ax, offset g_rosterPartyBuffer
	mov	word ptr [bp+si+var_154], ax
	mov	word ptr [bp+si+var_154+2], seg	seg022
	mov	si, [bp+counter]
	inc	[bp+counter]
	inc	[bp+nameToDelete]
	shl	si, 1
	shl	si, 1
	lfs	bx, [bp+si+var_154]
	cmp	byte ptr fs:[bx], 0
	jnz	short l_partyLoopEntry
l_partyLoopExit:
	dec	[bp+counter]
	mov	ax, [bp+counter]
	mov	[bp+var_156], ax
	mov	[bp+nameToDelete], 0
l_characterLoopEntry:
	cmp	[bp+nameToDelete], 75
	jge	l_characterLoopExit
	mov	ax, [bp+counter]
	sub	ax, [bp+var_156]
	mov	cx, charSize
	imul	cx
	add	ax, 0
	mov	si, [bp+counter]
	shl	si, 1
	shl	si, 1
	mov	word ptr [bp+si+var_154], ax
	mov	word ptr [bp+si+var_154+2], seg	seg022
	mov	si, [bp+counter]
	inc	[bp+counter]
	inc	[bp+nameToDelete]
	shl	si, 1
	shl	si, 1
	lfs	bx, [bp+si+var_154]
	cmp	byte ptr fs:[bx], 0
	jnz	short l_characterLoopEntry
l_characterLoopExit:
	dec	[bp+counter]
	push	[bp+counter]
	lea	ax, [bp+var_154]
	push	ss
	push	ax
	mov	ax, offset s_deleteWho
	push	ds
	push	ax
	call	text_scrollingWindow
	add	sp, 0Ah
	mov	[bp+nameToDelete], ax
	or	ax, ax
	jl	l_return
	mov	ax, [bp+var_156]
	cmp	[bp+nameToDelete], ax
	jge	short l_checkInParty
	push	[bp+nameToDelete]
	push	cs
	call	near ptr camp_deleteParty
	add	sp, 2
	jmp	l_return
l_checkInParty:
	mov	si, [bp+nameToDelete]
	shl	si, 1
	shl	si, 1
	push	word ptr [bp+si+var_154+2]
	push	word ptr [bp+si+var_154]
	push	cs
	call	near ptr party_nameExists
	add	sp, 4
	or	ax, ax
	jl	short l_verifyDelete
	mov	si, [bp+nameToDelete]
	shl	si, 1
	shl	si, 1
	push	word ptr [bp+si+var_154+2]
	push	word ptr [bp+si+var_154]
	call	printStringWClear
	add	sp, 4

	mov	ax, offset s_currentlyInParty
	push	ds
	push	ax
	call	printString
	add	sp, 4
	mov	ax, 4000h
	push	ax
	call	getKey
	add	sp, 2
	jmp	l_return
l_verifyDelete:
	mov	ax, offset s_confirmDelete
	push	ds
	push	ax
	call	printStringWClear
	add	sp, 4
	mov	si, [bp+nameToDelete]
	shl	si, 1
	shl	si, 1
	push	word ptr [bp+si+var_154+2]
	push	word ptr [bp+si+var_154]
	call	printString
	add	sp, 4
	call	getYesNo
	or	ax, ax
	jz	short l_return
	mov	ax, [bp+nameToDelete]
	mov	[bp+var_158], ax
l_packRoster:
	mov	ax, [bp+counter]
	cmp	[bp+var_158], ax
	jge	short l_zeroName
	mov	si, [bp+var_158]
	shl	si, 1
	shl	si, 1
	push	word ptr [bp+si+var_154+2]
	push	word ptr [bp+si+var_154]
	mov	si, [bp+var_158]
	shl	si, 1
	shl	si, 1
	push	[bp+si+var_14E]
	push	[bp+si+var_150]
	push	cs
	call	near ptr copyCharacterBuf
	add	sp, 8
	inc	[bp+var_158]
	jmp	short l_packRoster
l_zeroName:
	mov	si, [bp+counter]
	shl	si, 1
	shl	si, 1
	lfs	bx, [bp+si+var_154]
	mov	byte ptr fs:[bx], 0
	jmp	short l_return
l_noSavedCharacters:
	mov	ax, offset s_noCharsOnDisk
	push	ds
	push	ax
	call	printString
	add	sp, 4
	mov	ax, 4000h
	push	ax
	call	getKey
	add	sp, 2
l_return:
	pop	si
	mov	sp, bp
	pop	bp
	retf
camp_deleteMember endp


; Attributes: bp-based frame

camp_deleteParty proc far

	outputStringBufP= dword ptr -10Ah
	partyBuf= dword ptr -106h
	var_102= word ptr -102h
	outputStringBuf= word ptr -100h
	partyIndexNumber= word ptr	 6

	push	bp
	mov	bp, sp
	mov	ax, 10Ah
	call	someStackOperation
	push	si

	mov	ax, [bp+partyIndexNumber]
	mov	cl, 7
	shl	ax, cl
	add	ax, offset g_rosterPartyBuffer
	mov	word ptr [bp+partyBuf], ax
	mov	word ptr [bp+partyBuf+2], seg seg022
	mov	ax, offset s_confirmDelete
	push	ds
	push	ax
	lea	ax, [bp+outputStringBuf]
	push	ss
	push	ax
	call	strcat
	add	sp, 8
	mov	word ptr [bp+outputStringBufP], ax
	mov	word ptr [bp+outputStringBufP+2], dx

	push	word ptr [bp+partyBuf+2]
	push	word ptr [bp+partyBuf]
	push	dx
	push	ax
	call	strcat
	add	sp, 8
	mov	word ptr [bp+outputStringBufP], ax
	mov	word ptr [bp+outputStringBufP+2], dx

	lfs	bx, dword ptr [bp+outputStringBufP]
	inc	word ptr [bp+outputStringBufP]
	mov	byte ptr fs:[bx], '?'
	lfs	bx, dword ptr [bp+outputStringBufP]
	inc	word ptr [bp+outputStringBufP]
	mov	byte ptr fs:[bx], 0

	lea	ax, [bp+outputStringBuf]
	push	ss
	push	ax
	call	printStringWClear
	add	sp, 4
	call	getYesNo
	or	ax, ax
	jz	short l_return
	mov	ax, [bp+partyIndexNumber]
	mov	[bp+var_102], ax
l_packPartyBuf:
	cmp	[bp+var_102], 9
	jge	short l_zeroPartyBuf
	mov	ax, word ptr [bp+partyBuf]
	mov	dx, word ptr [bp+partyBuf+2]
	add	ax, 80h
	mov	word ptr [bp+outputStringBufP], ax
	mov	word ptr [bp+outputStringBufP+2], dx
	mov	ax, 80h
	push	ax
	push	dx
	push	word ptr [bp+outputStringBufP]
	push	dx
	push	word ptr [bp+partyBuf]
	call	memcpy
	add	sp, 0Ah
	mov	ax, word ptr [bp+outputStringBufP]
	mov	dx, word ptr [bp+outputStringBufP+2]
	mov	word ptr [bp+partyBuf], ax
	mov	word ptr [bp+partyBuf+2], dx
	inc	[bp+var_102]
	jmp	short l_packPartyBuf
l_zeroPartyBuf:
	mov	word ptr [bp+partyBuf], offset g_partyBufTail
	mov	word ptr [bp+partyBuf+2], seg seg022
	mov	[bp+var_102], 0
l_zeroPartyBufLoopEntry:
	cmp	[bp+var_102], 80h
	jge	short l_return
	mov	bx, [bp+var_102]
	lfs	si, [bp+partyBuf]
	mov	byte ptr fs:[bx+si], 0
	inc	[bp+var_102]
	jmp	short l_zeroPartyBufLoopEntry
l_return:
	pop	si
	mov	sp, bp
	pop	bp
	retf
camp_deleteParty endp

; Attributes: bp-based frame

camp_saveParty proc far

	savedPartyCount=	word ptr -18h
	partyName=	word ptr -16h
	var_2= word ptr	-2

	push	bp
	mov	bp, sp
	mov	ax, 18h
	call	someStackOperation

	mov	ax, offset s_askPartyName
	push	ds
	push	ax
	call	printStringWClear
	add	sp, 4
	mov	ax, 0Eh
	push	ax
	lea	ax, [bp+partyName]
	push	ss
	push	ax
	call	readString
	add	sp, 6
	or	ax, ax
	jz	short l_return
	push	cs
	call	near ptr roster_countParties
	mov	[bp+savedPartyCount], ax
	lea	ax, [bp+partyName]
	push	ss
	push	ax
	push	cs
	call	near ptr roster_partyExists
	add	sp, 4
	mov	[bp+var_2], ax
	or	ax, ax
	jge	short loc_13291
	mov	ax, [bp+savedPartyCount]
	mov	[bp+var_2], ax
loc_13291:
	cmp	[bp+var_2], 9
	jg	short l_return
	lea	ax, [bp+partyName]
	push	ss
	push	ax
	push	[bp+var_2]
	push	cs
	call	near ptr roster_makeParty
	add	sp, 6
l_return:
	mov	sp, bp
	pop	bp
	retf
camp_saveParty endp


; Attributes: bp-based frame

roster_partyExists proc far

	loopCounter= word ptr	-2
	arg_0= word ptr	 6
	arg_2= word ptr	 8

	push	bp
	mov	bp, sp
	mov	ax, 2
	call	someStackOperation

	mov	[bp+loopCounter], 0
l_loopEntry:
	mov	bx, [bp+loopCounter]
	mov	cl, 7
	shl	bx, cl
	lea	ax, g_rosterPartyBuffer[bx]
	mov	dx, seg	seg022
	push	dx
	push	ax
	push	[bp+arg_2]
	push	[bp+arg_0]
	call	strcmp
	add	sp, 8
	or	ax, ax
	jz	l_returnPartyIndex
	inc	[bp+loopCounter]
	cmp	[bp+loopCounter], 0Ah
	jl	l_loopEntry
l_returnMinusOne:
	mov	ax, 0FFFFh
	jmp	short l_return
l_returnPartyIndex:
	mov	ax, [bp+loopCounter]
l_return:
	mov	sp, bp
	pop	bp
	retf
roster_partyExists endp


; Attributes: bp-based frame

; Create the party in the roster's party buffer
;
; DWORD - arg_2 & arg_4

roster_makeParty proc far

	var_6= word ptr	-6
	partyBufP= dword ptr -4
	partyIndexNumber= word ptr	 6
	arg_2= word ptr	 8
	arg_4= word ptr	 0Ah

	push	bp
	mov	bp, sp
	mov	ax, 6
	call	someStackOperation

	mov	ax, [bp+partyIndexNumber]
	mov	cl, 7
	shl	ax, cl
	add	ax, offset g_rosterPartyBuffer
	mov	word ptr [bp+partyBufP], ax
	mov	word ptr [bp+partyBufP+2], seg seg022
	lfs	bx, [bp+partyBufP]
	mov	byte ptr fs:[bx], '>'
	push	[bp+arg_4]
	push	[bp+arg_2]
	mov	ax, word ptr [bp+partyBufP]
	mov	dx, word ptr [bp+partyBufP+2]
	inc	ax
	push	dx
	push	ax
	call	_strcpy
	add	sp, 8
	mov	[bp+var_6], 0
	jmp	short loc_1333C
loc_13339:
	inc	[bp+var_6]
loc_1333C:
	cmp	[bp+var_6], 7
	jge	short loc_1336F
	mov	ax, charSize
	imul	[bp+var_6]
	mov	bx, ax
	lea	ax, party._name[bx]
	mov	dx, seg	seg027
	push	dx
	push	ax
	mov	ax, [bp+var_6]
	mov	cl, 4
	shl	ax, cl
	add	ax, word ptr [bp+partyBufP]
	mov	dx, word ptr [bp+partyBufP+2]
	add	ax, 10h
	push	dx
	push	ax
	call	_strcpy
	add	sp, 8
	jmp	short loc_13339
loc_1336F:
	mov	sp, bp
	pop	bp
	retf
roster_makeParty endp

; Attributes: bp-based frame

roster_countParties proc far

	loopCounter= word ptr	-6
	partyBufferP= dword ptr -4

	push	bp
	mov	bp, sp
	mov	ax, 6
	call	someStackOperation
	push	si

	mov	word ptr [bp+partyBufferP], offset g_rosterPartyBuffer
	mov	word ptr [bp+partyBufferP+2], seg seg022
	mov	[bp+loopCounter], 0
l_loopEntry:
	mov	bx, [bp+loopCounter]
	mov	cl, 7
	shl	bx, cl
	lfs	si, [bp+partyBufferP]
	cmp	byte ptr fs:[bx+si], 0
	jz	l_returnCounter
	inc	[bp+loopCounter]
	cmp	[bp+loopCounter], 0Ah
	jl	short l_loopEntry
	mov	ax, 0Ah			; Return maximum number of parties
	jmp	short l_return
l_returnCounter:
	mov	ax, [bp+loopCounter]
l_return:
	pop	si
	mov	sp, bp
	pop	bp
	retf
roster_countParties endp


; Attributes: bp-based frame

camp_saveAndExit proc far

	push	bp
	mov	bp, sp

	mov	ax, offset s_saveAndExit
	push	ds
	push	ax
	call	printStringWClear
	add	sp, 4
	push	cs
	call	near ptr roster_writeParty
	sub	ax, ax
	push	ax
	call	getKey
	add	sp, 2
	cmp	ax, 0Dh
	jnz	short loc_13412
	mov	g_mapRval, 0FFh
	push	cs
	call	near ptr roster_countCharacters
	push	ax
	push	cs
	call	near ptr writeCharacterFile
	add	sp, 2
	push	cs
	call	near ptr roster_countParties
	push	ax
	push	cs
	call	near ptr writePartyFile
	add	sp, 2
loc_13412:
	call	text_clear
	mov	sp, bp
	pop	bp
	retf
camp_saveAndExit endp

; Attributes: bp-based frame

camp_exit	proc far

	push	bp
	mov	bp, sp

	push	cs
	call	near ptr roster_writeParty
	push	cs
	call	near ptr roster_countCharacters
	push	ax
	push	cs
	call	near ptr writeCharacterFile
	add	sp, 2
	push	cs
	call	near ptr roster_countParties
	push	ax
	push	cs
	call	near ptr writePartyFile
	add	sp, 2

	mov	g_currentHour, 6
	sub	al, al
	mov	g_levelNumber, al
	mov	gs:isNight, al
	mov	g_mapRval, 2

	mov	sp, bp
	pop	bp
	retf
camp_exit	endp

; Attributes: bp-based frame

camp_enter proc	far

	lastActiveSlot=	word ptr -58h
	loopCounter=	word ptr -56h
	mouseBitmask=	word ptr -54h
	optionKeys=	word ptr -52h
	currentKey=	word ptr -3Eh
	optionMouse=	word ptr -3Ch
	campOptionList=	word ptr -14h

	push	bp
	mov	bp, sp
	mov	ax, 58h
	call	someStackOperation
	push	si

	call	endNoncombatSong

	; End all duration spells when entering camp
	mov	[bp+loopCounter], 0
l_durationSpellLoopEntry:
	mov	bx, [bp+loopCounter]
	cmp	lightDuration[bx], 0
	jz	short l_notActive
	push	bx
	call	icon_deactivate
	add	sp, 2
l_notActive:
	inc	[bp+loopCounter]
	cmp	[bp+loopCounter], 5
	jl	short l_durationSpellLoopEntry

	mov	gs:gl_detectSecretDoorFlag, 0
	mov	gs:g_songAcBonus,	0
	push	cs
	call	near ptr readRosterFiles
	push	cs
	call	near ptr roster_writeParty
	mov	ax, offset s_ruinTitle
	push	ds
	push	ax
	call	setTitle
	add	sp, 4
	sub	ax, ax
	push	ax
	call	bigpic_drawPictureNumber
	add	sp, 2
l_mainIoLoopEntry:
	call	text_clear
	lea	ax, [bp+campOptionList]
	push	ss
	push	ax
	push	cs
	call	near ptr camp_configOptionList
	add	sp, 4
	lea	ax, [bp+optionMouse]
	push	ss
	push	ax
	lea	ax, [bp+optionKeys]
	push	ss
	push	ax
	lea	ax, [bp+campOptionList]
	push	ss
	push	ax
	mov	ax, offset s_campMenuString
	push	ds
	push	ax
	call	printVarString
	add	sp, 10h
	mov	[bp+mouseBitmask], ax
	push	cs
	call	near ptr party_findEmptySlot
	mov	[bp+lastActiveSlot], ax
	mov	ax, [bp+mouseBitmask]
	or	ah, 20h
	push	ax
	call	getKey
	add	sp, 2
	mov	[bp+currentKey], ax

	cmp	ax, '0'			; Print character if 1-7
	jle	short l_checkKeyAgainstOptions
	mov	ax, [bp+lastActiveSlot]
	add	ax, '1'
	cmp	ax, [bp+currentKey]
	jle	short l_checkKeyAgainstOptions
	mov	ax, [bp+currentKey]
	sub	ax, '1'
	push	ax
	call	character_print
	add	sp, 2
	sub	ax, ax
	push	ax
	call	bigpic_drawPictureNumber
	add	sp, 2
	mov	ax, offset s_ruinTitle
	push	ds
	push	ax
	call	setTitle
	add	sp, 4
	jmp	short loc_135A7

l_checkKeyAgainstOptions:
	mov	[bp+loopCounter], 0
loc_13569:
	mov	si, [bp+loopCounter]
	cmp	byte ptr [bp+si+optionKeys], 0
	jz	short loc_135A7

	mov	al, byte ptr [bp+si+optionKeys]
	cbw
	cmp	ax, [bp+currentKey]
	jz	short l_executeCampFunction
	shl	si, 1
	mov	ax, [bp+currentKey]
	cmp	[bp+si+optionMouse], ax
	jnz	short loc_135A2

l_executeCampFunction:
	mov	bx, [bp+loopCounter]
	shl	bx, 1
	shl	bx, 1
	call	g_campActionFunctions[bx]
	cmp	g_mapRval, 0
	jz	short loc_135A2
	mov	ax, g_mapRval
	jmp	short loc_135AA
loc_135A2:
	inc	[bp+loopCounter]
	jmp	short loc_13569
loc_135A7:
	jmp	l_mainIoLoopEntry
loc_135AA:
	pop	si
	mov	sp, bp
	pop	bp
	retf
camp_enter endp



; Attributes: bp-based frame

readRosterFiles proc far

	bufferP= dword ptr -0Ah
	loopCounter= word ptr	-6
	fileDescriptor= word ptr	-4
	characterCount= word ptr	-2

	push	bp
	mov	bp, sp
	mov	ax, 0Ah
	call	someStackOperation

	push	si
	mov	word ptr [bp+bufferP], offset g_rosterCharacterBuffer
	mov	word ptr [bp+bufferP+2], seg seg022
	mov	[bp+loopCounter], 0
	jmp	short loc_135CF
loc_135CC:
	inc	[bp+loopCounter]
loc_135CF:
	cmp	[bp+loopCounter], 4Bh	
	jge	short loc_135E6
	mov	ax, charSize
	imul	[bp+loopCounter]
	mov	bx, ax
	lfs	si, [bp+bufferP]
	mov	byte ptr fs:[bx+si], 0
	jmp	short loc_135CC
loc_135E6:
	mov	ax, offset s_thievesInf
	push	ds
	push	ax
	push	cs
	call	near ptr openFile
	add	sp, 4
	mov	[bp+fileDescriptor], ax
	mov	ax, 9000
	push	ax
	mov	ax, offset g_rosterCharacterBuffer
	mov	dx, seg	seg022
	push	dx
	push	ax
	push	[bp+fileDescriptor]
	call	read
	add	sp, 8
	push	[bp+fileDescriptor]
	call	close
	add	sp, 2
	push	cs
	call	near ptr roster_countCharacters
	mov	[bp+characterCount], ax
	mov	[bp+loopCounter], ax
	jmp	short loc_13626
loc_13623:
	inc	[bp+loopCounter]
loc_13626:
	cmp	[bp+loopCounter], 75
	jge	short loc_1363D
	mov	ax, charSize
	imul	[bp+loopCounter]
	mov	bx, ax
	lfs	si, [bp+bufferP]
	mov	byte ptr fs:[bx+si], 0
	jmp	short loc_13623
loc_1363D:
	mov	word ptr [bp+bufferP], offset g_rosterPartyBuffer
	mov	word ptr [bp+bufferP+2], seg seg022
	mov	[bp+loopCounter], 0
	jmp	short loc_13651
loc_1364E:
	inc	[bp+loopCounter]
loc_13651:
	cmp	[bp+loopCounter], 0Ah
	jge	short loc_13667
	mov	bx, [bp+loopCounter]
	mov	cl, 7
	shl	bx, cl
	lfs	si, [bp+bufferP]
	mov	byte ptr fs:[bx+si], 0
	jmp	short loc_1364E
loc_13667:
	mov	ax, offset s_partiesInf
	push	ds
	push	ax
	push	cs
	call	near ptr openFile
	add	sp, 4
	mov	[bp+fileDescriptor], ax
	mov	ax, 500h
	push	ax
	mov	ax, offset g_rosterPartyBuffer
	mov	dx, seg	seg022
	push	dx
	push	ax
	push	[bp+fileDescriptor]
	call	read
	add	sp, 8
	push	cs
	call	near ptr roster_countParties
	mov	[bp+loopCounter], ax
	jmp	short loc_13699
loc_13696:
	inc	[bp+loopCounter]
loc_13699:
	cmp	[bp+loopCounter], 0Ah
	jge	short loc_136AF
	mov	bx, [bp+loopCounter]
	mov	cl, 7
	shl	bx, cl
	lfs	si, [bp+bufferP]
	mov	byte ptr fs:[bx+si], 0
	jmp	short loc_13696
loc_136AF:
	push	[bp+fileDescriptor]
	call	close
	add	sp, 2
	mov	ax, [bp+characterCount]
	jmp	short $+2
	pop	si
	mov	sp, bp
	pop	bp
	retf
readRosterFiles endp

; Attributes: bp-based frame

writeCharacterFile proc far

	var_2= word ptr	-2
	arg_0= word ptr	 6

	push	bp
	mov	bp, sp
	mov	ax, 2
	call	someStackOperation

	mov	ax, offset s_thievesInf
	push	ds
	push	ax
	push	cs
	call	near ptr openFile
	add	sp, 4
	mov	[bp+var_2], ax
	mov	ax, charSize
	imul	[bp+arg_0]
	inc	ax
	push	ax
	mov	ax, offset g_rosterCharacterBuffer
	mov	dx, seg	seg022
	push	dx
	push	ax
	push	[bp+var_2]
	call	write
	add	sp, 8
	push	[bp+var_2]
	call	close
	add	sp, 2
	mov	sp, bp
	pop	bp
	retf
writeCharacterFile endp

; Attributes: bp-based frame

writePartyFile proc far

	var_2= word ptr	-2
	arg_0= word ptr	 6

	push	bp
	mov	bp, sp
	mov	ax, 2
	call	someStackOperation

	mov	ax, offset s_partiesInf
	push	ds
	push	ax
	push	cs
	call	near ptr openFile
	add	sp, 4
	mov	[bp+var_2], ax
	mov	ax, [bp+arg_0]
	mov	cl, 7
	shl	ax, cl
	inc	ax
	push	ax
	mov	ax, offset g_rosterPartyBuffer
	mov	dx, seg	seg022
	push	dx
	push	ax
	push	[bp+var_2]
	call	write
	add	sp, 8
	push	[bp+var_2]
	call	close
	add	sp, 2
	mov	sp, bp
	pop	bp
	retf
writePartyFile endp

; Attributes: bp-based frame

roster_writeParty proc far

	emptySlot= word ptr -4
	counter= word ptr -2

	push	bp
	mov	bp, sp
	mov	ax, 8
	call	someStackOperation

	push	cs
	call	near ptr party_findEmptySlot
	mov	[bp+emptySlot],	ax
	mov	[bp+counter], 0
	jmp	short loc_13769
loc_13766:
	inc	[bp+counter]
loc_13769:
	mov	ax, [bp+emptySlot]
	cmp	[bp+counter], ax
	jge	l_return
	push	[bp+counter]
	call	roster_writeCharacter
	add	sp, 2
	jmp	loc_13766
l_return:
	mov	sp, bp
	pop	bp
	retf
roster_writeParty endp

; Attributes: bp-based frame

roster_writeCharacter proc far
	var_4= word ptr	-4
	var_2= word ptr	-2
	partySlotNumber= word ptr  6

	push	bp
	mov	bp, sp
	mov	ax, 4
	call	someStackOperation

	mov	ax, charSize
	imul	[bp+partySlotNumber]
	mov	bx, ax
	lea	ax, party._name[bx]
	mov	dx, seg	seg027
	push	dx
	push	ax
	push	cs
	call	near ptr roster_nameExists
	add	sp, 4
	mov	[bp+var_4], ax
	or	ax, ax
	jge	short l_overwrite
	push	cs
	call	near ptr roster_countCharacters
	mov	[bp+var_2], ax
	mov	ax, charSize
	imul	[bp+var_2]
	mov	bx, ax
	lea	ax, g_rosterCharacterBuffer[bx]
	mov	dx, seg	seg022
	push	dx
	push	ax
	mov	ax, charSize
	imul	[bp+var_2]
	mov	bx, ax
	lea	ax, party._name[bx]
	mov	dx, seg	seg027
	push	dx
	push	ax
	push	cs
	call	near ptr copyCharacterBuf
	add	sp, 8
	jmp	short l_return

l_overwrite:
	mov	ax, charSize
	imul	[bp+var_4]
	mov	bx, ax
	lea	ax, g_rosterCharacterBuffer[bx]
	mov	dx, seg	seg022
	push	dx
	push	ax
	mov	ax, charSize
	imul	[bp+partySlotNumber]
	mov	bx, ax
	lea	ax, party._name[bx]
	mov	dx, seg	seg027
	push	dx
	push	ax
	push	cs
	call	near ptr copyCharacterBuf
	add	sp, 8

l_return:
	mov	sp, bp
	pop	bp
	retf
roster_writeCharacter endp

; Attributes: bp-based frame

; DWORD - arg_0 & arg_2, arg_4 & arg_6

copyCharacterBuf proc far

	arg_0= word ptr	 6
	arg_2= word ptr	 8
	arg_4= word ptr	 0Ah
	arg_6= word ptr	 0Ch

	push	bp
	mov	bp, sp

	mov	ax, 78h	
	push	ax
	push	[bp+arg_2]
	push	[bp+arg_0]
	push	[bp+arg_6]
	push	[bp+arg_4]
	call	memcpy
	add	sp, 0Ah
	mov	sp, bp
	pop	bp
	retf
copyCharacterBuf endp


; This function	counts the number of characters	in
; the ioBuffer memory area.
; Attributes: bp-based frame

roster_countCharacters	proc far

	bufferP= dword ptr -6
	loopCounter= word ptr -2

	push	bp
	mov	bp, sp
	mov	ax, 6
	call	someStackOperation
	push	si

	mov	word ptr [bp+bufferP], offset g_rosterCharacterBuffer
	mov	word ptr [bp+bufferP+2], seg seg022
	mov	[bp+loopCounter], 0
loc_13842:
	cmp	[bp+loopCounter], 75
	jge	loc_13858
	mov	ax, charSize
	imul	[bp+loopCounter]
	mov	bx, ax
	lfs	si, [bp+bufferP]
	cmp	fs:[bx+si+character_t._name], 0
	jz	short loc_13858
	inc	[bp+loopCounter]
	jmp	short loc_13842
loc_13858:
	mov	ax, [bp+loopCounter]
	jmp	short $+2
	pop	si
	mov	sp, bp
	pop	bp
	retf
roster_countCharacters	endp

; This function creates a byte array to determine what
; menu items are available in the Camp
;
; a[0] - Add a member
; a[1] - Remove a member
; a[2] - Rename a member
; a[3] - Create a member
; a[4] - Transfer characters
; a[5] - Delete a member
; a[6] - Save the party
; a[7] - Leave the game
; a[8] - Enter wilderness

; Attributes: bp-based frame

camp_configOptionList proc far

	counter= word ptr -2
	arg_0= dword ptr  6

	push	bp
	mov	bp, sp
	mov	ax, 2
	call	someStackOperation
	push	si

	push	cs
	call	near ptr party_findEmptySlot
	cmp	ax, 7
	jge	short loc_1387B
	mov	al, 1
	jmp	short l_setElementZero
loc_1387B:
	sub	al, al
l_setElementZero:
	lfs	bx, [bp+arg_0]
	mov	fs:[bx+campStru_t.hasEmptySlot], al	; Add a member

	push	cs
	call	near ptr party_isNotEmpty
	lfs	bx, [bp+arg_0]
	mov	fs:[bx+campStru_t.notEmpty], al		; Remove a member

	cmp	fs:[bx+campStru_t.notEmpty], 1
	sbb	ax, ax
	neg	ax
	mov	fs:[bx+campStru_t.isEmpty], al		; Rename a member

	push	cs
	call	near ptr roster_countCharacters
	cmp	ax, 75
	jge	short loc_138AB
	mov	al, 1
	jmp	short l_setElementThree
loc_138AB:
	sub	al, al
l_setElementThree:
	lfs	bx, [bp+arg_0]
	mov	fs:[bx+campStru_t.canSaveChar],	al	; Create a member

	mov	al, fs:[bx+campStru_t.canSaveChar]
	mov	fs:[bx+campStru_t.canSaveChar_1], al	; Transfer characters

	mov	[bp+counter], campStru_t.field_5	; Set the rest to 1
	jmp	short loc_138C9
loc_138C6:
	inc	[bp+counter]
loc_138C9:
	cmp	[bp+counter], 8
	jge	short loc_138DB
	mov	bx, [bp+counter]
	lfs	si, [bp+arg_0]
	mov	byte ptr fs:[bx+si], 1
	jmp	short loc_138C6
loc_138DB:
	lfs	bx, [bp+arg_0]
	mov	al, fs:[bx+campStru_t.notEmpty]
	mov	fs:[bx+campStru_t.field_6], al		; Save the party
	push	cs
	call	near ptr party_getLastSlot
	cmp	ax, 7
	jge	short loc_138F3
	mov	al, 1
	jmp	short loc_138F5
loc_138F3:
	sub	al, al
loc_138F5:
	lfs	bx, [bp+arg_0]
	mov	fs:[bx+8], al				; Enter Wilderness
	pop	si
	mov	sp, bp
	pop	bp
	retf
camp_configOptionList endp


; This function	searches through the roster looking
; for an entry that has	0 as the first character of
; the name field.
; Attributes: bp-based frame

party_findEmptySlot proc	far

	loopCounter= word ptr	-2

	push	bp
	mov	bp, sp
	mov	ax, 2
	call	someStackOperation

	mov	[bp+loopCounter], 0
l_loopEntry:
	mov	ax, charSize
	imul	[bp+loopCounter]
	mov	bx, ax
	cmp	byte ptr gs:party._name[bx], 0
	jz	l_returnCounter
	inc	[bp+loopCounter]
	cmp	[bp+loopCounter], 7
	jl	l_loopEntry
	mov	ax, 7
	jmp	short l_return
l_returnCounter:
	mov	ax, [bp+loopCounter]
l_return:
	mov	sp, bp
	pop	bp
	retf
party_findEmptySlot endp

; This function	returns	1 if roster slot zero
; is occupied. Zero otherwise
; Attributes: bp-based frame

party_isNotEmpty	proc far
	push	bp
	mov	bp, sp
	cmp	gs:party._name, 1
	sbb	ax, ax
	inc	ax
	mov	sp, bp
	pop	bp
	retf
party_isNotEmpty	endp


; This function	starts at the end of the roster	and
; returns the index of the last	slot that still	has
; a character active
; Attributes: bp-based frame

party_getLastSlot proc far

	loopCounter= word ptr	-2

	push	bp
	mov	bp, sp
	mov	ax, 2
	call	someStackOperation

	mov	[bp+loopCounter], 6
l_loopEntry:
	push	[bp+loopCounter]
	push	cs
	call	near ptr party_isSlotActive
	add	sp, 2
	or	ax, ax
	jnz	l_returnCounter
	dec	[bp+loopCounter]
	cmp	[bp+loopCounter], 0
	jge	l_loopEntry
	mov	ax, 99
	jmp	l_return
l_returnCounter:
	mov	ax, [bp+loopCounter]
l_return:
	mov	sp, bp
	pop	bp
	retf
party_getLastSlot endp

; This function	returns	0 if the roster	slot at	slotNo
; is empty, field_67 !=	0, or field_2d & 1c
; Attributes: bp-based frame

party_isSlotActive proc	far

	slotNo=	word ptr  6

	push	bp
	mov	bp, sp

	mov	ax, charSize
	imul	[bp+slotNo]
	mov	bx, ax
	cmp	byte ptr gs:party._name[bx], 0
	jz	short l_returnZero

	mov	ax, charSize
	imul	[bp+slotNo]
	mov	bx, ax
	cmp	gs:(party.specAbil+3)[bx], 0
	jnz	short l_returnZero

	mov	ax, charSize
	imul	[bp+slotNo]
	mov	bx, ax
	test	gs:party.status[bx], stat_dead	or stat_stoned or stat_paralyzed
	jnz	short l_returnZero

	mov	ax, 1
	jmp	short l_return

l_returnZero:
	sub	ax, ax

l_return:
	mov	sp, bp
	pop	bp
	retf
party_isSlotActive endp

; Attributes: bp-based frame

tavern_enter proc far

	loopCounter= word ptr -4
	lastCharNo= word ptr -2

	push	bp
	mov	bp, sp
	mov	ax, 4
	call	someStackOperation

	push	cs
	call	near ptr party_findEmptySlot
	mov	[bp+lastCharNo], ax

	; Reset drunk status
	mov	[bp+loopCounter], 0
l_resetDrunkLoop:
	mov	bx, [bp+loopCounter]
	mov	tav_drunkLevel[bx], 0
	inc	[bp+loopCounter]
	cmp	[bp+loopCounter], 7
	jl	l_resetDrunkLoop

	mov	ax, 83
	push	ax
	call	bigpic_drawPictureNumber
	add	sp, 2
	push	cs
	call	near ptr tav_setTitle
	add	sp, 2
	mov	g_tavernSayingBase, ax

l_tavernMainLoop:
	mov	ax, offset s_tavernGreeting
	push	ds
	push	ax
	call	printStringWClear
	add	sp, 4
	mov	ax, 70h	
	push	ax
	call	getKey
	add	sp, 2
	cmp	ax, 'E'
	jz	short l_exitTavern
	cmp	ax, 'O'
	jz	short l_orderDrink
	cmp	ax, 'T'
	jz	short l_talkToBarkeep
	cmp	ax, 112h
	jz	short l_orderDrink
	cmp	ax, 113h
	jz	short l_talkToBarkeep
	cmp	ax, 114h
	jz	short l_exitTavern
	jmp	l_tavernMainLoop

l_orderDrink:
	push	[bp+lastCharNo]
	push	cs
	call	near ptr tav_orderDrink
	add	sp, 2
	or	ax, ax
	jnz	short l_returnZero
	mov	byte ptr g_printPartyFlag,	0
	jmp	short l_waitAndLoop

l_talkToBarkeep:
	push	[bp+lastCharNo]
	push	cs
	call	near ptr tavern_talkToBarkeep
	add	sp, 2
	mov	byte ptr g_printPartyFlag,	0
	jmp	short l_waitAndLoop

l_exitTavern:
	call	text_clear
	jmp	short l_returnZero

l_waitAndLoop:
	mov	ax, 4000h
	push	ax
	call	getKey
	add	sp, 2
	jmp	l_tavernMainLoop

l_returnZero:
	sub	ax, ax

l_return:
	mov	sp, bp
	pop	bp
	retf
tavern_enter endp

; Attributes: bp-based frame

tav_orderDrink proc far

	stringBuffer= word ptr -112h
	isOrdered=	word ptr -12h
	drinkIndexNumber=	word ptr -10h
	loopCounter= word ptr	-0Eh
	orderer= word ptr	-0Ch
	inputKey= word ptr	-0Ah
	lineCount= word ptr	-8
	mouseMask= word ptr	-6
	stringBufferP= dword ptr	-4
	lastCharNo= word ptr  6

	push	bp
	mov	bp, sp
	mov	ax, 112h
	call	someStackOperation

	mov	ax, offset s_whoWillOrder
	push	ds
	push	ax
	call	printString
	add	sp, 4

	push	cs
	call	near ptr readSlotNumber
	mov	[bp+orderer], ax
	or	ax, ax
	jl	l_returnZero

	mov	ax, charSize
	imul	[bp+orderer]
	mov	bx, ax
	test	gs:party.status[bx], stat_dead or stat_stoned or stat_paralyzed
	jz	short l_orderLoopEntry

	mov	bx, [bp+orderer]
	mov	tav_drunkLevel[bx], maxDrunkLevel
	jmp	l_checkDrunkLevel

l_orderLoopEntry:
	mov	ax, offset s_seatThyself
	push	ds
	push	ax
	lea	ax, [bp+stringBuffer]
	push	ss
	push	ax
	call	strcat
	add	sp, 8
	mov	word ptr [bp+stringBufferP], ax
	mov	word ptr [bp+stringBufferP+2], dx

	mov	ax, charSize
	imul	[bp+orderer]
	mov	bx, ax
	lea	ax, party._name[bx]
	mov	dx, seg	seg027
	push	dx
	push	ax
	push	word ptr [bp+stringBufferP+2]
	push	word ptr [bp+stringBufferP]
	call	strcat
	add	sp, 8
	mov	word ptr [bp+stringBufferP], ax
	mov	word ptr [bp+stringBufferP+2], dx

	lea	ax, [bp+stringBuffer]
	push	ss
	push	ax
	call	printStringWClear
	add	sp, 4
	mov	al, gs:txt_numLines
	sub	ah, ah
	add	ax, 2
	mov	[bp+lineCount], ax
	mov	[bp+mouseMask], 0
	mov	[bp+loopCounter], 0
loc_13B61:
	mov	bx, [bp+lineCount]
	add	bx, [bp+loopCounter]
	shl	bx, 1
	mov	ax, bitMask16bit[bx]
	or	[bp+mouseMask], ax
	inc	[bp+loopCounter]
	cmp	[bp+loopCounter], 5
	jl	short loc_13B61

	mov	ax, offset s_drinkOptions
	push	ds
	push	ax
	call	printString
	add	sp, 4

l_inputLoop:
	push	[bp+mouseMask]
	call	getKey
	add	sp, 2
	mov	[bp+inputKey], ax
	cmp	ax, dosKeys_ESC
	jz	l_returnZero
	cmp	ax, 119h
	jz	l_returnZero

	mov	[bp+isOrdered], 1
	mov	[bp+loopCounter], 0
l_checkKeyLoop:
	mov	bx, [bp+loopCounter]
	mov	al, byte ptr s_drinkOptionKeys[bx]
	cbw
	cmp	ax, [bp+inputKey]
	jz	short l_setDrinkNumber

	mov	ax, bx
	add	ax, [bp+lineCount]
	add	ax, 10Eh
	cmp	ax, [bp+inputKey]
	jz	short l_setDrinkNumber

l_checkKeyNext:
	inc	[bp+loopCounter]
	cmp	[bp+loopCounter], 5
	jl	short l_checkKeyLoop
	jmp	short l_checkForOrder

l_setDrinkNumber:
	mov	ax, bx
	mov	[bp+drinkIndexNumber], ax
	mov	[bp+isOrdered], 0

l_checkForOrder:
	cmp	[bp+isOrdered], 0
	jnz	short l_inputLoop

l_checkDrunkLevel:
	mov	bx, [bp+orderer]
	cmp	tav_drunkLevel[bx], maxDrunkLevel
	jl	short l_payForDrink

	mov	ax, offset s_cantOrder
	push	ds
	push	ax
	call	printString
	add	sp, 4
	push	[bp+lastCharNo]
	push	cs
	call	near ptr tav_isPartyDrunk
	add	sp, 2
	or	ax, ax
	jz	l_returnZero

	mov	ax, offset s_partyIsDisgrace
	push	ds
	push	ax
	call	printString
	add	sp, 4
	mov	g_currentHour, 16h
	mov	ax, 1
	jmp	l_return

l_payForDrink:
	; BUG - This should probably be [bp+drinkIndexNumber]. As it is, the amount paid
	; for the drink is dependent on which party slot the drinker is in. The character
	; in slot 7 actually pays 0 for each drink.
	;
	mov	bx, [bp+drinkIndexNumber]
	mov	al, g_drinkPriceList[bx]
	cbw
	cwd
	push	dx
	push	ax
	push	[bp+orderer]
	push	cs
	call	near ptr character_removeGold
	add	sp, 6
	or	ax, ax
	jz	short l_notEnoughGold
	mov	ax, offset s_hereOrToGo
	push	ds
	push	ax
	call	printStringWClear
	add	sp, 4

l_hereToGoLoopEntry:
	mov	ax, 6
	push	ax
	call	getKey
	add	sp, 2
	cmp	ax, 'H'
	jz	short l_drinkHere
	cmp	ax, 'T'
	jz	short l_drinkToGo
	cmp	ax, 10Fh
	jz	short l_drinkHere
	cmp	ax, 110h
	jz	short l_drinkToGo
	jmp	short l_hereToGoLoopEntry

l_drinkHere:
	push	[bp+drinkIndexNumber]
	push	[bp+orderer]
	push	cs
	call	near ptr tavern_drink
	add	sp, 4
	jmp	l_returnZero

l_drinkToGo:
	push	[bp+drinkIndexNumber]
	push	[bp+orderer]
	push	cs
	call	near ptr tavern_getWineskin
	add	sp, 4
	jmp	short l_returnZero

l_notEnoughGold:
	mov	ax, offset s_notEnoughGold
	push	ds
	push	ax
	call	printStringWClear
	add	sp, 4

l_returnZero:
	sub	ax, ax

l_return:
	mov	sp, bp
	pop	bp
	retf
tav_orderDrink endp

; Attributes: bp-based frame

; DWORD: arg_2 & goldAmount

character_removeGold	proc far

	partySlotNumber= word ptr	 6
	arg_2= word ptr	 8
	goldAmount= word ptr	 0Ah

	push	bp
	mov	bp, sp
	push	si

	mov	ax, [bp+arg_2]
	mov	dx, [bp+goldAmount]
	mov	cx, ax
	mov	bx, dx
	mov	ax, charSize
	imul	[bp+partySlotNumber]
	mov	si, ax
	cmp	word ptr gs:(party.gold+2)[si], bx
	ja	short loc_13CEF
	jb	short loc_13CEB
	cmp	word ptr gs:party.gold[si], cx
	jnb	short loc_13CEF
loc_13CEB:
	sub	ax, ax
	jmp	short loc_13D0D
loc_13CEF:
	mov	ax, [bp+arg_2]
	mov	dx, bx
	mov	cx, ax
	mov	ax, charSize
	imul	[bp+partySlotNumber]
	mov	si, ax
	sub	word ptr gs:party.gold[si], cx
	sbb	word ptr gs:(party.gold+2)[si], bx
	mov	ax, 1
	jmp	short $+2
loc_13D0D:
	pop	si
	mov	sp, bp
	pop	bp
	retf
character_removeGold	endp

; Attributes: bp-based frame

tavern_drink proc far

	slotLevel= word ptr	-2
	slotNumber= word ptr	 6
	drinkIndexNumber= word ptr	 8

	push	bp
	mov	bp, sp
	mov	ax, 2
	call	someStackOperation
	push	si

	call	text_clear

	cmp	[bp+drinkIndexNumber], 4	; Ginger Ale
	jnz	short l_notGingerAle

	mov	ax, offset s_thirstQuencher
	push	ds
	push	ax
	call	printString
	add	sp, 4
	jmp	l_return

l_notGingerAle:
	cmp	[bp+drinkIndexNumber], 3	; Mead
	jnz	short l_notMead

	mov	ax, offset s_goodStuff
	push	ds
	push	ax
	call	printString
	add	sp, 4
	jmp	short l_calculateDrunkLevel

l_notMead:
	mov	ax, offset s_burpNotBad
	push	ds
	push	ax
	call	printString
	add	sp, 4

l_calculateDrunkLevel:
	mov	bx, [bp+slotNumber]
	mov	si, [bp+drinkIndexNumber]
	mov	al, tavern_drinkStrength[si]
	add	tav_drunkLevel[bx], al
	cmp	tav_drunkLevel[bx], 0Ch
	jle	short l_printDrunkString

	mov	bx, [bp+slotNumber]
	mov	tav_drunkLevel[bx], 0Ch

l_printDrunkString:
	mov	bx, [bp+slotNumber]
	mov	al, tav_drunkLevel[bx]
	cbw
	mov	bx, ax
	shl	bx, 1
	shl	bx, 1
	push	word ptr (drunkString+2)[bx]
	push	word ptr drunkString[bx]
	call	printString
	add	sp, 4

	; Restore bard songs
	mov	ax, charSize
	imul	[bp+slotNumber]
	mov	si, ax
	cmp	gs:party.class[si], class_bard
	jnz	short l_return

	mov	ax, gs:party.level[si]
	sub	ax, 0FFh
	sbb	cx, cx
	and	ax, cx
	add	ax, 0FFh
	mov	[bp+slotLevel], ax
	mov	al, gs:party.specAbil[si]
	sub	ah, ah
	cmp	ax, [bp+slotLevel]
	jnb	short l_return
	inc	gs:party.specAbil[si]

l_return:
	mov	ax, 4000h
	push	ax
	call	getKey
	add	sp, 2
	pop	si
	mov	sp, bp
	pop	bp
	retf
tavern_drink endp

; Attributes: bp-based frame

tavern_getWineskin	proc far

	drinkFlags= word ptr	-2
	partySlotNumber= word ptr	 6
	drinkIndexNumber= word ptr	 8

	push	bp
	mov	bp, sp
	mov	ax, 2
	call	someStackOperation

	cmp	[bp+drinkIndexNumber], 4		; Ginger Ale
	jnz	short l_fillWithSpirits

	sub	ax, ax					; wineskin->water
	jmp	short l_addWindskin

l_fillWithSpirits:
	mov	ax, 4					; wineskin->spirits

l_addWindskin:
	mov	[bp+drinkFlags], ax
	mov	ax, 1
	push	ax
	push	[bp+drinkFlags]
	mov	ax, 76h	
	push	ax
	push	[bp+partySlotNumber]
	call	inventory_addItem
	add	sp, 8
	or	ax, ax
	jz	short l_inventoryFull

	mov	ax, offset s_barkeepFillsWineskin
	push	ds
	push	ax
	call	printString
	add	sp, 4
	jmp	short l_return

l_inventoryFull:
	mov	ax, offset s_sorryBut
	push	ds
	push	ax
	call	printString
	add	sp, 4
	mov	ax, charSize
	imul	[bp+partySlotNumber]
	mov	bx, ax
	lea	ax, party._name[bx]
	mov	dx, seg	seg027
	push	dx
	push	ax
	call	printString
	add	sp, 4
	mov	ax, offset s_cantCarryAnyMore
	push	ds
	push	ax
	call	printString
	add	sp, 4

l_return:
	mov	ax, 4000h
	push	ax
	call	getKey
	add	sp, 2
	mov	sp, bp
	pop	bp
	retf
tavern_getWineskin	endp


; Attributes: bp-based frame

tav_isPartyDrunk proc far

	lastCharNo= word ptr  6

	push	bp
	mov	bp, sp

l_loopEntry:
	cmp	[bp+lastCharNo], 0
	jl	short l_returnOne
	mov	bx, [bp+lastCharNo]
	cmp	tav_drunkLevel[bx], maxDrunkLevel
	jl	short l_returnZero
	dec	[bp+lastCharNo]
	jmp	short l_loopEntry

l_returnOne:
	mov	ax, 1
	jmp	short l_return

l_returnZero:
	sub	ax, ax

l_return:
	mov	sp, bp
	pop	bp
	retf
tav_isPartyDrunk endp

; Attributes: bp-based frame

tav_setTitle proc far
	deltaN=	word ptr -8
	counter= word ptr -6
	tavernIndex= word ptr	-4
	deltaE=	word ptr -2

	push	bp
	mov	bp, sp
	mov	ax, 8
	call	someStackOperation
	push	si

	mov	[bp+tavernIndex], 4
	mov	si, g_direction
	shl	si, 1
	mov	ax, sq_north
	sub	ax, dirDeltaN[si]
	mov	[bp+deltaN], ax
	mov	ax, dirDeltaE[si]
	add	ax, sq_east
	mov	[bp+deltaE], ax

	mov	[bp+counter], 0
l_loopEntry:
	mov	ax, [bp+counter]
	mov	cx, ax
	shl	ax, 1
	shl	ax, 1
	add	ax, cx
	mov	si, ax
	mov	al, byte ptr g_tavernData.sqN[si]
	cbw
	cmp	ax, [bp+deltaN]
	jnz	short l_loopIncrement

	mov	al, g_tavernData.sqE[si]
	cbw
	cmp	ax, [bp+deltaE]
	jnz	short l_loopIncrement

	mov	al, g_tavernData.location[si]
	cbw
	cmp	ax, g_locationNumber
	jnz	short l_loopIncrement

	mov	ax, cx
	mov	[bp+tavernIndex], ax
	jmp	short l_setTitleAndReturn
l_loopIncrement:
	inc	[bp+counter]
	cmp	[bp+counter], 4
	jl	l_loopEntry

l_setTitleAndReturn:
	mov	bx, [bp+tavernIndex]
	shl	bx, 1
	shl	bx, 1
	push	word ptr (tavernNames+2)[bx]
	push	word ptr tavernNames[bx]
	call	setTitle
	add	sp, 4
	mov	bx, [bp+tavernIndex]
	mov	ax, bx
	shl	bx, 1
	shl	bx, 1
	add	bx, ax
	mov	al, g_tavernData.sayingBase[bx]
	cbw

	pop	si
	mov	sp, bp
	pop	bp
	retf
tav_setTitle endp


; Attributes: bp-based frame

tavern_talkToBarkeep proc far

	var_A= word ptr	-0Ah
	talkerSlotNumber= word ptr	-8
	tipAmount= dword ptr	-4

	push	bp
	mov	bp, sp
	mov	ax, 0Ah
	call	someStackOperation

	mov	ax, offset s_whoTalksToBarkeep
	push	ds
	push	ax
	call	printStringWClear
	add	sp, 4
	push	cs
	call	near ptr readSlotNumber
	mov	[bp+talkerSlotNumber], ax
	or	ax, ax
	jl	l_returnZero

	call	text_clear

	; Check talker drunk level
	mov	bx, [bp+talkerSlotNumber]
	cmp	tav_drunkLevel[bx], 0Ch
	jge	l_noConditionToTalk

	mov	ax, offset s_talkAintCheap
	push	ds
	push	ax
	call	printString
	add	sp, 4

	mov	bx, [bp+talkerSlotNumber]
	cmp	tav_drunkLevel[bx], 5
	jl	short l_skipNameCalling

	mov	ax, offset s_beerBreath
	push	ds
	push	ax
	call	printString
	add	sp, 4

l_skipNameCalling:
	mov	ax, offset s_barkeepSays
	push	ds
	push	ax
	call	printString
	add	sp, 4
	mov	ax, offset s_howMuchWillTip
	push	ds
	push	ax
	call	printString
	add	sp, 4
	call	readGold
	mov	word ptr [bp+tipAmount], ax
	mov	word ptr [bp+tipAmount+2], dx
	or	dx, ax
	jz	l_return
	push	word ptr [bp+tipAmount+2]
	push	word ptr [bp+tipAmount]
	push	[bp+talkerSlotNumber]
	push	cs
	call	near ptr character_removeGold
	add	sp, 6
	or	ax, ax
	jnz	short l_hasEnoughGold

	mov	ax, offset s_notEnoughGold
	push	ds
	push	ax
	call	printString
	add	sp, 4
	jmp	short l_return

l_hasEnoughGold:
	mov	ax, charSize
	imul	[bp+talkerSlotNumber]
	mov	bx, ax
	mov	ax, word ptr gs:party.gold[bx]
	or	ax, word ptr gs:(party.gold+2)[bx]
	jz	short l_gaveAllGold
	mov	[bp+var_A], 4

	jmp	short loc_14020
loc_1401D:
	dec	[bp+var_A]
loc_14020:
	cmp	[bp+var_A], 0
	jl	short l_return
	mov	bx, [bp+var_A]
	shl	bx, 1
	mov	ax, g_tavernSayingCost[bx]
	sub	dx, dx
	cmp	dx, word ptr [bp+tipAmount+2]
	ja	short loc_1401D
	jb	short loc_1403D
	cmp	ax, word ptr [bp+tipAmount]
	jnb	short loc_1401D
loc_1403D:
	mov	bx, [bp+var_A]
	add	bx, g_tavernSayingBase
	shl	bx, 1
	shl	bx, 1
	push	word ptr (barkeepSayings+2)[bx]
	push	word ptr barkeepSayings[bx]
	call	printString
	add	sp, 4
	jmp	short l_return

l_gaveAllGold:
	mov	ax, offset s_moneyTalks
	push	ds
	push	ax
	call	printString
	add	sp, 4
	jmp	short l_return

l_noConditionToTalk:
	mov	ax, offset s_noConditionToTalk
	push	ds
	push	ax
	call	printString
	add	sp, 4
	jmp	l_return

l_returnZero:
	sub	ax, ax

l_return:
	mov	sp, bp
	pop	bp
	retf
tavern_talkToBarkeep endp

; Attributes: bp-based frame

temple_enter proc far

	lastSlot= word ptr	-4
	inputKey= word ptr	-2

	push	bp
	mov	bp, sp
	mov	ax, 4
	call	someStackOperation

	call	text_clear
	mov	ax, 49
	push	ax
	call	bigpic_drawPictureNumber
	add	sp, 2
	push	cs
	call	near ptr temple_setTitle
	push	cs
	call	near ptr party_findEmptySlot
	mov	[bp+lastSlot], ax
l_templeIoLoopEntry:
	mov	ax, offset s_templeGreeting
	push	ds
	push	ax
	call	printStringWClear
	add	sp, 4

l_badKey:
	mov	ax, 70h	
	push	ax
	call	getKey
	add	sp, 2
	mov	[bp+inputKey], ax

	; Subtract 4 if selected with mouse
	cmp	ax, 10Eh
	jl	short l_skipMouseSubtract
	cmp	ax, 119h
	jg	short l_skipMouseSubtract
	sub	[bp+inputKey], 4

l_skipMouseSubtract:
	mov	ax, [bp+inputKey]
	jmp	short l_keySwitch
l_healCharacter:
	push	cs
	call	near ptr temple_getHealee
	jmp	short l_ioWaitAndLoop
l_poolGold:
	push	[bp+lastSlot]
	push	cs
	call	near ptr temple_getGoldPoolee
	add	sp, 2
l_ioWaitAndLoop:
	mov	byte ptr g_printPartyFlag,	0
	mov	ax, 4000h
	push	ax
	call	getKey
	add	sp, 2
	jmp	l_templeIoLoopEntry
l_keySwitch:
	cmp	ax, 'E'
	jz	short l_returnZero
	cmp	ax, 'H'
	jz	short l_healCharacter
	cmp	ax, 'P'
	jz	short l_poolGold
	cmp	ax, 10Eh
	jz	short l_healCharacter
	cmp	ax, 10Fh
	jz	short l_poolGold
	cmp	ax, 110h
	jz	short l_returnZero
	jmp	l_badKey
l_returnZero:
	sub	ax, ax
l_return:
	mov	sp, bp
	pop	bp
	retf
temple_enter endp

; Attributes: bp-based frame

; DWORD - var_108 & var_10A

temple_getHealee proc far

	deltaHP= word ptr -112h
	payee= word ptr	-110h
	statusAilment= word ptr	-10Eh
	var_10A= word ptr -10Ah
	var_108= word ptr -108h
	stringBuffer= word ptr -104h
	healeeSlotNumber= word ptr	-4
	healCost= word ptr -2
	lastPartySlot= word ptr	 6

	push	bp
	mov	bp, sp
	mov	ax, 112h
	call	someStackOperation
	push	si

	mov	ax, offset s_whoNeedsHealing
	push	ds
	push	ax
	call	printStringWClear
	add	sp, 4

	push	cs
	call	near ptr readSlotNumber
	mov	[bp+healeeSlotNumber], ax
	or	ax, ax
	jl	l_return

	mov	ax, [bp+lastPartySlot]
	cmp	[bp+healeeSlotNumber], ax
	jge	l_return

	mov	ax, charSize
	imul	[bp+healeeSlotNumber]
	mov	bx, ax
	lea	ax, party._name[bx]
	mov	dx, seg	seg027
	push	dx
	push	ax
	lea	ax, [bp+stringBuffer]
	push	ss
	push	ax
	call	strcat
	add	sp, 8
	mov	[bp+var_10A], ax
	mov	[bp+var_108], dx

	push	[bp+healeeSlotNumber]
	push	cs
	call	near ptr temple_getStatusAilment
	add	sp, 2
	mov	[bp+statusAilment], ax
	or	ax, ax
	jz	short l_noStatusAilment
	mov	ax, offset s_isInBadShape
	push	ds
	push	ax
	push	[bp+var_108]
	push	[bp+var_10A]
	call	strcat
	add	sp, 8
	mov	[bp+var_10A], ax
	mov	[bp+var_108], dx
	mov	ax, offset s_thouMustSacrifice
	push	ds
	push	ax
	push	dx
	push	[bp+var_10A]
	call	strcat
	add	sp, 8
	mov	[bp+var_10A], ax
	mov	[bp+var_108], dx
	push	[bp+statusAilment]
	push	[bp+healeeSlotNumber]
	push	cs
	call	near ptr temple_getHealPrice
	add	sp, 4
	mov	[bp+healCost], ax
	jmp	l_getPayer
l_noStatusAilment:
	mov	ax, charSize
	imul	[bp+healeeSlotNumber]
	mov	si, ax
	mov	ax, gs:party.maxHP[si]
	sub	ax, gs:party.currentHP[si]
	mov	[bp+deltaHP], ax
	or	ax, ax
	jnz	short l_healHpAmount

	mov	ax, gs:party.maxLevel[si]
	cmp	gs:party.level[si], ax
	jnz	short l_healLevelDrain

	mov	ax, offset s_dontNeedHealing
	push	ds
	push	ax
	push	[bp+var_108]
	push	[bp+var_10A]
	call	strcat
	add	sp, 8
	mov	[bp+var_10A], ax
	mov	[bp+var_108], dx
	lea	ax, [bp+stringBuffer]
	push	ss
	push	ax
	call	printStringWClear
	add	sp, 4
	jmp	l_return

l_healLevelDrain:
	mov	ax, offset s_drainedOfLife
	push	ds
	push	ax
	push	[bp+var_108]
	push	[bp+var_10A]
	call	strcat
	add	sp, 8
	mov	[bp+var_10A], ax
	mov	[bp+var_108], dx
	mov	ax, 8
	push	ax
	push	[bp+healeeSlotNumber]
	push	cs
	call	near ptr temple_getHealPrice
	add	sp, 4
	mov	[bp+healCost], ax
	jmp	short l_getPayer
l_healHpAmount:
	mov	ax, offset s_hasWounds
	push	ds
	push	ax
	push	[bp+var_108]
	push	[bp+var_10A]
	call	strcat
	add	sp, 8
	mov	[bp+var_10A], ax
	mov	[bp+var_108], dx
	mov	ax, [bp+deltaHP]
	mov	cx, ax
	shl	ax, 1
	shl	ax, 1
	add	ax, cx
	shl	ax, 1
	mov	[bp+healCost], ax
	mov	ax, offset s_donationWillBe
	push	ds
	push	ax
	push	dx
	push	[bp+var_10A]
	call	strcat
	add	sp, 8
	mov	[bp+var_10A], ax
	mov	[bp+var_108], dx
l_getPayer:
	sub	ax, ax
	push	ax
	mov	ax, [bp+healCost]
	cwd
	push	dx
	push	ax
	push	[bp+var_108]
	push	[bp+var_10A]
	call	itoa
	add	sp, 0Ah
	mov	[bp+var_10A], ax
	mov	[bp+var_108], dx
	mov	ax, offset s_templeGoldForfeit
	push	ds
	push	ax
	push	ax
	push	dx
	push	[bp+var_10A]
	call	strcat
	add	sp, 8
	mov	[bp+var_10A], ax
	mov	[bp+var_108], dx
	lea	ax, [bp+stringBuffer]
	push	ss
	push	ax
	call	printStringWClear
	add	sp, 4
	push	cs
	call	near ptr readSlotNumber
	mov	[bp+payee], ax
	or	ax, ax
	jl	l_return

	mov	ax, [bp+healCost]
	cwd
	push	dx
	push	ax
	push	[bp+payee]
	push	cs
	call	near ptr character_removeGold
	add	sp, 6
	or	ax, ax
	jnz	short l_clearStatus
	mov	ax, offset s_sorryButWithoutProper
	push	ds
	push	ax
	call	printStringWClear
	add	sp, 4
	jmp	l_return
l_clearStatus:
	cmp	[bp+statusAilment], 0
	jz	short l_healLevel
	push	[bp+statusAilment]
	push	[bp+healeeSlotNumber]
	push	cs
	call	near ptr temple_clearStatusAilment
	add	sp, 4
	jmp	short l_layHands
l_healLevel:
	mov	ax, charSize
	imul	[bp+healeeSlotNumber]
	mov	si, ax
	mov	ax, gs:party.maxLevel[si]
	cmp	gs:party.level[si], ax
	jz	short l_healHp
	dec	ax
	push	ax
	push	[bp+healeeSlotNumber]
	push	cs
	call	near ptr getLevelXp
	add	sp, 4
	mov	word ptr gs:party.experience[si], ax
	mov	word ptr gs:(party.experience+2)[si], dx
	mov	ax, charSize
	imul	[bp+healeeSlotNumber]
	mov	si, ax
	mov	ax, gs:party.maxLevel[si]
	mov	gs:party.level[si], ax
	jmp	short l_layHands
l_healHp:
	mov	ax, charSize
	imul	[bp+healeeSlotNumber]
	mov	si, ax
	mov	ax, gs:party.maxHP[si]
	mov	gs:party.currentHP[si], ax
l_layHands:
	mov	ax, offset s_layHands
	push	ds
	push	ax
	lea	ax, [bp+stringBuffer]
	push	ss
	push	ax
	call	strcat
	add	sp, 8
	mov	[bp+var_10A], ax
	mov	[bp+var_108], dx
	xor	ax, ax
	push	ax
	mov	ax, 3
	push	ax
	push	[bp+healeeSlotNumber]
	push	dx
	push	[bp+var_10A]
	push	cs
	call	near ptr printCharPronoun
	add	sp, 0Ah
	mov	[bp+var_10A], ax
	mov	[bp+var_108], dx
	mov	ax, offset s_elipsis
	push	ds
	push	ax
	push	dx
	push	[bp+var_10A]
	call	strcat
	add	sp, 8
	mov	[bp+var_10A], ax
	mov	[bp+var_108], dx
	mov	ax, offset s_elipsisAnd
	push	ds
	push	ax
	push	dx
	push	[bp+var_10A]
	call	strcat
	add	sp, 8
	mov	[bp+var_10A], ax
	mov	[bp+var_108], dx
	sub	ax, ax
	push	ax
	push	ax
	push	[bp+healeeSlotNumber]
	push	dx
	push	[bp+var_10A]
	push	cs
	call	near ptr printCharPronoun
	add	sp, 0Ah
	mov	[bp+var_10A], ax
	mov	[bp+var_108], dx
	mov	ax, offset s_isHealed
	push	ds
	push	ax
	push	dx
	push	[bp+var_10A]
	call	strcat
	add	sp, 8
	mov	[bp+var_10A], ax
	mov	[bp+var_108], dx
	lea	ax, [bp+stringBuffer]
	push	ss
	push	ax
	call	printStringWClear
	add	sp, 4
l_return:
	pop	si
	mov	sp, bp
	pop	bp
	retf
temple_getHealee endp

; Attributes: bp-based frame

; XXX - arg_4 should probably be a word ptr

printCharPronoun proc far

	var_16=	word ptr -16h
	var_2= word ptr	-2
	arg_0= word ptr	 6
	arg_2= word ptr	 8
	arg_4= byte ptr	 0Ah
	arg_6= word ptr	 0Ch
	arg_8= word ptr  0Eh

	push	bp
	mov	bp, sp
	mov	ax, 16h
	call	someStackOperation
	push	si

	test	[bp+arg_4], 80h
	jz	short loc_1452D
	mov	ax, word ptr [bp+arg_4]
	and	ax, 3
	mov	cx, monStruSize
	imul	cx
	mov	si, ax
	mov	al, gs:monGroups.packedGenAc[si]
	sub	ah, ah
	mov	cl, 6
	shr	ax, cl
	and	ax, 3
	mov	[bp+var_2], ax
	cmp	ax, 3
	jnz	short loc_1452B
	lea	ax, [bp+var_16]
	push	ss
	push	ax
	lea	ax, monGroups._name[si]
	mov	dx, seg	seg027
	push	dx
	push	ax
	call	unmaskString
	add	sp, 8
	sub	ax, ax
	push	ax
	push	[bp+arg_2]
	push	[bp+arg_0]
	lea	ax, [bp+var_16]
	push	ss
	push	ax
	call	str_pluralize
	add	sp, 0Ah
	jmp	short loc_14586
loc_1452B:
	jmp	short loc_14564
loc_1452D:
	getCharP	word ptr [bp+arg_4], si
	mov	al, gs:party.gender[si]
	sub	ah, ah
	and	ax, 3
	mov	[bp+var_2], ax
	cmp	ax, 3
	jnz	short loc_14564
	lea	ax, party._name[si]
	mov	dx, seg	seg027
	push	dx
	push	ax
	push	[bp+arg_2]
	push	[bp+arg_0]
	call	strcat
	add	sp, 8
	jmp	short loc_14586
loc_14564:
	mov	bx, [bp+var_2]
	add	bx, [bp+arg_6]
	shl	bx, 1
	shl	bx, 1
	push	word ptr (pronounString+2)[bx]
	push	word ptr pronounString[bx]
	push	[bp+arg_2]
	push	[bp+arg_0]
	call	strcat
	add	sp, 8
loc_14586:
	cmp	[bp+arg_8], 0
	jz	printCharPronoun_exit
	mov	ax, offset s_exclBlankLine
	push	ds
	push	ax
	push	dx
	push	ax
	call	strcat
	add	sp, 8

printCharPronoun_exit:
	pop	si
	mov	sp, bp
	pop	bp
	retf
printCharPronoun endp

; Attributes: bp-based frame

temple_setTitle	proc far

	deltaNS= word ptr	-8
	loopCounter= word ptr	-6
	templeIndex= word ptr	-4
	deltaEW= word ptr	-2

	push	bp
	mov	bp, sp
	mov	ax, 8
	call	someStackOperation
	push	si

	mov	si, g_direction
	shl	si, 1
	mov	ax, sq_north
	sub	ax, dirDeltaN[si]
	mov	[bp+deltaNS], ax
	mov	ax, dirDeltaE[si]
	add	ax, sq_east
	mov	[bp+deltaEW], ax
	mov	[bp+templeIndex], 3

	mov	[bp+loopCounter], 0
l_loopEntry:
	mov	si, [bp+loopCounter]
	mov	cl, 2
	shl	si, cl
	mov	al, byte ptr templeLoc.sqN[si]
	sub	ah, ah
	cmp	ax, [bp+deltaNS]
	jnz	short l_loopIncrement

	mov	al, templeLoc.sqE[si]
	cmp	ax, [bp+deltaEW]
	jnz	short l_loopIncrement

	mov	al, templeLoc.location[si]
	cmp	ax, g_locationNumber
	jnz	short l_loopIncrement

	mov	ax, [bp+loopCounter]
	mov	[bp+templeIndex], ax
	jmp	short l_setTitle
l_loopIncrement:
	inc	[bp+loopCounter]
	cmp	[bp+loopCounter], 3
	jl	l_loopEntry
l_setTitle:
	mov	bx, [bp+templeIndex]
	shl	bx, 1
	shl	bx, 1
	push	word ptr (templeTitles+2)[bx]
	push	word ptr templeTitles[bx]
	call	setTitle
	add	sp, 4

	pop	si
	mov	sp, bp
	pop	bp
	retf
temple_setTitle	endp

; Attributes: bp-based frame

temple_getHealPrice proc far

	targetLevel= word ptr	-2
	targetSlotNumber= word ptr	 6
	ailmentIndex= word ptr	 8

	push	bp
	mov	bp, sp

	mov	ax, charSize
	imul	[bp+targetSlotNumber]
	mov	bx, ax
	cmp	gs:party.class[bx], class_monster
	jb	short loc_14656
	mov	[bp+targetLevel], 1
	jmp	short loc_14670
loc_14656:
	mov	ax, charSize
	imul	[bp+targetSlotNumber]
	mov	bx, ax
	mov	ax, gs:party.level[bx]
	sub	ax, 13
	sbb	cx, cx
	and	ax, cx
	add	ax, 13
	mov	[bp+targetLevel], ax
loc_14670:
	mov	bx, [bp+ailmentIndex]
	shl	bx, 1
	mov	ax, temple_healPrice[bx]
	imul	[bp+targetLevel]

	mov	sp, bp
	pop	bp
	retf
temple_getHealPrice endp

; Attributes: bp-based frame

temple_getStatusAilment proc far

	counter= word ptr -4
	status=	word ptr -2
	targetSlotNumber= word ptr	 6

	push	bp
	mov	bp, sp
	mov	ax, 4
	call	someStackOperation

	mov	ax, charSize
	imul	[bp+targetSlotNumber]
	mov	bx, ax
	mov	al, gs:party.status[bx]
	sub	ah, ah
	mov	[bp+status], ax
	or	ax, ax
	jz	short l_returnZero
	mov	[bp+counter], 6

l_loopEntry:
	mov	bx, [bp+counter]
	mov	al, templeStatusBitmasks[bx]
	sub	ah, ah
	test	[bp+status], ax
	jnz	l_returnValue
	dec	[bp+counter]
	cmp	[bp+counter], 0
	jge	short l_loopEntry

l_returnValue:
	mov	al, templeHealPriceIndex[bx]
	jmp	l_return

l_returnZero:
	sub	ax, ax

l_return:
	mov	sp, bp
	pop	bp
	retf
temple_getStatusAilment endp

; Attributes: bp-based frame

temple_clearStatusAilment proc far

	targetSlotNumber= word ptr	 6
	ailmentIndex= word ptr	 8

	push	bp
	mov	bp, sp

	mov	ax, charSize
	imul	[bp+targetSlotNumber]
	mov	si, ax
	mov	bx, [bp+ailmentIndex]
	mov	al, statusHealMask[bx]
	and	gs:party.status[si], al
	mov	gs:party.hostileFlag[si], 0
	mov	ax, [bp+ailmentIndex]
	cmp	ax, 2
	jz	short l_revertAgeStatus

	cmp	ax, 6
	jz	short l_dispossess

	jmp	short l_revertDeath

l_revertAgeStatus:
	mov	ax, charSize
	imul	[bp+targetSlotNumber]
	mov	si, ax
	mov	ax, 5
	push	ax
	lea	ax, party.strength[si]
	mov	dx, seg	seg027
	push	dx
	push	ax
	lea	ax, party.savedST[si]
	push	dx
	push	ax
	call	character_applyAgeStatus
	add	sp, 0Ah
	jmp	short l_return

l_dispossess:
	mov	ax, charSize
	imul	[bp+targetSlotNumber]
	mov	bx, ax
	mov	gs:party.currentHP[bx], 1

l_revertDeath:
	mov	ax, charSize
	imul	[bp+targetSlotNumber]
	mov	bx, ax
	cmp	gs:party.currentHP[bx], 0
	jnz	short l_return

	mov	ax, charSize
	imul	[bp+targetSlotNumber]
	mov	bx, ax
	mov	gs:party.currentHP[bx], 1

l_return:
	pop	si
	mov	sp, bp
	pop	bp
	retf
temple_clearStatusAilment endp

; Attributes: bp-based frame

temple_getGoldPoolee proc far

	pooleeSlotNumber= word ptr	-2
	lastSlot= word ptr	 6

	push	bp
	mov	bp, sp
	mov	ax, 2
	call	someStackOperation

	mov	ax, offset s_whomGathersGold
	push	ds
	push	ax
	call	printStringWClear
	add	sp, 4
	push	cs
	call	near ptr readSlotNumber
	mov	[bp+pooleeSlotNumber], ax
	or	ax, ax
	jl	short l_return
	mov	ax, [bp+lastSlot]
	cmp	[bp+pooleeSlotNumber], ax
	jge	short l_return

	push	ax
	push	[bp+pooleeSlotNumber]
	push	cs
	call	near ptr doPoolGold
	add	sp, 4
	mov	ax, charSize
	imul	[bp+pooleeSlotNumber]
	mov	bx, ax
	lea	ax, party._name[bx]
	mov	dx, seg	seg027
	push	dx
	push	ax
	call	printStringWClear
	add	sp, 4
	mov	ax, offset s_hathAllTheGold
	push	ds
	push	ax
	call	printString
	add	sp, 4

l_return:
	mov	sp, bp
	pop	bp
	retf
temple_getGoldPoolee endp

; Attributes: bp-based frame

readSlotNumber proc far

	inputKey= word ptr	-2

	push	bp
	mov	bp, sp

l_loopEntry:
	mov	ax, 2000h
	push	ax
	call	getKey
	add	sp, 2
	mov	[bp+inputKey], ax
	cmp	ax, dosKeys_ESC
	jz	l_returnMinusOne
	cmp	[bp+inputKey], '0'
	jle	short l_loopEntry
	cmp	[bp+inputKey], '8'
	jge	short l_loopEntry
	sub	[bp+inputKey], '1'	
	mov	ax, charSize
	imul	[bp+inputKey]
	mov	bx, ax
	cmp	byte ptr gs:party._name[bx], 0
	jz	short l_loopEntry
	mov	ax, [bp+inputKey]
	jmp	short l_return
l_returnMinusOne:
	mov ax, 0FFFFh
l_return:
	mov	sp, bp
	pop	bp
	retf
readSlotNumber endp

; DWORD - var_4 & var_6

; Attributes: bp-based frame

doPoolGold proc	far

	var_6= word ptr	-6
	var_4= word ptr	-4
	loopCounter= word ptr	-2
	poolTarget= word ptr	 6
	lastSlot= word ptr	 8

	push	bp
	mov	bp, sp
	mov	ax, 6
	call	someStackOperation
	push	si

	sub	ax, ax
	mov	[bp+var_4], ax
	mov	[bp+var_6], ax
	mov	[bp+loopCounter], ax

l_loopEntry:
	mov	ax, [bp+lastSlot]
	cmp	[bp+loopCounter], ax
	jge	short l_giveGold

	mov	ax, charSize
	imul	[bp+loopCounter]
	mov	si, ax
	cmp	byte ptr gs:party._name[si], 0
	jz	short l_loopIncrement

	mov	ax, word ptr gs:party.gold[si]
	mov	dx, word ptr gs:(party.gold+2)[si]
	add	[bp+var_6], ax
	adc	[bp+var_4], dx
	sub	ax, ax
	mov	word ptr gs:(party.gold+2)[si], ax
	mov	word ptr gs:party.gold[si], ax
l_loopIncrement:
	inc	[bp+loopCounter]
	jmp	short l_loopEntry

l_giveGold:
	mov	ax, [bp+var_6]
	mov	dx, [bp+var_4]
	mov	cx, ax
	mov	bx, dx
	mov	ax, charSize
	imul	[bp+poolTarget]
	mov	si, ax
	mov	word ptr gs:party.gold[si], cx
	mov	word ptr gs:(party.gold+2)[si], bx
	pop	si
	mov	sp, bp
	pop	bp
	retf
doPoolGold endp


; This function	gets the XP requirements for a
; given	level
;
; XP calculation is:
;   if level > 11
;     add "(level * 400,00) - 4,400,000" to
;   the class specific values for levels 2-11

; DWORD - var_2 & var_4

; Attributes: bp-based frame

getLevelXp proc far

	var_8= dword ptr -8
	var_4= word ptr	-4
	var_2= word ptr	-2
	playerNo= word ptr  6
	level= word ptr	 8

	push	bp
	mov	bp, sp
	mov	ax, 8
	call	someStackOperation
	push	si

	; For levels higher than 11, the xp calculation is
	; (level * 400,000) - 4,400,000
	cmp	[bp+level], 11
	jle	short l_levelUnderTwelve
	mov	ax, 1A80h		; 400,000
	mov	dx, 6
	push	dx
	push	ax
	mov	ax, [bp+level]
	cwd
	push	dx
	push	ax
	call	_level32bitMult
	sub	ax, 2380h		; 4,400,000
	sbb	dx, 43h	
	mov	[bp+var_4], ax
	mov	[bp+var_2], dx
	mov	[bp+level], 11
	jmp	short l_classSpecificXp

l_levelUnderTwelve:
	sub	ax, ax
	mov	[bp+var_2], ax
	mov	[bp+var_4], ax

l_classSpecificXp:
	mov	ax, charSize
	imul	[bp+playerNo]
	mov	bx, ax
	mov	bl, gs:party.class[bx]
	sub	bh, bh
	shl	bx, 1
	shl	bx, 1
	mov	ax, word ptr classXPReqs[bx]
	mov	dx, word ptr (classXPReqs+2)[bx]
	mov	word ptr [bp+var_8], ax
	mov	word ptr [bp+var_8+2], dx
	mov	bx, [bp+level]
	shl	bx, 1
	shl	bx, 1
	lfs	si, [bp+var_8]
	mov	ax, fs:[bx+si]
	mov	dx, fs:[bx+si+2]
	add	ax, [bp+var_4]
	adc	dx, [bp+var_2]

	pop	si
	mov	sp, bp
	pop	bp
	retf
getLevelXp endp

; Attributes: bp-based frame

empty_enter proc	far
	push	bp
	mov	bp, sp

	call	random
	test	al, 3
	jnz	short l_noBattle

	mov	g_partyAttackFlag, 0
	call	bat_init

l_noBattle:
	cmp	g_locationNumber, 1
	jnz	short l_useEmptyPicture
	mov	ax, 50
	jmp	short l_showPicture

l_useEmptyPicture:
	mov	ax, 50

l_showPicture:
	push	ax
	call	bigpic_drawPictureNumber
	add	sp, 2
	mov	ax, offset s_building
	push	ds
	push	ax
	call	setTitle
	add	sp, 4
	mov	ax, offset s_emptyBuilding
	push	ds
	push	ax
	call	printStringWClear
	add	sp, 4
	mov	ax, 4000h
	push	ax
	call	getKey
	add	sp, 2
	sub	ax, ax

	mov	sp, bp
	pop	bp
	retf
empty_enter endp

; Attributes: bp-based frame
storage_enter proc	far

	push	bp
	mov	bp, sp

	mov	ax, 50
	push	ax
	call	bigpic_drawPictureNumber
	add	sp, 2
	mov	ax, offset s_building
	push	ds
	push	ax
	call	setTitle
	add	sp, 4
	push	cs
	call	near ptr readInventoryStf
l_ioLoopEntry:
	mov	ax, offset s_storageMenu
	push	ds
	push	ax
	call	printStringWClear
	add	sp, 4
	push	cs
	call	near ptr readSlotNumber
	or	ax, ax
	jl	short l_return

	push	ax
	push	cs
	call	near ptr storage_getItem
	add	sp, 2
	jmp	short l_ioLoopEntry
l_return:
	push	cs
	call	near ptr writeInventoryStf
	call	text_clear
	mov	g_mapRval, 2
	sub	ax, ax

	mov	sp, bp
	pop	bp
	retf
storage_enter endp

; Attributes: bp-based frame

; DWORD - var_140 & var_142

storage_getItem proc far

	itemListP= word ptr -372h
	itemList= word ptr -302h
	var_142= word ptr -142h
	var_140= word ptr -140h
	itemListLength= word ptr -13Eh
	var_13C= word ptr -13Ch
	var_13A= word ptr -13Ah
	var_138= word ptr -138h
	var_38=	word ptr -38h
	arg_0= word ptr	 6

	push	bp
	mov	bp, sp
	mov	ax, 372h
	call	someStackOperation
	push	di
	push	si

loc_14A05:
	lea	ax, [bp+var_38]
	push	ss
	push	ax
	lea	ax, [bp+itemListP]
	push	ss
	push	ax
	lea	ax, [bp+itemList]
	push	ss
	push	ax
	push	cs
	call	near ptr storage_createItemList
	add	sp, 0Ch
	mov	[bp+itemListLength], ax
	or	ax, ax
	jz	l_empty

	mov	ax, offset s_would
	push	ds
	push	ax
	lea	ax, [bp+var_138]
	push	ss
	push	ax
	call	strcat
	add	sp, 8
	mov	[bp+var_142], ax
	mov	[bp+var_140], dx
	mov	ax, charSize
	imul	[bp+arg_0]
	mov	bx, ax
	lea	ax, party._name[bx]
	mov	dx, seg	seg027
	push	dx
	push	ax
	push	[bp+var_140]
	push	[bp+var_142]
	call	strcat
	add	sp, 8
	mov	[bp+var_142], ax
	mov	[bp+var_140], dx
	mov	ax, offset s_likeToPickup
	push	ds
	push	ax
	push	dx
	push	[bp+var_142]
	call	strcat
	add	sp, 8
	mov	[bp+var_142], ax
	mov	[bp+var_140], dx
	push	[bp+itemListLength]
	lea	ax, [bp+itemListP]
	push	ss
	push	ax
	lea	ax, [bp+var_138]
	push	ss
	push	ax
	call	text_scrollingWindow
	add	sp, 0Ah
	mov	[bp+var_13A], ax
	or	ax, ax
	jl	l_return
	mov	di, ax
	shl	di, 1
	mov	ax, [bp+di+var_38]
	mov	[bp+var_13C], ax
	mov	cx, ax
	shl	ax, 1
	add	ax, cx
	mov	si, ax
	mov	al, (strg_inventory+2)[si]
	sub	ah, ah
	push	ax
	mov	al, (strg_inventory+1)[si]
	push	ax
	mov	al, strg_inventory[si]
	push	ax
	push	[bp+arg_0]
	call	inventory_addItem
	add	sp, 8
	or	ax, ax
	jz	short l_allFull
	mov	bx, [bp+var_13C]
	mov	ax, bx
	shl	bx, 1
	add	bx, ax
	mov	strg_inventory[bx], 0
	mov	ax, offset s_youPickUpItem
	push	ds
	push	ax
	call	printStringWClear
	add	sp, 4
	jmp	short l_delayAndLoop
l_allFull:
	mov	ax, offset s_allFull
	push	ds
	push	ax
	call	printStringWClear
	add	sp, 4
	mov	ax, 4
	push	ax
	call	text_delayNoTable
	add	sp, 2
	jmp	short l_return
l_empty:
	mov	ax, offset s_buildingIsEmpty
	push	ds
	push	ax
	call	printStringWClear
	add	sp, 4
	mov	ax, 4
	push	ax
	call	text_delayNoTable
	add	sp, 2
	jmp	short l_return
l_delayAndLoop:
	mov	ax, 4
	push	ax
	call	text_delayNoTable
	add	sp, 2
	jmp	loc_14A05
l_return:
	pop	si
	pop	di
	mov	sp, bp
	pop	bp
	retf
storage_getItem endp

; Attributes: bp-based frame

writeInventoryStf proc far

	fd= word ptr	-2

	push	bp
	mov	bp, sp
	mov	ax, 2
	call	someStackOperation

	mov	ax, offset a_inventoryStf
	push	ds
	push	ax
	push	cs
	call	near ptr openFile
	add	sp, 4
	mov	[bp+fd], ax
	mov	ax, 54h	
	push	ax
	mov	ax, offset strg_inventory
	mov	dx, seg	dseg
	push	dx
	push	ax
	push	[bp+fd]
	call	write
	add	sp, 8
	push	[bp+fd]
	call	close
	add	sp, 2

	mov	sp, bp
	pop	bp
	retf
writeInventoryStf endp

; Attributes: bp-based frame

readInventoryStf proc far

	fd= word ptr	-2

	push	bp
	mov	bp, sp
	mov	ax, 2
	call	someStackOperation

	mov	ax, offset a_inventoryStf
	push	ds
	push	ax
	push	cs
	call	near ptr openFile
	add	sp, 4
	mov	[bp+fd], ax
	mov	ax, 84
	push	ax
	mov	ax, offset strg_inventory
	mov	dx, seg	dseg
	push	dx
	push	ax
	push	[bp+fd]
	call	read
	add	sp, 8
	push	[bp+fd]
	call	close
	add	sp, 2

	mov	sp, bp
	pop	bp
	retf
readInventoryStf endp


; The state of the 0x46 progress flag determines the items
; that are in the storage building.

; itemList is a string with all of the items in the storage building
; strcat'd together separated by 0
;
; itemListP is a list of pointers to the individual item strings;

; Attributes: bp-based frame

storage_createItemList proc far

	itemListLength= word ptr	-8
	var_6= word ptr	-6
	var_4= word ptr	-4
	itemNumber= word ptr	-2
	itemList= dword ptr  6
	itemListP= dword ptr  0Ah
	arg_8= dword ptr  0Eh

	push	bp
	mov	bp, sp
	mov	ax, 8
	call	someStackOperation
	push	si

	mov	[bp+itemListLength], 0
	mov	ax, 46h	
	push	ax
	call	checkProgressFlags
	add	sp, 2
	or	ax, ax
	jz	short l_flagNotSet
	mov	ax, 28
	jmp	short l_loopEntry
l_flagNotSet:
	mov	ax, 18

l_loopEntry:
	mov	[bp+var_6], ax
	mov	[bp+var_4], 0

l_loopHead:
	mov	bx, [bp+var_4]
	mov	ax, bx
	shl	bx, 1
	add	bx, ax
	mov	al, strg_inventory[bx]
	sub	ah, ah
	mov	[bp+itemNumber], ax
	or	ax, ax
	jz	short l_loopTest
	mov	bx, [bp+itemListLength]
	shl	bx, 1
	shl	bx, 1
	lfs	si, [bp+itemListP]
	mov	ax, word ptr [bp+itemList]
	mov	dx, word ptr [bp+itemList+2]
	mov	fs:[bx+si], ax
	mov	fs:[bx+si+2], dx
	mov	bx, [bp+itemNumber]
	shl	bx, 1
	shl	bx, 1
	push	word ptr (g_itemStringList+2)[bx]
	push	word ptr g_itemStringList[bx]
	push	word ptr [bp+itemList+2]
	push	word ptr [bp+itemList]
	call	strcat
	add	sp, 8
	mov	word ptr [bp+itemList], ax
	mov	word ptr [bp+itemList+2], dx
	lfs	bx, dword ptr [bp+itemList]
	inc	word ptr [bp+itemList]
	mov	byte ptr fs:[bx], 0
	mov	bx, [bp+itemListLength]
	inc	[bp+itemListLength]
	shl	bx, 1
	lfs	si, [bp+arg_8]
	mov	ax, [bp+var_4]
	mov	fs:[bx+si], ax

l_loopTest:
	inc	[bp+var_4]
	mov	ax, [bp+var_6]
	cmp	[bp+var_4], ax
	jl	l_loopHead

l_return:
	mov	ax, [bp+itemListLength]
	jmp	short $+2
	pop	si
	mov	sp, bp
	pop	bp
	retf
storage_createItemList endp

; This function	inserts	a new member into the last
; active slot in the party. Dead, paralyzed or	stoned
; members are moved down.
; Attributes: bp-based frame

party_addCharacter proc far

	var_6= word ptr	-6
	var_4= word ptr	-4
	emptySlot= word	ptr -2

	push	bp
	mov	bp, sp
	mov	ax, 6
	call	someStackOperation
	push	si

	push	cs
	call	near ptr party_getLastSlot
	mov	[bp+emptySlot],	ax
	cmp	ax, 7
	jge	l_return
	mov	[bp+var_4], 0
loc_14CB5:
	push	cs
	call	near ptr party_getLastSlot
	cmp	ax, [bp+var_4]
	jle	short l_return
	mov	ax, charSize
	imul	[bp+var_4]
	mov	si, ax
	test	gs:party.status[si], stat_dead	or stat_stoned or stat_paralyzed
	jz	short loc_14D2B
	mov	ax, offset newCharBuffer
	mov	dx, seg	seg027
	push	dx
	push	ax
	lea	ax, party._name[si]
	push	dx
	push	ax
	push	cs
	call	near ptr copyCharacterBuf
	add	sp, 8
	push	[bp+var_4]
	push	cs
	call	near ptr party_pack
	add	sp, 2
	cmp	gs:newCharBuffer.class,	class_illusion
	jz	short loc_14D29
	cmp	gs:newCharBuffer.specAbil+3, 0
	jnz	short loc_14D29
	push	cs
	call	near ptr party_findEmptySlot
	mov	[bp+var_6], ax
	mov	ax, charSize
	imul	[bp+var_6] 
	mov	bx, ax
	lea	ax, party._name[bx]
	mov	dx, seg	seg027
	push	dx
	push	ax
	mov	ax, offset newCharBuffer
	push	dx
	push	ax
	push	cs
	call	near ptr copyCharacterBuf
	add	sp, 8
loc_14D29:
	jmp	short loc_14D2E
loc_14D2B:
	inc	[bp+var_4]
loc_14D2E:
	jmp	short loc_14CB5
l_return:
	pop	si
	mov	sp, bp
	pop	bp
	retf
party_addCharacter endp

; Attributes: bp-based frame

; DWORD - arg_0 & arg_2

openFile proc far

	var_2= word ptr	-2
	arg_0= word ptr	 6
	arg_2= word ptr	 8

	push	bp
	mov	bp, sp
	mov	ax, 2
	call	someStackOperation

loc_14D40:
	mov	ax, 2
	push	ax
	push	[bp+arg_2]
	push	[bp+arg_0]
	call	open
	add	sp, 6
	mov	[bp+var_2], ax
	inc	ax
	jnz	short loc_14D81
	mov	ax, offset s_insertDisk
	mov	dx, seg	dseg
	push	dx
	push	ax
	call	printString
	add	sp, 4
	mov	ax, offset s_diskTwo
	push	ds
	push	ax
	call	printString
	add	sp, 4
	mov	ax, 4000h
	push	ax
	call	getKey
	add	sp, 2
loc_14D81:
	cmp	[bp+var_2], 0FFFFh
	jz	short loc_14D40
	mov	ax, [bp+var_2]
	jmp	short $+2
	mov	sp, bp
	pop	bp
	retf
openFile endp


seg002 ends

; Segment type: Pure code
seg003 segment byte public 'CODE' use16
        assume cs:seg003
        assume es:nothing, ss:nothing, ds:dseg, fs:nothing, gs:seg027
; Attributes: bp-based frame

; This function replaces the '3' in the disk3 offset
; to a '1'. Not really useful in a hard drive installation
;

disk1Swap proc far

	arg_0= word ptr	 6

	push	bp
	mov	bp, sp

	cmp	[bp+arg_0], 0
	jz	short l_return
	lfs	bx, disk3
	mov	byte ptr fs:[bx+5], '1'
l_return:
	mov	sp, bp
	pop	bp
	retf
disk1Swap endp

; Attributes: bp-based frame

getYesNo proc far

	inputKey= word ptr	-6
	mouseOffset= word ptr	-4
	var_2= word ptr	-2

	push	bp
	mov	bp, sp
	mov	ax, 6
	call	someStackOperation
	push	di
	push	si

	push	cs
	call	near ptr txt_newLine
	mov	al, gs:txt_numLines
	sub	ah, ah
	mov	si, ax
	mov	di, si
	shl	di, 1
	mov	ax, (bitMask16bit+2)[di]
	or	ax, bitMask16bit[di]
	mov	[bp+var_2], ax
	mov	[bp+mouseOffset], si
	mov	ax, offset s_yesNo
	push	ds
	push	ax
	call	printString
	add	sp, 4
l_loopEntry:
	push	[bp+var_2]
	call	getKey
	add	sp, 2
	mov	[bp+inputKey], ax
	cmp	ax, 10Eh
	jl	short loc_14E0B
	cmp	ax, 119h
	jg	short loc_14E0B
	mov	ax, [bp+mouseOffset]
	sub	[bp+inputKey], ax

loc_14E0B:
	mov	ax, [bp+inputKey]
	cmp	ax, 'N'
	jz	short l_clearAndReturnZero
	cmp	ax, 'Y'	
	jz	short l_clearAndReturnOne
	cmp	ax, 10Eh
	jz	short l_clearAndReturnOne
	cmp	ax, 10Fh
	jz	short l_clearAndReturnZero
	jmp	short l_loopEntry

l_clearAndReturnOne:
	push	cs
	call	near ptr text_clear
	mov	ax, 1
	jmp	short l_return

l_clearAndReturnZero:
	push	cs
	call	near ptr text_clear
	sub	ax, ax
	jmp	short l_return

l_return:
	pop	si
	pop	di
	mov	sp, bp
	pop	bp
	retf
getYesNo endp


; Attributes: bp-based frame
; Read a key from the user. The mouse can also be used to select an option

getKey proc far

	inputKey= word ptr	-2
	mouseLineCount= word ptr	 6

	push	bp
	mov	bp, sp
	mov	ax, 2
	call	someStackOperation

	mov	spell_mouseClicked, 0
	push	cs
	call	near ptr sub_1766A
l_loopEntry:
	call	checkMouse
	cmp	mouse_moved, 0
	jz	short l_skipMouseUpdate
	call	far ptr	sub_3E974

	push	[bp+mouseLineCount]
	push	cs
	call	near ptr mouse_updateIcon
	add	sp, 2
	push	cs
	call	near ptr sub_1766A

l_skipMouseUpdate:
	push	[bp+mouseLineCount]
	push	cs
	call	near ptr mouse_getClick
	add	sp, 2
	mov	[bp+inputKey], ax
	or	ax, ax
	jz	short l_skipMouseClick
	call	far ptr	sub_3E974
	mov	spell_mouseClicked, 1
	mov	ax, [bp+inputKey]
	jmp	short l_return

l_skipMouseClick:
	call	checkKeyboard
	or	ax, ax
	jz	short loc_14EBE
	call	far ptr	sub_3E974

	call	_readChFromKeyboard
	mov	[bp+inputKey], ax
	or	al, al
	jz	short loc_14EB9
	mov	al, byte ptr [bp+inputKey]
	sub	ah, ah
	push	ax
	call	toUpper
	add	sp, 2
	jmp	short l_return
loc_14EB9:
	mov	ax, [bp+inputKey]
	jmp	short l_return
loc_14EBE:
	push	cs
	call	near ptr doRealtimeEvents
	push	cs
	call	near ptr party_print
	jmp	short l_loopEntry

l_return:
	mov	sp, bp
	pop	bp
	retf
getKey endp

; This function sets the mouse icon. It is only called from
; text_scrollingWindow
;

; Attributes: bp-based frame

mouse_setScrollingIcon proc far

	var_4= word ptr	-4
	var_2= word ptr	-2
	arg_0= word ptr	 6

	push	bp
	mov	bp, sp
	mov	ax, 4
	call	someStackOperation

	mov	ax, mouseBoxes._left[1 * sizeof mouseBox_t]
	cmp	mouse_x, ax
	jl	short l_notInTextWindow
	mov	ax, mouseBoxes._right[1 * sizeof mouseBox_t]
	cmp	mouse_x, ax
	jge	short l_notInTextWindow
	mov	ax, mouseBoxes._top[1 * sizeof mouseBox_t]
	cmp	mouse_y, ax
	jl	short l_notInTextWindow
	mov	ax, mouseBoxes._bottom[1 * sizeof mouseBox_t]
	cmp	mouse_y, ax
	jge	short l_notInTextWindow
	mov	ax, mouse_y
	sub	ax, 4
	mov	cl, 3
	sar	ax, cl
	mov	[bp+var_2], ax
	mov	ax, [bp+arg_0]
	mov	bx, [bp+var_2]
	shl	bx, 1
	test	bitMask16bit[bx], ax
	jz	short loc_14F2D
	mov	ax, 5
	jmp	short loc_14F30
loc_14F2D:
	mov	ax, 6
loc_14F30:
	mov	[bp+var_4], ax
	jmp	short loc_14F3A
l_notInTextWindow:
	mov	[bp+var_4], 6
loc_14F3A:
	mov	ax, [bp+var_4]
	cmp	gs:g_currentMouseIcon, ax
	jz	short l_return
	mov	gs:g_currentMouseIcon, ax
	push	ax

	call	far ptr	vid_setMouseIcon
	add	sp, 2
l_return:
	mov	sp, bp
	pop	bp
	retf
mouse_setScrollingIcon endp

; Attributes: bp-based frame

mouse_updateIcon proc far

	var_6= word ptr	-6
	loopCounter= word ptr	-4
	iconNumber= word ptr	-2
	arg_0= word ptr	 6

	push	bp
	mov	bp, sp
	mov	ax, 6
	call	someStackOperation
	push	si

	test	[bp+arg_0], 4000h
	jnz	l_setIconFive

	mov	[bp+loopCounter], 0
l_loopEntry:
	mov	si, [bp+loopCounter]
	mov	cl, 3
	shl	si, cl
	mov	ax, mouse_x
	cmp	mouseBoxes._left[si],	ax
	jg	short l_loopIncrement
	cmp	mouseBoxes._right[si],	ax
	jle	short l_loopIncrement
	mov	ax, mouse_y
	cmp	mouseBoxes._top[si],	ax
	jg	short l_loopIncrement
	cmp	mouseBoxes._bottom[si],	ax
	jg	short l_loopExit

l_loopIncrement:
	inc	[bp+loopCounter]
	cmp	[bp+loopCounter], 3
	jl	short l_loopEntry

l_loopExit:
	mov	ax, [bp+loopCounter]
	or	ax, ax
	jnz	short loc_15064

	; Bitmask 8000h sets the mouse icon when the mouse is in the
	; bigpic area. This is where the direction arrow icons are
	; set
	mov	ax, [bp+arg_0]
	test	bitMask16bit+1Eh, ax		; 8000h
	jz	short l_setIconSix
	cmp	mouse_y, 2Dh 
	jge	short loc_14FDE
	jmp	l_setIconOne

loc_14FDE:
	cmp	mouse_y, 4Bh 
	jle	short loc_14FED
	jmp	short l_setIconTwo

loc_14FED:
	cmp	mouse_x, 4Ah 
	jge	short l_setIconFour
	jmp	short l_setIconThree

loc_1500E:
	mov	ax, mouse_y
	sub	ax, 4
	mov	cl, 3
	sar	ax, cl
	mov	[bp+var_6], ax
	mov	ax, [bp+arg_0]
	mov	bx, [bp+var_6]
	shl	bx, 1
	test	bitMask16bit[bx], ax
	jz	short l_setIconSix
	jmp	short l_setIconFive

loc_15040:
	test	[bp+arg_0], 2000h
	jz	short l_setIconSix
	jmp	short l_setIconFive


loc_15064:
	cmp	ax, 1				; Mouse in text window
	jz	short loc_1500E
	cmp	ax, 2				; Mouse in party area
	jz	short loc_15040
	jmp	short l_setIconSix

l_setIconOne:
	mov	[bp+iconNumber], 1
	jmp	short l_setIconAndReturn

l_setIconTwo:
	mov	[bp+iconNumber], 2
	jmp	short l_setIconAndReturn

l_setIconThree:
	mov	[bp+iconNumber], 3
	jmp	short l_setIconAndReturn

l_setIconFour:
	mov	[bp+iconNumber], 4
	jmp	short l_setIconAndReturn

l_setIconFive:
	mov	[bp+iconNumber], 5
	jmp	short l_setIconAndReturn

l_setIconSix:
	mov	[bp+iconNumber], 6

l_setIconAndReturn:
	mov	ax, [bp+iconNumber]
	cmp	gs:g_currentMouseIcon, ax
	jz	short l_return
	mov	gs:g_currentMouseIcon, ax
	push	ax
	call	far ptr	vid_setMouseIcon
	add	sp, 2

l_return:
	pop	si
	mov	sp, bp
	pop	bp
	retf
mouse_updateIcon endp

; Attributes: bp-based frame

mouse_getClick proc far

	var_8= word ptr	-8
	var_6= word ptr	-6
	var_4= word ptr	-4
	var_2= word ptr	-2
	arg_0= word ptr	 6

	push	bp
	mov	bp, sp
	mov	ax, 8
	call	someStackOperation
	push	si

	call	checkGamePort
	or	ax, ax
	jnz	short loc_150AE
	call	checkOtherGamePort
	or	ax, ax
	jz	short loc_150B3
loc_150AE:
	mov	ax, 1
	jmp	short loc_150B5
loc_150B3:
	sub	ax, ax
loc_150B5:
	mov	[bp+var_8], ax
	mov	ax, word_440BC
	cmp	[bp+var_8], ax
	jnz	short loc_150C4
	sub	ax, ax
	jmp	short loc_150C7
loc_150C4:
	mov	ax, [bp+var_8]
loc_150C7:
	mov	[bp+var_2], ax
	mov	ax, [bp+var_8]
	mov	word_440BC, ax
	cmp	[bp+var_2], 0
	jz	l_returnZero

	test	[bp+arg_0], 4000h
	jz	short loc_150E9
	mov	ax, 20h	
	jmp	l_return
loc_150E9:
	mov	[bp+var_4], 0
	jmp	short loc_150F3
loc_150F0:
	inc	[bp+var_4]
loc_150F3:
	cmp	[bp+var_4], 3
	jge	short loc_1512C
	mov	si, [bp+var_4]
	mov	cl, 3
	shl	si, cl
	mov	ax, mouse_x
	cmp	mouseBoxes._left[si],	ax
	jg	short loc_150F0
	cmp	mouseBoxes._right[si],	ax
	jle	short loc_150F0
	mov	ax, mouse_y
	cmp	mouseBoxes._top[si],	ax
	jg	short loc_150F0
	cmp	mouseBoxes._bottom[si],	ax
	jle	short loc_150F0
loc_1512C:
	mov	ax, [bp+var_4]
	jmp	loc_151CE
loc_15132:
	mov	ax, [bp+arg_0]
	test	bitMask16bit+1Eh, ax
	jz	short l_returnZero
	cmp	mouse_y, 2Dh 
	jge	short loc_15154
	mov	ax, dosKeys_upArrow
	jmp	l_return
loc_15154:
	cmp	mouse_y, 4Bh 
	jle	short loc_15164
	mov	ax, dosKeys_downArrow
	jmp	l_return
loc_15164:
	cmp	mouse_x, 4Ah 
	jge	short loc_15177
	mov	ax, dosKeys_leftArrow
	jmp	short l_return
loc_15177:
	mov	ax, dosKeys_rightArrow
	jmp	short l_return
loc_1517E:
	mov	ax, mouse_y
	sub	ax, 4
	mov	cl, 3
	sar	ax, cl
	mov	[bp+var_6], ax
	mov	ax, [bp+arg_0]
	mov	bx, [bp+var_6]
	shl	bx, 1
	test	bitMask16bit[bx], ax
	jz	short l_returnZero
	mov	ax, [bp+var_6]
	add	ax, 10Eh
	jmp	short l_return
loc_151AD:
	test	[bp+arg_0], 2000h
	jz	short l_returnZero
	mov	ax, mouse_y
	sub	ax, 88h	
	mov	cl, 3
	sar	ax, cl
	add	ax, 30h	
	jmp	short l_return
loc_151CE:
	or	ax, ax
	jz	loc_15132
loc_151D5:
	cmp	ax, 1
	jz	short loc_1517E
	cmp	ax, 2
	jz	short loc_151AD
l_returnZero:
	sub	ax, ax
	jmp	short $+2
l_return:
	pop	si
	mov	sp, bp
	pop	bp
	retf
mouse_getClick endp

; Attributes: bp-based frame

readChNoMouse proc far

	inputKey= word ptr	-2

	push	bp
	mov	bp, sp
	mov	ax, 2
	call	someStackOperation

	sub	ax, ax
	push	ax
	push	cs
	call	near ptr mouse_getClick
	add	sp, 2
loc_151FF:
	call	checkKeyboard
	or	ax, ax
	jz	short loc_151FF
loc_1520A:
	call	_readChFromKeyboard
	mov	[bp+inputKey], ax
	or	al, al
	jz	short loc_1521D
	mov	al, byte ptr [bp+inputKey]
	sub	ah, ah
	jmp	short loc_15222
loc_1521D:
	mov	ax, [bp+inputKey]
	jmp	short $+2
loc_15222:
	mov	sp, bp
	pop	bp
	retf
readChNoMouse endp

; Attributes: bp-based frame

doRealtimeEvents proc far

	var_4= word ptr	-4
	var_2= word ptr	-2

	push	bp
	mov	bp, sp
	mov	ax, 4
	call	someStackOperation
	push	si

	mov	ax, gs:word_42294
	cmp	_clockTicks, ax
	jz	short loc_15256
	mov	ax, _clockTicks
	mov	gs:word_42294, ax
	call	gfx_animate
loc_15256:
	mov	ax, _clockTicks
	mov	cl, 5
	sar	ax, cl
	mov	[bp+var_4], ax
	cmp	gs:word_42410, ax
	jz	short loc_15296
	mov	gs:word_42410, ax
	mov	si, ax
	mov	cl, 4
	sar	si, cl

	cmp	gs:word_41E6C, si
	jz	short loc_15296
	mov	gs:word_41E6C, si

	cmp	gs:advanceTimeFlag, 0
	jnz	short loc_15296
	call	bat_partyApplyPoison
loc_15296:
	cmp	gs:advanceTimeFlag, 0
	jz	short loc_152A5
	jmp	loc_1538E
loc_152A5:
	mov	si, gs:word_42410
	mov	cl, 4
	sar	si, cl
	cmp	gs:word_42456, si
	jz	loc_1538E
	mov	gs:word_42456, si

	cmp	g_songDuration, 0		; Song timer
	jz	short loc_152E3
	mov	al, g_songDuration
	dec	g_songDuration
	cmp	al, 1
	jnz	short loc_152E3
	call	endNoncombatSong

loc_152E3:
	mov	ax, gs:word_4233E
	dec	gs:word_4233E
	cmp	ax, 1
	jg	short loc_1533E
	mov	gs:word_4233E, 0Ah
	mov	[bp+var_2], 0
l_iconLoopEntry:
	mov	bx, [bp+var_2]
	cmp	lightDuration[bx], 0
	jz	short l_iconLoopIncrement
	cmp	lightDuration[bx], 0FFh
	jz	short l_iconLoopIncrement
	mov	al, lightDuration[bx]
	dec	lightDuration[bx]
	cmp	al, 1
	jnz	short l_iconLoopIncrement
	push	[bp+var_2]
	call	icon_deactivate
	add	sp, 2
l_iconLoopIncrement:
	inc	[bp+var_2]
	cmp	[bp+var_2], 5
	jl	short l_iconLoopEntry

loc_1533E:
	cmp	inDungeonMaybe, 0
	jnz	short loc_15356
	cmp	gs:isNight, 0
	jz	short loc_15362
loc_15356:
	cmp	gs:regenSpptSq,	0
	jz	short loc_15378
loc_15362:
	call	party_applySpptRegen
	cmp	gs:songRegenSppt, 0
	jz	short loc_15378
	call	party_applySpptRegen
loc_15378:
	call	party_applyEquipmentEffects
	cmp	gs:sqRegenHPFlag, 0
	jz	loc_doRealtimeEvents_label_1
	call	party_regenHp

loc_doRealtimeEvents_label_1:
	cmp	gs:byte_41E81, 0
	jz	short loc_1538E
	call	dunsq_drainHp
loc_1538E:
	mov	ax, gs:word_42410
	mov	cl, 6
	sar	ax, cl
	mov	[bp+var_4], ax
	cmp	gs:word_42330, ax
	jz	short l_return
	mov	gs:word_42330, ax
	cmp	gs:advanceTimeFlag, 0
	jnz	short l_return

	mov	al, g_currentHour
	inc	g_currentHour
	cmp	al, 23
	jb	short loc_153CF
	mov	g_currentHour, 0		; Set to midnight
loc_153CF:
	cmp	g_currentHour, 6
	jb	short l_setIsNightTonight
	cmp	g_currentHour, 18
	jbe	short l_setIsNightToDay
l_setIsNightTonight:
	mov	al, 1
	jmp	short l_setIsNight
l_setIsNightToDay:
	sub	al, al
l_setIsNight:
	mov	gs:isNight, al
l_return:
	pop	si
	mov	sp, bp
	pop	bp
	retf
doRealtimeEvents endp

; Attributes: bp-based frame

isAlphaNum proc	far
	arg_0= byte ptr	 6

	push	bp
	mov	bp, sp

	mov	al, [bp+arg_0]
	cbw
	push	ax
	call	toUpper
	add	sp, 2
	mov	[bp+arg_0], al
	cmp	al, 'A'
	jl	short loc_15414
	cmp	al, 'Z'
	jle	short l_returnTrue
loc_15414:
	cmp	[bp+arg_0], '0'
	jl	short l_returnFalse
	cmp	[bp+arg_0], '9'
	jg	short l_returnFalse
l_returnTrue:
	mov	ax, 1
	jmp	short l_return
l_returnFalse:
	sub	ax, ax
l_return:
	mov	sp, bp
	pop	bp
	retf
isAlphaNum endp

; If the first argument is >=0 then this function checks for input from 
; the keyboard with the first argument as a time limit. If the time limit 
; is reached before a character is entered, the function returns a space (' ').
;
; If the first argument is <0 then this function just calls readChNoMouse
; and returns that functions return value.
;
; Attributes: bp-based frame

timedGetKey proc far

	var_4= word ptr	-4
	var_2= word ptr	-2
	timeDelay= word ptr	 6

	push	bp
	mov	bp, sp
	mov	ax, 4
	call	someStackOperation

	cmp	[bp+timeDelay], 0
	jge	short l_getkeyWithDelay
	push	cs
	call	near ptr readChNoMouse
	jmp	short l_return
l_getkeyWithDelay:
	mov	ax, [bp+timeDelay]
	mov	cx, ax
	shl	ax, 1
	shl	ax, 1
	add	ax, cx
	shl	ax, 1
	add	ax, _clockTicks
	mov	[bp+var_4], ax
l_timerLoop:
	mov	ax, [bp+var_4]
	cmp	_clockTicks, ax
	jz	short l_returnSpace
	call	checkKeyboard
	or	ax, ax
	jz	short l_timerLoop
	call	_readChFromKeyboard
	mov	[bp+var_2], ax
	or	al, al
	jz	short l_returnKey
	mov	al, byte ptr [bp+var_2]
	sub	ah, ah
	jmp	short l_return
l_returnKey:
	mov	ax, [bp+var_2]
	jmp	short l_return
l_returnSpace:
	mov	ax, 20h	
l_return:
	mov	sp, bp
	pop	bp
	ret
timedGetKey endp

; Attributes: bp-based frame
text_delayNoTable	proc far

	delayTime= word ptr 6

	push	bp
	mov	bp, sp

	sub	ax, ax
	push	ax
	mov	ax, [bp+delayTime]
	shl	ax, 1
	shl	ax, 1
	push	ax
	call	getKeyWithDelay
	add	sp, 4

	mov	sp, bp
	pop	bp
	retf
text_delayNoTable	endp

text_delayWithTable	proc far

	push	bp
	mov	bp, sp

	mov	ax, 1
	push	ax
	mov	bl, txtDelayIndex
	sub	bh, bh
	mov	al, txtDelayTable[bx]
	sub	ah, ah
	push	ax
	call	getKeyWithDelay
	add	sp, 4

	mov	sp, bp
	pop	bp
	retf
text_delayWithTable	endp

; This is where the print delay occurs during battle.
getKeyWithDelay proc far

	var_2= word ptr	-2
	delayTime= word ptr	 6
	speedupFlag= word ptr 8

	push	bp
	mov	bp, sp
	mov	ax, 2
	call	someStackOperation

	cmp	[bp+delayTime], 0
	jl	l_return

	mov	ax, [bp+delayTime]
	add	ax, _clockTicks
	mov	[bp+var_2], ax
	push	cs
	call	near ptr sub_1766A

l_loopEntry:
	call	checkKeyboard
	or	ax, ax
	jz	short l_doTimeEvents
	call	_readChFromKeyboard

	cmp	[bp+speedupFlag], 0
	jz	l_skipFastCheck

	sub	ah, ah
	cmp	ax, '>'
	jz	l_faster
	cmp	ax, '.'
	jnz	l_slowCheck

l_faster:
	mov	al, txtDelayIndex
	dec	txtDelayIndex
	or	al, al
	ja	l_printFaster
	mov	txtDelayIndex, 0
	jmp	l_loopEntry

l_slowCheck:
	cmp	ax, '<'
	jz	l_slower
	cmp	ax, ','
	jnz	l_skipFastCheck

l_slower:
	mov	al, txtDelayIndex
	inc	txtDelayIndex
	cmp	al, 9
	jb	l_printSlower
	mov	txtDelayIndex, 9
	jmp	l_loopEntry

l_printFaster:
	mov	ax, offset s_faster
	jmp	l_doPrint

l_printSlower:
	mov	ax, offset s_slower

l_doPrint:
	push	ds
	push	ax
	call	printString
	add	sp, 4
	jmp	l_loopEntry

l_skipFastCheck:
	call	far ptr	sub_3E974
	jmp	short l_return

l_doTimeEvents:
	call	checkMouse
	push	cs
	call	near ptr doRealtimeEvents
	push	cs
	call	near ptr party_print
	mov	ax, [bp+var_2]
	cmp	_clockTicks, ax
	jl	short loc_1550B
	call	far ptr	sub_3E974
	jmp	short l_return
loc_1550B:
	cmp	mouse_moved, 0
	jz	short loc_15520
	call	far ptr	sub_3E974
	push	cs
	call	near ptr sub_1766A
loc_15520:
	jmp	l_loopEntry
l_return:
	mov	sp, bp
	pop	bp
	retf
getKeyWithDelay endp

; Attributes: bp-based frame

minimap_show proc far

	rowP=	dword ptr -16h
	squareFlags=	word ptr -12h
	nsCounter=	word ptr -10h
	ewCounter=	word ptr -0Eh
	nsValue= word ptr	-0Ch
	ewValue= word ptr	-0Ah
	screenY= word ptr	-08h
	screenX= word ptr	-6
	upDownValue= word ptr	-4
	rightLeftValue= word ptr	-2
	rowPList= dword ptr  6			; Array of points to the dungeon rows
	squareEW= word ptr	 0Ah
	squareNS= word ptr	 0Ch
	leftLimit= word ptr	 0Eh
	downLimit= word ptr	 10h

	push	bp
	mov	bp, sp
	mov	ax, 16h
	call	someStackOperation
	push	si

	mov	[bp+rightLeftValue], 8
	mov	[bp+upDownValue], 6
l_loopEntry:
	mov	gs:g_text_clearFlag, 1
	push	cs
	call	near ptr text_clear
	mov	gs:g_text_clearFlag, 1

	mov	[bp+ewCounter], 0
	jmp	short loc_1555E
loc_1555B:
	inc	[bp+ewCounter]
loc_1555E:
	cmp	[bp+ewCounter], 11h
	jge	l_getInput
	mov	ax, [bp+squareEW]
	sub	ax, [bp+rightLeftValue]
	add	ax, [bp+ewCounter]
	mov	[bp+ewValue], ax
	mov	[bp+nsCounter], 0
	jmp	short loc_1557D
loc_1557A:
	inc	[bp+nsCounter]
loc_1557D:
	cmp	[bp+nsCounter], 0Ch
	jge	loc_1555B
loc_15586:
	mov	ax, [bp+squareNS]
	sub	ax, [bp+upDownValue]
	add	ax, [bp+nsCounter]
	mov	[bp+nsValue], ax
	or	ax, ax
	jl	loc_156F6
loc_15599:
	mov	ax, [bp+downLimit]
	cmp	[bp+nsValue], ax
	jge	loc_156F6
loc_155A4:
	cmp	[bp+ewValue], 0
	jl	short loc_155AF
	mov	ax, 1
	jmp	short loc_155B1
loc_155AF:
	sub	ax, ax
loc_155B1:
	mov	cx, [bp+leftLimit]
	mov	si, ax
	cmp	[bp+ewValue], cx
	jge	short loc_155C0
	mov	ax, 1
	jmp	short loc_155C2
loc_155C0:
	sub	ax, ax
loc_155C2:
	test	ax, si
	jz	loc_156F6
loc_155C9:
	mov	ax, [bp+nsCounter]
	mov	cl, 3
	shl	ax, cl
	sub	ax, 5Eh	
	neg	ax
	mov	[bp+screenY], ax
	mov	ax, [bp+ewCounter]
	shl	ax, cl
	add	ax, 0A9h 
	mov	[bp+screenX], ax
	mov	ax, offset minimap_squareToDraw
	mov	dx, seg	seg023
	push	dx
	push	ax
	call	minimap_clearSquare
	add	sp, 4
	mov	bx, [bp+ewValue]
	mov	ax, bx
	shl	bx, 1
	shl	bx, 1
	add	bx, ax
	mov	ax, bx
	mov	bx, [bp+nsValue]
	shl	bx, 1
	shl	bx, 1
	lfs	si, [bp+rowPList]
	lfs	si, fs:[bx+si]
	mov	bx, ax
	mov	al, fs:[bx+si+4]
	sub	ah, ah
	mov	[bp+squareFlags], ax
	test	byte ptr [bp+squareFlags], 2
	jnz	l_squareUndiscovered
loc_15621:
	test	byte ptr [bp+squareFlags], 1
	jz	l_squareUndiscovered
loc_1562A:
	mov	ax, [bp+rightLeftValue]
	cmp	[bp+ewCounter], ax
	jnz	short loc_1564E
	mov	ax, [bp+upDownValue]
	cmp	[bp+nsCounter], ax
	jnz	short loc_1564E
	mov	ax, minimap_X
	push	ax
	mov	ax, offset minimap_squareToDraw
	mov	dx, seg	seg023
	push	dx
	push	ax
	call	minimap_setSquare
	add	sp, 6
loc_1564E:
	cmp	word_43F12, 0
	jz	short loc_15671
	test	byte ptr [bp+squareFlags], 8
	jz	short loc_1566F
	mov	ax, minimap_dot
	push	ax
	mov	ax, offset minimap_squareToDraw
	mov	dx, seg	seg023
	push	dx
	push	ax
	call	minimap_setSquare
	add	sp, 6
loc_1566F:
	jmp	short loc_1568B
loc_15671:
	test	byte ptr [bp+squareFlags], 4
	jz	short loc_1568B
	mov	ax, minimap_dot
	push	ax
	mov	ax, offset minimap_squareToDraw
	mov	dx, seg	seg023
	push	dx
	push	ax
	call	minimap_setSquare
	add	sp, 6

loc_1568B:
	mov	bx, [bp+nsValue]
	shl	bx, 1
	shl	bx, 1
	lfs	si, [bp+rowPList]
	mov	ax, fs:[bx+si]
	mov	dx, fs:[bx+si+2]
	mov	cx, [bp+ewValue]
	mov	bx, cx
	shl	cx, 1
	shl	cx, 1
	add	cx, bx
	add	ax, cx
	mov	word ptr [bp+rowP], ax
	mov	word ptr [bp+rowP+2],	dx
	lfs	bx, [bp+rowP]
	mov	ah, fs:[bx+1]
	sub	al, al
	mov	cl, fs:[bx]
	sub	ch, ch
	add	ax, cx
	push	ax
	push	cs
	call	near ptr minimap_getWalls
	add	sp, 2
	jmp	short l_drawSquare

l_squareUndiscovered:
	mov	ax, minimap_undiscovered
	push	ax
	mov	ax, offset minimap_squareToDraw
	mov	dx, seg	seg023
	push	dx
	push	ax
	call	minimap_setSquare
	add	sp, 6

l_drawSquare:
	mov	ax, 1
	push	ax
	mov	ax, 63h	
	push	ax
	push	[bp+screenX]
	push	[bp+screenY]
	call	far ptr	gfx_writeCharacter
	add	sp, 8
loc_156F6:
	jmp	loc_1557A

l_getInput:
	push	cs
	call	near ptr getKey
	add	sp, 2
	cmp	ax, dosKeys_ESC
	jz	short l_clearAndReturn
	cmp	ax, dosKeys_upArrow
	jz	short l_upArrow
	cmp	ax, dosKeys_leftArrow
	jz	short l_leftArrow
	cmp	ax, dosKeys_rightArrow
	jz	short l_rightArrow
	cmp	ax, dosKeys_downArrow
	jz	short l_downArrow
	jmp	l_loopEntry

l_downArrow:
	mov	ax, [bp+downLimit]
	cmp	[bp+upDownValue], ax
	jge	short l_afterDownLoop
	inc	[bp+upDownValue]
l_afterDownLoop:
	jmp	l_loopEntry

l_upArrow:
	cmp	[bp+upDownValue], 0
	jz	short l_afterUpLoop
	dec	[bp+upDownValue]
l_afterUpLoop:
	jmp	l_loopEntry

l_rightArrow:
	cmp	[bp+rightLeftValue], 0
	jz	short l_afterRightLoop
	dec	[bp+rightLeftValue]
l_afterRightLoop:
	jmp	l_loopEntry

l_leftArrow:
	mov	ax, [bp+leftLimit]
	cmp	[bp+rightLeftValue], ax
	jge	short l_afterLeftLoop
	inc	[bp+rightLeftValue]
l_afterLeftLoop:
	jmp	l_loopEntry

l_clearAndReturn:
	push	cs
	call	near ptr text_clear

l_return:
	pop	si
	mov	sp, bp
	pop	bp
	retf
minimap_show endp

; Attributes: bp-based frame

minimap_getWalls proc far

	directionLoopCounter= word ptr	-2
	squareWalls= word ptr	 6

	push	bp
	mov	bp, sp
	mov	ax, 2
	call	someStackOperation

	; Loop through all of the directions getting the value
	; of the walls in each direction
	;
	mov	[bp+directionLoopCounter], 0
l_loopEntry:
	mov	ax, [bp+directionLoopCounter]
	dec	ax
	push	ax
	push	[bp+squareWalls]
	call	dungeon_getWallInDirection
	add	sp, 4
	and	ax, 0Fh
	mov	bx, ax
	cmp	minimap_bitmaskOffsetList[bx],	80h
	jnb	short l_loopIncrement
	mov	al, minimap_bitmaskOffsetList[bx]
	sub	ah, ah
	or	ax, [bp+directionLoopCounter]
	push	ax
	mov	ax, offset minimap_squareToDraw
	mov	dx, seg	seg023
	push	dx
	push	ax
	call	minimap_setSquare
	add	sp, 6
l_loopIncrement:
	inc	[bp+directionLoopCounter]
	cmp	[bp+directionLoopCounter], 4
	jl	short l_loopEntry
l_return:
	mov	sp, bp
	pop	bp
	retf
minimap_getWalls endp

; Attributes: bp-based frame

_mfunc_getString proc far

	memOffset= word	ptr  6
	memSegment= word ptr  8
	rbuf= dword ptr	 0Ah

	push	bp
	mov	bp, sp

	mov	ax, [bp+memOffset]
	mov	dx, [bp+memSegment]
	mov	dataBufOff, ax
	mov	dataBufSeg, dx
	mov	bitsLeft, 0
	mov	_str_capFlag, 0
loc_157E6:
	push	cs
	call	near ptr _mfunc_unpackChar
	lfs	bx, [bp+rbuf]
	inc	word ptr [bp+rbuf]
	mov	fs:[bx], al
	or	al, al
	jnz	short loc_157E6
	mov	ax, dataBufOff
	mov	dx, dataBufSeg
	jmp	short $+2

	mov	sp, bp
	pop	bp
	retf
_mfunc_getString endp

; Attributes: bp-based frame

_mfunc_unpackChar proc far

	push	bp
	mov	bp, sp

l_extractCharacter:
	mov	ax, 5
	push	ax
	push	cs
	call	near ptr _mfunc_extractCh
	add	sp, 2
	or	ax, ax
	jz	short l_return
	cmp	ax, 30
	jz	short l_setCapitalFlag
	cmp	ax, 31
	jz	short l_hialphabetChar
	jmp	short l_loalphabetChar

l_setCapitalFlag:
	mov	_str_capFlag, 1
	jmp	short l_extractCharacter

l_hialphabetChar:
	mov	ax, 6
	push	ax
	push	cs
	call	near ptr _mfunc_extractCh
	add	sp, 2
	mov	bx, ax
	mov	al, _str_Hialphabet[bx]
	cbw
	cmp	_str_capFlag, 0
	jz	short l_return
	mov	_str_capFlag, 0
	jmp	l_returnCapital

l_loalphabetChar:
	mov	bx, ax
	mov	al, _str_Loalphabet[bx-1]
	cbw
	cmp	_str_capFlag, 0
	jz	short l_return
	mov	_str_capFlag, 0
l_returnCapital:
	push	ax
	call	toUpper
	add	sp, 2
l_return:
	mov	sp, bp
	pop	bp
	retf
_mfunc_unpackChar endp

; This function extracts a number of bits from the data buffer
; 
; Attributes: bp-based frame

_mfunc_extractCh proc far

	var_2= word ptr	-2
	bitCount= word ptr	 6

	push	bp
	mov	bp, sp
	mov	ax, 2
	call	someStackOperation

	mov	[bp+var_2], 0
loc_158BC:
	mov	ax, [bp+bitCount]
	dec	[bp+bitCount]
	or	ax, ax
	jz	short l_return
	dec	bitsLeft
	jns	short loc_158E4
	mov	bx, dataBufOff
	inc	dataBufOff
	mov	fs, dataBufSeg
	mov	al, fs:[bx]
	mov	curStrByte, al
	mov	bitsLeft, 7
loc_158E4:
	shl	[bp+var_2], 1
	cmp	curStrByte, 80h
	jb	short loc_158F3
	mov	ax, 1
	jmp	short loc_158F5
loc_158F3:
	sub	ax, ax
loc_158F5:
	or	[bp+var_2], ax
	shl	curStrByte, 1
	jmp	short loc_158BC
l_return:
	mov	ax, [bp+var_2]
	jmp	short $+2
	mov	sp, bp
	pop	bp
	retf
_mfunc_extractCh endp


; This function	copies 16 bytes	from fromBuffer	to
; toBuffer and ANDs each byte with 0x7f to remove
; the "encryption"
; Attributes: bp-based frame

unmaskString proc far

	loopCounter= word ptr	-2
	fromBuffer= dword ptr  6
	toBuffer= dword	ptr  0Ah

	push	bp
	mov	bp, sp
	mov	ax, 2
	call	someStackOperation

	mov	[bp+loopCounter], 0
l_loopEntry:
	lfs	bx, [bp+fromBuffer]
	mov	al, fs:[bx]
	cmp	al, 0FFh
	jz	short l_return
	or	al, al
	jz	short l_return
	inc	word ptr [bp+fromBuffer]
	mov	al, fs:[bx]
	and	al, 7Fh
	lfs	bx, dword ptr [bp+toBuffer]
	inc	word ptr [bp+toBuffer]
	mov	byte ptr fs:[bx], al
	inc	[bp+loopCounter]
	cmp	[bp+loopCounter], 16
	jl	short l_loopEntry
l_return:
	lfs	bx, dword ptr [bp+toBuffer]
	inc	word ptr [bp+toBuffer]
	mov	byte ptr fs:[bx], 0
	mov	sp, bp
	pop	bp
	retf
unmaskString endp

; DWORD - arg_0 & arg_2
; Attributes: bp-based frame

text_scrollingWindow proc far

	var_20=	word ptr -20h
	var_1E=	word ptr -1Eh
	var_1C=	word ptr -1Ch
	var_1A=	word ptr -1Ah
	var_18=	word ptr -18h
	highlightedLine=	word ptr -16h
	var_14=	word ptr -14h
	var_12=	word ptr -12h
	var_10=	word ptr -10h
	var_E= word ptr	-0Eh
	var_C= word ptr	-0Ch
	TxtNumLines= word ptr	-0Ah
	var_8= word ptr	-8
	var_6= word ptr	-6
	var_4= word ptr	-4
	var_2= word ptr	-2
	arg_0= word ptr	 6
	arg_2= word ptr	 8
	arg_4= dword ptr  0Ah
	itemCount= word ptr	 0Eh

	push	bp
	mov	bp, sp
	mov	ax, 20h
	call	someStackOperation
	push	si

	sub	ax, ax
	mov	[bp+var_12], ax
	mov	[bp+highlightedLine], ax
	mov	[bp+var_1E], ax
	mov	[bp+var_10], ax
	mov	[bp+var_E], 1
	push	cs
	call	near ptr sub_1766A

loc_1597F:
	cmp	[bp+var_E], 0
	jz	l_doRealTimeEvents

loc_15988:
	call	far ptr	sub_3E974
	push	[bp+arg_2]
	push	[bp+arg_0]
	call	printStringWClear
	add	sp, 4

	mov	al, gs:txt_numLines
	sub	ah, ah
	inc	ax
	mov	[bp+TxtNumLines], ax
	mov	ax, 0Ah
	sub	ax, [bp+TxtNumLines]
	mov	[bp+var_6], ax
	mov	ax, [bp+var_12]
	add	ax, [bp+var_6]
	cmp	ax, [bp+itemCount]
	jle	short loc_159BF
	mov	ax, [bp+itemCount]
loc_159BF:
	mov	[bp+var_1C], ax
	mov	ax, [bp+var_12]
	mov	[bp+var_1A], ax
	jmp	short loc_159CD
loc_159CA:
	inc	[bp+var_1A]
loc_159CD:
	mov	ax, [bp+var_1C]
	cmp	[bp+var_1A], ax
	jge	short loc_159EF
	mov	bx, [bp+var_1A]
	shl	bx, 1
	shl	bx, 1
	lfs	si, [bp+arg_4]
	push	word ptr fs:[bx+si+2]
	push	word ptr fs:[bx+si]
	call	printString
	add	sp, 4
	jmp	short loc_159CA
loc_159EF:
	mov	[bp+var_4], 0
	mov	ax, [bp+var_12]
	add	ax, [bp+var_6]
	cmp	ax, [bp+itemCount]
	jle	short loc_15A07
	mov	ax, [bp+itemCount]
	sub	ax, [bp+var_12]
	jmp	short loc_15A0A
loc_15A07:
	mov	ax, [bp+var_6]
loc_15A0A:
	mov	[bp+var_14], ax
	mov	[bp+var_1A], 0
	jmp	short loc_15A17
loc_15A14:
	inc	[bp+var_1A]
loc_15A17:
	mov	ax, [bp+var_14]
	cmp	[bp+var_1A], ax
	jge	short loc_15A35
	mov	bx, [bp+var_1A]
	add	bx, [bp+TxtNumLines]
	shl	bx, 1
	mov	ax, bitMask16bit[bx]
	or	[bp+var_4], ax
	jmp	short loc_15A14
loc_15A35:
	mov	ax, bitMask16bit+16h
	or	[bp+var_4], ax
	push	cs
	call	near ptr scroll_printArrows
	mov	ax, [bp+highlightedLine]
	add	ax, [bp+TxtNumLines]
	sub	ax, [bp+var_12]
	push	ax
	call	far ptr	sub_3E96E			; This probably does the highlighting
	add	sp, 2
	push	cs
	call	near ptr sub_1766A
	mov	[bp+var_E], 0
	jmp	short l_getInput

l_doRealTimeEvents:
	push	cs
	call	near ptr doRealtimeEvents

l_getInput:
	call	checkMouse
	cmp	mouse_moved, 0
	jz	short l_skipMouseIcon
	call	far ptr	sub_3E974
	push	[bp+var_4]
	push	cs
	call	near ptr mouse_setScrollingIcon
	add	sp, 2
	mov	[bp+var_2], 1
	push	cs
	call	near ptr sub_1766A

l_skipMouseIcon:
	push	[bp+var_4]
	push	cs
	call	near ptr scroll_checkArrowClick
	add	sp, 2
	mov	[bp+var_8], ax
	or	ax, ax
	jz	l_checkKeyboard
	call	checkGamePort
	or	ax, ax
	jnz	short loc_15AB4
	call	checkOtherGamePort
	or	ax, ax
	jz	short loc_15AB9
loc_15AB4:
	mov	ax, 1
	jmp	short loc_15ABB
loc_15AB9:
	sub	ax, ax
loc_15ABB:
	mov	[bp+var_20], ax
	cmp	[bp+var_1E], ax
	jnz	short loc_15AC7
	sub	ax, ax
	jmp	short loc_15ACA
loc_15AC7:
	mov	ax, [bp+var_20]
loc_15ACA:
	mov	[bp+var_10], ax
	mov	ax, [bp+var_20]
	mov	word_440BC, ax
	cmp	[bp+var_8], 10Eh
	jl	short loc_15B27
	cmp	[bp+var_8], 118h
	jg	short loc_15B27
	cmp	[bp+var_2], 0
	jz	short loc_15AFB
	mov	ax, [bp+var_8]
	sub	ax, [bp+txtNumLines]
	add	ax, [bp+var_12]
	sub	ax, 10Eh
	mov	[bp+highlightedLine], ax
	mov	[bp+var_2], 0
loc_15AFB:
	cmp	[bp+var_10], 0
	jz	short loc_15B0C
	call	far ptr	sub_3E974
	mov	ax, [bp+highlightedLine]
	jmp	l_return
loc_15B0C:
	mov	ax, [bp+var_C]
	cmp	[bp+highlightedLine], ax
	jz	short loc_15B19
	mov	ax, 1
	jmp	short loc_15B1B
loc_15B19:
	sub	ax, ax
loc_15B1B:
	mov	[bp+var_E], ax
	mov	ax, [bp+highlightedLine]
	mov	[bp+var_C], ax
	jmp	l_checkKeyboard
loc_15B27:
	mov	ax, [bp+var_8]
	jmp	short loc_15B98
loc_15B2C:
	cmp	[bp+var_10], 0
	jz	short loc_15B5A
	mov	ax, [bp+itemCount]
	sub	ax, 5
	cmp	ax, [bp+var_12]
	jle	short loc_15B5A
	add	[bp+var_12], 5
	mov	ax, [bp+var_12]
	add	ax, 2
	mov	[bp+highlightedLine], ax
	mov	si, [bp+itemCount]
	dec	si
	cmp	ax, si
	jle	short loc_15B55
	mov	[bp+highlightedLine], si
loc_15B55:
	mov	[bp+var_E], 1
loc_15B5A:
	jmp	short l_checkKeyboard
loc_15B5C:
	cmp	[bp+var_10], 0
	jz	short loc_15B81
	cmp	[bp+var_12], 5
	jle	short loc_15B6E
	sub	[bp+var_12], 5
	jmp	short loc_15B73
loc_15B6E:
	mov	[bp+var_12], 0
loc_15B73:
	mov	ax, [bp+var_12]
	add	ax, 2
	mov	[bp+highlightedLine], ax
	mov	[bp+var_E], 1
loc_15B81:
	jmp	short l_checkKeyboard
loc_15B83:
	cmp	[bp+var_10], 0
	jz	short loc_15B94
	call	far ptr	sub_3E974
	mov	ax, 0FFFFh
	jmp	l_return
loc_15B94:
	jmp	short l_checkKeyboard

loc_15B98:
	cmp	ax, dosKeys_ESC
	jz	short loc_15B83
	cmp	ax, dosKeys_upArrow
	jz	short loc_15B5C
	cmp	ax, dosKeys_downArrow
	jz	short loc_15B2C

l_checkKeyboard:
	call	checkKeyboard
	or	ax, ax
	jz	loc_15D04
	call	_readChFromKeyboard
	mov	[bp+var_18], ax
	or	al, al
	jz	short loc_15BD4
	mov	al, byte ptr [bp+var_18]
	sub	ah, ah
	push	ax
	call	toUpper
	add	sp, 2
	mov	[bp+var_8], ax
	jmp	short loc_15BDA
loc_15BD4:
	mov	ax, [bp+var_18]
	mov	[bp+var_8], ax
loc_15BDA:
	mov	[bp+var_E], 1
	mov	ax, [bp+var_8]
	jmp	l_keySwitch

l_enterKey:
	call	far ptr	sub_3E974
	mov	ax, [bp+highlightedLine]
	jmp	l_return

l_escapeKey:
	call	far ptr	sub_3E974
	mov	ax, 0FFFFh
	jmp	l_return

l_upArrow:
	cmp	[bp+highlightedLine], 0
	jz	short l_upArrowScroll
	dec	[bp+highlightedLine]

l_upArrowScroll:
	mov	ax, [bp+var_12]
	cmp	[bp+highlightedLine], ax
	jge	short l_upArrowDone
	dec	[bp+var_12]
l_upArrowDone:
	jmp	loc_15D04

l_downArrow:
	mov	ax, [bp+itemCount]
	dec	ax
	cmp	ax, [bp+highlightedLine]
	jle	short l_downArrowScroll
	inc	[bp+highlightedLine]
l_downArrowScroll:
	mov	ax, [bp+var_12]
	add	ax, [bp+var_6]
	cmp	ax, [bp+highlightedLine]
	jg	short l_downArrowDone
	inc	[bp+var_12]
l_downArrowDone:
	jmp	loc_15D04

l_pageDown:
	mov	ax, [bp+highlightedLine]
	add	ax, [bp+var_6]
	mov	cx, [bp+itemCount]
	dec	cx
	cmp	ax, cx
	jge	short loc_15C48
	mov	ax, [bp+var_6]
	add	[bp+highlightedLine], ax
	add	[bp+var_12], ax
	jmp	short l_pageDownDone
loc_15C48:
	mov	ax, [bp+itemCount]
	dec	ax
	mov	[bp+highlightedLine], ax
	mov	ax, [bp+var_6]
	cmp	[bp+highlightedLine], ax
	jl	short loc_15C66
	mov	ax, [bp+itemCount]
	mov	cx, [bp+var_6]
	sar	cx, 1
	sub	ax, cx
	mov	[bp+var_12], ax
	jmp	short l_pageDownDone
loc_15C66:
	mov	[bp+var_12], 0
l_pageDownDone:
	jmp	loc_15D04

l_pageUp:
	mov	ax, [bp+var_6]
	cmp	[bp+highlightedLine], ax
	jg	short loc_15C82
	mov	[bp+highlightedLine], 0
	mov	[bp+var_12], 0
	jmp	short l_pageUpDown
loc_15C82:
	mov	ax, [bp+var_6]
	sub	[bp+highlightedLine], ax
	cmp	[bp+var_12], ax
	jle	short loc_15C92
	sub	[bp+var_12], ax
	jmp	short l_pageUpDown
loc_15C92:
	mov	[bp+var_12], 0
l_pageUpDown:
	jmp	short loc_15D04

l_homeKey:
	sub	ax, ax
	mov	[bp+var_12], ax
	mov	[bp+highlightedLine], ax
	jmp	short loc_15D04

l_endKey:
	mov	ax, [bp+itemCount]
	dec	ax
	mov	[bp+highlightedLine], ax
	mov	ax, [bp+var_6]
	cmp	[bp+highlightedLine], ax
	jge	short loc_15CB6
	sub	ax, ax
	jmp	short loc_15CC0
loc_15CB6:
	mov	ax, [bp+highlightedLine]
	mov	cx, [bp+var_6]
	sar	cx, 1
	sub	ax, cx
loc_15CC0:
	mov	[bp+var_12], ax
	jmp	short loc_15D04

l_keySwitch:
	cmp	ax, dosKeys_upArrow
	jz	l_upArrow
	jg	short l_higherThanUpArrow
	cmp	ax, dosKeys_Enter
	jz	l_enterKey
	cmp	ax, dosKeys_ESC
	jz	l_escapeKey
	cmp	ax, dosKeys_home
	jz	short l_homeKey
	jmp	short loc_15D04

l_higherThanUpArrow:
	cmp	ax, dosKeys_pageUp
	jz	short l_pageUp
	cmp	ax, dosKeys_end
	jz	short l_endKey
	cmp	ax, dosKeys_downArrow
	jz	l_downArrow
	cmp	ax, dosKeys_pageDown
	jz	l_pageDown

loc_15D04:
	jmp	loc_1597F
l_return:
	pop	si
	mov	sp, bp
	pop	bp
	retf
text_scrollingWindow endp

; Attributes: bp-based frame

scroll_printArrows proc far
	push	bp
	mov	bp, sp

	mov	ax, 1
	push	ax
	mov	ax, 61h	
	push	ax
	mov	ax, 0B2h 
	push	ax
	mov	ax, 5Eh	
	push	ax
	call	far ptr	gfx_writeCharacter
	add	sp, 8

	mov	ax, 1
	push	ax
	mov	ax, 62h	
	push	ax
	mov	ax, 120h
	push	ax
	mov	ax, 5Eh	
	push	ax
	call	far ptr	gfx_writeCharacter
	add	sp, 8

	mov	ax, 1
	push	ax
	mov	ax, 5Eh	
	push	ax
	mov	ax, 0E0h 
	push	ax
	mov	ax, offset s_esc
	push	ds
	push	ax
	push	cs
	call	near ptr writeStringAt
	add	sp, 0Ah
	mov	sp, bp
	pop	bp
	retf
scroll_printArrows endp


; Attributes: bp-based frame

scroll_checkArrowClick proc far

	var_4= word ptr	-4
	var_2= word ptr	-2
	arg_0= word ptr	 6

	push	bp
	mov	bp, sp
	mov	ax, 4
	call	someStackOperation

	mov	[bp+var_2], 0

	; Check if the mouse is in the text window
	mov	ax, mouseBoxes._left[1 * sizeof mouseBox_t]
	cmp	mouse_x, ax
	jl	l_return

	mov	ax, mouseBoxes._right[1 * sizeof mouseBox_t]
	cmp	mouse_x, ax
	jge	short l_return

	mov	ax, mouseBoxes._top[1 * sizeof mouseBox_t]
	cmp	mouse_y, ax
	jl	short l_return

	mov	ax, mouseBoxes._bottom[1 * sizeof mouseBox_t]
	cmp	mouse_y, ax
	jge	short l_return

	mov	ax, mouse_y
	sub	ax, 4
	mov	cl, 3
	sar	ax, cl
	mov	[bp+var_4], ax
	cmp	ax, 0Bh
	jnz	short l_checkListItem

l_checkUpArrow:
	mov	ax, mouseBoxes._left[1 * sizeof mouseBox_t]
	add	ax, 32h	
	cmp	mouse_x, ax
	jge	short l_checkEsc
	mov	ax, dosKeys_upArrow
	jmp	short l_return

l_checkEsc:
	mov	ax, mouseBoxes._right[1 * sizeof mouseBox_t]
	sub	ax, 32h	
	cmp	mouse_x, ax
	jge	short l_checkDownArrow
	mov	ax, dosKeys_ESC
	jmp	short l_return

l_checkDownArrow:
	mov	ax, dosKeys_downArrow
	jmp	short l_return

l_checkListItem:
	mov	ax, [bp+arg_0]
	mov	bx, [bp+var_4]
	shl	bx, 1
	test	bitMask16bit[bx], ax
	jz	short l_returnZero
	mov	ax, [bp+var_4]
	add	ax, 10Eh
	jmp	short l_return
l_returnZero:
	sub	ax, ax
l_return:
	mov	sp, bp
	pop	bp
	retf
scroll_checkArrowClick endp

; Attributes: bp-based frame

readString proc far

	var_6= word ptr	-6
	var_4= word ptr	-4
	var_2= word ptr	-2
	arg_0= dword ptr  6
	arg_4= word ptr	 0Ah

	push	bp
	mov	bp, sp
	mov	ax, 6
	call	someStackOperation
	push	si

	mov	[bp+var_6], 0
	push	cs
	call	near ptr txt_newLine
	push	cs
	call	near ptr readString_insertCursor
loc_15E2D:
	push	cs
	call	near ptr readChNoMouse
	mov	[bp+var_2], ax
	cmp	ax, 0Dh
	jz	loc_15F0D

	mov	[bp+var_4], ax
	push	ax
	push	cs
	call	near ptr isAlphaNum
	add	sp, 2
	or	ax, ax
	jnz	short loc_15E6F
	cmp	[bp+var_2], ' '
	jz	short loc_15E6F
	cmp	[bp+var_2], '-'
	jz	short loc_15E6F
	cmp	[bp+var_2], '.'
	jz	short loc_15E6F
	cmp	[bp+var_2], ','
	jz	short loc_15E6F
	cmp	[bp+var_2], ':'
	jz	short loc_15E6F
	cmp	[bp+var_2], '\'
	jnz	short loc_15EAC
loc_15E6F:
	mov	ax, [bp+arg_4]
	cmp	[bp+var_6], ax
	jge	short loc_15EAA
	mov	bx, [bp+var_6]
	lfs	si, [bp+arg_0]
	mov	al, byte ptr [bp+var_2]
	mov	fs:[bx+si], al
	sub	ax, ax
	push	ax
	mov	ax, 5Fh	
	push	ax
	push	cs
	call	near ptr readString_echoChar
	add	sp, 4
	mov	bx, [bp+var_6]
	inc	[bp+var_6]
	lfs	si, [bp+arg_0]
	mov	al, fs:[bx+si]
	cbw
	push	ax
	push	cs
	call	near ptr readString_printChar
	add	sp, 2
	push	cs
	call	near ptr readString_insertCursor
loc_15EAA:
	jmp	short loc_15F0A
loc_15EAC:
	cmp	[bp+var_2], 8
	jnz	short loc_15EDB
	cmp	[bp+var_6], 0
	jle	short loc_15EDB
	dec	[bp+var_6]
	mov	bx, [bp+var_6]
	lfs	si, [bp+arg_0]
	mov	al, fs:[bx+si]
	cbw
	push	ax
	push	cs
	call	near ptr text_characterWidth
	add	sp, 2
	push	ax
	push	cs
	call	near ptr readString_overwriteCursor
	add	sp, 2
	push	cs
	call	near ptr readString_insertCursor
	jmp	short loc_15F0A
loc_15EDB:
	cmp	[bp+var_2], 1Bh
	jnz	short loc_15F0A
loc_15EE1:
	cmp	[bp+var_6], 0
	jle	short loc_15F06
	dec	[bp+var_6]
	mov	bx, [bp+var_6]
	lfs	si, [bp+arg_0]
	mov	al, fs:[bx+si]
	cbw
	push	ax
	push	cs
	call	near ptr text_characterWidth
	add	sp, 2
	push	ax
	push	cs
	call	near ptr readString_overwriteCursor
	add	sp, 2
	jmp	short loc_15EE1
loc_15F06:
	push	cs
	call	near ptr readString_insertCursor
loc_15F0A:
	jmp	loc_15E2D

loc_15F0D:
	mov	bx, [bp+var_6]
	lfs	si, [bp+arg_0]
	mov	byte ptr fs:[bx+si], 0
	sub	ax, ax
	push	ax
	mov	ax, 5Fh	
	push	ax
	push	cs
	call	near ptr readString_echoChar
	add	sp, 4
	cmp	[bp+var_6], 0
	jz	short l_returnNull
	mov	ax, word ptr [bp+arg_0]
	mov	dx, word ptr [bp+arg_0+2]
	jmp	short l_return
l_returnNull:
	sub	ax, ax
	cwd
l_return:
	pop	si
	mov	sp, bp
	pop	bp
	retf
readString endp

; Attributes: bp-based frame

readString_insertCursor proc far
	push	bp
	mov	bp, sp

	mov	ax, 1
	push	ax
	mov	ax, ch_InsertCursor
	push	ax
	push	cs
	call	near ptr readString_echoChar
	add	sp, 4

	mov	sp, bp
	pop	bp
	retf
readString_insertCursor endp

; Attributes: bp-based frame

readString_overwriteCursor proc far

	arg_0= byte ptr	 6

	push	bp
	mov	bp, sp

	sub	ax, ax
	push	ax
	mov	ax, ch_OverwriteCursor
	push	ax
	push	cs
	call	near ptr readString_echoChar
	add	sp, 4
	mov	al, [bp+arg_0]
	sub	gs:g_currentCharPosition, al
	sub	ax, ax
	push	ax
	mov	ax, ch_OverwriteCursor
	push	ax
	push	cs
	call	near ptr readString_echoChar
	add	sp, 4

	mov	sp, bp
	pop	bp
	retf
readString_overwriteCursor endp

; Attributes: bp-based frame

readString_printChar proc far

	inCharacter= word ptr	 6

	push	bp
	mov	bp, sp

	mov	ax, 1
	push	ax
	mov	ax, [bp+inCharacter]
	sub	ax, ' '
	push	ax
	push	cs
	call	near ptr readString_echoChar
	add	sp, 4
	push	[bp+inCharacter]
	push	cs
	call	near ptr text_characterWidth
	add	sp, 2
	add	gs:g_currentCharPosition, al

	mov	sp, bp
	pop	bp
	retf
readString_printChar endp


; Attributes: bp-based frame

readString_echoChar proc far

	arg_0= word ptr	 6
	arg_2= word ptr	 8

	push	bp
	mov	bp, sp

	push	[bp+arg_2]
	push	[bp+arg_0]
	mov	al, gs:g_currentCharPosition
	sub	ah, ah
	add	ax, 0A8h 
	push	ax
	mov	al, gs:txt_numLines
	sub	ah, ah
	mov	cl, 3
	shl	ax, cl
	add	ax, 6
	push	ax
	call	far ptr	gfx_writeCharacter
	add	sp, 8

	mov	sp, bp
	pop	bp
	retf
readString_echoChar endp

; Attributes: bp-based frame

readGold proc far

	stringBuffer=	word ptr -14h
	gold= dword ptr	-4

	push	bp
	mov	bp, sp
	mov	ax, 14h
	call	someStackOperation

	mov	ax, 10h
	push	ax
	lea	ax, [bp+stringBuffer]
	push	ss
	push	ax
	push	cs
	call	near ptr readString
	add	sp, 6
	or	dx, ax
	jz	short l_returnZero
	lea	ax, [bp+gold]
	push	ss
	push	ax
	mov	ax, offset s_u
	push	ds
	push	ax
	lea	ax, [bp+stringBuffer]
	push	ss
	push	ax
	call	sscanf
	add	sp, 0Ch
	mov	ax, word ptr [bp+gold]
	mov	dx, word ptr [bp+gold+2]
	jmp	short l_return
l_returnZero:
	sub	ax, ax
	cwd
	jmp	short $+2
l_return:
	mov	sp, bp
	pop	bp
	retf
readGold endp

; Attributes: bp-based frame

strcat	proc far

	toStr= dword ptr  6
	fromStr= dword ptr  0Ah

	push	bp
	mov	bp, sp

l_loopEntry:
	lfs	bx, [bp+fromStr]
	inc	word ptr [bp+fromStr]
	mov	al, fs:[bx]
	lfs	bx, [bp+toStr]
	inc	word ptr [bp+toStr]
	mov	fs:[bx], al
	or	al, al
	jnz	short l_loopEntry
	lfs	bx, [bp+toStr]
	mov	byte ptr fs:[bx], 0
	dec	word ptr [bp+toStr]
	mov	ax, word ptr [bp+toStr]
	mov	dx, word ptr [bp+toStr+2]

	mov	sp, bp
	pop	bp
	retf
strcat	endp

; Attributes: bp-based frame

itoa proc far

	var_4= word ptr	-4
	var_2= byte ptr	-2
	stringP= dword ptr  6
	inNumber= dword ptr	 0Ah
	maxDigits= word ptr	 0Eh

	push	bp
	mov	bp, sp
	mov	ax, 4
	call	someStackOperation
	push	si

	mov	[bp+var_2], 20h	
	cmp	[bp+maxDigits], 0
	jnz	short loc_160A6

	push	word ptr [bp+inNumber+2]
	push	word ptr [bp+inNumber]
	push	cs
	call	near ptr _itoa_countDigits
	add	sp, 4
	mov	[bp+maxDigits], ax

loc_160A6:
	cmp	word ptr [bp+inNumber+2], 0
	jge	short loc_160C3

	mov	ax, word ptr [bp+inNumber]
	mov	dx, word ptr [bp+inNumber+2]
	neg	ax
	adc	dx, 0
	neg	dx
	mov	word ptr [bp+inNumber], ax
	mov	word ptr [bp+inNumber+2], dx
	mov	[bp+var_2], 2Dh	
loc_160C3:
	mov	ax, 0Ah
	cwd
	push	dx
	push	ax
	push	word ptr [bp+inNumber+2]
	push	word ptr [bp+inNumber]
	call	_32bitMod
	add	al, 30h	
	mov	si, [bp+maxDigits]
	lfs	bx, [bp+stringP]
	mov	fs:[bx+si-1], al
	mov	ax, [bp+maxDigits]
	dec	ax
	mov	[bp+var_4], ax
	jmp	short loc_160EC
loc_160E9:
	dec	[bp+var_4]
loc_160EC:
	cmp	[bp+var_4], 0
	jle	short loc_1613B
	mov	ax, 0Ah
	cwd
	push	dx
	push	ax
	lea	ax, [bp+inNumber]
	push	ax
	call	_32bitDivide
	mov	ax, word ptr [bp+inNumber]
	or	ax, word ptr [bp+inNumber+2]
	jz	short loc_16128
	mov	ax, 0Ah
	cwd
	push	dx
	push	ax
	push	word ptr [bp+inNumber+2]
	push	word ptr [bp+inNumber]
	call	_32bitMod
	add	al, 30h	
	mov	si, [bp+var_4]
	lfs	bx, [bp+stringP]
	mov	fs:[bx+si-1], al
	jmp	short loc_16139
loc_16128:
	mov	si, [bp+var_4]
	lfs	bx, [bp+stringP]
	mov	al, [bp+var_2]
	mov	fs:[bx+si-1], al
	mov	[bp+var_2], 20h	
loc_16139:
	jmp	short loc_160E9
loc_1613B:
	cmp	word ptr [bp+inNumber+2], 0
	jg	short loc_1614F
	jl	short loc_16149
	cmp	word ptr [bp+inNumber], 0Ah
	jnb	short loc_1614F
loc_16149:
	cmp	[bp+var_2], 2Dh	
	jnz	short loc_16175
loc_1614F:
	mov	[bp+var_4], 0
	jmp	short loc_16159
loc_16156:
	inc	[bp+var_4]
loc_16159:
	mov	ax, [bp+maxDigits]
	cmp	[bp+var_4], ax
	jge	short loc_1616D
	lfs	bx, [bp+stringP]
	inc	word ptr [bp+stringP]
	mov	byte ptr fs:[bx], 2Ah
	jmp	short loc_16156
loc_1616D:
	mov	ax, word ptr [bp+stringP]
	mov	dx, word ptr [bp+stringP+2]
	jmp	short l_return
loc_16175:
	mov	ax, [bp+maxDigits]
	add	ax, word ptr [bp+stringP]
	mov	dx, word ptr [bp+stringP+2]
	jmp	short $+2
l_return:
	pop	si
	mov	sp, bp
	pop	bp
	retf
itoa endp


; This function counts the digits in arg_0
;
; Attributes: bp-based frame

_itoa_countDigits proc far

	var_2= word ptr	-2
	arg_0= word ptr	 6
	arg_2= word ptr	 8

	push	bp
	mov	bp, sp
	mov	ax, 2
	call	someStackOperation
	cmp	[bp+arg_2], 0
	jge	short loc_1619D
	mov	[bp+var_2], 2
	jmp	short loc_161A2
loc_1619D:
	mov	[bp+var_2], 1
loc_161A2:
	jmp	short loc_161A7
loc_161A4:
	inc	[bp+var_2]
loc_161A7:
	mov	ax, 0Ah
	cwd
	push	dx
	push	ax
	lea	ax, [bp+arg_0]
	push	ax
	call	_32bitDivide
	or	dx, ax
	jnz	short loc_161A4
	mov	ax, [bp+var_2]
	jmp	short $+2
	mov	sp, bp
	pop	bp
	retf
_itoa_countDigits endp


; This is a convenience function for printing a string and a three digit
; number. It has a maximum size of 32 bytes for string+number
;
; Attributes: bp-based frame

printStringAndThreeDigits proc far

	var_24=	word ptr -24h
	var_4= dword ptr -4
	arg_0= word ptr	 6
	arg_2= word ptr	 8
	arg_4= word ptr	 0Ah

	push	bp
	mov	bp, sp
	mov	ax, 24h
	call	someStackOperation

	push	[bp+arg_2]
	push	[bp+arg_0]
	lea	ax, [bp+var_24]
	push	ss
	push	ax
	call	strcat
	add	sp, 8
	mov	word ptr [bp+var_4], ax
	mov	word ptr [bp+var_4+2], dx

	mov	ax, 3
	push	ax
	mov	ax, [bp+arg_4]
	cwd
	push	dx
	push	ax
	push	word ptr [bp+var_4+2]
	push	word ptr [bp+var_4]
	call	itoa
	add	sp, 0Ah
	mov	word ptr [bp+var_4], ax
	mov	word ptr [bp+var_4+2], dx

	lfs	bx, [bp+var_4]
	mov	byte ptr fs:[bx], 0
	lea	ax, [bp+var_24]
	push	ss
	push	ax
	call	printString
	add	sp, 4
	mov	sp, bp
	pop	bp
	retf
printStringAndThreeDigits endp


; This function takes arg_0, multiplies it by 100, shifts the lower
; 16 bits (ax) 8 bits to the right and prints that number. Weird.
;
; Attributes: bp-based frame

printThiefAbilValues proc far

	arg_0= dword ptr 6
	arg_4= word ptr	 0Ah

	push	bp
	mov	bp, sp

	mov	ax, 64h	
	imul	[bp+arg_4]
	mov	cl, 8
	sar	ax, cl
	push	ax
	push	[bp+arg_0]
	push	cs
	call	near ptr printStringAndThreeDigits
	add	sp, 6

	mov	sp, bp
	pop	bp
	retf
printThiefAbilValues endp

; This function copies srcString into destString depending on
; the value passed.
;
; The '/' character in srcString indicates the start of the singular
; value. The end of the singular part (and beginning of the plural)
; part is indicated by '\'. Finally, the end of the plural part is
; indicated by a '\' or NULL.
;
; E.g. 'Wol/f\ves'
;   If value
;
; The current state is saved in [bp+stringState]
; 0 - initialState: Look for '/' (singular) or '\' (plural)
; 1 - skipSingular: '/' found but value is non-zero
; 2 - copySingular: '/' found and value is zero
; 3 - copyPlural:   '\' found and value is non-zero
; 4 - skipPlural:   '\' found and value is zero
; 5 - finalState:   Copy characters until 0
;
; Attributes: bp-based frame

str_pluralize proc far

	stringState= word ptr	-2
	srcString= dword ptr  6
	destString= dword ptr  0Ah
	value= word ptr	 0Eh

	push	bp
	mov	bp, sp
	mov	ax, 2
	call	someStackOperation

	mov	[bp+stringState], 0
l_stateCheck:
	mov	ax, [bp+stringState]
	or	ax, ax
	jz	l_initialSingularCheck
	cmp	ax, 1
	jz	l_skipSingular
	cmp	ax, 2
	jz	l_copySingular
	cmp	ax, 3
	jz	l_copyPlural
	cmp	ax, 4
	jz	l_skipPlural
	cmp	ax, 5
	jz	l_finalState
	jmp	l_nextCharacter

l_initialSingularCheck:
	lfs	bx, [bp+srcString]		; Copy from srcString
	mov	al, fs:[bx]
	lfs	bx, [bp+destString]		; to destString
	mov	fs:[bx], al
	cmp	al, '/'	
	jnz	short l_initialPluralCheck

	cmp	[bp+value], 0
	jz	short loc_16273
	mov	ax, 1
	jmp	short loc_16276
loc_16273:
	mov	ax, 2
loc_16276:
	mov	[bp+stringState], ax
	jmp	l_nextCharacter

l_initialPluralCheck:
	lfs	bx, [bp+destString]
	cmp	byte ptr fs:[bx], '\'
	jnz	short loc_16297
	cmp	[bp+value], 0
	jz	short loc_1628F
	mov	ax, 3
	jmp	short loc_16292
loc_1628F:
	mov	ax, 4
loc_16292:
	mov	[bp+stringState], ax
	jmp	l_nextCharacter

loc_16297:
	cmp	byte ptr fs:[bx], 0
	jz	l_nextCharacter
	inc	word ptr [bp+destString]
	jmp	l_nextCharacter

l_skipSingular:
	lfs	bx, [bp+srcString]
	cmp	byte ptr fs:[bx], '\'
	jnz	short loc_162B1
	mov	[bp+stringState], 3
loc_162B1:
	jmp	l_nextCharacter

l_copySingular:
	lfs	bx, [bp+srcString]
	mov	al, fs:[bx]
	lfs	bx, [bp+destString]
	mov	fs:[bx], al
	cmp	al, '\'
	jnz	short loc_162CC
	mov	[bp+stringState], 4
	jmp	l_nextCharacter
loc_162CC:
	lfs	bx, [bp+srcString]
	cmp	byte ptr fs:[bx], 0
	jz	short l_nextCharacter
	inc	word ptr [bp+destString]
	jmp	short l_nextCharacter

l_copyPlural:
	lfs	bx, [bp+srcString]
	mov	al, fs:[bx]
	lfs	bx, [bp+destString]
	mov	fs:[bx], al
	cmp	al, '\'	
	jnz	short loc_162F1
	mov	[bp+stringState], 5
	jmp	short loc_162FD
loc_162F1:
	lfs	bx, [bp+srcString]
	cmp	byte ptr fs:[bx], 0
	jz	short loc_162FD
	inc	word ptr [bp+destString]
loc_162FD:
	jmp	short l_nextCharacter

l_skipPlural:
	lfs	bx, [bp+srcString]
	cmp	byte ptr fs:[bx], '\'
	jnz	short loc_1630D
	mov	[bp+stringState], 5
loc_1630D:
	jmp	short l_nextCharacter

l_finalState:
	lfs	bx, [bp+srcString]
	cmp	byte ptr fs:[bx], 0
	jz	short l_nextCharacter
	mov	al, fs:[bx]
	lfs	bx, [bp+destString]
	inc	word ptr [bp+destString]
	mov	fs:[bx], al

l_nextCharacter:
	lfs	bx, [bp+srcString]
	inc	word ptr [bp+srcString]
	cmp	byte ptr fs:[bx], 0
	jnz	l_stateCheck

l_return:
	mov	ax, word ptr [bp+destString]
	mov	dx, word ptr [bp+destString+2]
	jmp	short $+2
	mov	sp, bp
	pop	bp
	retf
str_pluralize endp

; Attributes: bp-based frame

stairsPluralHelper proc far

	stringBufP=	dword ptr -54h
	stringBuffer=	word ptr -50h
	arg_0= dword ptr	 6
	arg_4= word ptr	 0Ah

	push	bp
	mov	bp, sp
	mov	ax, 54h
	call	someStackOperation

	push	[bp+arg_4]
	lea	ax, [bp+stringBuffer]
	push	ss
	push	ax
	push	[bp+arg_0]
	call	str_pluralize
	add	sp, 0Ah
	mov	word ptr [bp+stringBufP], ax
	mov	word ptr [bp+stringBufP+2], dx
	lfs	bx, [bp+stringBufP]
	mov	byte ptr fs:[bx], 0
	lea	ax, [bp+stringBuffer]
	push	ss
	push	ax
	call	printString
	add	sp, 4

	mov	sp, bp
	pop	bp
	retf
stairsPluralHelper endp

; Attributes: bp-based frame


; Attributes: bp-based frame

printStringWClear proc far

	inString= dword ptr	 6

	push	bp
	mov	bp, sp

	push	cs
	call	near ptr text_clear
	push	[bp+inString]
	call	printString
	add	sp, 4

	mov	sp, bp
	pop	bp
	retf
printStringWClear endp

; Attributes: bp-based frame

printString proc far

	lineBuffer=	word ptr -62h
	inStringP=	dword ptr -12h
	characterCount= word ptr	-0Eh
	linesPrinted= word ptr	-0Ch
	pixelsUsed= word ptr	-0Ah
	var_8= word ptr	-8
	var_6= word ptr	-6
	currentCharacter= word ptr	-4
	var_2= word ptr	-2
	inString= dword ptr  6

	push	bp
	mov	bp, sp
	mov	ax, 62h
	call	someStackOperation
	push	si

	mov	ax, word ptr [bp+inString]
	mov	dx, word ptr [bp+inString+2]
	mov	word ptr [bp+inStringP], ax
	mov	word ptr [bp+inStringP+2],	dx
	mov	[bp+characterCount], 0
	mov	[bp+pixelsUsed], 0
	mov	[bp+linesPrinted], 0

l_nextCharacter:
	lfs	bx, [bp+inString]
	cmp	byte ptr fs:[bx], 0
	jz	l_return
	lfs	bx, [bp+inStringP]
	inc	word ptr [bp+inStringP]
	mov	al, fs:[bx]
	cbw
	mov	[bp+currentCharacter], ax
	or	ax, ax
	jz	l_stringEnd
	cmp	ax, 0Ah
	jz	l_newline
	cmp	ax, 20h	
	jz	l_space
	jmp	l_otherCharacter

l_stringEnd:
	mov	si, [bp+characterCount]
	mov	byte ptr [bp+si+lineBuffer], 0
	cmp	[bp+characterCount], 0
	jz	l_return
	lea	ax, [bp+lineBuffer]
	push	ss
	push	ax
	push	cs
	call	near ptr text_nlWriteString
	add	sp, 4
	jmp	l_return

l_newline:
	mov	si, [bp+characterCount]
	mov	byte ptr [bp+si+lineBuffer], 0
	cmp	[bp+characterCount], 0
	jz	short loc_16441
	lea	ax, [bp+lineBuffer]
	push	ss
	push	ax
	push	cs
	call	near ptr text_nlWriteString
	add	sp, 4

loc_16441:
	push	cs
	call	near ptr txt_newLine

loc_16445:
	mov	ax, [bp+linesPrinted]
	inc	[bp+linesPrinted]
	cmp	ax, 50
	jle	short loc_16457
	mov	ax, 3
	jmp	l_return

loc_16457:
	mov	ax, word ptr [bp+inStringP]
	mov	dx, word ptr [bp+inStringP+2]
	mov	word ptr [bp+inString], ax
	mov	word ptr [bp+inString+2], dx
	mov	[bp+pixelsUsed], 0
	mov	[bp+characterCount], 0
	jmp	l_nextCharacter

l_space:
	cmp	[bp+pixelsUsed], 0			; Skip space if it's the first character
	jz	l_nextCharacter				; on the line

l_otherCharacter:
	mov	si, [bp+characterCount]
	inc	[bp+characterCount]
	mov	al, byte ptr [bp+currentCharacter]
	mov	byte ptr [bp+si+lineBuffer], al
	push	[bp+currentCharacter]
	push	cs
	call	near ptr text_characterWidth
	add	sp, 2
	add	[bp+pixelsUsed], ax
	cmp	[bp+pixelsUsed], 138
	jl	l_nextCharacter

	mov	ax, [bp+linesPrinted]
	inc	[bp+linesPrinted]
	cmp	ax, 50
	jle	short l_wrapText
	mov	ax, 3
	jmp	l_return

l_wrapText:
	mov	ax, [bp+characterCount]
	mov	[bp+var_2], ax
	mov	ax, word ptr [bp+inStringP]
	mov	dx, word ptr [bp+inStringP+2]
	mov	[bp+var_8], ax
	mov	[bp+var_6], dx

l_backtrackForSpace:					; Backtrack through the string looking for
	dec	[bp+characterCount]			; a space (or 0) to avoid splitting the
	mov	si, [bp+characterCount]			; last word over two lines
	cmp	byte ptr [bp+si+lineBuffer], ' '
	jz	short l_spaceFound
	or	si, si
	jl	short l_spaceFound
	dec	word ptr [bp+inStringP]
	jmp	short l_backtrackForSpace

l_spaceFound:
	cmp	[bp+characterCount], 0
	jz	short loc_16506
	mov	si, [bp+characterCount]
	mov	byte ptr [bp+si+lineBuffer], 0
	lea	ax, [bp+lineBuffer]
	push	ss
	push	ax
	push	cs
	call	near ptr text_nlWriteString
	add	sp, 4
	mov	[bp+pixelsUsed], 0
	mov	[bp+characterCount], 0
	mov	ax, word ptr [bp+inStringP]
	mov	dx, word ptr [bp+inStringP+2]
	mov	word ptr [bp+inString], ax
	mov	word ptr [bp+inString+2], dx
	jmp	l_nextCharacter

loc_16506:
	mov	si, [bp+var_2]
	mov	byte ptr [bp+si+lineBuffer], 6Fh 
	mov	ax, [bp+var_8]
	mov	dx, [bp+var_6]
	dec	ax
	mov	word ptr [bp+inStringP], ax
	mov	word ptr [bp+inStringP+2],	dx
	lea	ax, [bp+lineBuffer]
	push	ss
	push	ax
	push	cs
	call	near ptr text_nlWriteString
	add	sp, 4
	mov	[bp+pixelsUsed], 0
	mov	[bp+characterCount], 0
	mov	ax, word ptr [bp+inStringP]
	mov	dx, word ptr [bp+inStringP+2]
	mov	word ptr [bp+inString], ax
	mov	word ptr [bp+inString+2], dx
	jmp	l_nextCharacter

l_return:
	pop	si
	mov	sp, bp
	pop	bp
	retf
printString endp

; Attributes: bp-based frame

text_nlWriteString proc far

	inString= dword ptr	 6

	push	bp
	mov	bp, sp

	mov	gs:g_text_clearFlag, 1		; Mark text window as clearable
	cmp	gs:g_currentCharPosition, 0		; If not at the beginning of the line
	jz	short l_writeString
	push	cs
	call	near ptr txt_newLine

l_writeString:
	push	[bp+inString]
	push	cs
	call	near ptr text_writeString
	add	sp, 4			; Write the string

	mov	sp, bp
	pop	bp
	retf
text_nlWriteString endp

; This function actually writes each character to the text window.
;
; Note that there is no bounds checking in this function. All bounds
; checking is assumed to have been done by the caller.
;
; Attributes: bp-based frame

text_writeString proc far

	currentCharacter= byte ptr	-2
	inString= dword ptr  6

	push	bp
	mov	bp, sp
	mov	ax, 2
	call	someStackOperation

l_loop:
	lfs	bx, [bp+inString]
	mov	al, fs:[bx]
	mov	[bp+currentCharacter], al
	or	al, al
	jz	short l_return

	mov	ax, 1
	push	ax

	mov	al, [bp+currentCharacter]	; Get current character
	cbw
	sub	ax, 32				; Subtract ' '
	push	ax

	mov	al, gs:g_currentCharPosition	; Push horizontal position
	sub	ah, ah
	add	ax, 168
	push	ax

	mov	al, gs:txt_numLines		; Push vertical position
	sub	ah, ah
	mov	cl, 3
	shl	ax, cl
	add	ax, 6
	push	ax

	call	far ptr	gfx_writeCharacter
	add	sp, 8
	lfs	bx, [bp+inString]
	inc	word ptr [bp+inString]
	mov	al, fs:[bx]
	cbw
	push	ax
	push	cs
	call	near ptr text_characterWidth
	add	sp, 2
	add	gs:g_currentCharPosition, al
	jmp	short l_loop
l_return:
	mov	sp, bp
	pop	bp
	retf
text_writeString endp

; Attributes: bp-based frame

txt_newLine proc far
	push	bp
	mov	bp, sp

	mov	gs:g_currentCharPosition, 0		; Move position to start of line
	mov	al, gs:txt_numLines
	inc	gs:txt_numLines
	cmp	al, 0Bh
	jb	short loc_16635
	push	cs
	call	near ptr text_scroll
	mov	gs:txt_numLines, 0Bh
loc_16635:
	mov	sp, bp
	pop	bp
	retf
txt_newLine endp

; Attributes: bp-based frame

text_scroll proc far
	push	bp
	mov	bp, sp
	mov	ax, 50h	
	push	ax
	call	far ptr	sub_3E980
	add	sp, 2
	mov	ax, 50h	
	push	ax
	call	far ptr	sub_3E980
	add	sp, 2
	mov	sp, bp
	pop	bp
	retf
text_scroll endp

; Attributes: bp-based frame

intro_scrollText proc far

	var_A30= word ptr -0A30h
	var_A2E= word ptr -0A2Eh
	var_25E= word ptr -25Eh
	var_25C= word ptr -25Ch
	var_25A= word ptr -25Ah
	var_258= word ptr -258h
	var_256= word ptr -256h
	arg_0= word ptr	 6
	arg_2= word ptr	 8

	push	bp
	mov	bp, sp
	mov	ax, 0A30h
	call	someStackOperation
	push	si

	lea	ax, [bp+var_258]
	push	ss
	push	ax
	lea	ax, [bp+var_A2E]
	push	ss
	push	ax
	push	[bp+arg_2]
	push	[bp+arg_0]
	push	cs
	call	near ptr text_wrapLongString
	add	sp, 0Ch
	mov	[bp+var_A30], ax

	mov	[bp+var_25A], 0FFF8h
	jmp	short loc_16694
loc_16690:
	inc	[bp+var_25A]
loc_16694:
	mov	ax, [bp+var_A30]
	sub	ax, 4
	cmp	ax, [bp+var_25A]
	jle	l_return

	sub	ax, ax
	push	ax
	mov	ax, 5Ch	
	push	ax
	mov	ax, 96h	
	push	ax
	mov	ax, 1Ch
	push	ax
	sub	ax, ax
	push	ax
	call	far ptr	sub_3E96B
	add	sp, 0Ah
	mov	[bp+var_25C], 0

loc_166C6:
	mov	ax, [bp+var_25C]
	add	ax, [bp+var_25A]
	mov	[bp+var_25E], ax
	or	ax, ax
	jl	short loc_16715
	mov	ax, [bp+var_A30]
	cmp	[bp+var_25E], ax
	jge	short loc_16715
	sub	ax, ax
	push	ax
	mov	ax, [bp+var_25C]
	mov	cl, 3
	shl	ax, cl
	add	ax, 1Ch
	push	ax
	mov	ax, 3
	push	ax
	mov	si, [bp+var_25E]
	shl	si, 1
	shl	si, 1
	push	[bp+si+var_256]
	push	[bp+si+var_258]
	push	cs
	call	near ptr writeStringAt
	add	sp, 0Ah

loc_16715:
	inc	[bp+var_25C]
	cmp	[bp+var_25C], 8
	jl	short loc_166C6

loc_16717:
	mov	ax, 2
	push	ax
	push	cs
	call	near ptr timedGetKey
	add	sp, 2
	cmp	ax, dosKeys_ESC
	jnz	loc_16690
l_return:
	pop	si
	mov	sp, bp
	pop	bp
	retf
intro_scrollText endp

; Attributes: bp-based frame

doVictoryMaybe proc far

	var_A38= word ptr -0A38h
	var_A36= word ptr -0A36h
	var_266= word ptr -266h
	var_264= word ptr -264h
	var_262= word ptr -262h
	fd= word ptr -260h
	var_25E= word ptr -25Eh
	var_25C= word ptr -25Ch
	var_25A= word ptr -25Ah
	var_258= word ptr -258h
	var_256= word ptr -256h

	push	bp
	mov	bp, sp
	mov	ax, 0A38h
	call	someStackOperation
	push	si

	mov	[bp+var_262], 0
loc_16745:
	push	[bp+var_262]
	call	icon_deactivate
	add	sp, 2
	inc	[bp+var_262]
	cmp	[bp+var_262], 5
	jl	short loc_16745

loc_1675E:
	mov	gs:byte_422A0, 0
	mov	ax, 80E8h
	push	ax
	call	_mallocMaybe
	add	sp, 2
	mov	[bp+var_25E], ax
	mov	[bp+var_25C], dx

loc_1677F:
	sub	ax, ax
	push	ax
	mov	ax, offset s_victory
	push	ds
	push	ax
	call	open
	add	sp, 6
	mov	[bp+fd], ax
	inc	ax
	jnz	short loc_167BC

	mov	ax, offset s_insertDisk
	push	ds
	push	ax		; Change disks if necessary
	call	printString
	add	sp, 4
	push	dseg_0
	push	disk1
	call	printString
	add	sp, 4
	mov	ax, 4000h
	push	ax
	call	getKey
	add	sp, 2

loc_167BC:
	cmp	[bp+fd], 0FFFFh
	jz	short loc_1677F
	mov	ax, 80E8h
	push	ax
	mov	ax, offset g_rosterCharacterBuffer
	mov	dx, seg	seg022
	push	dx
	push	ax
	push	[bp+fd]
	call	read
	add	sp, 8
	push	[bp+fd]
	call	close
	add	sp, 2

	push	[bp+var_25C]
	push	[bp+var_25E]
	mov	ax, offset g_rosterCharacterBuffer
	mov	dx, seg	seg022
	push	dx
	push	ax
	call	d3cmp_flate
	add	sp, 8

	mov	ax, offset g_rosterCharacterBuffer
	mov	dx, seg	seg022
	push	dx
	push	ax
	mov	ax, [bp+var_25E]
	mov	dx, [bp+var_25C]
	add	ax, 0Dh
	push	dx
	push	ax
	call	far ptr	sub_3E97D
	add	sp, 8
	mov	ax, 4000h
	push	ax
	call	getKey
	add	sp, 2
	mov	[bp+var_25A], 0

	jmp	short loc_16836
loc_16832:
	inc	[bp+var_25A]
loc_16836:
	cmp	[bp+var_25A], 5
	jge	loc_1690F
loc_16840:
	lea	ax, [bp+var_258]
	push	ss
	push	ax
	lea	ax, [bp+var_A36]
	push	ss
	push	ax
	mov	bx, [bp+var_25A]
	shl	bx, 1
	shl	bx, 1
	push	word ptr (victoryMessageList+2)[bx]
	push	word ptr victoryMessageList[bx]
	push	cs
	call	near ptr text_wrapLongString
	add	sp, 0Ch
	mov	[bp+var_A38], ax

	mov	[bp+var_262], 0FFF8h
	jmp	short loc_16879
loc_16875:
	inc	[bp+var_262]
loc_16879:
	mov	ax, [bp+var_A38]
	sub	ax, 4
	cmp	ax, [bp+var_262]
	jle	loc_16832

	mov	ax, 0Bh
	push	ax
	mov	ax, 0BEh 
	push	ax
	mov	ax, 0A1h 
	push	ax
	mov	ax, 7Eh	
	push	ax
	mov	ax, 0Ah
	push	ax
	call	far ptr	sub_3E96B
	add	sp, 0Ah
	mov	[bp+var_264], 0

loc_168AD:
	mov	ax, [bp+var_264]
	add	ax, [bp+var_262]
	mov	[bp+var_266], ax
	or	ax, ax
	jl	short loc_168FC
	mov	ax, [bp+var_A38]
	cmp	[bp+var_266], ax
	jge	short loc_168FC
	sub	ax, ax
	push	ax
	mov	ax, [bp+var_264]
	mov	cl, 3
	shl	ax, cl
	add	ax, 7Eh	
	push	ax
	mov	ax, 0Dh
	push	ax
	mov	si, [bp+var_266]
	shl	si, 1
	shl	si, 1
	push	[bp+si+var_256]
	push	[bp+si+var_258]
	push	cs
	call	near ptr writeStringAt
	add	sp, 0Ah
loc_168FC:
	inc	[bp+var_264]
	cmp	[bp+var_264], 8
	jl	short loc_168AD

loc_168FE:
	mov	ax, 2
	push	ax
	push	cs
	call	near ptr timedGetKey
	add	sp, 2
	jmp	loc_16875

loc_1690F:
	sub	ax, ax
	push	ax
	mov	ax, offset s_bardscr
	push	ds
	push	ax
	call	openFile
	add	sp, 4
	mov	[bp+fd], ax
	inc	ax
	jnz	short loc_1694C

	mov	ax, offset s_insertDisk
	push	ds
	push	ax
	call	printString
	add	sp, 4
	push	dseg_0
	push	disk1
	call	printString
	add	sp, 4
	mov	ax, 0FFFFh
	push	ax
	push	cs
	call	near ptr timedGetKey
	add	sp, 2

loc_1694C:
	cmp	[bp+fd], 0FFFFh
	jz	short loc_1690F
	mov	ax, 80E8h
	push	ax
	mov	ax, offset g_rosterCharacterBuffer
	mov	dx, seg	seg022
	push	dx
	push	ax
	push	[bp+fd]
	call	read
	add	sp, 8
	push	[bp+fd]
	call	close
	add	sp, 2
	push	[bp+var_25C]
	push	[bp+var_25E]
	mov	ax, offset g_rosterCharacterBuffer
	mov	dx, seg	seg022
	push	dx
	push	ax
	call	d3cmp_flate
	add	sp, 8
	mov	ax, offset g_rosterCharacterBuffer
	mov	dx, seg	seg022
	push	dx
	push	ax
	mov	ax, [bp+var_25E]
	mov	dx, [bp+var_25C]
	add	ax, 0Dh
	push	dx
	push	ax
	call	far ptr	sub_3E97D
	add	sp, 8
	push	[bp+var_25C]
	push	[bp+var_25E]
	call	_freeMaybe
	add	sp, 4
	call	map_resetLocation
	mov	g_mapRval, 1

	pop	si
	mov	sp, bp
	pop	bp
	retf
doVictoryMaybe endp

; Attributes: bp-based frame

text_wrapLongString proc far

	var_10=	word ptr -10h
	currentLineNumber= word ptr	-0Eh
	var_C= dword ptr -0Ch
	var_8= word ptr	-8
	currenCharacter= word ptr	-6
	var_2= word ptr	-2
	message= dword ptr  6
	stringBuffer= dword ptr  0Ah
	linePList= dword ptr  0Eh		; A list of pointers to each line after wrapping

	push	bp
	mov	bp, sp
	mov	ax, 10h
	call	someStackOperation
	push	si

	mov	[bp+var_8], 0
	mov	[bp+currentLineNumber], 0
	mov	bx, [bp+currentLineNumber]
	inc	[bp+currentLineNumber]
	shl	bx, 1
	shl	bx, 1
	lfs	si, [bp+linePList]
	mov	ax, word ptr [bp+stringBuffer]
	mov	dx, word ptr [bp+stringBuffer+2]
	mov	fs:[bx+si], ax
	mov	fs:[bx+si+2], dx
loc_16A04:
	lfs	bx, [bp+message]
	cmp	byte ptr fs:[bx], 0
	jz	l_nullTerminateAndReturn
loc_16A10:
	inc	word ptr [bp+message]
	mov	al, fs:[bx]
	cbw
	mov	[bp+currenCharacter], ax
	or	ax, ax
	jz	l_endingNull
	cmp	ax, 0Ah
	jz	l_newLine
	jmp	l_copyCharacter

l_endingNull:
	lfs	bx, [bp+stringBuffer]
	inc	word ptr [bp+stringBuffer]
	mov	byte ptr fs:[bx], 0
	mov	ax, [bp+currentLineNumber]
	jmp	l_return

l_newLine:
	lfs	bx, [bp+stringBuffer]
	inc	word ptr [bp+stringBuffer]
	mov	byte ptr fs:[bx], 0
	mov	bx, [bp+currentLineNumber]
	inc	[bp+currentLineNumber]
	shl	bx, 1
	shl	bx, 1
	lfs	si, [bp+linePList]
	mov	ax, word ptr [bp+stringBuffer]
	mov	dx, word ptr [bp+stringBuffer+2]
	mov	fs:[bx+si], ax
	mov	fs:[bx+si+2], dx
	mov	[bp+var_8], 0
	lfs	bx, [bp+message]
	cmp	byte ptr fs:[bx], ' '
	jnz	short loc_16A62
	inc	word ptr [bp+message]
loc_16A62:
	jmp	loc_16A04

l_copyCharacter:
	lfs	bx, [bp+stringBuffer]
	inc	word ptr [bp+stringBuffer]
	mov	al, byte ptr [bp+currenCharacter]
	mov	fs:[bx], al
	push	[bp+currenCharacter]
	push	cs
	call	near ptr text_characterWidth
	add	sp, 2
	add	[bp+var_8], ax
	cmp	[bp+var_8], 96h	
	jl	short loc_16AEA
	mov	ax, word ptr [bp+stringBuffer]
	mov	dx, word ptr [bp+stringBuffer+2]
	dec	ax
	mov	word ptr [bp+var_C], ax
	mov	word ptr [bp+var_C+2], dx
	mov	[bp+var_2], 0
loc_16A97:
	lfs	bx, [bp+var_C]
	cmp	byte ptr fs:[bx], ' '
	jz	short loc_16AC0
	cmp	[bp+var_8], 0
	jle	short loc_16AC0
	dec	word ptr [bp+var_C]
	mov	al, fs:[bx]
	cbw
	push	ax
	push	cs
	call	near ptr text_characterWidth
	add	sp, 2
	mov	[bp+var_10], ax
	add	[bp+var_2], ax
	sub	[bp+var_8], ax
	jmp	short loc_16A97
loc_16AC0:
	lfs	bx, [bp+var_C]
	inc	word ptr [bp+var_C]
	mov	byte ptr fs:[bx], 0
	mov	bx, [bp+currentLineNumber]
	inc	[bp+currentLineNumber]
	shl	bx, 1
	shl	bx, 1
	lfs	si, [bp+linePList]
	mov	ax, word ptr [bp+var_C]
	mov	dx, word ptr [bp+var_C+2]
	mov	fs:[bx+si], ax
	mov	fs:[bx+si+2], dx
	mov	ax, [bp+var_2]
	mov	[bp+var_8], ax
loc_16AEA:
	jmp	loc_16A04

l_nullTerminateAndReturn:
	lfs	bx, dword ptr [bp+stringBuffer]
	inc	word ptr [bp+stringBuffer]
	mov	byte ptr fs:[bx], 0
	mov	ax, [bp+currentLineNumber]
	jmp	short $+2
l_return:
	pop	si
	mov	sp, bp
	pop	bp
	retf
text_wrapLongString endp

; Attributes: bp-based frame

party_print proc far

	tmp= word ptr -32h
	counter= word ptr -30h
	slotNumber=	word ptr -2Eh
	partyLineP=	dword ptr -2Ch
	partyLine= word ptr -28h
	var_26=	byte ptr -26h
	var_24=	byte ptr -24h

	push	bp
	mov	bp, sp
	mov	ax, 32h
	call	someStackOperation
	push	si

	cmp	byte ptr g_printPartyFlag,	0
	jnz	l_return

	call	party_update
	mov	byte ptr g_printPartyFlag,	1
	call	far ptr	sub_3E974

	mov	[bp+slotNumber], 0
l_charNumberLoopEntry:
	mov	ax, charSize
	imul	[bp+slotNumber]
	mov	bx, ax
	cmp	byte ptr gs:party._name[bx], 0
	jz	l_emptyPartySlot

	mov	[bp+counter], 0
l_copyCharName:
	mov	ax, charSize
	imul	[bp+slotNumber]
	mov	bx, ax
	add	bx, [bp+counter]
	mov	al, byte ptr gs:party._name[bx]
	mov	si, [bp+counter]
	mov	byte ptr [bp+si+partyLine], al
	or	al, al
	jz	short l_printAc
	inc	[bp+counter]
	jmp	short l_copyCharName

l_printAc:
	push	[bp+slotNumber]
	lea	ax, [bp+partyLine]
	push	ss
	push	ax
	push	cs
	call	near ptr party_clearAndPrintLine
	add	sp, 6

	mov	ax, 3
	push	ax
	mov	ax, charSize
	imul	[bp+slotNumber]
	mov	bx, ax
	mov	al, gs:party.ac[bx]
	cbw
	sub	ax, 10
	neg	ax
	cwd
	push	dx
	push	ax
	lea	ax, [bp+partyLine]
	push	ss
	push	ax
	push	cs
	call	near ptr itoa
	add	sp, 0Ah
	mov	word ptr [bp+partyLineP], ax
	mov	word ptr [bp+partyLineP+2],	dx
	lfs	bx, [bp+partyLineP]
	mov	byte ptr fs:[bx], 0
	mov	ax, 1
	push	ax
	push	[bp+slotNumber]
	mov	ax, 10h
	push	ax
	lea	ax, [bp+partyLine]
	push	ss
	push	ax
	push	cs
	call	near ptr party_printAt
	add	sp, 0Ah
	mov	ax, charSize
	imul	[bp+slotNumber]
	mov	bx, ax
	cmp	gs:party.status[bx], 0
	jz	short l_printMaxHp

	mov	[bp+counter], 6
l_detectStatusLoop:
	mov	ax, charSize
	imul	[bp+slotNumber]
	mov	bx, ax
	mov	al, gs:party.status[bx]
	sub	ah, ah
	mov	bx, [bp+counter]
	mov	cx, ax
	mov	al, statusBitmaskList[bx]
	cbw
	test	cx, ax
	jnz	short l_hasStatus
	dec	[bp+counter]
	cmp	[bp+counter], 0
	jge	short l_detectStatusLoop
	jmp	l_printCurrentHp

l_hasStatus:
	mov	[bp+tmp], 0

l_strcpyStatusString:
	mov	si, [bp+counter]
	shl	si, 1
	shl	si, 1
	mov	bx, [bp+tmp]
	mov	al, byte ptr s_statusAbbreviations[bx+si]
	mov	si, bx
	mov	byte ptr [bp+si+partyLine], al
	inc	[bp+tmp]
	cmp	[bp+tmp], 4
	jl	short l_strcpyStatusString

	mov	[bp+var_24], 0
	mov	ax, 1
	push	ax
	push	[bp+slotNumber]
	mov	ax, 14h
	push	ax
	lea	ax, [bp+partyLine]
	push	ss
	push	ax
	push	cs
	call	near ptr party_printAt
	add	sp, 0Ah
	jmp	short l_printCurrentHp

l_printMaxHp:
	mov	ax, 3
	push	ax
	mov	ax, charSize
	imul	[bp+slotNumber]
	mov	bx, ax
	sub	ax, ax
	push	ax
	push	gs:party.maxHP[bx]
	lea	ax, [bp+partyLine]
	push	ss
	push	ax
	call	itoa
	add	sp, 0Ah
	mov	word ptr [bp+partyLineP], ax
	mov	word ptr [bp+partyLineP+2], dx
	lfs	bx, [bp+partyLineP]
	mov	byte ptr fs:[bx], 0
	mov	ax, 1
	push	ax
	push	[bp+slotNumber]
	mov	ax, 14h
	push	ax
	lea	ax, [bp+partyLine]
	push	ss
	push	ax
	push	cs
	call	near ptr party_printAt
	add	sp, 0Ah

l_printCurrentHp:
	mov	ax, 3
	push	ax
	mov	ax, charSize
	imul	[bp+slotNumber]
	mov	bx, ax
	sub	ax, ax
	push	ax
	push	gs:party.currentHP[bx]
	lea	ax, [bp+partyLine]
	push	ss
	push	ax
	call	itoa
	add	sp, 0Ah
	mov	word ptr [bp+partyLineP], ax
	mov	word ptr [bp+partyLineP+2], dx
	lfs	bx, [bp+partyLineP]
	mov	byte ptr fs:[bx], 0
	sub	ax, ax
	push	ax
	push	[bp+slotNumber]
	mov	ax, 18h
	push	ax
	lea	ax, [bp+partyLine]
	push	ss
	push	ax
	push	cs
	call	near ptr party_printAt
	add	sp, 0Ah

	mov	ax, 3
	push	ax
	mov	ax, charSize
	imul	[bp+slotNumber]
	mov	bx, ax
	sub	ax, ax
	push	ax
	push	gs:party.maxSppt[bx]
	lea	ax, [bp+partyLine]
	push	ss
	push	ax
	call	itoa
	add	sp, 0Ah
	mov	word ptr [bp+partyLineP], ax
	mov	word ptr [bp+partyLineP+2], dx
	lfs	bx, [bp+partyLineP]
	mov	byte ptr fs:[bx], 0
	mov	ax, 1
	push	ax
	push	[bp+slotNumber]
	mov	ax, 1Ch
	push	ax
	lea	ax, [bp+partyLine]
	push	ss
	push	ax
	push	cs
	call	near ptr party_printAt
	add	sp, 0Ah

	mov	ax, 3
	push	ax
	mov	ax, charSize
	imul	[bp+slotNumber]
	mov	bx, ax
	sub	ax, ax
	push	ax
	push	gs:party.currentSppt[bx]
	lea	ax, [bp+partyLine]
	push	ss
	push	ax
	call	itoa
	add	sp, 0Ah
	mov	word ptr [bp+partyLineP], ax
	mov	word ptr [bp+partyLineP+2], dx
	lfs	bx, [bp+partyLineP]
	mov	byte ptr fs:[bx], 0
	sub	ax, ax
	push	ax
	push	[bp+slotNumber]
	mov	ax, 20h	
	push	ax
	lea	ax, [bp+partyLine]
	push	ss
	push	ax
	push	cs
	call	near ptr party_printAt
	add	sp, 0Ah

	mov	ax, charSize
	imul	[bp+slotNumber]
	mov	bx, ax
	mov	al, gs:party.class[bx]
	sub	ah, ah
	mov	si, ax
	shl	si, 1
	mov	al, byte ptr classAbbreviations[si]
	mov	byte ptr [bp+partyLine], al
	mov	al, byte ptr (classAbbreviations+1)[si]
	mov	byte ptr [bp+partyLine+1], al
	mov	[bp+var_26], ah
	mov	ax, 1
	push	ax
	push	[bp+slotNumber]
	mov	ax, 24h	
	push	ax
	lea	ax, [bp+partyLine]
	push	ss
	push	ax
	push	cs
	call	near ptr party_printAt
	add	sp, 0Ah
	jmp	short l_charNumberLoopIncrement

l_emptyPartySlot:
	mov	byte ptr [bp+partyLine], 0
	push	[bp+slotNumber]
	lea	ax, [bp+partyLine]
	push	ss
	push	ax
	push	cs
	call	near ptr party_clearAndPrintLine
	add	sp, 6

l_charNumberLoopIncrement:
	inc	[bp+slotNumber]
	cmp	[bp+slotNumber], 7
	jl	l_charNumberLoopEntry
	push	cs
	call	near ptr sub_1766A

l_return:
	pop	si
	mov	sp, bp
	pop	bp
	retf
party_print endp

; Attributes: bp-based frame

party_clearAndPrintLine proc far

	var_2= word ptr	-2
	inString= dword ptr	 6
	partySlotNumber= word ptr	 0Ah

	push	bp
	mov	bp, sp
	mov	ax, 2
	call	someStackOperation

	mov	ax, [bp+partySlotNumber]
	mov	cl, 3
	shl	ax, cl
	mov	[bp+var_2], ax
	mov	ax, 7
	push	ax
	mov	ax, [bp+var_2]
	add	ax, 97h	
	push	ax
	mov	ax, 13Ah
	push	ax
	mov	ax, [bp+var_2]
	add	ax, 90h	
	push	ax
	mov	ax, 0Bh
	push	ax
	call	far ptr	sub_3E96B
	add	sp, 0Ah
	mov	ax, 1
	push	ax
	mov	ax, [bp+var_2]
	add	ax, 90h	
	push	ax
	mov	ax, 0Ch
	push	ax
	push	[bp+inString]
	push	cs
	call	near ptr writeStringAt
	add	sp, 0Ah

	mov	sp, bp
	pop	bp
	retf
party_clearAndPrintLine endp

; Attributes: bp-based frame

party_printAt proc far

	inString= dword ptr	 6
	column= word ptr	 0Ah
	slotNumber= word ptr	 0Ch
	colorFlag= word ptr	 0Eh

	push	bp
	mov	bp, sp

	cmp	[bp+colorFlag], 1
	sbb	ax, ax
	neg	ax
	push	ax
	mov	ax, [bp+slotNumber]
	mov	cl, 3
	shl	ax, cl
	add	ax, 90h	
	push	ax
	mov	ax, [bp+column]
	shl	ax, cl
	add	ax, 0Ch
	push	ax
	push	[bp+inString]
	push	cs
	call	near ptr printAt
	add	sp, 0Ah

	mov	sp, bp
	pop	bp
	retf
party_printAt endp

; Attributes: bp-based frame

setTitle proc far

	startingColumn= word ptr	-2
	inString= dword ptr	 6

	push	bp
	mov	bp, sp
	mov	ax, 2
	call	someStackOperation

	sub	ax, ax
	push	ax
	mov	ax, 71h	
	push	ax
	mov	ax, 82h	
	push	ax
	mov	ax, 6Ah	
	push	ax
	mov	ax, 12h
	push	ax
	call	far ptr	sub_3E96B
	add	sp, 0Ah

	mov	ax, 70h	
	push	ax
	push	[bp+inString]
	push	cs
	call	near ptr centerString
	add	sp, 6
	mov	[bp+startingColumn], ax
	sub	ax, ax
	push	ax
	mov	ax, 6Ah	
	push	ax
	mov	ax, [bp+startingColumn]
	add	ax, 12h
	push	ax
	push	[bp+inString]
	push	cs
	call	near ptr writeStringAt
	add	sp, 0Ah

	mov	sp, bp
	pop	bp
	retf
setTitle endp

; 1. Calculate the pixel maxWidth of the passed in string
; 2. Subtract half the pixel maxWidth from the maxWidth
;
; Attributes: bp-based frame

centerString proc far

	var_2= word ptr	-2
	inString= dword ptr  6
	maxWidth= word ptr	 0Ah

	push	bp
	mov	bp, sp
	mov	ax, 2
	call	someStackOperation

	mov	[bp+var_2], 0
l_loop:
	lfs	bx, [bp+inString]
	cmp	byte ptr fs:[bx], 0
	jz	short l_return
	inc	word ptr [bp+inString]
	mov	al, fs:[bx]
	cbw
	push	ax
	push	cs
	call	near ptr text_characterWidth
	add	sp, 2
	add	[bp+var_2], ax
	jmp	short l_loop

l_return:
	mov	ax, [bp+maxWidth]
	sub	ax, [bp+var_2]
	cwd
	sub	ax, dx
	sar	ax, 1

	mov	sp, bp
	pop	bp
	retf
centerString endp

; Attributes: bp-based frame

writeStringAt proc far

	var_2= byte ptr	-2
	inString= dword ptr  6
	column= word ptr	 0Ah
	row= word ptr	 0Ch
	colorFlag= word ptr	 0Eh

	push	bp
	mov	bp, sp
	mov	ax, 2
	call	someStackOperation

l_loop:
	lfs	bx, [bp+inString]
	mov	al, fs:[bx]
	mov	[bp+var_2], al
	or	al, al
	jz	short l_return
	push	[bp+colorFlag]
	cbw
	sub	ax, 20h	
	push	ax
	push	[bp+column]
	push	[bp+row]
	call	far ptr	gfx_writeCharacter
	add	sp, 8
	lfs	bx, [bp+inString]
	mov	al, fs:[bx]
	cbw
	push	ax
	push	cs
	call	near ptr text_characterWidth
	add	sp, 2
	add	[bp+column], ax
	inc	word ptr [bp+inString]
	jmp	short l_loop
l_return:
	mov	sp, bp
	pop	bp
	retf
writeStringAt endp

; Attributes: bp-based frame

printAt proc far

	inString= dword ptr  6
	column= word ptr	 0Ah
	row= word ptr	 0Ch
	colorFlag= word ptr	 0Eh

	push	bp
	mov	bp, sp

l_loop:
	lfs	bx, [bp+inString]
	mov	al, fs:[bx]
	or	al, al
	jz	short l_return
	push	[bp+colorFlag]
	cbw
	sub	ax, 20h	
	push	ax
	push	[bp+column]
	push	[bp+row]
	call	far ptr	gfx_writeCharacter
	add	sp, 8
	add	[bp+column], 8
	inc	word ptr [bp+inString]
	jmp	short l_loop
l_return:
	mov	sp, bp
	pop	bp
	retf
printAt endp

; Attributes: bp-based frame

text_clear	proc far
	push	bp
	mov	bp, sp
	cmp	gs:g_text_clearFlag, 0
	jz	short l_return
	sub	al, al
	mov	gs:txt_numLines, al
	mov	gs:g_currentCharPosition, al
	mov	ax, 0Fh
	push	ax
	mov	ax, 66h	
	push	ax
	mov	ax, 132h
	push	ax
	mov	ax, 6
	push	ax
	mov	ax, 0A7h 
	push	ax
	call	far ptr	sub_3E96B
	add	sp, 0Ah
	mov	gs:g_text_clearFlag, 0
l_return:
	mov	sp, bp
	pop	bp
	retf
text_clear	endp

; Attributes: bp-based frame

text_characterWidth	proc far

	inCharacter= byte ptr	 6

	push	bp
	mov	bp, sp
	mov	al, [bp+inCharacter]
	cbw

	cmp	ax, 'i'
	jz	l_returnThree
	cmp	ax, ' '
	jz	l_returnSix
	cmp	ax, 'm'
	jz	l_returnEight
	cmp	ax, 'a'
	jl	l_returnEight
	cmp	ax, 'z'
	jle	l_returnSix

l_returnEight:
	mov	ax, 8
	jmp	short l_return

l_returnThree:
	mov	ax, 3
	jmp	short l_return

l_returnSix:
	mov	ax, 6

l_return:
	mov	sp, bp
	pop	bp
	retf
text_characterWidth	endp

; Attributes: bp-based frame

icons_read proc far

	fd= word ptr	-2

	push	bp
	mov	bp, sp
	mov	ax, 2
	call	someStackOperation

l_retry:
	sub	ax, ax
	push	ax
	mov	ax, offset s_iconFilePath
	push	ds
	push	ax
	call	open
	add	sp, 6
	mov	[bp+fd], ax
	cmp	ax, 0FFFFh
	jnz	l_asdf
	mov	ax, offset s_insertDisk
	push	ds
	push	ax
	call	printString
	add	sp, 4
	push	dseg_0
	push	disk1
	call	printString
	add	sp, 4
	mov	ax, 4000h
	push	ax
	call	getKey
	add	sp, 2
l_asdf:
	push	[bp+fd]
	call	huf_init
	add	sp, 2
	mov	ax, 474h
	push	ax
	mov	ax, offset iconLight
	mov	dx, seg	seg023
	push	dx
	push	ax
	call	huf_flate
	add	sp, 6
	mov	ax, 820h
	push	ax
	mov	ax, offset iconCompass
	mov	dx, seg	seg023
	push	dx
	push	ax
	call	huf_flate
	add	sp, 6
	mov	ax, 550h
	push	ax
	mov	ax, offset iconAreaEnchant
	mov	dx, seg	seg023
	push	dx
	push	ax
	call	huf_flate
	add	sp, 6
	mov	ax, 1E0h
	push	ax
	mov	ax, offset iconShield
	mov	dx, seg	seg023
	push	dx
	push	ax
	call	huf_flate
	add	sp, 6
	mov	ax, 640h
	push	ax
	mov	ax, offset iconLevitation
	mov	dx, seg	seg023
	push	dx
	push	ax
	call	huf_flate
	add	sp, 6
	push	[bp+fd]
	call	close
	add	sp, 2

	mov	sp, bp
	pop	bp
	retf
icons_read endp

; Attributes: bp-based frame

bigpic_drawPictureNumber proc far

	var_E= word ptr	-0Eh
	var_C= word ptr	-0Ch
	var_8= word ptr	-8
	var_6= word ptr	-6
	fd= word ptr -4
	var_2= word ptr	-2
	indexNo= word ptr  6

	push	bp
	mov	bp, sp
	mov	ax, 0Eh
	call	someStackOperation
	push	si

	cmp	[bp+indexNo], 0FEh
	jnz	short loc_171CF
	mov	ax, 7
	push	ax
	mov	ax, 66h	
	push	ax
	mov	ax, 7Fh	
	push	ax
	mov	ax, 0Fh
	push	ax
	mov	ax, 11h
	push	ax
	call	far ptr	sub_3E96B
	add	sp, 0Ah
	jmp	l_return
loc_171CF:
	mov	ax, 88
	imul	bigpicIndexMultiplier
	mov	si, ax
	mov	bx, [bp+indexNo]
	cmp	bigpicIndex[bx+si-58h],	0FFh
	jnz	short loc_171E7
	xor	byte ptr bigpicIndexMultiplier, 3
loc_171E7:
	mov	ax, 88
	imul	bigpicIndexMultiplier
	mov	si, ax
	cmp	bigpicIndex[bx+si-58h],	0FFh
	jnz	short loc_17206
	mov	ax, offset s_getPictureError
	push	ds
	push	ax
	call	printString
	add	sp, 4
	jmp	l_return

loc_17206:
	mov	ax, 88
	imul	bigpicIndexMultiplier
	mov	si, ax
	mov	bx, [bp+indexNo]
	mov	al, bigpicIndex[bx+si-58h]
	sub	ah, ah
	mov	[bp+var_2], ax

loc_1721B:
	sub	ax, ax
	push	ax
	mov	bx, bigpicIndexMultiplier
	shl	bx, 1
	shl	bx, 1
	push	word ptr lowPic[bx-2]
	push	word ptr lowPic[bx-4]
	call	open
	add	sp, 6
	mov	[bp+fd], ax
	inc	ax
	jnz	short loc_1726A
	mov	ax, offset s_insertDisk
	push	ds
	push	ax
	call	printString
	add	sp, 4
	mov	bx, bigpicIndexMultiplier
	shl	bx, 1
	shl	bx, 1
	push	dseg_0[bx]
	push	disk1[bx]
	call	printString
	add	sp, 4
	mov	ax, 4000h
	push	ax
	call	getKey
	add	sp, 2
loc_1726A:
	cmp	[bp+fd], 0FFFFh
	jz	short loc_1721B
	mov	ax, 0FFFFh
	push	ax
	mov	ax, [bp+var_2]
	shl	ax, 1
	shl	ax, 1
	sub	cx, cx
	push	cx
	push	ax
	push	[bp+fd]
	call	lseek
	add	sp, 8
	mov	ax, 4
	push	ax
	lea	ax, [bp+var_8]
	push	ss
	push	ax
	push	[bp+fd]
	call	read
	add	sp, 8
	mov	ax, 0FFFFh
	push	ax
	push	[bp+var_6]
	push	[bp+var_8]
	push	[bp+fd]
	call	lseek
	add	sp, 8
	mov	ax, 19712
	push	ax
	call	_mallocMaybe
	add	sp, 2
	mov	[bp+var_E], ax
	mov	[bp+var_C], dx
	mov	ax, 19712
	push	ax
	push	dx
	push	[bp+var_E]
	push	[bp+fd]
	call	read
	add	sp, 8
	push	gs:bigpicCellData_seg
	push	gs:bigpicCellData_off
	push	[bp+var_C]
	push	[bp+var_E]
	call	d3cmp_flate
	add	sp, 8
	push	[bp+var_C]
	push	[bp+var_E]
	call	_freeMaybe
	add	sp, 4
	push	[bp+fd]
	call	close
	add	sp, 2
	push	gs:bigpicCellData_seg
	push	gs:bigpicCellData_off
	push	cs
	call	near ptr bigpic_configureCells
	add	sp, 4
	mov	ax, offset bigpicBuf
	mov	dx, seg	seg021
	push	dx
	push	ax
	push	gs:bigpicCellData_seg
	push	gs:bigpicCellData_off
	call	far ptr	vid_drawBigpic
	add	sp, 8
	cmp	[bp+indexNo], 53
	jz	short loc_1734A
	mov	al, 1
	jmp	short loc_1734C
loc_1734A:
	sub	al, al
loc_1734C:
	mov	gs:byte_422A0, al
	mov	gs:bigpicCellNumber, 0
	sub	ax, ax
	jmp	short $+2
l_return:
	pop	si
	mov	sp, bp
	pop	bp
	retf
bigpic_drawPictureNumber endp

; The bigpic data consists of "cells". The first cell is the base
; image. The remaining cells are xor'd onto the previous cell.
; This function configures the remaining cells.
;
; Attributes: bp-based frame

bigpic_configureCells proc far

	arg_0= dword ptr  6

	push	bp
	mov	bp, sp
	push	si

	mov	si, 1340h
l_loop:
	lfs	bx, [bp+arg_0]
	mov	al, fs:[bx]
	xor	fs:[bx+1340h], al
	inc	word ptr [bp+arg_0]
	inc	si
	cmp	si, 4D00h
	jl	short l_loop

	pop	si
	mov	sp, bp
	pop	bp
	retf
bigpic_configureCells endp


; Attributes: bp-based frame

map_read proc far

	var_E= word ptr	-0Eh
	memOffset= word	ptr -0Ch
	memSegment= word ptr -0Ah
	var_6= word ptr	-6
	fd= word ptr -4
	var_2= word ptr	-2
	arg_0= word ptr	 6
	arg_2= word ptr	 8
	arg_4= word ptr	 0Ah

	push	bp
	mov	bp, sp
	mov	ax, 0Eh
	call	someStackOperation

	mov	bx, [bp+arg_0]
	shl	bx, 1
	mov	al, byte ptr levelPathTable.fileType[bx]
	sub	ah, ah
	mov	[bp+var_E], ax
loc_173AD:
	sub	ax, ax
	push	ax
	mov	bx, [bp+var_E]
	shl	bx, 1
	shl	bx, 1
	push	word ptr (disk3+2)[bx]
	push	word ptr disk3[bx]
	call	open
	add	sp, 6
	mov	[bp+fd], ax
	inc	ax
	jnz	short loc_173FA
	mov	ax, offset s_insertDisk
	push	ds
	push	ax
	call	printString
	add	sp, 4
	mov	bx, [bp+var_E]
	shl	bx, 1
	shl	bx, 1
	push	dseg_0[bx]
	push	disk1[bx]
	call	printString
	add	sp, 4
	mov	ax, 4000h
	push	ax
	call	getKey
	add	sp, 2
loc_173FA:
	cmp	[bp+fd], 0FFFFh
	jz	short loc_173AD
	mov	bx, [bp+arg_0]
	shl	bx, 1
	mov	al, levelPathTable.fileIndexMaybe[bx]
	sub	ah, ah
	mov	[bp+var_2], ax
	mov	ax, 0FFFFh
	push	ax
	mov	ax, [bp+var_2]
	shl	ax, 1
	cwd
	push	dx
	push	ax
	push	[bp+fd]
	call	lseek
	add	sp, 8
	mov	ax, 2
	push	ax
	lea	ax, [bp+var_6]
	push	ss
	push	ax
	push	[bp+fd]
	call	read
	add	sp, 8
	mov	ax, 0FFFFh
	push	ax
	sub	ax, ax
	push	ax
	push	[bp+var_6]
	push	[bp+fd]
	call	lseek
	add	sp, 8
	mov	ax, 4000
	push	ax
	call	_mallocMaybe
	add	sp, 2
	mov	[bp+memOffset],	ax
	mov	[bp+memSegment], dx
	mov	ax, 4000
	push	ax
	push	dx
	push	[bp+memOffset]
	push	[bp+fd]
	call	read
	add	sp, 8

	push	[bp+arg_4]
	push	[bp+arg_2]
	push	[bp+memSegment]
	push	[bp+memOffset]
	call	d3cmp_flate
	add	sp, 8

	push	[bp+memSegment]
	push	[bp+memOffset]
	call	_freeMaybe
	add	sp, 4
	push	[bp+fd]
	call	close
	add	sp, 2

	mov	sp, bp
	pop	bp
	retf
map_read endp

; Attributes: bp-based frame

map_readGraphics proc far

	var_4= word ptr	-4
	fd= word ptr	-2
	arg_0= word ptr	 6

	push	bp
	mov	bp, sp
	mov	ax, 4
	call	someStackOperation

	mov	ax, word_4414E
	cmp	[bp+arg_0], ax
	jz	l_return

l_retry:
	sub	ax, ax
	push	ax
	mov	bx, [bp+arg_0]
	shl	bx, 1
	shl	bx, 1
	push	word ptr (map_graphicsTable+2)[bx]
	push	word ptr map_graphicsTable[bx]
	call	open
	add	sp, 6
	mov	[bp+fd], ax
	inc	ax
	jnz	short loc_17513
	mov	bx, [bp+arg_0]
	mov	al, byte_43F4A[bx]
	sub	ah, ah
	mov	[bp+var_4], ax
	mov	ax, offset s_insertDisk
	push	ds
	push	ax
	call	printString
	add	sp, 4
	mov	bx, [bp+var_4]
	shl	bx, 1
	shl	bx, 1
	push	dseg_0[bx]
	push	disk1[bx]
	call	printString
	add	sp, 4
	mov	ax, 4000h
	push	ax
	call	getKey
	add	sp, 2
loc_17513:
	cmp	[bp+fd], 0FFFFh
	jz	short l_retry
	mov	ax, [bp+arg_0]
	mov	word_4414E, ax
	mov	ax, 4A38h
	push	ax
	mov	ax, offset graphicsBuf
	mov	dx, seg	seg023
	push	dx
	push	ax
	push	[bp+fd]
	call	read
	add	sp, 8
	push	[bp+fd]
	call	close
	add	sp, 2
l_return:
	mov	sp, bp
	pop	bp
	retf
map_readGraphics endp

; Attributes: bp-based frame

map_readMonsters	proc far

	var_A= word ptr	-0Ah
	_size= word ptr -8
	var_6= word ptr -6
	var_4= word ptr	-4
	_fd= word ptr	-2
	index= word ptr	 6

	push	bp
	mov	bp, sp
	mov	ax, 0Ah
	call	someStackOperation

	mov	ax, 480h
	push	ax
	sub	ax, ax
	push	ax
	mov	ax, offset monsterBuf
	mov	dx, seg	seg023
	push	dx
	push	ax
	call	memset
	add	sp, 8
	mov	[bp+_size], 0

	; If the index is the last index in the file, read the full 0x480 bytes.
	; Otherwise, read the index, then read the next index, subtract to get the
	; length of the monster roster for the level.
	;
	cmp	[bp+index], 17
	jz	l_hardcode_size
	cmp	[bp+index], 40
	jnz	l_skip_hardcode

l_hardcode_size:
	mov	[bp+_size], 480h

l_skip_hardcode:
	cmp	[bp+index], 11h
	jge	short loc_17571
	sub	ax, ax
	jmp	short loc_17574
loc_17571:
	mov	ax, 1
loc_17574:
	mov	[bp+var_A], ax
loc_17577:
	sub	ax, ax
	push	ax
	mov	bx, [bp+var_A]
	shl	bx, 1
	shl	bx, 1
	push	word ptr (monsterFiles+2)[bx]
	push	word ptr monsterFiles[bx]
	call	open
	add	sp, 6
	mov	[bp+_fd], ax
	inc	ax
	jnz	short loc_175C4
	mov	ax, offset s_insertDisk
	push	ds
	push	ax
	call	printString
	add	sp, 4
	mov	bx, [bp+var_A]
	shl	bx, 1
	shl	bx, 1
	push	word ptr (disk2+2)[bx]
	push	word ptr disk2[bx]
	call	printString
	add	sp, 4
	mov	ax, 4000h
	push	ax
	call	getKey
	add	sp, 2
loc_175C4:
	cmp	[bp+_fd], 0FFFFh
	jz	short loc_17577
	cmp	[bp+var_A], 0
	jz	short loc_175D4
	sub	[bp+index], 11h
loc_175D4:
	mov	ax, 0FFFFh
	push	ax
	mov	ax, [bp+index]
	shl	ax, 1
	cwd
	push	dx
	push	ax
	push		[bp+_fd]
	call	lseek
	add	sp, 8

	mov	ax, 2
	push	ax
	lea	ax, [bp+var_4]
	push	ss
	push	ax
	push	[bp+_fd]
	call	read
	add	sp, 8

	cmp	[bp+_size], 0
	jnz	l_read_data

	mov	ax, 2
	push	ax
	lea	ax, [bp+var_6]
	push	ss
	push	ax
	push	[bp+_fd]
	call	read
	add	sp, 8

	mov	ax, [bp+var_6]
	sub	ax, [bp+var_4]
	mov	[bp+_size], ax

l_read_data:
	mov	ax, 0FFFFh
	push	ax
	mov	ax, [bp+var_4]
	cwd
	push	dx
	push	ax
	push	[bp+_fd]
	call	lseek
	add	sp, 8

	push	[bp+_size]
	mov	ax, offset monsterBuf
	mov	dx, seg	seg023
	push	dx
	push	ax
	push	[bp+_fd]
	call	read
	add	sp, 8

	push	[bp+_fd]
	call	close
	add	sp, 2

	mov	sp, bp
	pop	bp
	retf
map_readMonsters	endp

; Attributes: bp-based frame

printMessageAndExit proc far

	arg_0= dword ptr	 6

	push	bp
	mov	bp, sp

	call	text_clear
	push	[bp+arg_0]
	call	printString
	add	sp, 4
	mov	ax, 4000h
	push	ax
	call	getKey
	add	sp, 2
	call	cleanupAndExit

	mov	sp, bp
	pop	bp
	retf
printMessageAndExit endp


; Attributes: bp-based frame

sub_1766A proc far
	push	bp
	mov	bp, sp
	cmp	gs:byte_422A0, 0
	jz	short loc_17688
	push	cs
	call	near ptr sub_17691
	or	ax, ax
	jz	short l_return
loc_17688:
	call	far ptr	sub_3E971
l_return:
	mov	sp, bp
	pop	bp
	retf
sub_1766A endp

; Attributes: bp-based frame

sub_17691 proc far
	push	bp
	mov	bp, sp
	mov	ax, mouseBoxes._left
	cmp	mouse_x, ax
	jl	short loc_176CB
	mov	ax, mouseBoxes._right
	cmp	mouse_x, ax
	jge	short loc_176CB
	mov	ax, mouseBoxes._top
	cmp	mouse_y, ax
	jl	short loc_176CB
	mov	ax, mouseBoxes._bottom
	cmp	mouse_y, ax
	jl	short loc_176D0
loc_176CB:
	mov	ax, 1
	jmp	short loc_176D2
loc_176D0:
	sub	ax, ax
loc_176D2:
	jmp	short $+2
	mov	sp, bp
	pop	bp
	retf
sub_17691 endp


seg003 ends

; Segment type: Pure code
seg004 segment word public 'CODE' use16
        assume cs:seg004
;org 7
        assume es:nothing, ss:nothing, ds:dseg, fs:nothing, gs:seg027
align 2

; XXX - Revisit after bigpic_copyTopoElem
; Attributes: bp-based frame

bigpic_drawTopology proc far

	headerSize= word ptr -1Eh
	height=	word ptr -1Ch
	tileOffset= dword ptr -1Ah
	gfxSourceBufferP= dword ptr -12h
	row= word ptr -0Eh
	column=	word ptr -0Ch
	var_A= word ptr	-0Ah
	tileIndexNumber= word ptr	-8
	quadrantWidth= word ptr	-6
	srcSkip= word ptr	-2
	quadrant= word ptr  6
	sq= word ptr  8
	gfxSourceBuffer= dword ptr	 0Ah		; GFX source address

	push	bp
	mov	bp, sp
	mov	ax, 1Eh
	call	someStackOperation
	push	di
	push	si

	cmp	inDungeonMaybe, 0
	jz	short l_notInDungeon
	mov	ax, 10h
	jmp	short l_setHeaderSize

l_notInDungeon:
	mov	ax, 14h

l_setHeaderSize:
	mov	[bp+headerSize], ax

	; Set column
	mov	si, [bp+quadrant]
	shl	si, 1
	mov	al, byte ptr g_tile_quadrantCoordinates.column[si]
	cbw
	mov	[bp+column], ax

	; Set row
	mov	al, g_tile_quadrantCoordinates.row[si]
	cbw
	mov	[bp+row], ax

	mov	bx, [bp+quadrant]
	mov	al, g_tile_quadrantWidthList[bx]
	cbw
	mov	[bp+quadrantWidth], ax

	mov	al, g_tile_quadrantAspectOffsetList[bx]
	cbw
	mov	cx, [bp+sq]
	shl	cx, 1
	shl	cx, 1
	add	ax, cx
	mov	[bp+tileIndexNumber], ax

	mov	ax, [bp+headerSize]
	cmp	[bp+tileIndexNumber], ax
	jge	l_return

loc_177A8:
	mov	di, [bp+tileIndexNumber]
	lfs	bx, [bp+gfxSourceBuffer]
	mov	ah, fs:[bx+di+1]
	sub	al, al
	mov	bx, di
	mov	di, word ptr [bp+gfxSourceBuffer]
	mov	cl, fs:[bx+di]
	sub	ch, ch
	add	ax, cx
	add	ax, di
	mov	dx, fs
	add	ax, 9
	mov	word ptr [bp+tileOffset], ax
	mov	word ptr [bp+tileOffset+2], dx
	lfs	bx, [bp+tileOffset]
	inc	word ptr [bp+tileOffset]
	mov	al, fs:[bx]
	cbw
	mov	[bp+srcSkip], ax

	mov	bx, word ptr [bp+tileOffset]
	inc	word ptr [bp+tileOffset]
	mov	al, fs:[bx]
	cbw
	mov	[bp+height], ax

	mov	ax, word ptr [bp+tileOffset]
	add	ax, 2
	mov	word ptr [bp+gfxSourceBufferP], ax
	mov	word ptr [bp+gfxSourceBufferP+2], dx
	cmp	[bp+column], 0
	jge	short loc_17813
	mov	ax, [bp+column]
	sub	word ptr [bp+gfxSourceBufferP], ax
	mov	ax, [bp+quadrantWidth]
	add	ax, [bp+column]
	jns	short loc_17809
	sub	ax, ax

loc_17809:
	mov	[bp+var_A], ax
	mov	[bp+column], 0
	jmp	short loc_1782F

loc_17813:
	mov	ax, [bp+column]
	add	ax, [bp+quadrantWidth]
	cmp	ax, 56
	jle	short loc_17829
	mov	ax, 55
	sub	ax, [bp+column]
	mov	[bp+var_A], ax
	jmp	short loc_1782F

loc_17829:
	mov	ax, [bp+quadrantWidth]
	mov	[bp+var_A], ax

loc_1782F:
	cmp	[bp+srcSkip], 0
	jz	short l_return
	mov	bx, [bp+quadrant]
	mov	al, g_quadrantRightFlagList[bx]
	cbw
	push	ax					; rightFlag
	mov	al, g_tile_quadrantScaleFactor[bx]
	cbw
	push	ax
	push	[bp+height]
	push	[bp+srcSkip]
	push	[bp+var_A]
	push	[bp+row]
	push	[bp+column]
	push	word ptr [bp+gfxSourceBufferP+2]
	push	word ptr [bp+gfxSourceBufferP]
	call	_bigpic_copyTopoElem
	add	sp, 12h

l_return:
	pop	si
	pop	di
	mov	sp, bp
	pop	bp
	retf
bigpic_drawTopology endp

; Attributes: bp-based frame

bigpic_setBackground	proc far

	var_4= word ptr	-4
	var_2= word ptr	-2
	arg_0= dword ptr  6

	push	bp
	mov	bp, sp
	mov	ax, 4
	call	someStackOperation

	test	g_levelFlags, 20h
	jz	l_inDungeon

	mov	ax, 44h			; Outdoor sky color
	push	ax
	mov	ax, 0BBBBh		; Outdoor ground color
	push	ax
	mov	ax, offset bigpicBuf
	mov	dx, seg seg021
	push	dx
	push	ax
	call	bigpic_memcpy
	add	sp, 8
	jmp	l_return

l_inDungeon:
	push	si
	lfs	bx, [bp+arg_0]
	mov	ah, fs:(graphicsBuf+11h)[bx]
	sub	al, al
	mov	cl, fs:(graphicsBuf+10h)[bx]
	sub	ch, ch
	add	ax, cx
	add	ax, bx
	mov	dx, fs
	add	ax, 0Dh
	mov	[bp+var_4], ax
	mov	[bp+var_2], dx
	mov	ax, 9A0h
	push	ax
	push	dx
	push	[bp+var_4]
	mov	ax, offset bigpicBuf
	mov	dx, seg	seg021
	push	dx
	push	ax
	call	memcpy
	add	sp, 0Ah
	lfs	bx, [bp+arg_0]
	mov	ah, fs:(graphicsBuf+13h)[bx]
	sub	al, al
	mov	cl, fs:(graphicsBuf+12h)[bx]
	sub	ch, ch
	add	ax, cx
	add	ax, bx
	mov	dx, fs
	add	ax, 0Dh
	mov	[bp+var_4], ax
	mov	[bp+var_2], dx
	mov	ax, 9A0h
	push	ax
	push	dx
	push	[bp+var_4]
	mov	ax, (offset bigpicBuf+9A0h)
	mov	dx, seg	seg021
	push	dx
	push	ax
	call	memcpy
	add	sp, 0Ah
	cmp	lightDistance, 4
	jnb	short l_return
	mov	al, lightDistance
	sub	ah, ah
	mov	si, ax
	shl	si, 1
	push	bigpicLightSize[si]
	sub	ax, ax
	push	ax
	mov	bx, bigpicLightOffset[si]
	lea	ax, bigpicBuf[bx]
	mov	dx, seg	seg021
	push	dx
	push	ax
	call	memset
	add	sp, 8
	pop	si
l_return:
	mov	sp, bp
	pop	bp
	retf
bigpic_setBackground	endp


seg004 ends

; Segment type: Pure code
seg005 segment byte public 'CODE' use16
        assume cs:seg005
        assume es:nothing, ss:nothing, ds:dseg, fs:nothing, gs:seg027
; Attributes: bp-based frame

icon_deactivate proc far

	iconIndex= word ptr	 6

	push	bp
	mov	bp, sp

	mov	bx, [bp+iconIndex]
	mov	al, iconClearIndex[bx]
	sub	ah, ah
	push	ax
	push	bx
	push	cs
	call	near ptr icon_draw
	add	sp, 4
	mov	bx, [bp+iconIndex]
	mov	lightDuration[bx], 0
	mov	ax, [bp+iconIndex]
	or	ax, ax
	jz	short l_light
	cmp	ax, 2
	jz	short l_detect
	cmp	ax, 3
	jz	short l_shield
	jmp	short l_return

l_light:
	sub	al, al
	mov	lightDistance, al
	mov	gs:gl_detectSecretDoorFlag, al
	jmp	short l_return

l_detect:
	mov	g_detectType, 0
	jmp	short l_return

l_shield:
	mov	shieldAcBonus, 0

l_return:
	mov	sp, bp
	pop	bp
	retf
icon_deactivate endp

; Attributes: bp-based frame

icon_activate proc far

	iconIndex= word ptr	 6

	push	bp
	mov	bp, sp
	push	si

	mov	bx, [bp+iconIndex]
	mov	iconCurrentDelay[bx], 1
	mov	bx, [bp+iconIndex]
	mov	si, bx
	sub	al, al
	mov	byte_44718[si],	al
	mov	iconCurrentCell[bx],	al
	sub	ax, ax
	push	ax
	push	[bp+iconIndex]
	push	cs
	call	near ptr icon_draw
	add	sp, 4

	pop	si
	mov	sp, bp
	pop	bp
	retf
icon_activate endp

; Attributes: bp-based frame

gfx_animate proc far

	iconNumber= word ptr	-2

	push	bp
	mov	bp, sp
	mov	ax, 2
	call	someStackOperation
	push	si

	mov	al, byte ptr g_direction
	mov	iconCurrentCell[1], al

	cmp	gs:byte_422A0, 0
	jz	short loc_17A34

	mov	ax, gs:word_4245A
	inc	gs:word_4245A
	test	al, 3
	jnz	short loc_17A34

	inc	gs:bigpicCellNumber
	and	gs:bigpicCellNumber, 3
	mov	ax, offset bigpicBuf
	mov	dx, seg	seg021
	push	dx
	push	ax
	mov	al, gs:bigpicCellNumber
	sub	ah, ah
	mov	cx, 1340h
	mul	cx
	add	ax, gs:bigpicCellData_off
	mov	dx, gs:bigpicCellData_seg
	push	dx
	push	ax
	call	far ptr	vid_drawBigpic
	add	sp, 8
	jmp	short loc_17A9C

loc_17A34:
	cmp	gs:word_42560, 0
	jz	short loc_17A9C

	mov	ax, gs:word_4245A
	inc	gs:word_4245A
	test	al, 7
	jnz	short loc_17A9C
	inc	gs:bigpicCellNumber
	cmp	gs:bigpicCellNumber, 3
	jnz	short loc_17A6D
	mov	gs:word_42560, 0

loc_17A6D:
	mov	ax, offset bigpicBuf
	mov	dx, seg	seg021
	push	dx
	push	ax
	mov	al, gs:bigpicCellNumber
	sub	ah, ah
	mov	cx, 1340h
	mul	cx
	add	ax, gs:bigpicCellData_off
	mov	dx, gs:bigpicCellData_seg
	push	dx
	push	ax
	call	far ptr	vid_drawBigpic
	add	sp, 8

loc_17A9C:
	mov	[bp+iconNumber], 0
loc_17AA3:
	mov	bx, [bp+iconNumber]
	cmp	lightDuration[bx], 0
	jz	short l_increment

	; Unsure what this block does because byte_44718 and iconCurrentCell shouldn't
	; ever be different.
	mov	si, bx
	mov	al, byte_44718[si]
	cmp	iconCurrentCell[bx],	al
	jz	short loc_17AE0
	mov	al, iconCurrentCell[si]
	mov	byte_44718[bx],	al
	mov	bx, [bp+iconNumber]
	mov	al, iconCurrentCell[bx]
	cbw
	push	ax
	push	bx
	push	cs
	call	near ptr icon_draw
	add	sp, 4

loc_17AE0:
	mov	bx, [bp+iconNumber]
	cmp	iconAnimationDelay[bx],	0
	jz	short l_increment

	mov	al, iconCurrentDelay[bx]
	dec	iconCurrentDelay[bx]
	cmp	al, 1
	jnz	short l_increment

	mov	bx, [bp+iconNumber]
	mov	si, bx
	mov	al, iconAnimationDelay[si]
	mov	iconCurrentDelay[bx], al		; Set up delay for next cell

	mov	bx, [bp+iconNumber]
	inc	iconCurrentCell[bx]
	mov	al, iconCurrentCell[bx]
	mov	bx, [bp+iconNumber]
	cmp	al, iconClearIndex[bx]
	jnz	short l_increment
	mov	iconCurrentCell[bx],	0

l_increment:
	inc	[bp+iconNumber]
	cmp	[bp+iconNumber], 5
	jl	short loc_17AA3

l_return:
	pop	si
	mov	sp, bp
	pop	bp
	retf
gfx_animate endp

; Attributes: bp-based frame

icon_draw proc far

	var_4= word ptr	-4
	var_2= word ptr	-2
	arg_0= byte ptr	 6
	arg_2= byte ptr	 8

	push	bp
	mov	bp, sp
	mov	ax, 4
	call	someStackOperation
	push	si
	mov	bl, [bp+arg_0]
	sub	bh, bh
	shl	bx, 1
	shl	bx, 1
	mov	ax, word ptr iconDataList[bx]
	mov	dx, word ptr (iconDataList+2)[bx]
	mov	[bp+var_4], ax
	mov	[bp+var_2], dx
loc_17B46:
	mov	al, [bp+arg_2]
	dec	[bp+arg_2]
	or	al, al
	jz	short loc_17B60
	mov	bl, [bp+arg_0]
	sub	bh, bh
	shl	bx, 1
	mov	ax, word_4470E[bx]
	add	[bp+var_4], ax
	jmp	short loc_17B46
loc_17B60:
	mov	al, [bp+arg_0]
	sub	ah, ah
	mov	si, ax
	mov	al, iconWidth[si]
	push	ax
	mov	al, iconHeight[si]
	push	ax
	mov	al, iconXOffset[si]
	push	ax
	push	[bp+var_2]
	push	[bp+var_4]
	call	far ptr	sub_3E986
	add	sp, 0Ah
	pop	si
	mov	sp, bp
	pop	bp
locret_17B88:
	retf
icon_draw endp


seg005 ends

; Segment type: Pure code
seg006 segment word public 'CODE' use16
        assume cs:seg006
;org 9
        assume es:nothing, ss:nothing, ds:dseg, fs:nothing, gs:seg027
align 2

; Attributes: bp-based frame

party_update proc far

	slotNumber=	word ptr -2

	push	bp
	mov	bp, sp
	mov	ax, 2
	call	someStackOperation

	mov	[bp+slotNumber], 0
l_loop:
	mov	ax, charSize
	imul	[bp+slotNumber]
	mov	bx, ax
	cmp	byte ptr gs:party._name[bx], 0
	jz	short l_next
	push	[bp+slotNumber]
	push	cs
	call	near ptr character_update
	add	sp, 2

l_next:
	inc	[bp+slotNumber]
	cmp	[bp+slotNumber], 7
	jl	short l_loop

	mov	sp, bp
	pop	bp
	retf
party_update endp

; Attributes: bp-based frame

character_update proc far

	songAcBonus= word ptr	-4
	acValue= word ptr	-2
	slotNumber=	word ptr  6

	push	bp
	mov	bp, sp
	mov	ax, 4
	call	someStackOperation
	push	si

	mov	ax, charSize
	imul	[bp+slotNumber]
	mov	bx, ax
	test	gs:party.status[bx], stat_dead	or stat_stoned
	jz	short l_skipResurrect

	mov	ax, itemEff_resurrect
	push	ax
	push	[bp+slotNumber]
	push	cs
	call	near ptr character_isEffectEquipped
	add	sp, 4
	or	ax, ax
	jnz	short l_skipResurrect

	push	cs
	call	near ptr inventory_pack
	mov	ax, charSize
	imul	[bp+slotNumber]
	mov	bx, ax
	and	gs:party.status[bx], stat_poisoned or stat_old	or stat_paralyzed or stat_possessed or stat_nuts or stat_unknown
	mov	ax, charSize
	imul	[bp+slotNumber]
	mov	si, ax
	mov	ax, gs:party.maxHP[si]
	mov	gs:party.currentHP[si], ax

l_skipResurrect:
	cmp	gs:songHalfDamage, 0
	jz	short l_noSongAcBonus

	mov	al, gs:g_currentSinger
	sub	ah, ah
	cmp	ax, [bp+slotNumber]
	jnz	short l_noSongAcBonus
	mov	ax, charSize
	imul	[bp+slotNumber]
	mov	bx, ax
	cmp	gs:party.level[bx], 60
	jbe	short l_notMaxLevelSinger
	mov	ax, 0Fh
	jmp	short l_setSongAcBonus

l_notMaxLevelSinger:
	mov	ax, charSize
	imul	[bp+slotNumber]
	mov	bx, ax
	mov	ax, gs:party.level[bx]
	shr	ax, 1
	shr	ax, 1

l_setSongAcBonus:
	mov	[bp+songAcBonus], ax
	jmp	short l_songBonusExit

l_noSongAcBonus:
	mov	[bp+songAcBonus], 0

l_songBonusExit:
	push	[bp+slotNumber]
	push	cs
	call	near ptr character_getEquipmentAcBonus
	add	sp, 2
	mov	si, ax

	push	[bp+slotNumber]
	call	character_getDexterityAcBonus
	add	sp, 2
	mov	cx, ax

	mov	ax, charSize
	imul	[bp+slotNumber]
	mov	bx, ax
	mov	al, gs:party.acBase[bx]
	sub	ah, ah
	mov	bx, [bp+slotNumber]
	mov	dl, gs:byte_42444[bx]
	sub	dh, dh
	add	ax, dx
	add	ax, cx
	add	ax, si
	add	ax, [bp+songAcBonus]
	mov	[bp+acValue], ax

	mov	ax, charSize
	imul	bx
	mov	bx, ax
	cmp	gs:party.class[bx], class_monk
	jnz	short l_notMonk
	mov	ax, charSize
	imul	[bp+slotNumber]
	mov	bx, ax
	mov	ax, gs:party.level[bx]
	sub	ax, 0FFh
	sbb	cx, cx
	and	ax, cx
	add	ax, 0FFh
	add	[bp+acValue], ax

l_notMonk:
	mov	al, shieldAcBonus
	sub	ah, ah
	mov	cl, gs:partySpellAcBonus
	sub	ch, ch
	add	ax, cx
	mov	cl, gs:g_songAcBonus
	add	ax, cx
	mov	cl, gs:g_charFreezeAcPenalty
	sub	ax, cx
	or	ax, ax
	jle	short l_checkMaxAc
	add	[bp+acValue], ax

l_checkMaxAc:
	mov	al, byte ptr [bp+acValue]
	cmp	ax, 60
	jle	l_setValues
	mov	ax, 60

l_setValues:
	mov	cx, ax
	mov	ax, charSize
	imul	[bp+slotNumber]
	mov	bx, ax
	mov	gs:party.ac[bx], cl
	mov	ax, charSize
	imul	[bp+slotNumber]
	mov	bx, ax
	cmp	gs:party.currentHP[bx], 0
	jnz	short l_return
	mov	ax, charSize
	imul	[bp+slotNumber]
	mov	bx, ax
	or	gs:party.status[bx], stat_dead

l_return:
	pop	si
	mov	sp, bp
	pop	bp
	retf
character_update endp

; Attributes: bp-based frame
character_getDexterityAcBonus proc	far

	slotNumber= word ptr	 6

	push	bp
	mov	bp, sp
	mov	ax, charSize
	imul	[bp+slotNumber]
	mov	bx, ax
	mov	al, gs:party.dexterity[bx]
	sub	ah, ah
	sub	ax, 14
	or	ax, ax
	jle	short l_returnZero

	mov	bx, ax
	mov	al, g_acDexterityBonus[bx]
	sub	ah, ah
	jmp	short l_return

l_returnZero:
	sub	ax, ax

l_return:
	mov	sp, bp
	pop	bp
	retf
character_getDexterityAcBonus endp

; Attributes: bp-based frame

character_getEquipmentAcBonus proc far

	inventorySlotNumber= word ptr	-4
	acBonus= word ptr	-2
	slotNumber= word ptr	 6

	push	bp
	mov	bp, sp
	mov	ax, 4
	call	someStackOperation

	mov	[bp+acBonus], 0
	mov	[bp+inventorySlotNumber], 0

l_loop:
	mov	ax, charSize
	imul	[bp+slotNumber]
	mov	bx, ax
	add	bx, [bp+inventorySlotNumber]
	mov	al, gs:party.inventory.itemFlags[bx]
	and	al, 3
	cmp	al, 1
	jnz	short l_next

	mov	ax, charSize
	imul	[bp+slotNumber]
	mov	bx, ax
	add	bx, [bp+inventorySlotNumber]
	mov	bl, gs:party.inventory.itemNo[bx]
	sub	bh, bh
	mov	al, item_acBonWeapDam[bx]
	sub	ah, ah
	and	ax, 0Fh
	add	[bp+acBonus], ax

l_next:
	add	[bp+inventorySlotNumber], 3
	cmp	[bp+inventorySlotNumber], 36
	jl	short l_loop

	mov	ax, [bp+acBonus]
	mov	sp, bp
	pop	bp
	retf
character_getEquipmentAcBonus endp

; Attributes: bp-based frame
;
; Return:
;   0 - has effect and is equipped
;   1 - has effect and not equipped
;  -1 - does not have effect
;

character_isEffectEquipped proc far

	rval= word ptr -4
	inventorySlotNumber= word ptr	-2
	slotNumber= word ptr  6
	effectNumber= word ptr  8

	push	bp
	mov	bp, sp
	mov	ax, 4
	call	someStackOperation

	mov	[bp+rval], 0FFFFh
	cmp	byte ptr gs:party._name[bx], 0
	jz	short l_return

	mov	[bp+inventorySlotNumber], 1
l_loop:
	mov	ax, charSize
	imul	[bp+slotNumber]
	mov	bx, ax
	add	bx, [bp+inventorySlotNumber]
	mov	al, gs:party.inventory.itemFlags[bx]
	sub	ah, ah
	mov	bx, ax
	mov	al, itemEffectList[bx]
	and	ax, 0Fh
	cmp	ax, [bp+effectNumber]
	jnz	l_next

	; Effect found. Determine if the item is equipped or not.
	;
	mov	[bp+rval], 1
	mov	ax, [bp+inventorySlotNumber]
	dec	ax
	mov	gs:g_inventoryPackStart, ax
	mov	ax, [bp+slotNumber]
	mov	gs:g_inventoryPackTarget, ax
	mov	ax, charSize
	imul	[bp+slotNumber]
	mov	bx, ax
	add	bx, [bp+inventorySlotNumber]
	mov	al, gs:party.acBase[bx]
	and	al, 3
	cmp	al, 1
	jnz	short l_next

	sub	ax, ax
	mov	[bp+rval], ax
	jmp	short l_return

l_next:
	add	[bp+inventorySlotNumber], 3
	cmp	[bp+inventorySlotNumber], 24h
	jl	l_loop

l_return:
	mov	ax, [bp+rval]
	mov	sp, bp
	pop	bp
	retf
character_isEffectEquipped endp

; Attributes: bp-based frame

inventory_pack proc	far
	inventorySlotNumber= word ptr	-2

	push	bp
	mov	bp, sp
	mov	ax, 2
	call	someStackOperation
	push	si

	mov	ax, gs:g_inventoryPackStart
	mov	[bp+inventorySlotNumber], ax
l_packLoop:
	mov	ax, charSize
	imul	gs:g_inventoryPackTarget
	mov	si, ax
	add	si, [bp+inventorySlotNumber]
	mov	al, gs:(party.inventory.itemFlags+3)[si]
	mov	gs:party.inventory.itemFlags[si], al
	inc	[bp+inventorySlotNumber]
	cmp	[bp+inventorySlotNumber], 33
	jl	short l_packLoop

	mov	[bp+inventorySlotNumber], 33
l_clearLoop:
	mov	ax, charSize
	imul	gs:g_inventoryPackTarget
	mov	bx, ax
	add	bx, [bp+inventorySlotNumber]
	mov	gs:party.inventory.itemFlags[bx], 0
	inc	[bp+inventorySlotNumber]
	cmp	[bp+inventorySlotNumber], 36
	jl	short l_clearLoop

l_return:
	pop	si
	mov	sp, bp
	pop	bp
	retf
inventory_pack endp

; Attributes: bp-based frame

inventory_addItem proc far

	inventorySlotNumber= word ptr	-4
	itemEquipFlag= word ptr	-2
	slotNumber=	word ptr  6
	itemNumber= word ptr	 8
	itemFlags= byte ptr	 0Ah
	itemCount= byte ptr	 0Ch

	push	bp
	mov	bp, sp
	mov	ax, 4
	call	someStackOperation
	mov	ax, charSize
	imul	[bp+slotNumber]
	mov	bx, ax
	cmp	byte ptr gs:party._name[bx], 0
	jz	l_returnZero

	mov	[bp+inventorySlotNumber], 0
l_loop:
	mov	ax, charSize
	imul	[bp+slotNumber]
	mov	bx, ax
	add	bx, [bp+inventorySlotNumber]
	cmp	gs:party.inventory.itemNo[bx],	0
	jz	short l_foundEmptySlot

	add	[bp+inventorySlotNumber], 3
	cmp	[bp+inventorySlotNumber], 36
	jl	short l_loop
	jmp	l_returnZero

l_foundEmptySlot:
	mov	ax, charSize
	imul	[bp+slotNumber]
	mov	bx, ax
	mov	bl, gs:party.class[bx]
	sub	bh, bh
	mov	al, classEquipMask[bx]
	sub	ah, ah
	mov	bx, [bp+itemNumber]
	mov	cl, itemEquipMask[bx]
	sub	ch, ch
	test	ax, cx
	jz	short l_setUnequippable

	sub	ax, ax
	jmp	short l_setFlags

l_setUnequippable:
	mov	ax, itemFlag_unequipable

l_setFlags:
	mov	[bp+itemEquipFlag], ax
	mov	al, [bp+itemFlags]
	or	al, byte ptr [bp+itemEquipFlag]
	mov	cx, ax
	mov	ax, charSize
	imul	[bp+slotNumber]
	mov	bx, ax
	add	bx, [bp+inventorySlotNumber]
	mov	gs:party.inventory.itemFlags[bx], cl

	mov	al, byte ptr [bp+itemNumber]
	mov	cx, ax
	mov	ax, charSize
	imul	[bp+slotNumber]
	mov	bx, ax
	add	bx, [bp+inventorySlotNumber]
	mov	gs:party.inventory.itemNo[bx],	cl

	mov	al, [bp+itemCount]
	mov	cx, ax
	mov	ax, charSize
	imul	[bp+slotNumber]
	mov	bx, ax
	add	bx, [bp+inventorySlotNumber]
	mov	gs:party.inventory.itemCount[bx], cl

	mov	ax, 1
	jmp	short l_return

l_returnZero:
	sub	ax, ax

l_return:
	mov	sp, bp
	pop	bp
	retf
inventory_addItem endp

; This function	returns	1 if the item can be
; used.
; Attributes: bp-based frame

inventory_canBeUsed proc far

	itemNumber= word ptr	-2
	slotNumber=	word ptr  6
	inventorySlotNumber= word ptr	 8

	push	bp
	mov	bp, sp
	mov	ax, 2
	call	someStackOperation

	mov	ax, charSize
	imul	[bp+slotNumber]
	mov	bx, [bp+inventorySlotNumber]
	mov	cx, bx
	shl	bx, 1
	add	bx, cx
	add	bx, ax
	mov	al, gs:party.inventory.itemFlags[bx]
	and	al, 3
	cmp	al, 2
	jz	short l_returnZero

	mov	ax, charSize
	imul	[bp+slotNumber]
	mov	bx, [bp+inventorySlotNumber]
	mov	cx, bx
	shl	bx, 1
	add	bx, cx
	add	bx, ax
	mov	al, gs:party.inventory.itemNo[bx]
	sub	ah, ah
	mov	[bp+itemNumber], ax
	mov	bx, ax
	mov	al, itemSpellNo[bx]
	mov	g_curSpellNumber, ax
	cmp	ax, 0FFh
	jz	short l_returnZero

	mov	ax, charSize
	imul	[bp+slotNumber]
	mov	bx, [bp+inventorySlotNumber]
	mov	cx, bx
	shl	bx, 1
	add	bx, cx
	add	bx, ax
	cmp	gs:party.inventory.itemCount[bx], 0
	jz	short l_returnZero

	mov	bx, [bp+itemNumber]
	cmp	itemTypeList[bx], itType_quiver
	jnz	short l_returnOne

	mov	ax, itType_bow
	push	ax
	push	[bp+slotNumber]
	push	cs
	call	near ptr character_itemTypeCanBeUsed
	add	sp, 4
	jmp	short l_return

l_returnZero:
	sub	ax, ax
	jmp	short l_return

l_returnOne:
	mov	ax, 1

l_return:
	mov	sp, bp
	pop	bp
	retf
inventory_canBeUsed endp

; Attributes: bp-based frame

character_hasTypeEquipped proc far

	inventorySlotNumber= word ptr -2
	slotNumber= word ptr  6
	itemType= word ptr  8

	push	bp
	mov	bp, sp
	mov	ax, 2
	call	someStackOperation

	mov	[bp+inventorySlotNumber], 0
l_loop:
	mov	ax, charSize
	imul	[bp+slotNumber]
	mov	bx, ax
	add	bx, [bp+inventorySlotNumber]
	mov	al, gs:party.inventory.itemNo[bx]
	sub	ah, ah
	mov	bx, ax
	mov	al, itemTypeList[bx]
	and	ax, 0Fh
	cmp	ax, [bp+itemType]
	jnz	short l_next
	mov	ax, charSize
	imul	[bp+slotNumber]
	mov	bx, ax
	add	bx, [bp+inventorySlotNumber]
	mov	al, gs:party.inventory.itemFlags[bx]
	and	al, 3
	cmp	al, itemFlag_equipped
	jz	short l_returnOne

l_next:
	add	[bp+inventorySlotNumber], 3
	cmp	[bp+inventorySlotNumber], inventorySize
	jl	short l_loop

l_returnZero:
	sub	ax, ax
	jmp	short l_return

l_returnOne:
	mov	ax, 1

l_return:
	mov	sp, bp
	pop	bp
	retf
character_hasTypeEquipped endp

; Attributes: bp-based frame

character_itemTypeCanBeUsed proc far

	inventorySlotNumber= word ptr -2
	slotNumber= word ptr  6
	itemType= word ptr	 8

	push	bp
	mov	bp, sp
	mov	ax, 2
	call	someStackOperation

	mov	[bp+inventorySlotNumber], 0

l_loop:
	mov	ax, charSize
	imul	[bp+slotNumber]
	mov	bx, ax
	add	bx, [bp+inventorySlotNumber]
	mov	al, gs:party.inventory.itemNo[bx]
	sub	ah, ah
	mov	bx, ax
	mov	al, itemTypeList[bx]
	and	ax, 0Fh

	cmp	ax, [bp+itemType]
	jnz	short l_next

	cmp	[bp+itemType], itType_weapon
	jnz	short l_returnOne

	mov	ax, charSize
	imul	[bp+slotNumber]
	mov	bx, ax
	add	bx, [bp+inventorySlotNumber]
	mov	al, gs:party.inventory.itemFlags[bx]
	and	al, 3
	cmp	al, itemFlag_equipped
	jz	short l_returnOne

l_next:
	add	[bp+inventorySlotNumber], 3
	cmp	[bp+inventorySlotNumber], inventorySize
	jge	short l_returnZero
	jmp	short l_loop
	

l_returnOne:
	mov	ax, 1
	jmp	short l_return

l_returnZero:
	sub	ax, ax

l_return:
	mov	sp, bp
	pop	bp
	retf
character_itemTypeCanBeUsed endp

; This function	returns	the slot number	of an equipped
; item that matches the	type requested
; Attributes: bp-based frame

character_getTypeEquippedSlot proc far

	itemNumber= word ptr	-4
	inventorySlotNumber= word ptr -2
	slotNumber= word ptr  6
	itemType= word ptr  8

	push	bp
	mov	bp, sp
	mov	ax, 4
	call	someStackOperation

	mov	[bp+inventorySlotNumber], 0
l_loop:
	mov	ax, charSize
	imul	[bp+slotNumber]
	mov	bx, ax
	add	bx, [bp+inventorySlotNumber]
	mov	al, gs:party.inventory.itemNo[bx]
	sub	ah, ah
	mov	[bp+itemNumber], ax
	mov	bx, ax
	mov	al, itemTypeList[bx]
	and	ax, 0Fh
	cmp	ax, [bp+itemType]
	jnz	short l_next

	mov	ax, charSize
	imul	[bp+slotNumber]
	mov	bx, ax
	add	bx, [bp+inventorySlotNumber]
	mov	al, gs:party.inventory.itemFlags[bx]
	and	al, 3
	cmp	al, itemFlag_equipped
	jnz	short l_next

	mov	ax, [bp+itemNumber]
	jmp	short l_return

l_next:
	add	[bp+inventorySlotNumber], 3
	cmp	[bp+inventorySlotNumber], inventorySize
	jl	short l_loop

l_returnFail:
	mov	ax, 0FFFFh

l_return:
	mov	sp, bp
	pop	bp
	retf
character_getTypeEquippedSlot endp

; Attributes: bp-based frame

character_print proc far

	lineCount= word ptr	-8
	inKey= word ptr	-6
	mouseMask= word ptr	-4
	lastSlot= word ptr	-2
	slotNumber= word ptr	 6

	push	bp
	mov	bp, sp
	mov	ax, 8
	call	someStackOperation

	call	party_findEmptySlot
	mov	[bp+lastSlot], ax
	cmp	[bp+slotNumber], ax
	jge	l_return

	mov	ax, charSize
	imul	[bp+slotNumber]
	mov	bx, ax
	mov	al, gs:party.picIndex[bx]
	sub	ah, ah
	push	ax
	call	bigpic_drawPictureNumber
	add	sp, 2

	mov	ax, charSize
	imul	[bp+slotNumber]
	mov	bx, ax
	lea	ax, party._name[bx]
	mov	dx, seg	seg027
	push	dx
	push	ax
	call	setTitle
	add	sp, 4

l_statLoop:
	push	[bp+lastSlot]
	push	[bp+slotNumber]
	push	cs
	call	near ptr character_printStats
	add	sp, 2

	mov	[bp+mouseMask], 0
	mov	al, gs:txt_numLines
	sub	ah, ah
	sub	ax, 2
	mov	[bp+lineCount], ax

l_setMouseMask:
	mov	al, gs:txt_numLines
	sub	ah, ah
	cmp	ax, [bp+lineCount]
	jb	short l_getKey

	mov	bx, [bp+lineCount]
	shl	bx, 1
	mov	ax, bitMask16bit[bx]
	or	[bp+mouseMask], ax
	inc	[bp+lineCount]
	jmp	short l_setMouseMask

l_getKey:
	push	[bp+mouseMask]
	call	getKey
	add	sp, 2
	mov	[bp+inKey], ax
	cmp	ax, 'P'	
	jz	short l_poolGold
	mov	al, gs:txt_numLines
	sub	ah, ah
	add	ax, 10Ch
	cmp	ax, [bp+inKey]
	jnz	short l_checkTradeGold

l_poolGold:
	push	[bp+lastSlot]
	push	[bp+slotNumber]
	call	doPoolGold
	add	sp, 4
	jmp	short l_checkEscape

l_checkTradeGold:
	cmp	[bp+inKey], 'T'
	jz	short l_tradeGold
	mov	al, gs:txt_numLines
	sub	ah, ah
	add	ax, 10Dh
	cmp	ax, [bp+inKey]
	jnz	short l_checkEscape

l_tradeGold:
	push	[bp+lastSlot]
	push	[bp+slotNumber]
	push	cs
	call	near ptr character_getGoldTradee
	add	sp, 4

l_checkEscape:
	cmp	[bp+inKey], dosKeys_ESC
	jz	short l_printInventory
	mov	al, gs:txt_numLines
	sub	ah, ah
	add	ax, 10Eh
	cmp	ax, [bp+inKey]
	jnz	l_statLoop

l_printInventory:
	call	text_clear
	mov	ax, charSize
	imul	[bp+slotNumber]
	mov	bx, ax
	cmp	gs:party.class[bx], class_monster
	jnb	short l_printSpecialAbilities

	push	[bp+slotNumber]
	push	cs
	call	near ptr inventory_print
	add	sp, 2

l_printSpecialAbilities:
	push	[bp+slotNumber]
	push	cs
	call	near ptr character_hasSpecialAbilities
	add	sp, 4
	or	ax, ax
	jz	short l_return

	push	[bp+slotNumber]
	push	cs
	call	near ptr character_printAbilities
	add	sp, 2

l_return:
	mov	sp, bp
	pop	bp
	retf
character_print endp

; Attributes: bp-based frame

inventory_appendCharges proc far

	stringBuffer= dword ptr  6
	itemCount= word ptr	 0Ah

	push	bp
	mov	bp, sp

	lfs	bx, [bp+stringBuffer]
	inc	word ptr [bp+stringBuffer]
	mov	byte ptr fs:[bx], ' '

	lfs	bx, [bp+stringBuffer]
	inc	word ptr [bp+stringBuffer]
	mov	byte ptr fs:[bx], '#'

	mov	ax, 2
	push	ax
	mov	ax, [bp+itemCount]
	cwd
	push	dx
	push	ax
	push	word ptr [bp+stringBuffer+2]
	push	word ptr [bp+stringBuffer]
	call	itoa
	add	sp, 0Ah

	mov	sp, bp
	pop	bp
	retf
inventory_appendCharges endp

; Attributes: bp-based frame
;
; DWORD - var_42 & var_44
;
inventory_trade proc	far

	tradeeSlotNumber=	word ptr -4Ch
	var_4C=	word ptr -4Ah
	var_4A=	word ptr -48h
	var_46=	word ptr -46h
	var_44=	word ptr -44h
	var_42=	word ptr -42h
	stringBuffer=	word ptr -40h
	slotNumber= word ptr	 6
	inventorySlotNumber= word ptr	 8

	push	bp
	mov	bp, sp
	mov	ax, 4Ch
	call	someStackOperation

	mov	ax, offset s_whoDoes
	push	ds
	push	ax
	lea	ax, [bp+stringBuffer]
	push	ss
	push	ax
	call	strcat
	add	sp, 8
	mov	[bp+var_44], ax
	mov	[bp+var_42], dx
	mov	ax, charSize
	imul	[bp+slotNumber]
	mov	bx, ax
	lea	ax, party._name[bx]
	mov	dx, seg	seg027
	push	dx
	push	ax
	push	[bp+var_42]
	push	[bp+var_44]
	call	strcat
	add	sp, 8
	mov	[bp+var_44], ax
	mov	[bp+var_42], dx
	mov	ax, offset s_wantToGiveItTo
	push	ds
	push	ax
	push	dx
	push	[bp+var_44]
	call	strcat
	add	sp, 8
	mov	[bp+var_44], ax
	mov	[bp+var_42], dx
	lea	ax, [bp+stringBuffer]
	push	ss
	push	ax
	call	printString
	add	sp, 4
	call	readSlotNumber
	mov	[bp+tradeeSlotNumber], ax
	or	ax, ax
	jl	l_return

loc_183BD:
	mov	ax, [bp+inventorySlotNumber]
	mov	cx, ax
	shl	ax, 1
	add	ax, cx
	mov	[bp+var_4A], ax

	mov	ax, charSize
	imul	[bp+slotNumber]
	mov	bx, ax
	add	bx, [bp+var_4A]
	mov	al, gs:[bx+62h]
	sub	ah, ah
	and	ax, 0FCh
	mov	[bp+var_46], ax

	mov	ax, charSize
	imul	[bp+slotNumber]
	mov	bx, ax
	add	bx, [bp+var_4A]
	mov	al, gs:[bx+63h]
	sub	ah, ah
	mov	[bp+var_4C], ax

	mov	ax, charSize
	imul	[bp+slotNumber]
	mov	bx, ax
	add	bx, [bp+var_4A]
	mov	al, gs:[bx+64h]
	sub	ah, ah

	push	ax
	push	[bp+var_46]
	push	[bp+var_4C]
	push	[bp+tradeeSlotNumber]
	push	cs
	call	near ptr inventory_addItem
	add	sp, 8
	or	ax, ax
	jz	short l_noRoom

	push	[bp+inventorySlotNumber]
	push	[bp+slotNumber]
	push	cs
	call	near ptr inventory_discard
	add	sp, 4
	jmp	short l_return

l_noRoom:
	mov	ax, offset s_allFull
	push	ds
	push	ax
	call	printStringWClear
	add	sp, 4
	mov	ax, 4000h
	push	ax
	call	getKey
	add	sp, 2

l_return:
	mov	sp, bp
	pop	bp
	retf
inventory_trade endp

; Attributes: bp-based frame

inventory_discard proc far

	slotNumber= word ptr	 6
	inventorySlotNumber= word ptr	 8

	push	bp
	mov	bp, sp
	mov	ax, [bp+inventorySlotNumber]
	mov	cx, ax
	shl	ax, 1
	add	ax, cx
	mov	gs:g_inventoryPackStart, ax
	mov	ax, [bp+slotNumber]
	mov	gs:g_inventoryPackTarget, ax
	call	inventory_pack
	mov	sp, bp
	pop	bp
	retf
inventory_discard endp

; Attributes: bp-based frame

inventory_equip proc	far
	itemType= word ptr -4
	loopCounter= word ptr -2
	slotNumber= word ptr  6
	inventorySlotNumber=	word ptr  8

	push	bp
	mov	bp, sp
	mov	ax, 4
	call	someStackOperation

	mov	ax, charSize
	imul	[bp+slotNumber]
	mov	bx, [bp+inventorySlotNumber]
	mov	cx, bx
	shl	bx, 1
	add	bx, cx
	add	bx, ax
	mov	al, gs:party.inventory.itemNo[bx]
	sub	ah, ah

	mov	bx, ax
	mov	al, itemTypeList[bx]
	and	ax, 0Fh
	mov	[bp+itemType], ax
	or	ax, ax
	jz	l_return

	mov	ax, charSize
	imul	[bp+slotNumber]
	mov	cx, bx
	shl	bx, 1
	add	bx, cx
	add	bx, ax
	and	gs:party.inventory.itemFlags[bx], 0FCh

	mov	ax, charSize
	imul	[bp+slotNumber]
	mov	bx, [bp+inventorySlotNumber]
	mov	cx, bx
	shl	bx, 1
	add	bx, cx
	add	bx, ax
	or	gs:party.inventory.itemFlags[bx], itemFlag_equipped

	mov	[bp+loopCounter], 0

l_unequipLoop:
	mov	ax, [bp+inventorySlotNumber]
	mov	cx, ax
	shl	ax, 1
	add	ax, cx
	cmp	ax, [bp+loopCounter]
	jz	short l_unequipNext

	mov	ax, charSize
	imul	[bp+slotNumber]
	mov	bx, ax
	add	bx, [bp+loopCounter]
	mov	al, gs:party.inventory.itemNo[bx]
	sub	ah, ah
	mov	bx, ax
	mov	al, itemTypeList[bx]
	and	ax, 0Fh
	cmp	ax, [bp+itemType]
	jnz	short l_unequipNext
	mov	ax, charSize
	imul	[bp+slotNumber]
	mov	bx, ax
	add	bx, [bp+loopCounter]
	mov	al, gs:party.inventory.itemFlags[bx]
	and	al, 3
	cmp	al, 2
	jz	short l_unequipNext
	mov	ax, charSize
	imul	[bp+slotNumber]
	mov	bx, ax
	add	bx, [bp+loopCounter]
	and	gs:party.inventory.itemFlags[bx], 0FCh

l_unequipNext:
	add	[bp+loopCounter], 3
	cmp	[bp+loopCounter], 36
	jl	short l_unequipLoop

l_return:
	mov	sp, bp
	pop	bp
	retf
inventory_equip endp

; Attributes: bp-based frame

inventory_unequip proc far

	slotNumber= word ptr	 6
	inventorySlotNumber= word ptr	 8

	push	bp
	mov	bp, sp
	mov	ax, charSize
	imul	[bp+slotNumber]
	mov	bx, [bp+inventorySlotNumber]
	mov	cx, bx
	shl	bx, 1
	add	bx, cx
	add	bx, ax
	and	gs:party.inventory.itemFlags[bx], 0FCh

	mov	ax, charSize
	imul	[bp+slotNumber]
	mov	bx, [bp+inventorySlotNumber]
	mov	cx, bx
	shl	bx, 1
	add	bx, cx
	add	bx, ax
	mov	al, gs:party.inventory.itemNo[bx]
	sub	ah, ah
	mov	bx, ax
	mov	al, itemTypeList[bx]
	and	al, 0Fh
	cmp	al, itType_instrument
	jnz	short l_return

	push	[bp+slotNumber]
	call	song_stopPlaying
	add	sp, 2

l_return:
	mov	sp, bp
	pop	bp
	retf
inventory_unequip endp

; Attributes: bp-based frame

inventory_identify proc far

	inventoryIndex=	word ptr -46h
	stringBuffer=	word ptr -44h
	stringBufferP= dword ptr -4
	slotNumber= word ptr	 6
	inventorySlotNumber= word ptr	 8

	push	bp
	mov	bp, sp
	mov	ax, 46h
	call	someStackOperation

	mov	ax, charSize
	imul	[bp+slotNumber]
	mov	bx, ax
	test	gs:party.status[bx], 1Ch
	jnz	l_return

loc_185D7:
	mov	ax, charSize
	imul	[bp+slotNumber]
	mov	bx, ax
	lea	ax, party._name[bx]
	mov	dx, seg	seg027
	push	dx
	push	ax
	lea	ax, [bp+stringBuffer]
	push	ss
	push	ax
	call	strcat
	add	sp, 8
	mov	word ptr [bp+stringBufferP], ax
	mov	word ptr [bp+stringBufferP+2], dx

	mov	ax, [bp+inventorySlotNumber]
	mov	cx, ax
	shl	ax, 1
	add	ax, cx
	mov	[bp+inventoryIndex], ax

	call	random
	mov	cx, ax

	mov	ax, charSize
	imul	[bp+slotNumber]
	mov	bx, ax
	cmp	gs:(party.specAbil+1)[bx], cl
	jbe	short loc_18634

	mov	ax, charSize
	imul	[bp+slotNumber]
	mov	bx, ax
	add	bx, [bp+inventoryIndex]
	and	gs:party.inventory.itemFlags[bx], 3Fh
	jmp	short loc_18645

loc_18634:
	mov	ax, charSize
	imul	[bp+slotNumber]
	mov	bx, ax
	add	bx, [bp+inventoryIndex]
	or	gs:party.inventory.itemFlags[bx], 40h

loc_18645:
	mov	ax, charSize
	imul	[bp+slotNumber]
	mov	bx, ax
	add	bx, [bp+inventoryIndex]
	cmp	gs:party.inventory.itemFlags[bx], 80h
	jb	short loc_1865D
	mov	ax, 1
	jmp	short loc_1865F
loc_1865D:
	sub	ax, ax
loc_1865F:
	push	ax
	push	word ptr [bp+stringBufferP+2]
	push	word ptr [bp+stringBufferP]
	mov	ax, offset s_triesToIdentify
	push	ds
	push	ax
	call	str_pluralize
	add	sp, 0Ah
	mov	word ptr [bp+stringBufferP], ax
	mov	word ptr [bp+stringBufferP+2], dx

	lfs	bx, [bp+stringBufferP]
	mov	byte ptr fs:[bx], 0

	lea	ax, [bp+stringBuffer]
	push	ss
	push	ax
	call	printString
	add	sp, 4
	mov	ax, 4000h
	push	ax
	call	getKey
	add	sp, 2

l_return:
	mov	sp, bp
	pop	bp
	retf
inventory_identify endp

; Attributes: bp-based frame

inventory_print proc far

	containerNumber= word ptr -114h
	inventoryListBuffer= word ptr -112h
	inventoryActionNumber=	word ptr -52h
	inventoryCount=	word ptr -50h
	mouseLineCount=	word ptr -4Eh
	inventoryListP=	word ptr -4Ch
	inventorySlotNumber=	word ptr -1Ch
	optionCharacters=	word ptr -1Ah
	inventorySlotOptions=	word ptr -14h
	inKey= word ptr	-0Eh
	optionMouse= word ptr	-0Ch
	slotNumber= word ptr	 6

	push	bp
	mov	bp, sp
	mov	ax, 114h
	call	someStackOperation
	push	si

l_inventoryLoop:
	lea	ax, [bp+inventoryListP]
	push	ss
	push	ax
	lea	ax, [bp+inventoryListBuffer]
	push	ss
	push	ax
	push	[bp+slotNumber]
	push	cs
	call	near ptr inventory_getItemList
	add	sp, 0Ah
	mov	[bp+inventoryCount], ax
	or	ax, ax
	jnz	short l_hasInventory

	mov	ax, offset s_pocketsAreEmpty
	push	ds
	push	ax
	call	printString
	add	sp, 4
	mov	ax, 4000h
	push	ax
	call	getKey
	add	sp, 2
	jmp	l_return

l_hasInventory:
	push	[bp+inventoryCount]
	lea	ax, [bp+inventoryListP]
	push	ss
	push	ax
	mov	ax, offset s_inventory
	push	ds
	push	ax
	call	text_scrollingWindow
	add	sp, 0Ah
	mov	[bp+inventorySlotNumber], ax

	call	text_clear
	cmp	[bp+inventorySlotNumber], 0
	jl	l_return

	push	[bp+inventorySlotNumber]
	push	[bp+slotNumber]
	lea	ax, [bp+inventorySlotOptions]
	push	ss
	push	ax
	push	cs
	call	near ptr inventory_getOptions
	add	sp, 4
	call	text_clear
	lea	ax, [bp+optionMouse]
	push	ss
	push	ax
	lea	ax, [bp+optionCharacters]
	push	ss
	push	ax
	lea	ax, [bp+inventorySlotOptions]
	push	ss
	push	ax
	mov	ax, offset s_inventoryVarString
	push	ds
	push	ax
	call	printVarString
	add	sp, 10h
	mov	[bp+mouseLineCount], ax

	mov	ax, charSize
	imul	[bp+slotNumber]
	mov	bx, [bp+inventorySlotNumber]
	mov	cx, bx
	shl	bx, 1
	add	bx, cx
	add	bx, ax
	cmp	gs:party.inventory.itemNo[bx],	76h 
	jz	short l_isContainer

	mov	ax, charSize
	imul	[bp+slotNumber]
	mov	bx, cx
	shl	bx, 1
	add	bx, cx
	add	bx, ax
	cmp	gs:party.inventory.itemNo[bx],	7Dh 
	jnz	short l_inputLoop

l_isContainer:
	mov	ax, charSize
	imul	[bp+slotNumber]
	mov	bx, [bp+inventorySlotNumber]
	mov	cx, bx
	shl	bx, 1
	add	bx, cx
	add	bx, ax
	mov	al, gs:party.inventory.itemFlags[bx]
	sub	ah, ah
	shr	ax, 1
	shr	ax, 1
	and	ax, 0Fh
	mov	[bp+containerNumber], ax
	mov	ax, offset s_itsFilledWith
	push	ds
	push	ax
	call	printString
	add	sp, 4
	mov	bx, [bp+containerNumber]
	shl	bx, 1
	shl	bx, 1
	push	word ptr (wineskinString+2)[bx]
	push	word ptr wineskinString[bx]
	call	printString
	add	sp, 4

l_inputLoop:
	push	[bp+mouseLineCount]
	call	getKey
	add	sp, 2
	mov	[bp+inKey], ax
	cmp	ax, dosKeys_ESC
	jz	l_inventoryLoop

	mov	[bp+inventoryActionNumber], 0
l_actionLoop:
	mov	si, [bp+inventoryActionNumber]
	cmp	byte ptr [bp+si+optionCharacters], 0
	jz	short l_inputLoop

	mov	al, byte ptr [bp+si+optionCharacters]
	cbw
	cmp	ax, [bp+inKey]
	jz	short l_performAction

	shl	si, 1
	mov	ax, [bp+inKey]
	cmp	[bp+si+optionMouse], ax
	jnz	short l_actionLoopNext

l_performAction:
	call	text_clear
	push	[bp+inventorySlotNumber]
	push	[bp+slotNumber]
	mov	bx, [bp+inventoryActionNumber]
	shl	bx, 1
	shl	bx, 1
	call	g_inventoryActionFunctions[bx]
	add	sp, 4
	mov	byte ptr g_printPartyFlag,	0
	call	party_print
	jmp	l_inventoryLoop

l_actionLoopNext:
	inc	[bp+inventoryActionNumber]
	jmp	short l_actionLoop

l_return:
	pop	si
	mov	sp, bp
	pop	bp
	retf
inventory_print endp

; Populate optionList with 1s for inventory actions
;
; 0 - Trade
; 1 - Discard
; 2 - Equip
; 3 - Unequip
; 4 - Identify
;
; Attributes: bp-based frame

inventory_getOptions proc far

	loopCounter= word ptr	-4
	savedItemFlags= word ptr	-2
	optionList= dword ptr  6
	slotNumber= word ptr	 0Ah
	inventorySlotNumber= word ptr	 0Ch

	push	bp
	mov	bp, sp
	mov	ax, 4
	call	someStackOperation
	push	si

	mov	ax, charSize
	imul	[bp+slotNumber]
	mov	bx, [bp+inventorySlotNumber]
	mov	cx, bx
	shl	bx, 1
	add	bx, cx
	add	bx, ax
	mov	al, gs:party.inventory.itemFlags[bx]
	sub	ah, ah
	mov	[bp+savedItemFlags], ax
	mov	al, byte ptr [bp+savedItemFlags]
	and	al, 3
	cmp	al, 1
	jnz	short l_setUnequipFalse
	mov	al, 1
	jmp	short l_setUnequip
l_setUnequipFalse:
	sub	al, al
l_setUnequip:
	lfs	bx, [bp+optionList]
	mov	fs:[bx+3], al

	; This loop sets: trade, discard and equip
	; to 0 if unequip is set above
	;
	mov	[bp+loopCounter], 0
l_loop:
	lfs	bx, [bp+optionList]
	cmp	byte ptr fs:[bx+3], 1
	sbb	ax, ax
	neg	ax
	mov	bx, [bp+loopCounter]
	mov	si, word ptr [bp+optionList]
	mov	fs:[bx+si], al
	inc	[bp+loopCounter]
	cmp	[bp+loopCounter], 3
	jl	short l_loop

	lfs	bx, [bp+optionList]
	mov	byte ptr fs:[bx+4], 0		; Initialze identify to false

	lfs	bx, [bp+optionList]
	cmp	byte ptr fs:[bx], 0
	jz	short l_return

	; Set Equip to false if item is unequippable
	mov	al, byte ptr [bp+savedItemFlags]
	and	al, 3
	cmp	al, 2
	jnz	short l_setIdentify
	mov	byte ptr fs:[bx+2], 0

l_setIdentify:
	mov	al, byte ptr [bp+savedItemFlags]
	and	al, 0C0h
	cmp	al, 80h
	jnz	short l_return

	mov	ax, charSize
	imul	[bp+slotNumber]
	mov	bx, ax
	cmp	gs:party.class[bx], class_rogue

	jnz	short l_return
	lfs	bx, [bp+optionList]
	mov	byte ptr fs:[bx+4], 1

l_return:
	pop	si
	mov	sp, bp
	pop	bp
	retf
inventory_getOptions endp

; Attributes: bp-based frame

inventory_getItemList proc far

	itemNumber= word ptr	-0Ah
	inventoryCount= word ptr	-8
	inventoryLength= word ptr	-6
	inventorySlotNumber= word ptr	-4
	savedItemFlags= word ptr	-2
	slotNumber= word ptr	 6
	listBuffer= dword ptr  8
	listBufferP= dword ptr  0Ch

	push	bp
	mov	bp, sp
	mov	ax, 0Ah
	call	someStackOperation
	push	si

	mov	[bp+inventoryLength], 0
	mov	[bp+inventorySlotNumber], 0

l_loop:
	mov	ax, charSize
	imul	[bp+slotNumber]
	mov	bx, ax
	add	bx, [bp+inventorySlotNumber]
	cmp	gs:party.inventory.itemNo[bx],	0
	jz	l_return

	mov	ax, charSize
	imul	[bp+slotNumber]
	mov	bx, ax
	add	bx, [bp+inventorySlotNumber]
	mov	al, gs:party.inventory.itemFlags[bx]
	sub	ah, ah
	mov	[bp+savedItemFlags], ax

	mov	bx, [bp+inventoryLength]
	inc	[bp+inventoryLength]
	shl	bx, 1
	shl	bx, 1
	lfs	si, [bp+listBufferP]
	mov	ax, word ptr [bp+listBuffer]
	mov	dx, word ptr [bp+listBuffer+2]
	mov	fs:[bx+si], ax
	mov	fs:[bx+si+2], dx
	cmp	[bp+savedItemFlags], itemFlag_unidentified
	jl	short l_itemIdentified

	test	byte ptr [bp+savedItemFlags], 3
	jnz	short l_itemIdentified

	; Set flags to 3 which is '?' for unidentified
	mov	[bp+savedItemFlags], 3

l_itemIdentified:
	lfs	bx, [bp+listBuffer]
	inc	word ptr [bp+listBuffer]
	mov	si, [bp+savedItemFlags]
	and	si, 3
	mov	al, g_itemFlagCharacters[si]
	mov	fs:[bx], al

	mov	ax, charSize
	imul	[bp+slotNumber]
	mov	bx, ax
	add	bx, [bp+inventorySlotNumber]
	mov	al, gs:party.inventory.itemNo[bx]
	sub	ah, ah
	mov	[bp+itemNumber], ax

	mov	ax, charSize
	imul	[bp+slotNumber]
	mov	bx, ax
	add	bx, [bp+inventorySlotNumber]
	mov	al, gs:party.inventory.itemFlags[bx]
	sub	ah, ah
	push	ax
	push	[bp+itemNumber]
	push	word ptr [bp+listBuffer+2]
	push	word ptr [bp+listBuffer]
	push	cs
	call	near ptr inventory_getItemName
	add	sp, 8
	mov	word ptr [bp+listBuffer], ax
	mov	word ptr [bp+listBuffer+2], dx

	mov	ax, charSize
	imul	[bp+slotNumber]
	mov	bx, ax
	add	bx, [bp+inventorySlotNumber]
	mov	al, gs:party.inventory.itemCount[bx]
	sub	ah, ah
	mov	[bp+inventoryCount], ax
	cmp	ax, 0FFh
	jz	short l_terminateString
	cmp	ax, 1
	jz	short l_addCharge
	push	ax
	push	word ptr [bp+listBuffer+2]
	push	word ptr [bp+listBuffer]
	push	cs
	call	near ptr inventory_appendCharges
	add	sp, 6
	mov	word ptr [bp+listBuffer], ax
	mov	word ptr [bp+listBuffer+2], dx
	jmp	short l_terminateString

l_addCharge:
	mov	bx, [bp+itemNumber]
	cmp	g_itemBaseCount[bx],	1
	jz	short l_terminateString
	push	[bp+inventoryCount]
	push	word ptr [bp+listBuffer+2]
	push	word ptr [bp+listBuffer]
	push	cs
	call	near ptr inventory_appendCharges
	add	sp, 6
	mov	word ptr [bp+listBuffer], ax
	mov	word ptr [bp+listBuffer+2], dx

l_terminateString:
	lfs	bx, [bp+listBuffer]
	inc	word ptr [bp+listBuffer]
	mov	byte ptr fs:[bx], 0

l_next:
	add	[bp+inventorySlotNumber], 3
	cmp	[bp+inventorySlotNumber], inventorySize
	jl	l_loop

l_return:
	mov	ax, [bp+inventoryLength]
	pop	si
	mov	sp, bp
	pop	bp
	retf
inventory_getItemList endp

; Attributes: bp-based frame
;
; DWORD - arg_0 & arg_2

inventory_getItemName proc far

	arg_0= word ptr	 6
	arg_2= word ptr	 8
	itemNumber=	word ptr  0Ah
	itemFlags= byte	ptr  0Ch

	push	bp
	mov	bp, sp

	test	[bp+itemFlags],	itemFlag_unidentified
	jz	short l_identifiedItem

	mov	bx, [bp+itemNumber]
	mov	al, itemTypeList[bx]
	sub	ah, ah
	and	ax, 0Fh
	mov	bx, ax
	shl	bx, 1
	shl	bx, 1
	push	word ptr (g_itemGenericStringList+2)[bx]
	push	word ptr g_itemGenericStringList[bx]
	push	[bp+arg_2]
	push	[bp+arg_0]
	call	strcat
	add	sp, 8
	jmp	short l_return

l_identifiedItem:
	mov	bx, [bp+itemNumber]
	shl	bx, 1
	shl	bx, 1
	push	word ptr (g_itemStringList+2)[bx]
	push	word ptr g_itemStringList[bx]
	push	[bp+arg_2]
	push	[bp+arg_0]
	call	strcat
	add	sp, 8

l_return:
	mov	sp, bp
	pop	bp
	retf
inventory_getItemName endp

; Attributes: bp-based frame

character_printStats proc far

	stringBuffer=	word ptr -0DAh
	loopCounter=	word ptr -26h
	attributeList=	word ptr -24h
	stringBufferP=	dword ptr -1Ah
	attributeP=	dword ptr -16h
	slotNumber= word ptr	 6

	push	bp
	mov	bp, sp
	mov	ax, 0DAh
	call	someStackOperation
	push	si

	call	text_clear

	mov	ax, charSize
	imul	[bp+slotNumber]
	mov	bx, ax
	lea	ax, party._name[bx]
	mov	dx, seg	seg027
	push	dx
	push	ax
	lea	ax, [bp+stringBuffer]
	push	ss
	push	ax
	call	strcat
	add	sp, 8
	mov	word ptr [bp+stringBufferP], ax
	mov	word ptr [bp+stringBufferP+2], dx

	mov	ax, charSize
	imul	[bp+slotNumber]
	mov	bx, ax
	mov	ax, 1
	cmp	gs:party.class[bx], class_illusion
	jnz	short l_setArticle
	sub	ax, ax

l_setArticle:
	push	ax
	push	word ptr [bp+stringBufferP+2]
	push	word ptr [bp+stringBufferP]
	mov	ax, offset s_isAn
	push	ds
	push	ax
	call	str_pluralize
	add	sp, 0Ah
	mov	word ptr [bp+stringBufferP], ax
	mov	word ptr [bp+stringBufferP+2], dx

	lfs	bx, [bp+stringBufferP]
	mov	byte ptr fs:[bx], ' '
	mov	ax, charSize
	imul	[bp+slotNumber]
	mov	bx, ax
	cmp	gs:party.class[bx], class_monster
	jnb	l_skipCharacterDescription

	mov	ax, offset s_level
	push	ds
	push	ax
	push	word ptr [bp+stringBufferP+2]
	push	word ptr [bp+stringBufferP]
	call	strcat
	add	sp, 8
	mov	word ptr [bp+stringBufferP], ax
	mov	word ptr [bp+stringBufferP+2], dx

	mov	ax, 3
	push	ax
	mov	ax, charSize
	imul	[bp+slotNumber]
	mov	bx, ax
	sub	ax, ax
	push	ax
	push	gs:party.level[bx]
	push	word ptr [bp+stringBufferP+2]
	push	word ptr [bp+stringBufferP]
	call	itoa
	add	sp, 0Ah
	mov	word ptr [bp+stringBufferP], ax
	mov	word ptr [bp+stringBufferP+2], dx

	lfs	bx, [bp+stringBufferP]
	inc	word ptr [bp+stringBufferP]
	mov	byte ptr fs:[bx], ' '

	mov	ax, charSize
	imul	[bp+slotNumber]
	mov	bx, ax
	mov	bl, gs:party.gender[bx]
	sub	bh, bh
	shl	bx, 1
	shl	bx, 1
	push	word ptr (s_genderString+2)[bx]
	push	word ptr s_genderString[bx]
	push	word ptr [bp+stringBufferP+2]
	push	word ptr [bp+stringBufferP]
	call	strcat
	add	sp, 8
	mov	word ptr [bp+stringBufferP], ax
	mov	word ptr [bp+stringBufferP+2], dx

	lfs	bx, [bp+stringBufferP]
	inc	word ptr [bp+stringBufferP]
	mov	byte ptr fs:[bx], ' '

	mov	ax, charSize
	imul	[bp+slotNumber]
	mov	bx, ax
	mov	bl, gs:party.race[bx]
	sub	bh, bh
	shl	bx, 1
	shl	bx, 1
	push	word ptr (g_raceString+2)[bx]
	push	word ptr g_raceString[bx]
	push	word ptr [bp+stringBufferP+2]
	push	word ptr [bp+stringBufferP]
	call	strcat
	add	sp, 8
	mov	word ptr [bp+stringBufferP], ax
	mov	word ptr [bp+stringBufferP+2], dx

	lfs	bx, [bp+stringBufferP]
	inc	word ptr [bp+stringBufferP]
	mov	byte ptr fs:[bx], ' '

l_skipCharacterDescription:
	mov	ax, charSize
	imul	[bp+slotNumber]
	mov	bx, ax
	mov	bl, gs:party.class[bx]
	sub	bh, bh
	shl	bx, 1
	shl	bx, 1
	push	word ptr (g_classString+2)[bx]
	push	word ptr g_classString[bx]
	push	word ptr [bp+stringBufferP+2]
	push	word ptr [bp+stringBufferP]
	call	strcat
	add	sp, 8
	mov	word ptr [bp+stringBufferP], ax
	mov	word ptr [bp+stringBufferP+2], dx

	mov	ax, charSize
	imul	[bp+slotNumber]
	mov	bx, ax
	cmp	gs:party.class[bx], class_monster
	jnb	short l_skipAttributes

	mov	ax, charSize
	imul	[bp+slotNumber]
	add	ax, offset party.strength
	mov	word ptr [bp+attributeP], ax
	mov	word ptr [bp+attributeP+2],	seg seg027

	mov	[bp+loopCounter], 0
l_attributeLoop:
	mov	bx, [bp+loopCounter]
	lfs	si, [bp+attributeP]
	mov	al, fs:[bx+si]
	sub	ah, ah
	mov	si, bx
	shl	si, 1
	mov	[bp+si+attributeList],	ax
	inc	[bp+loopCounter]
	cmp	[bp+loopCounter], 5
	jl	short l_attributeLoop

	mov	ax, charSize
	imul	[bp+slotNumber]
	mov	bx, ax
	mov	ax, gs:party.currentHP[bx]
	lfs	bx, [bp+stringBufferP]
	inc	word ptr [bp+stringBufferP]
	mov	byte ptr fs:[bx], 0Ah

	mov	ax, 5
	push	ax
	push	word ptr [bp+stringBufferP+2]
	push	word ptr [bp+stringBufferP]
	lea	ax, [bp+attributeList]
	push	ss
	push	ax
	push	cs
	call	near ptr getAttributeString
	add	sp, 0Ah

l_skipAttributes:
	lea	ax, [bp+stringBuffer]
	push	ss
	push	ax
	call	printString
	add	sp, 4

	mov	ax, charSize
	imul	[bp+slotNumber]
	mov	bx, ax
	cmp	gs:party.class[bx], class_monster
	jnb	short l_skipExperience

	lea	ax, [bp+stringBuffer]
	push	ss
	push	ax
	mov	ax, charSize
	imul	[bp+slotNumber]
	mov	bx, ax
	sub	ax, ax
	push	ax
	push	gs:party.maxSppt[bx]
	mov	ax, offset s_spellPoints
	push	ds
	push	ax
	push	cs
	call	near ptr printNumberAndString
	add	sp, 0Ch

	lea	ax, [bp+stringBuffer]
	push	ss
	push	ax
	mov	ax, charSize
	imul	[bp+slotNumber]
	mov	bx, ax
	push	word ptr gs:(party.experience+2)[bx]
	push	word ptr gs:party.experience[bx]
	mov	ax, offset s_expr
	push	ds
	push	ax
	push	cs
	call	near ptr printNumberAndString
	add	sp, 0Ch

l_skipExperience:
	lea	ax, [bp+stringBuffer]
	push	ss
	push	ax
	mov	ax, charSize
	imul	[bp+slotNumber]
	mov	bx, ax
	push	word ptr gs:(party.gold+2)[bx]
	push	word ptr gs:party.gold[bx]
	mov	ax, offset s_gold
	push	ds
	push	ax
	push	cs
	call	near ptr printNumberAndString
	add	sp, 0Ch

	mov	ax, offset s_poolGold
	push	ds
	push	ax
	call	printString
	add	sp, 4
	mov	ax, offset s_escToContinue
	push	ds
	push	ax
	call	printString
	add	sp, 4

	pop	si
	mov	sp, bp
	pop	bp
	retf
character_printStats endp

; Attributes: bp-based frame
;
; DWORD - arg_0 & arg_2, arg_8 & arg_A

printNumberAndString proc far

	stringBufferP= dword ptr -4
	arg_0= word ptr	 6
	arg_2= word ptr	 8
	arg_4= word ptr	 0Ah
	arg_6= word ptr	 0Ch
	arg_8= word ptr	 0Eh
	arg_A= word ptr	 10h

	push	bp
	mov	bp, sp
	mov	ax, 4
	call	someStackOperation

	push	[bp+arg_2]
	push	[bp+arg_0]
	push	[bp+arg_A]
	push	[bp+arg_8]
	call	strcat
	add	sp, 8
	mov	word ptr [bp+stringBufferP], ax
	mov	word ptr [bp+stringBufferP+2], dx

	sub	ax, ax
	push	ax
	push	[bp+arg_6]
	push	[bp+arg_4]
	push	dx
	push	word ptr [bp+stringBufferP]
	call	itoa
	add	sp, 0Ah
	mov	word ptr [bp+stringBufferP], ax
	mov	word ptr [bp+stringBufferP+2], dx

	lfs	bx, [bp+stringBufferP]
	mov	byte ptr fs:[bx], 0
	push	[bp+arg_A]
	push	[bp+arg_8]
	call	printString
	add	sp, 4

	mov	sp, bp
	pop	bp
	retf
printNumberAndString endp

; Attributes: bp-based frame
getAttributeString proc	far

	loopCounter= word ptr	-8
	attributeValue= word ptr	-6
	attributeStringP= dword ptr -4
	attributeList= dword ptr  6
	stringBuffer= dword ptr  0Ah
	attributeCount= word ptr	 0Eh

	push	bp
	mov	bp, sp
	mov	ax, 8
	call	someStackOperation

	mov	ax, offset s_attributeAbbreviations
	mov	word ptr [bp+attributeStringP], ax
	mov	word ptr [bp+attributeStringP+2], ds
	mov	[bp+loopCounter], 0

l_loop:
	mov	ax, [bp+attributeCount]
	cmp	[bp+loopCounter], ax
	jge	l_return

	lfs	bx, [bp+attributeStringP]
	inc	word ptr [bp+attributeStringP]
	mov	al, fs:[bx]
	lfs	bx, [bp+stringBuffer]
	inc	word ptr [bp+stringBuffer]
	mov	fs:[bx], al

	lfs	bx, [bp+attributeStringP]
	inc	word ptr [bp+attributeStringP]
	mov	al, fs:[bx]
	lfs	bx, [bp+stringBuffer]
	inc	word ptr [bp+stringBuffer]
	mov	fs:[bx], al

	lfs	bx, [bp+stringBuffer]
	inc	word ptr [bp+stringBuffer]
	mov	byte ptr fs:[bx], ':'

	lfs	bx, [bp+attributeList]
	add	word ptr [bp+attributeList], 2
	mov	ax, fs:[bx]
	mov	[bp+attributeValue], ax
	cmp	ax, 99	
	jle	short l_maxNinetyNine
	mov	[bp+attributeValue], 99

l_maxNinetyNine:
	cmp	[bp+attributeValue], 10
	jge	short l_skipOneDigitCheck

	; Add a space for one digit numbers
	lfs	bx, [bp+stringBuffer]
	inc	word ptr [bp+stringBuffer]
	mov	byte ptr fs:[bx], ' ' 

l_skipOneDigitCheck:
	mov	ax, 2
	push	ax
	mov	ax, [bp+attributeValue]
	cwd
	push	dx
	push	ax
	push	word ptr [bp+stringBuffer+2]
	push	word ptr [bp+stringBuffer]
	call	itoa
	add	sp, 0Ah
	mov	word ptr [bp+stringBuffer], ax
	mov	word ptr [bp+stringBuffer+2], dx

	lfs	bx, [bp+stringBuffer]
	inc	word ptr [bp+stringBuffer]
	mov	byte ptr fs:[bx], ' '
	inc	[bp+loopCounter]
	jmp	l_loop

l_return:
	lfs	bx, [bp+stringBuffer]
	mov	byte ptr fs:[bx], 0
	mov	sp, bp
	pop	bp
	retf
getAttributeString endp

; Attributes: bp-based frame
;
; DWORD - var_4 & var_6

character_getGoldTradee proc far

	var_6= word ptr	-6
	var_4= word ptr	-4
	tradeeSlotNumber= word ptr	-2
	slotNumber= word ptr	 6
	lastSlotNumber= word ptr	 8

	push	bp
	mov	bp, sp
	mov	ax, 6
	call	someStackOperation
	push	si

	call	text_clear
	mov	ax, offset s_tradeGoldToWhom
	push	ds
	push	ax
	call	printString
	add	sp, 4
	call	readSlotNumber
	mov	[bp+tradeeSlotNumber], ax
	or	ax, ax
	jl	l_return

	mov	ax, [bp+lastSlotNumber]
	cmp	[bp+tradeeSlotNumber], ax
	jg	l_return

	call	text_clear
	mov	ax, offset s_howMuchGoldToTrade
	push	ds
	push	ax
	call	printString
	add	sp, 4
	call	readGold
	mov	[bp+var_6], ax
	mov	[bp+var_4], dx
	or	dx, ax
	jz	short l_return

	push	[bp+var_4]
	push	[bp+var_6]
	push	[bp+slotNumber]
	call	character_removeGold
	add	sp, 6
	or	ax, ax
	jnz	short l_enoughGold

	call	text_clear
	mov	ax, offset s_notEnoughGold
	push	ds
	push	ax
	call	printString
	add	sp, 4
	jmp	short l_return

l_enoughGold:
	mov	ax, [bp+var_6]
	mov	dx, [bp+var_4]
	mov	cx, ax
	mov	bx, dx
	mov	ax, charSize
	imul	[bp+tradeeSlotNumber]
	mov	si, ax
	add	word ptr gs:party.gold[si], cx
	adc	word ptr gs:(party.gold+2)[si], bx
	call	text_clear
	mov	ax, offset s_done
	push	ds
	push	ax
	call	printString
	add	sp, 4
	mov	ax, 4000h
	push	ax
	call	getKey
	add	sp, 2
l_return:
	pop	si
	mov	sp, bp
	pop	bp
	retf
character_getGoldTradee endp

; Attributes: bp-based frame
; 
; DWORD - var_204 & var_206

character_printAbilities proc	far

	var_206= word ptr -204h
	var_204= word ptr -202h
	knownSpellCount= word ptr	-4
	currentSpellNumber= word ptr	-2
	slotNumber= word ptr	 6

	push	bp
	mov	bp, sp
	mov	ax, 206h
	call	someStackOperation
	push	si

	mov	ax, charSize
	imul	[bp+slotNumber]
	mov	bx, ax
	mov	al, gs:[bx+5Bh]
	sub	ah, ah

	cmp	ax, class_rogue
	jz	l_printRogue

	cmp	ax, class_bard
	jz	l_printBard

	cmp	ax, class_hunter
	jz	l_printHunter

	jmp	l_printSpells

l_printRogue:
	mov	ax, offset s_rogueAbilities
	push	ds
	push	ax
	call	printString
	add	sp, 4

	mov	ax, charSize
	imul	[bp+slotNumber]
	mov	bx, ax
	mov	al, gs:party.specAbil[bx]
	sub	ah, ah
	push	ax
	mov	ax, offset s_disarmTraps
	push	ds
	push	ax
	call	printThiefAbilValues
	add	sp, 6

	mov	ax, charSize
	imul	[bp+slotNumber]
	mov	bx, ax
	mov	al, gs:(party.specAbil+1)[bx]
	sub	ah, ah
	push	ax
	mov	ax, offset s_identifyChest
	push	ds
	push	ax
	call	printThiefAbilValues
	add	sp, 6

	mov	ax, charSize
	imul	[bp+slotNumber]
	mov	bx, ax
	mov	al, gs:(party.specAbil+1)[bx]
	sub	ah, ah
	push	ax
	mov	ax, offset s_identifyItem
	push	ds
	push	ax
	call	printThiefAbilValues
	add	sp, 6

	mov	ax, charSize
	imul	[bp+slotNumber]
	mov	bx, ax
	mov	al, gs:(party.specAbil+2)[bx]
	sub	ah, ah
	push	ax
	mov	ax, offset s_hideInShadows
	push	ds
	push	ax
	call	printThiefAbilValues
	add	sp, 6

	mov	ax, charSize
	imul	[bp+slotNumber]
	mov	bx, ax
	mov	al, gs:(party.specAbil+2)[bx]
	sub	ah, ah
	push	ax
	mov	ax, offset s_criticalHit
	push	ds
	push	ax
	call	printThiefAbilValues
	add	sp, 6

	jmp	l_waitAndReturn

l_printBard:
	mov	ax, offset s_bardAbilities
	push	ds
	push	ax
	call	printString
	add	sp, 4
	mov	ax, charSize
	imul	[bp+slotNumber]
	mov	bx, ax
	mov	al, gs:party.specAbil[bx]
	sub	ah, ah
	push	ax
	mov	ax, offset s_tunesLeft
	push	ds
	push	ax
	call	printStringAndThreeDigits
	add	sp, 6
	jmp	l_waitAndReturn

l_printHunter:
	mov	ax, offset s_hunterAbilities
	push	ds
	push	ax
	call	printString
	add	sp, 4
	mov	ax, charSize
	imul	[bp+slotNumber]
	mov	bx, ax
	mov	al, gs:party.specAbil[bx]
	sub	ah, ah
	push	ax
	mov	ax, offset s_criticalHit
	push	ds
	push	ax
	call	printThiefAbilValues
	add	sp, 6
	jmp	l_waitAndReturn

l_printSpells:
	mov	[bp+knownSpellCount], 0
	mov	[bp+currentSpellNumber], 0

l_loop:
	push	[bp+currentSpellNumber]
	push	[bp+slotNumber]
	push	cs
	call	near ptr character_learnedSpell
	add	sp, 4
	or	ax, ax
	jz	short l_loopNext
	mov	bx, [bp+currentSpellNumber]
	mov	cl, 3
	shl	bx, cl
	mov	ax, word ptr spellString.fullName[bx]
	mov	dx, word ptr (spellString.fullName+2)[bx]
	mov	si, [bp+knownSpellCount]
	inc	[bp+knownSpellCount]
	shl	si, 1
	shl	si, 1
	mov	[bp+si+var_206], ax
	mov	[bp+si+var_204], dx

l_loopNext:
	inc	[bp+currentSpellNumber]
	cmp	[bp+currentSpellNumber], c_spellCount
	jl	short l_loop

loc_190A5:
	cmp	[bp+knownSpellCount], 0
	jz	short loc_190C6
	push	[bp+knownSpellCount]
	lea	ax, [bp+var_206]
	push	ss
	push	ax
	mov	ax, offset s_knownSpells
	push	ds
	push	ax
	call	text_scrollingWindow
	add	sp, 0Ah
	jmp	l_return

loc_190C6:
	mov	ax, offset s_dontKnowAnySpells
	push	ds
	push	ax
	call	printString
	add	sp, 4

l_waitAndReturn:
	mov	ax, 4000h
	push	ax
	call	getKey
	add	sp, 2

l_return:
	pop	si
	mov	sp, bp
	pop	bp
	retf
character_printAbilities endp

; Attributes: bp-based frame

character_learnedSpell proc far

	slotNumber=	word ptr  6
	spellNumber= word ptr	 8

	push	bp
	mov	bp, sp

	mov	ax, charSize
	imul	[bp+slotNumber]
	mov	bx, ax
	mov	ax, [bp+spellNumber]
	mov	cl, 3
	sar	ax, cl
	add	bx, ax
	mov	al, gs:party.spells[bx]
	sub	ah, ah
	mov	bx, [bp+spellNumber]
	and	bx, 7
	mov	cl, byteMaskList[bx]
	sub	ch, ch
	and	ax, cx

	mov	sp, bp
	pop	bp
	retf
character_learnedSpell endp

; Attributes: bp-based frame

character_learnSpell	proc far

	slotNumber=	word ptr  6
	spellNumber= word ptr	 8

	push	bp
	mov	bp, sp

	mov	bx, [bp+spellNumber]
	and	bx, 7
	mov	al, byteMaskList[bx]
	mov	cx, ax
	mov	ax, charSize
	imul	[bp+slotNumber]
	mov	bx, ax
	mov	ax, [bp+spellNumber]
	mov	dx, cx
	mov	cl, 3
	sar	ax, cl
	add	bx, ax
	or	gs:party.spells[bx], dl

	mov	sp, bp
	pop	bp
	retf
character_learnSpell	endp

; This function	returns	one if the character class
; has special abilities	that need to be	printed
;
; Attributes: bp-based frame

character_hasSpecialAbilities proc far

	slotNumber= word ptr	 6

	push	bp
	mov	bp, sp
	mov	ax, charSize
	imul	[bp+slotNumber]
	mov	bx, ax
	cmp	gs:party.class[bx], class_monster
	jnb	short l_returnZero

	mov	ax, charSize
	imul	[bp+slotNumber]
	mov	bx, ax
	mov	al, gs:party.class[bx]
	sub	ah, ah

	or	ax, ax
	jz	short l_returnZero

	cmp	ax, class_paladin
	jz	short l_returnZero

	cmp	ax, class_monk
	jz	short l_returnZero

	mov	ax, 1
	jmp	short l_return

l_returnZero:
	sub	ax, ax

l_return:
	mov	sp, bp
	pop	bp
	retf
character_hasSpecialAbilities endp


seg006 ends

; Segment type: Pure code
seg007 segment word public 'CODE' use16
        assume cs:seg007
;org 0Dh
        assume es:nothing, ss:nothing, ds:dseg, fs:nothing, gs:seg027
align 2

; This function	sets the direction facing in the
; opposite direction. Used when	exiting	buildings.
; If the party was facing north, after this function
; they would be	facing south.
; Attributes: bp-based frame

map_turnAround proc far
	push	bp
	mov	bp, sp
	mov	ax, g_direction
	add	ax, 2
	and	ax, 3
	mov	g_direction, ax
	mov	sp, bp
	pop	bp
	retf
map_turnAround endp

; Attributes: bp-based frame
map_moveOneSquare proc	far
	push	bp
	mov	bp, sp
	push	si

	mov	si, g_direction
	shl	si, 1
	mov	ax, dirDeltaN[si]
	sub	sq_north, ax
	mov	ax, dirDeltaE[si]
	add	sq_east, ax

	pop	si
	mov	sp, bp
	pop	bp
	retf
map_moveOneSquare endp

; This function	is the mechanism behind	an if-then
; clause in the	code.
; Attributes: bp-based frame

mapvm_if	proc far

	memOff=	word ptr  6
	memSeg=	word ptr  8
	rval= word ptr	0Ah

	push	bp
	mov	bp, sp

	cmp	[bp+rval], 0
	jz	short loc_1926C

	cmp	gs:breakAfterFunc, 0
	jz	short loc_1925F

	push	[bp+memSeg]
	push	[bp+memOff]
	call	map_getDataOffsetP
	add	sp, 4
	mov	[bp+memOff], ax
	mov	[bp+memSeg], dx
	jmp	short l_return

loc_1925F:
	mov	gs:breakAfterFunc, 1
	jmp	short l_return

loc_1926C:
	cmp	gs:breakAfterFunc, 0
	jz	short l_return
	add	[bp+memOff], 2

l_return:
	mov	ax, [bp+memOff]
	mov	dx, [bp+memSeg]
	mov	sp, bp
	pop	bp
	retf
mapvm_if	endp

; Attributes: bp-based frame

dun_changeLevels proc far

	dungeonDataP= dword ptr -4

	push	bp
	mov	bp, sp
	mov	ax, 4
	call	someStackOperation
	push	si

	mov	word ptr [bp+dungeonDataP], offset g_rosterCharacterBuffer
	mov	word ptr [bp+dungeonDataP+2], seg seg022
	mov	si, g_dunLevelNum
	lfs	bx, [bp+dungeonDataP]
	mov	al, fs:[bx+si+dun_t.dunLevel]
	sub	ah, ah
	mov	dunLevelIndex, ax
	mov	al, fs:[bx+dun_t.deltaSqN]
	cbw
	add	sq_north, ax
	mov	al, fs:[bx+dun_t.deltaSqE]
	cbw
	add	sq_east, ax
	mov	gs:levelChangedFlag, 1
	mov	g_mapRval, 4

	pop	si
	mov	sp, bp
	pop	bp
	retf
dun_changeLevels endp

; Attributes: bp-based frame

dun_setExitLocation proc far

	dungeonDataP= dword ptr -4

	push	bp
	mov	bp, sp
	mov	ax, 4
	call	someStackOperation
	mov	word ptr [bp+dungeonDataP], offset g_rosterCharacterBuffer
	mov	word ptr [bp+dungeonDataP+2], seg seg022
	lfs	bx, [bp+dungeonDataP]
	mov	al, fs:[bx+dun_t.exitSqN]
	sub	ah, ah
	mov	sq_north, ax
	mov	al, fs:[bx+dun_t.exitSqE]
	mov	sq_east, ax
	mov	al, fs:[bx+dun_t.exitLocation]
	mov	g_locationNumber, ax
	mov	g_mapRval, 2
	mov	sp, bp
	pop	bp
	retf
dun_setExitLocation endp

; Attributes: bp-based frame

mfunc_downStairs proc far

	dataP= dword ptr  6

	push	bp
	mov	bp, sp

	cmp	g_sameSquareFlag, 0
	jnz	short l_return

	mov	g_sameSquareFlag, 1
	call	text_clear
	mov	al, g_levelFlags
	sub	ah, ah
	and	ax, 10h
	push	ax
	mov	ax, offset s_thereAreStairs
	push	ds
	push	ax
	call	stairsPluralHelper
	add	sp, 6
	call	getYesNo
	or	ax, ax
	jz	short l_return

	push	word ptr [bp+dataP+2]
	push	word ptr [bp+dataP]
	push	cs
	call	near ptr mfunc_setSameSquareFlag
	add	sp, 4
	dec	g_dunLevelNum
	jns	short l_changeLevel

	push	cs
	call	near ptr dun_setExitLocation
	jmp	short l_return

l_changeLevel:
	push	cs
	call	near ptr dun_changeLevels

l_return:
	mov	ax, word ptr [bp+dataP]
	mov	dx, word ptr [bp+dataP+2]
	mov	sp, bp
	pop	bp
	retf
mfunc_downStairs endp

; Attributes: bp-based frame

mfunc_upStairs proc far

	dataP= dword ptr  6

	push	bp
	mov	bp, sp

	cmp	g_sameSquareFlag, 0
	jnz	short l_return
	mov	g_sameSquareFlag, 1
	call	text_clear
	mov	al, g_levelFlags
	and	al, 10h
	cmp	al, 1
	sbb	cx, cx
	neg	cx
	push	cx
	mov	ax, offset s_thereAreStairs
	push	ds
	push	ax
	call	stairsPluralHelper
	add	sp, 6
	call	getYesNo
	or	ax, ax
	jz	short l_return
	push	word ptr [bp+dataP+2]
	push	word ptr [bp+dataP]
	push	cs
	call	near ptr mfunc_setSameSquareFlag
	add	sp, 4
	inc	g_dunLevelNum
	push	cs
	call	near ptr dun_changeLevels
l_return:
	mov	ax, word ptr [bp+dataP]
	mov	dx, word ptr [bp+dataP+2]
	mov	sp, bp
	pop	bp
	retf
mfunc_upStairs endp

; Attributes: bp-based frame

mfunc_utility proc far

	dataP= dword ptr  6

	push	bp
	mov	bp, sp

	lfs	bx, [bp+dataP]
	inc	word ptr [bp+dataP]
	mov	al, fs:[bx]
	sub	ah, ah
	cmp	ax, 3
	jz	short l_geomancer_convert
	cmp	ax, 4
	jz	short l_doScrySite
	cmp	ax, 5
	jz	short l_doVictory
	cmp	ax, 9
	jz	short l_copyProtection
	jmp	short l_notImplemented

l_geomancer_convert:
	mov	al, gs:g_userSlotNumber
	sub	ah, ah
	push	ax
	call	far ptr geomancer_convert
	add	sp, 2
	jmp	short l_returnSuccess

l_doScrySite:
	cmp	inDungeonMaybe, 0
	jz	short l_printLocation
	call	brilhasti_doBonus
	jmp	short l_returnSuccess
l_printLocation:
	call	printLocation
	jmp	short l_returnSuccess

l_doVictory:
	call	doVictoryMaybe
	jmp	short l_returnSuccess

l_copyProtection:
	call	copyProtection
	mov	gs:breakAfterFunc, ax
	jmp	short l_returnSuccess

l_notImplemented:
	push	word ptr [bp+dataP+2]
	push	word ptr [bp+dataP]
	push	cs
	call	near ptr mfunc_notImplemented
	add	sp, 4
	jmp	short l_return

l_returnSuccess:
	mov	ax, word ptr [bp+dataP]
	mov	dx, word ptr [bp+dataP+2]

l_return:
	mov	sp, bp
	pop	bp
	retf
mfunc_utility endp

; Attributes: bp-based frame

mfunc_teleport proc far

	destinationDungeon= word ptr	-2
	dataP= dword ptr  6

	push	bp
	mov	bp, sp
	mov	ax, 2
	call	someStackOperation
	push	word ptr [bp+dataP+2]
	push	word ptr [bp+dataP]
	call	mfunc_setSameSquareFlag
	add	sp, 4

	lfs	bx, [bp+dataP]
	inc	word ptr [bp+dataP]

	; Set new sq_north
	mov	al, fs:[bx]
	sub	ah, ah
	mov	sq_north, ax

	; Set new sq_east
	lfs	bx, [bp+dataP]
	inc	word ptr [bp+dataP]
	mov	al, fs:[bx]
	mov	sq_east, ax

	lfs	bx, [bp+dataP]
	inc	word ptr [bp+dataP]
	mov	al, fs:[bx]
	mov	[bp+destinationDungeon], ax

	cmp	inDungeonMaybe, 0
	jz	short loc_19557

	cmp	ax, 80h
	jb	short loc_19531
	mov	g_mapRval, gameState_inWilderness
	and	ax, 7Fh
	mov	g_locationNumber, ax
	jmp	short loc_19555
loc_19531:
	mov	ax, [bp+destinationDungeon]
	cmp	dunLevelIndex, ax
	jz	short loc_1954A
	mov	g_mapRval, gameState_inDungeon
loc_1954A:
	mov	ax, [bp+destinationDungeon]
	mov	dunLevelIndex, ax
loc_19555:
	jmp	short l_return

loc_19557:
	cmp	[bp+destinationDungeon], 80h
	jb	short loc_19579
	mov	g_mapRval, gameState_inDungeon
	mov	ax, [bp+destinationDungeon]
	and	ax, 7Fh
	mov	dunLevelIndex, ax
	jmp	short l_return

loc_19579:
	mov	ax, [bp+destinationDungeon]
	cmp	g_locationNumber, ax
	jz	short loc_19592
	mov	g_mapRval, gameState_inWilderness
loc_19592:
	mov	ax, [bp+destinationDungeon]
	mov	g_locationNumber, ax

l_return:
	mov	ax, word ptr [bp+dataP]
	mov	dx, word ptr [bp+dataP+2]
	mov	sp, bp
	pop	bp
	retf
mfunc_teleport endp

; Attributes: bp-based frame

mfunc_battle proc far

	loopCounter= word ptr	-2
	dataP= dword ptr  6

	push	bp
	mov	bp, sp
	mov	ax, 2
	call	someStackOperation
	push	si

	lfs	bx, [bp+dataP]
	inc	word ptr [bp+dataP]
	mov	al, fs:[bx]
	mov	g_monsterGroupCount, al
	cmp	al, 4
	jb	short l_skipZounds
	mov	ax, offset s_zounds
	push	ds
	push	ax
	call	printString
	add	sp, 4
	mov	ax, 4000h
	push	ax
	call	getKey
	add	sp, 2

l_skipZounds:
	mov	[bp+loopCounter], 0
l_setEncounterLoop:
	mov	al, g_monsterGroupCount
	sub	ah, ah
	cmp	ax, [bp+loopCounter]
	jbe	short l_doBattle
	mov	ax, monStruSize
	imul	[bp+loopCounter]
	mov	si, ax
	lfs	bx, [bp+dataP]
	inc	word ptr [bp+dataP]
	mov	al, fs:[bx]
	mov	byte ptr gs:monGroups._name[si], al
	lfs	bx, [bp+dataP]
	inc	word ptr [bp+dataP]
	mov	al, fs:[bx]
	mov	gs:monGroups.groupSize[si], al
	inc	[bp+loopCounter]
	jmp	short l_setEncounterLoop

l_doBattle:
	mov	gs:g_nonRandomBattleFlag, 1
	mov	g_partyAttackFlag, 0
	call	bat_init
	or	ax, ax
	jz	short l_battleOver
	mov	g_mapRval, gameState_partyDied
	mov	gs:breakAfterFunc, 0
	mov	ax, word ptr [bp+dataP]
	mov	dx, word ptr [bp+dataP+2]
	jmp	short l_return

l_battleOver:
	cmp	gs:runAwayFlag,	1
	sbb	ax, ax
	neg	ax
	push	ax
	push	word ptr [bp+dataP+2]
	push	word ptr [bp+dataP]
	call	mapvm_if
	add	sp, 6
	jmp	short $+2
l_return:
	pop	si
	mov	sp, bp
	pop	bp
	retf
mfunc_battle endp

; Attributes: bp-based frame

mfunc_clearPrintString proc far

	arg_0= dword ptr	 6

	push	bp
	mov	bp, sp
	call	text_clear
	push	word ptr [bp+dataP+2]
	push	word ptr [bp+dataP]
	push	cs
	call	near ptr mfunc_printString
	add	sp, 4
	mov	sp, bp
	pop	bp
	retf
mfunc_clearPrintString endp

; Replace the opcode at	*dataP with 0xff effectively
; removing the code from the level. Used so the	party
; only runs the	code at	the current square once	per
; level.
; Attributes: bp-based frame

mfunc_clearSpecial proc far

	destinationP= dword ptr -4
	dataP= dword ptr 6

	push	bp
	mov	bp, sp
	mov	ax, 4
	call	someStackOperation
	push	word ptr [bp+dataP+2]
	push	word ptr [bp+dataP]
	call	map_getDataOffsetP
	add	sp, 4
	mov	word ptr [bp+destinationP], ax
	mov	word ptr [bp+destinationP+2], dx
	lfs	bx, [bp+destinationP]
	mov	byte ptr fs:[bx], 0FFh
	mov	ax, word ptr [bp+dataP]
	mov	dx, word ptr [bp+dataP+2]
	add	ax, 2
	mov	sp, bp
	pop	bp
	retf
mfunc_clearSpecial endp

; This function	draws the bigpic image located at *dataP;
; Attributes: bp-based frame

mfunc_drawBigpic proc far

	picNo= word ptr	-2
	dataP=	dword ptr  6

	push	bp
	mov	bp, sp
	mov	ax, 2
	call	someStackOperation
	lfs	bx, [bp+dataP]
	inc	word ptr [bp+dataP]
	mov	al, fs:[bx]
	sub	ah, ah
	mov	[bp+picNo], ax
	call	bigpic_drawPictureNumber
	add	sp, 2
	mov	ax, word ptr [bp+dataP]
	mov	dx, word ptr [bp+dataP+2]
	mov	sp, bp
	pop	bp
	retf
mfunc_drawBigpic endp

; This function	reads an 0x80AND'd string from *membuf
; and sets the title. The string is 0xff terminated.
; Attributes: bp-based frame

mfunc_setTitle proc far

	stringBufferP= word ptr -102h
	stringBuffer= word ptr -100h
	dataP= dword ptr  6

	push	bp
	mov	bp, sp
	mov	ax, 102h
	call	someStackOperation
	push	si

	mov	[bp+stringBufferP], 0
l_unmaskLoop:
	lfs	bx, [bp+dataP]
	cmp	byte ptr fs:[bx], 0FFh
	jz	short l_setTitle
	inc	word ptr [bp+dataP]
	mov	al, fs:[bx]
	and	al, 7Fh
	mov	si, [bp+stringBufferP]
	inc	[bp+stringBufferP]
	mov	byte ptr [bp+si+stringBuffer], al
	jmp	short l_unmaskLoop

l_setTitle:
	mov	si, [bp+stringBufferP]
	mov	byte ptr [bp+si+stringBuffer], 0
	inc	word ptr [bp+dataP]
	lea	ax, [bp+stringBuffer]
	push	ss
	push	ax
	call	setTitle
	add	sp, 4
	mov	ax, word ptr [bp+dataP]
	mov	dx, word ptr [bp+dataP+2]
	pop	si
	mov	sp, bp
	pop	bp
	retf
mfunc_setTitle endp

; Attributes: bp-based frame

mfunc_waitForIo proc far

	arg_0= dword ptr 6

	push	bp
	mov	bp, sp
	mov	ax, 4000h
	push	ax
	call	getKey
	add	sp, 2
	mov	ax, word ptr [bp+dataP]
	mov	dx, word ptr [bp+dataP+2]
	mov	sp, bp
	pop	bp
	retf
mfunc_waitForIo endp

; Attributes: bp-based frame

mfunc_clearText proc far

	dataP= dword ptr 6

	push	bp
	mov	bp, sp
	call	text_clear
	mov	ax, word ptr [bp+dataP]
	mov	dx, word ptr [bp+dataP+2]
	mov	sp, bp
	pop	bp
	retf
mfunc_clearText endp

; Attributes: bp-based frame

mfunc_ifFlag proc far

	dataP= dword ptr  6

	push	bp
	mov	bp, sp

	lfs	bx, [bp+dataP]
	inc	word ptr [bp+dataP]
	mov	al, fs:[bx]
	sub	ah, ah
	push	ax
	push	cs
	call	near ptr checkProgressFlags
	add	sp, 2
	push	ax
	push	word ptr [bp+dataP+2]
	push	word ptr [bp+dataP]
	push	cs
	call	near ptr mapvm_if
	add	sp, 6
	mov	sp, bp
	pop	bp
	retf
mfunc_ifFlag endp

; Attributes: bp-based frame

mfunc_ifNotFlag	proc far

	dataP= dword ptr  6

	push	bp
	mov	bp, sp
	lfs	bx, [bp+dataP]
	inc	word ptr [bp+dataP]
	mov	al, fs:[bx]
	sub	ah, ah
	push	ax
	push	cs
	call	near ptr checkProgressFlags
	add	sp, 2
	cmp	ax, 1
	sbb	cx, cx
	neg	cx
	push	cx
	push	word ptr [bp+dataP+2]
	push	word ptr [bp+dataP]
	push	cs
	call	near ptr mapvm_if
	add	sp, 6
	mov	sp, bp
	pop	bp
	retf
mfunc_ifNotFlag	endp

; Attributes: bp-based frame

checkProgressFlags proc far

	var_4= word ptr	-4
	var_2= word ptr	-2
	flagData= word ptr	 6

	push	bp
	mov	bp, sp
	mov	ax, 4
	call	someStackOperation
	mov	ax, [bp+flagData]
	mov	cl, 3
	shr	ax, cl
	mov	[bp+var_4], ax
	mov	ax, [bp+flagData]
	and	ax, 7
	mov	[bp+var_2], ax
	mov	bx, [bp+var_4]
	mov	al, g_gameProgressFlags[bx]
	sub	ah, ah
	mov	bx, [bp+var_2]
	mov	cl, byteMaskList[bx]
	sub	ch, ch
	and	ax, cx
	mov	sp, bp
	pop	bp
	retf
checkProgressFlags endp

; Attributes: bp-based frame
;
; DWORD rowOffsetSeg & rowOffsetOff, charBufOff & charBufSeg

mfunc_makeDoor proc far

	squareP=	dword ptr -1Ch
	doorData=	word ptr -18h
	squareNumber=	word ptr -14h
	var_12=	dword ptr -12h
	rowNumber= word ptr	-0Eh
	charBufOff= word ptr -0Ch
	charBufSeg= word ptr -0Ah
	var_8= word ptr	-8
	rowOffsetOff= word ptr	-6
	rowOffsetSeg= word ptr	-4
	var_2= word ptr	-2
	dataP= dword ptr  6

	push	bp
	mov	bp, sp
	mov	ax, 1Ch
	call	someStackOperation

	mov	[bp+charBufOff], offset	g_rosterCharacterBuffer
	mov	[bp+charBufSeg], seg seg022
	mov	ax, [bp+charBufOff]
	mov	dx, [bp+charBufSeg]
	add	ax, 24h					; 24h == rowOffset
	mov	[bp+rowOffsetOff], ax
	mov	[bp+rowOffsetSeg], dx

	lfs	bx, [bp+dataP]
	inc	word ptr [bp+dataP]
	mov	al, fs:[bx]
	sub	ah, ah
	mov	[bp+rowNumber], ax

	mov	bx, word ptr [bp+dataP]
	inc	word ptr [bp+dataP]
	mov	al, fs:[bx]
	mov	[bp+squareNumber], ax

	mov	bx, word ptr [bp+dataP]
	inc	word ptr [bp+dataP]
	mov	al, fs:[bx]
	mov	[bp+doorData], ax

	mov	ax, [bp+rowNumber]
	shl	ax, 1
	add	ax, [bp+rowOffsetOff]
	mov	word ptr [bp+squareP], ax
	mov	word ptr [bp+squareP+2], dx
	lfs	bx, [bp+squareP]
	mov	ah, fs:[bx+1]
	sub	al, al
	mov	cl, fs:[bx]
	sub	ch, ch
	add	ax, cx
	mov	cx, [bp+squareNumber]
	mov	dx, cx
	shl	cx, 1
	shl	cx, 1
	add	cx, dx
	add	ax, cx
	add	ax, offset g_rosterCharacterBuffer
	mov	word ptr [bp+var_12], ax
	mov	word ptr [bp+var_12+2],	seg seg022
	mov	ax, [bp+doorData]
	and	ax, 0Fh
	mov	[bp+var_2], ax
	mov	cl, 4
	shr	[bp+doorData], cl
	test	byte ptr [bp+doorData], 2
	jz	short loc_198EC
	inc	word ptr [bp+var_12]
loc_198EC:
	test	byte ptr [bp+doorData], 1
	jz	short loc_1990E
	lfs	bx, [bp+var_12]
	mov	al, fs:[bx]
	sub	ah, ah
	and	ax, 0F0h
	mov	[bp+var_8], ax
	mov	ax, [bp+var_2]
	or	[bp+var_8], ax
	mov	al, byte ptr [bp+var_8]
	mov	fs:[bx], al
	jmp	short loc_1992C
loc_1990E:
	lfs	bx, [bp+var_12]
	mov	al, fs:[bx]
	sub	ah, ah
	and	ax, 0Fh
	mov	[bp+var_8], ax
	mov	ax, [bp+var_2]
	mov	cl, 4
	shl	ax, cl
	or	[bp+var_8], ax
	mov	al, byte ptr [bp+var_8]
	mov	fs:[bx], al
loc_1992C:
	mov	ax, word ptr [bp+dataP]
	mov	dx, word ptr [bp+dataP+2]
	mov	sp, bp
	pop	bp
	retf
mfunc_makeDoor endp

; Attributes: bp-based frame

mfunc_setFlag proc far

	flagNo=	word ptr -2
	dataP= dword ptr  6

	push	bp
	mov	bp, sp
	mov	ax, 2
	call	someStackOperation
	lfs	bx, [bp+dataP]
	inc	word ptr [bp+dataP]
	mov	al, fs:[bx]
	sub	ah, ah
	mov	[bp+flagNo], ax
	mov	ax, 0FFh
	push	ax
	push	[bp+flagNo]
	push	cs
	call	near ptr _updateFlags
	add	sp, 4
	mov	ax, word ptr [bp+dataP]
	mov	dx, word ptr [bp+dataP+2]
	mov	sp, bp
	pop	bp
	retf
mfunc_setFlag endp

; Attributes: bp-based frame

mfunc_clearFlag	proc far

	flagNo= word ptr	-2
	dataP= dword ptr  6

	push	bp
	mov	bp, sp
	mov	ax, 2
	call	someStackOperation
	lfs	bx, [bp+dataP]
	inc	word ptr [bp+dataP]
	mov	al, fs:[bx]
	sub	ah, ah
	mov	[bp+flagNo], ax
	sub	ax, ax
	push	ax
	push	[bp+flagNo]
	call	_updateFlags
	add	sp, 4
	mov	ax, word ptr [bp+dataP]
	mov	dx, word ptr [bp+dataP+2]
	mov	sp, bp
	pop	bp
	retf
mfunc_clearFlag	endp

; Attributes: bp-based frame

_updateFlags proc far

	flagNumber=	word ptr -6
	flagMaskIndex=	word ptr -4
	flagMask=	word ptr -2
	flagData=	word ptr  6
	initialMask=	byte ptr  8

	push	bp
	mov	bp, sp
	mov	ax, 6
	call	someStackOperation

	mov	ax, [bp+flagData]
	mov	cl, 3
	shr	ax, cl
	mov	[bp+flagNumber], ax

	mov	ax, [bp+flagData]
	and	ax, 7
	mov	[bp+flagMaskIndex], ax

	mov	bx, [bp+flagNumber]
	mov	al, g_gameProgressFlags[bx]
	sub	ah, ah
	mov	bx, [bp+flagMaskIndex]
	mov	cl, flagMaskList[bx]
	sub	ch, ch
	and	ax, cx
	mov	[bp+flagMask], ax

	mov	al, byteMaskList[bx]
	and	al, [bp+initialMask]
	or	al, byte ptr [bp+flagMask]
	mov	bx, [bp+flagNumber]
	mov	g_gameProgressFlags[bx], al
	mov	sp, bp
	pop	bp
	retf
_updateFlags endp

; Attributes: bp-based frame
mfunc_ifCurSpellEQ proc	far

	dataP= dword ptr  6

	push	bp
	mov	bp, sp
	lfs	bx, [bp+dataP]
	inc	word ptr [bp+dataP]
	mov	al, fs:[bx]
	sub	ah, ah
	cmp	ax, g_curSpellNumber
	jnz	short l_returnZero
	mov	ax, 1
	jmp	short l_return
l_returnZero:
	sub	ax, ax
l_return:
	push	ax
	push	word ptr [bp+dataP+2]
	push	word ptr [bp+dataP]
	push	cs
	call	near ptr mapvm_if
	add	sp, 6
	mov	sp, bp
	pop	bp
	retf
mfunc_ifCurSpellEQ endp

; Attributes: bp-based frame

mfunc_setMapRval proc far

	dataP= dword ptr	 6

	push	bp
	mov	bp, sp
	mov	gs:mapRval, 1
	mov	ax, word ptr [bp+dataP]
	mov	dx, word ptr [bp+dataP+2]
	mov	sp, bp
	pop	bp
	retf
mfunc_setMapRval endp

; Attributes: bp-based frame

mfunc_printString proc far

	stringBuffer= word ptr -100h
	dataP= dword ptr  6

	push	bp
	mov	bp, sp
	mov	ax, 100h
	call	someStackOperation
	lea	ax, [bp+stringBuffer]
	push	ss
	push	ax
	push	word ptr [bp+dataP+2]
	push	word ptr [bp+dataP]
	call	_mfunc_getString
	add	sp, 8
	mov	word ptr [bp+dataP], ax
	mov	word ptr [bp+dataP+2], dx
	lea	ax, [bp+stringBuffer]
	push	ss
	push	ax
	call	printString
	add	sp, 4
	mov	ax, word ptr [bp+dataP]
	mov	dx, word ptr [bp+dataP+2]
	mov	sp, bp
	pop	bp
	retf
mfunc_printString endp

; Attributes: bp-based frame

mfunc_doNothing	proc far

	dataP= dword ptr	 6

	push	bp
	mov	bp, sp
	mov	ax, word ptr [bp+dataP]
	mov	dx, word ptr [bp+dataP+2]
	mov	sp, bp
	pop	bp
	retf
mfunc_doNothing	endp

; Attributes: bp-based frame
mfunc_ifLiquid proc	far

	liquidIndex= word ptr	-4
	var_2= word ptr	-2
	dataP= dword ptr  6

	push	bp
	mov	bp, sp
	mov	ax, 4
	call	someStackOperation

	lfs	bx, [bp+dataP]
	inc	word ptr [bp+dataP]
	mov	al, fs:[bx]
	sub	ah, ah
	mov	[bp+liquidIndex], ax
	mov	al, charSize
	mul	gs:g_userSlotNumber
	mov	bx, ax
	mov	al, gs:g_usedItemSlotNumber
	sub	ah, ah
	add	bx, ax
	mov	al, gs:party.inventory.itemFlags[bx]
	sar	ax, 1
	sar	ax, 1
	and	ax, 0Fh
	mov	[bp+var_2], ax
	cmp	[bp+liquidIndex], ax
	jnz	short l_returnZero
	mov	ax, 1
	jmp	short l_return
l_returnZero:
	sub	ax, ax
l_return:
	push	ax
	push	word ptr [bp+dataP+2]
	push	word ptr [bp+dataP]
	push	cs
	call	near ptr mapvm_if
	add	sp, 6
	mov	sp, bp
	pop	bp
	retf
mfunc_ifLiquid endp

; Attributes: bp-based frame
;
; DWORD - var_10A & var_10C

mfunc_getItem proc far

	var_10C= word ptr -10Ch
	var_10A= word ptr -10Ah
	var_108= word ptr -108h
	stringBuffer= word ptr -106h
	var_6= word ptr	-6
	slotNumber= word ptr	-4
	var_2= word ptr	-2
	dataP= dword ptr  6

	push	bp
	mov	bp, sp
	mov	ax, 10Ch
	call	someStackOperation

	lfs	bx, [bp+dataP]
	inc	word ptr [bp+dataP]
	mov	al, fs:[bx]
	sub	ah, ah
	mov	[bp+var_108], ax

	mov	bx, word ptr [bp+dataP]
	inc	word ptr [bp+dataP]
	mov	al, fs:[bx]
	mov	[bp+var_2], ax

	mov	bx, word ptr [bp+dataP]
	inc	word ptr [bp+dataP]
	mov	al, fs:[bx]
	mov	[bp+var_6], ax

l_retry:
	call	text_clear
	mov	ax, offset s_whoWantsToGetThe
	push	ds
	push	ax
	lea	ax, [bp+stringBuffer]
	push	ss
	push	ax
	call	strcat
	add	sp, 8
	mov	[bp+var_10C], ax
	mov	[bp+var_10A], dx
	push	[bp+var_108]
	push	[bp+var_2]
	push	dx
	push	ax
	call	inventory_getItemName
	add	sp, 8
	mov	[bp+var_10C], ax
	mov	[bp+var_10A], dx
	lea	ax, [bp+stringBuffer]
	push	ss
	push	ax
	call	printString
	add	sp, 4
	call	readSlotNumber
	mov	[bp+slotNumber], ax
	or	ax, ax
	jge	short l_addItem
	sub	ax, ax
	push	ax
	push	word ptr [bp+dataP+2]
	push	word ptr [bp+dataP]
	push	cs
	call	near ptr mapvm_if
	add	sp, 6
	jmp	l_return

l_addItem:
	push	[bp+var_6]
	push	[bp+var_108]
	push	[bp+var_2]
	push	[bp+slotNumber]
	call	inventory_addItem
	add	sp, 8
	or	ax, ax
	jz	short l_inventoryFull
	mov	ax, charSize
	imul	[bp+slotNumber]
	mov	bx, ax
	lea	ax, party._name[bx]
	mov	dx, seg	seg027
	push	dx
	push	ax
	lea	ax, [bp+stringBuffer]
	push	ss
	push	ax
	call	strcat
	add	sp, 8
	mov	[bp+var_10C], ax
	mov	[bp+var_10A], dx
	mov	ax, offset s_gotThe
	push	ds
	push	ax
	push	dx
	push	[bp+var_10C]
	call	strcat
	add	sp, 8
	mov	[bp+var_10C], ax
	mov	[bp+var_10A], dx
	push	[bp+var_108]
	push	[bp+var_2]
	push	dx
	push	ax
	call	inventory_getItemName
	add	sp, 8
	mov	[bp+var_10C], ax
	mov	[bp+var_10A], dx
	lea	ax, [bp+stringBuffer]
	push	ss
	push	ax
	call	printString
	add	sp, 4
	mov	ax, 1
	push	ax
	push	word ptr [bp+dataP+2]
	push	word ptr [bp+dataP]
	push	cs
	call	near ptr mapvm_if
	add	sp, 6
	jmp	short l_return

l_inventoryFull:
	mov	ax, offset s_sorryBut
	push	ds
	push	ax
	lea	ax, [bp+stringBuffer]
	push	ss
	push	ax
	call	strcat
	add	sp, 8
	mov	[bp+var_10C], ax
	mov	[bp+var_10A], dx
	mov	ax, charSize
	imul	[bp+slotNumber]
	mov	bx, ax
	lea	ax, party._name[bx]
	mov	dx, seg	seg027
	push	dx
	push	ax
	push	[bp+var_10A]
	push	[bp+var_10C]
	call	strcat
	add	sp, 8
	mov	[bp+var_10C], ax
	mov	[bp+var_10A], dx
	mov	ax, offset s_cantCarryAnyMore
	push	ds
	push	ax
	push	dx
	push	[bp+var_10C]
	call	strcat
	add	sp, 8
	mov	[bp+var_10C], ax
	mov	[bp+var_10A], dx
	lea	ax, [bp+stringBuffer]
	push	ss
	push	ax
	call	printString
	add	sp, 4
	jmp	l_retry

l_return:
	mov	sp, bp
	pop	bp
	retf
mfunc_getItem endp

mfunc_ifPartyHasItem	proc far

	dataP= dword ptr  6

	push	bp
	mov	bp, sp
	lfs	bx, [bp+dataP]
	inc	word ptr [bp+dataP]
	mov	al, fs:[bx]
	sub	ah, ah
	push	ax
	push	cs
	call	near ptr vm_findItem
	add	sp, 2
	push	ax
	push	word ptr [bp+dataP+2]
	push	word ptr [bp+dataP]
	push	cs
	call	near ptr mapvm_if
	add	sp, 6
	mov	sp, bp
	pop	bp
	retf
mfunc_ifPartyHasItem	endp

; Attributes: bp-based frame
mfunc_ifPartyNotHasItem proc	far

	dataP= dword ptr  6

	push	bp
	mov	bp, sp
	lfs	bx, [bp+dataP]
	inc	word ptr [bp+dataP]
	mov	al, fs:[bx]
	sub	ah, ah
	push	ax
	push	cs
	call	near ptr vm_findItem
	add	sp, 2
	cmp	ax, 1
	sbb	cx, cx
	neg	cx
	push	cx
	push	word ptr [bp+dataP+2]
	push	word ptr [bp+dataP]
	push	cs
	call	near ptr mapvm_if
	add	sp, 6
	mov	sp, bp
	pop	bp
	retf
mfunc_ifPartyNotHasItem endp

; Attributes: bp-based frame

vm_findItem proc far

	slotNumber=	word ptr -4
	inventorySlotNumber= word ptr	-2
	arg_0= word ptr	 6

	push	bp
	mov	bp, sp
	mov	ax, 4
	call	someStackOperation
	mov	[bp+slotNumber], 0

l_characterLoop:
	mov	[bp+inventorySlotNumber], 1
l_inventoryLoop:
	mov	ax, charSize
	imul	[bp+slotNumber]
	mov	bx, ax
	add	bx, [bp+inventorySlotNumber]
	mov	al, gs:party.inventory.itemFlags[bx]
	sub	ah, ah
	cmp	ax, [bp+arg_0]
	jnz	short l_inventoryLoopNext
	mov	al, byte ptr [bp+inventorySlotNumber]
	dec	al
	mov	gs:g_usedItemSlotNumber, al
	mov	al, byte ptr [bp+slotNumber]
	mov	gs:g_userSlotNumber, al
	mov	ax, 1
	jmp	short l_return
l_inventoryLoopNext:
	add	[bp+inventorySlotNumber], 3
	cmp	[bp+inventorySlotNumber], inventorySize
	jl	short l_inventoryLoop
	inc	[bp+slotNumber]
	cmp	[bp+slotNumber], 7
	jl	short l_characterLoop
	sub	ax, ax
l_return:
	mov	sp, bp
	pop	bp
	retf
vm_findItem endp

; Attributes: bp-based frame

mfunc_ifSameSquare proc far

	dataP= dword ptr  6

	push	bp
	mov	bp, sp
	mov	ax, g_sameSquareFlag
	mov	g_sameSquareFlag, 1
	push	ax
	push	word ptr [bp+dataP+2]
	push	word ptr [bp+dataP]
	push	cs
	call	near ptr mapvm_if
	add	sp, 6
	mov	sp, bp
	pop	bp
	retf
mfunc_ifSameSquare endp

; Attributes: bp-based frame

mfunc_ifYesNo proc far

	dataP= dword ptr  6

	push	bp
	mov	bp, sp
	call	getYesNo
	push	ax
	push	word ptr [bp+dataP+2]
	push	word ptr [bp+dataP]
	push	cs
	call	near ptr mapvm_if
	add	sp, 6
	mov	sp, bp
	pop	bp
	retf
mfunc_ifYesNo endp

; Attributes: bp-based frame
mfunc_goto proc	far
	dataP= dword ptr	 6

	push	bp
	mov	bp, sp
	push	word ptr [bp+dataP+2]
	push	word ptr [bp+dataP]
	call	map_getDataOffsetP
	add	sp, 4
	mov	sp, bp
	pop	bp
	retf
mfunc_goto endp

; Attributes: bp-based frame

mfunc_battleNoCry proc far

	dataP= dword ptr	 6

	push	bp
	mov	bp, sp
	mov	gs:byte_4228B, 1
	push	word ptr [bp+dataP+2]
	push	word ptr [bp+dataP]
	push	cs
	call	near ptr mfunc_battle
	add	sp, 4
	mov	sp, bp
	pop	bp
	retf
mfunc_battleNoCry endp

; Attributes: bp-based frame

mfunc_setSameSquareFlag	proc far

	dataP= dword ptr	 6

	push	bp
	mov	bp, sp
	mov	g_sameSquareFlag, 0
	mov	ax, word ptr [bp+dataP]
	mov	dx, word ptr [bp+dataP+2]
	mov	sp, bp
	pop	bp
	retf
mfunc_setSameSquareFlag	endp

; Attributes: bp-based frame

mfunc_turnAround proc far

	dataP= dword ptr	 6

	push	bp
	mov	bp, sp
	push	cs
	call	near ptr map_turnAround
	push	cs
	call	near ptr map_moveOneSquare
	mov	ax, word ptr [bp+dataP]
	mov	dx, word ptr [bp+dataP+2]
	mov	sp, bp
	pop	bp
	retf
mfunc_turnAround endp

; Attributes: bp-based frame

mfunc_removeItem proc far

	dataP= dword ptr  6

	push	bp
	mov	bp, sp
	lfs	bx, [bp+dataP]
	inc	word ptr [bp+dataP]
	mov	al, fs:[bx]
	sub	ah, ah
	push	ax
	push	cs
	call	near ptr vm_removeItem
	add	sp, 2
	mov	ax, word ptr [bp+dataP]
	mov	dx, word ptr [bp+dataP+2]
	mov	sp, bp
	pop	bp
	retf
mfunc_removeItem endp

; Attributes: bp-based frame

vm_removeItem proc far

	slotNumber=	word ptr -4
	inventorySlotNumber= word ptr	-2
	itemNumber= word ptr	 6

	push	bp
	mov	bp, sp
	mov	ax, 4
	call	someStackOperation

	mov	[bp+slotNumber], 0

l_characterLoop:
	mov	[bp+inventorySlotNumber], 1

l_inventoryLoop:
	mov	ax, charSize
	imul	[bp+slotNumber]
	mov	bx, ax
	add	bx, [bp+inventorySlotNumber]
	mov	al, gs:party.inventory.itemFlags[bx]
	sub	ah, ah
	cmp	ax, [bp+itemNumber]
	jnz	short l_inventoryLoopNext
	mov	ax, [bp+inventorySlotNumber]
	dec	ax
	mov	gs:g_inventoryPackStart, ax
	mov	ax, [bp+slotNumber]
	mov	gs:g_inventoryPackTarget, ax
	call	inventory_pack
	jmp	short l_characterLoopNext

l_inventoryLoopNext:
	add	[bp+inventorySlotNumber], 3
	cmp	[bp+inventorySlotNumber], 24h	
	jl	short l_inventoryLoop

l_characterLoopNext:
	inc	[bp+slotNumber]
	cmp	[bp+slotNumber], 7
	jl	short l_characterLoop

l_return:
	mov	sp, bp
	pop	bp
	retf
vm_removeItem endp

; Attributes: bp-based frame

mfunc_incrementRegister proc far

	dataP= dword ptr  6

	push	bp
	mov	bp, sp
	lfs	bx, [bp+dataP]
	inc	word ptr [bp+dataP]
	mov	al, fs:[bx]
	sub	ah, ah
	mov	bx, ax
	shl	bx, 1
	inc	g_vm_registers[bx]
	mov	ax, word ptr [bp+dataP]
	mov	dx, word ptr [bp+dataP+2]
	mov	sp, bp
	pop	bp
	retf
mfunc_incrementRegister endp

; Attributes: bp-based frame

mfunc_decrementRegister proc far

	dataP= dword ptr  6

	push	bp
	mov	bp, sp
	lfs	bx, [bp+dataP]
	inc	word ptr [bp+dataP]
	mov	al, fs:[bx]
	sub	ah, ah
	mov	bx, ax
	shl	bx, 1
	dec	g_vm_registers[bx]
	mov	ax, word ptr [bp+dataP]
	mov	dx, word ptr [bp+dataP+2]
	mov	sp, bp
	pop	bp
	retf
mfunc_decrementRegister endp

; Attributes: bp-based frame
mfunc_ifRegisterClear proc	far

	dataP= dword ptr  6

	push	bp
	mov	bp, sp
	lfs	bx, [bp+dataP]
	inc	word ptr [bp+dataP]
	mov	al, fs:[bx]
	sub	ah, ah
	mov	bx, ax
	shl	bx, 1
	cmp	g_vm_registers[bx], 1
	sbb	ax, ax
	neg	ax
	push	ax
	push	word ptr [bp+dataP+2]
	push	word ptr [bp+dataP]
	push	cs
	call	near ptr mapvm_if
	add	sp, 6
	mov	sp, bp
	pop	bp
	retf
mfunc_ifRegisterClear endp

; Attributes: bp-based frame

mfunc_ifRegisterSet proc far

	dataP= dword ptr  6

	push	bp
	mov	bp, sp
	lfs	bx, [bp+dataP]
	inc	word ptr [bp+dataP]
	mov	al, fs:[bx]
	sub	ah, ah
	mov	bx, ax
	shl	bx, 1
	push	g_vm_registers[bx]
	push	word ptr [bp+dataP+2]
	push	word ptr [bp+dataP]
	push	cs
	call	near ptr mapvm_if
	add	sp, 6
	mov	sp, bp
	pop	bp
	retf
mfunc_ifRegisterSet endp

; Attributes: bp-based frame

mfunc_drainHp proc far

	slotNumber= word ptr	-4
	drainAmount= word ptr	-2
	dataP= dword ptr  6

	push	bp
	mov	bp, sp
	mov	ax, 4
	call	someStackOperation
	push	si

	lfs	bx, [bp+dataP]
	inc	word ptr [bp+dataP]
	mov	al, fs:[bx]
	sub	ah, ah
	mov	[bp+drainAmount], ax
	mov	bx, word ptr [bp+dataP]
	inc	word ptr [bp+dataP]
	mov	ah, fs:[bx]
	sub	al, al
	add	[bp+drainAmount], ax
	mov	[bp+slotNumber], 0

l_loop:
	mov	ax, [bp+drainAmount]
	mov	cx, ax
	mov	ax, charSize
	imul	[bp+slotNumber]
	mov	bx, ax
	cmp	gs:party.currentHP[bx], cx
	jbe	short l_killCharacter
	mov	ax, charSize
	imul	[bp+slotNumber]
	mov	bx, ax
	sub	gs:party.currentHP[bx], cx
	jmp	short l_next

l_killCharacter:
	mov	ax, charSize
	imul	[bp+slotNumber]
	mov	si, ax
	mov	gs:party.currentHP[si], 0
	or	gs:party.status[si], 4

l_next:
	inc	[bp+slotNumber]
	cmp	[bp+slotNumber], 7
	jl	short l_loop
	call	party_getLastSlot
	cmp	ax, 7
	jle	short l_return
	mov	g_mapRval, gameState_partyDied

l_return:
	mov	byte ptr g_printPartyFlag,	0
	mov	ax, word ptr [bp+dataP]
	mov	dx, word ptr [bp+dataP+2]
	pop	si
	mov	sp, bp
	pop	bp
	retf
mfunc_drainHp endp

; Attributes: bp-based frame

mfunc_ifInBox proc far

	sqE= word ptr	-0Ch
	sqN= word ptr	-0Ah
	northLowerBound= word ptr	-8
	eastLowerBound= word ptr	-6
	northUpperBound= word ptr	-4
	eastUpperBound= word ptr	-2
	dataP= dword ptr  6

	push	bp
	mov	bp, sp
	mov	ax, 0Ch
	call	someStackOperation
	push	si

	mov	ax, sq_north
	mov	[bp+sqN], ax
	mov	ax, sq_east
	mov	[bp+sqE], ax
	cmp	inDungeonMaybe, 0
	jnz	short l_skipWildernessOffset
	mov	si, g_direction
	shl	si, 1
	mov	ax, dirDeltaN[si]
	sub	[bp+sqN], ax
	mov	ax, dirDeltaE[si]
	add	[bp+sqE], ax
l_skipWildernessOffset:
	lfs	bx, [bp+dataP]
	inc	word ptr [bp+dataP]
	mov	al, fs:[bx]
	sub	ah, ah
	mov	[bp+northLowerBound], ax

	mov	bx, word ptr [bp+dataP]
	inc	word ptr [bp+dataP]
	mov	al, fs:[bx]
	mov	[bp+eastLowerBound], ax

	mov	bx, word ptr [bp+dataP]
	inc	word ptr [bp+dataP]
	mov	al, fs:[bx]
	mov	[bp+northUpperBound], ax

	mov	bx, word ptr [bp+dataP]
	inc	word ptr [bp+dataP]
	mov	al, fs:[bx]
	mov	[bp+eastUpperBound], ax

	mov	ax, [bp+northLowerBound]
	cmp	[bp+sqN], ax
	jl	short l_returnZero

	mov	ax, [bp+northUpperBound]
	cmp	[bp+sqN], ax
	jg	short l_returnZero

	mov	ax, [bp+eastLowerBound]
	cmp	[bp+sqE], ax
	jl	short l_returnZero

	mov	ax, [bp+eastUpperBound]
	cmp	[bp+sqE], ax
	jg	short l_returnZero

	mov	ax, 1
	jmp	short l_return
l_returnZero:
	sub	ax, ax
l_return:
	push	ax
	push	fs
	push	word ptr [bp+dataP]
	push	cs
	call	near ptr mapvm_if
	add	sp, 6
	pop	si
	mov	sp, bp
	pop	bp
	retf
mfunc_ifInBox endp

; Attributes: bp-based frame

mfunc_setLiquid proc far

	inventoryP= dword ptr -6
	liquidNumber= word ptr	-2
	dataP= dword ptr  6

	push	bp
	mov	bp, sp
	mov	ax, 6
	call	someStackOperation
	lfs	bx, [bp+dataP]
	inc	word ptr [bp+dataP]
	mov	al, fs:[bx]
	sub	ah, ah
	shl	ax, 1
	shl	ax, 1
	mov	[bp+liquidNumber], ax
	mov	al, 78h	
	mul	gs:g_userSlotNumber
	mov	cl, gs:g_usedItemSlotNumber
	sub	ch, ch
	add	ax, cx
	add	ax, offset party.inventory
	mov	word ptr [bp+inventoryP], ax
	mov	word ptr [bp+inventoryP+2], seg seg027
	lfs	bx, [bp+inventoryP]
	mov	al, fs:[bx]
	and	al, 0C3h
	or	al, byte ptr [bp+liquidNumber]
	mov	fs:[bx], al
	mov	ax, word ptr [bp+dataP]
	mov	dx, word ptr [bp+dataP+2]
	mov	sp, bp
	pop	bp
	retf
mfunc_setLiquid endp

; Attributes: bp-based frame

mfunc_addToContainer proc far

	var_4= word ptr	-4
	addAmount= word ptr	-2
	dataP= dword ptr  6

	push	bp
	mov	bp, sp
	mov	ax, 4
	call	someStackOperation
	push	si

	mov	al, 78h	
	mul	gs:g_userSlotNumber
	mov	si, ax
	mov	al, gs:g_usedItemSlotNumber
	sub	ah, ah
	add	si, ax
	mov	al, gs:party.inventory.itemCount[si]
	lfs	bx, [bp+dataP]
	inc	word ptr [bp+dataP]
	mov	cl, fs:[bx]
	sub	ch, ch
	add	ax, cx
	mov	[bp+addAmount], ax
	mov	al, gs:party.inventory.itemNo[si]
	sub	ah, ah
	mov	[bp+var_4], ax
	cmp	[bp+addAmount], 0FEh 
	jle	short loc_1A1FC
	mov	[bp+addAmount], 0FEh 
loc_1A1FC:
	mov	bx, [bp+var_4]
	mov	al, g_itemBaseCount[bx]
	sub	ah, ah
	sub	ax, [bp+addAmount]
	sbb	cx, cx
	and	ax, cx
	add	ax, [bp+addAmount]
	mov	cx, ax
	mov	al, 78h	
	mul	gs:g_userSlotNumber
	mov	bx, ax
	mov	al, gs:g_usedItemSlotNumber
	sub	ah, ah
	add	bx, ax
	mov	gs:party.inventory.itemCount[bx], cl
	mov	ax, word ptr [bp+dataP]
	mov	dx, word ptr [bp+dataP+2]
	pop	si
	mov	sp, bp
	pop	bp
	retf
mfunc_addToContainer endp

; Attributes: bp-based frame

mfunc_subtractFromContainer proc far

	itemCountP= dword ptr -0Ah
	var_4= word ptr	-4
	subtractAmount= word ptr	-2
	dataP= dword ptr  6

	push	bp
	mov	bp, sp
	mov	ax, 0Ah
	call	someStackOperation
	mov	al, 78h	
	mul	gs:g_userSlotNumber
	mov	cl, gs:g_usedItemSlotNumber
	sub	ch, ch
	add	ax, cx
	add	ax, offset party.inventory.itemCount
	mov	word ptr [bp+itemCountP], ax
	mov	word ptr [bp+itemCountP+2], seg seg027
	lfs	bx, [bp+itemCountP]
	mov	al, fs:[bx]
	sub	ah, ah
	mov	[bp+subtractAmount], ax
	lfs	bx, [bp+dataP]
	inc	word ptr [bp+dataP]
	mov	al, fs:[bx]
	mov	[bp+var_4], ax
	cmp	[bp+subtractAmount], 0FEh 
	jz	short l_return
	cmp	[bp+subtractAmount], ax
	jl	short l_setToZero
	mov	al, byte ptr [bp+subtractAmount]
	sub	al, byte ptr [bp+var_4]
	jmp	short l_setCount
l_setToZero:
	sub	al, al
l_setCount:
	lfs	bx, [bp+itemCountP]
	mov	fs:[bx], al
l_return:
	mov	ax, word ptr [bp+dataP]
	mov	dx, word ptr [bp+dataP+2]
	mov	sp, bp
	pop	bp
	retf
mfunc_subtractFromContainer endp

; Attributes: bp-based frame

mfunc_addToRegister proc far

	registerNumber= word ptr	-4
	addAmount= word ptr	-2
	dataP= dword ptr  6

	push	bp
	mov	bp, sp
	mov	ax, 4
	call	someStackOperation

	lfs	bx, [bp+dataP]
	inc	word ptr [bp+dataP]
	mov	al, fs:[bx]
	sub	ah, ah
	mov	[bp+registerNumber], ax

	mov	bx, word ptr [bp+dataP]
	inc	word ptr [bp+dataP]
	mov	al, fs:[bx]
	mov	[bp+addAmount], ax

	mov	bx, word ptr [bp+dataP]
	inc	word ptr [bp+dataP]
	mov	ah, fs:[bx]
	sub	al, al
	add	[bp+addAmount], ax
	mov	ax, [bp+addAmount]
	mov	bx, [bp+registerNumber]
	shl	bx, 1
	add	g_vm_registers[bx], ax
	mov	ax, word ptr [bp+dataP]
	mov	dx, word ptr [bp+dataP+2]
	mov	sp, bp
	pop	bp
	retf
mfunc_addToRegister endp

; Attributes: bp-based frame

mfunc_subtractFromRegister proc far

	registerNumber= word ptr -4
	subtractAmount= word ptr	-2
	dataP= dword ptr  6

	push	bp
	mov	bp, sp
	mov	ax, 4
	call	someStackOperation
	lfs	bx, [bp+dataP]
	inc	word ptr [bp+dataP]
	mov	al, fs:[bx]
	sub	ah, ah
	mov	[bp+registerNumber], ax

	mov	bx, word ptr [bp+dataP]
	inc	word ptr [bp+dataP]
	mov	al, fs:[bx]
	mov	[bp+subtractAmount], ax
	mov	bx, word ptr [bp+dataP]
	inc	word ptr [bp+dataP]
	mov	ah, fs:[bx]
	sub	al, al
	add	[bp+subtractAmount], ax

	mov	ax, [bp+subtractAmount]
	mov	bx, [bp+registerNumber]
	shl	bx, 1
	sub	g_vm_registers[bx], ax
	mov	ax, word ptr [bp+dataP]
	mov	dx, word ptr [bp+dataP+2]
	mov	sp, bp
	pop	bp
	retf
mfunc_subtractFromRegister endp

; Attributes: bp-based frame
mfunc_setDirection proc	far

	dataP= dword ptr  6

	push	bp
	mov	bp, sp
	lfs	bx, [bp+dataP]
	inc	word ptr [bp+dataP]
	mov	al, fs:[bx]
	sub	ah, ah
	mov	g_direction, ax
	mov	ax, word ptr [bp+dataP]
	mov	dx, word ptr [bp+dataP+2]
	mov	sp, bp
	pop	bp
	retf
mfunc_setDirection endp

; Attributes: bp-based frame

mfunc_readString proc far

	loopCounter= word ptr	-2
	dataP= dword ptr	 6

	push	bp
	mov	bp, sp
	mov	ax, 2
	call	someStackOperation
	mov	ax, 10h
	push	ax
	mov	ax, offset mfunc_ioBuf
	mov	dx, seg	seg027
	push	dx
	push	ax
	call	readString
	add	sp, 6

	mov	[bp+loopCounter], 0
l_loop:
	mov	bx, [bp+loopCounter]
	mov	al, gs:mfunc_ioBuf[bx]
	sub	ah, ah
	push	ax
	call	toUpper
	add	sp, 2
	mov	bx, [bp+loopCounter]
	mov	gs:mfunc_ioBuf[bx], al
	inc	[bp+loopCounter]
	cmp	[bp+loopCounter], 10h
	jl	short l_loop

	mov	ax, word ptr [bp+dataP]
	mov	dx, word ptr [bp+dataP+2]
	mov	sp, bp
	pop	bp
	retf
mfunc_readString endp

; Attributes: bp-based frame
vm_strcmp proc	far

	dataP= dword ptr  6
	stringBuffer= dword ptr  0Ah

	push	bp
	mov	bp, sp
l_loop:
	lfs	bx, [bp+dataP]
	mov	al, fs:[bx]
	and	al, 7Fh
	lfs	bx, [bp+stringBuffer]
	inc	word ptr [bp+stringBuffer]
	cmp	al, fs:[bx]
	jnz	short l_doneComparing
	inc	word ptr [bp+dataP]
	jmp	short l_loop
l_doneComparing:
	lfs	bx, [bp+dataP]
	cmp	byte ptr fs:[bx], 0FFh
	jnz	short l_returnZero
	mov	ax, 1
	jmp	short l_return
l_returnZero:
	sub	ax, ax
l_return:
	mov	sp, bp
	pop	bp
	retf
vm_strcmp endp

; Attributes: bp-based frame

mfunc_ifStringEquals proc far

	rval= word ptr	-2
	dataP= dword ptr  6

	push	bp
	mov	bp, sp
	mov	ax, 2
	call	someStackOperation
	mov	ax, offset mfunc_ioBuf
	mov	dx, seg	seg027
	push	dx
	push	ax
	push	word ptr [bp+dataP+2]
	push	word ptr [bp+dataP]
	push	cs
	call	near ptr vm_strcmp
	add	sp, 8
	mov	[bp+rval], ax

l_skipString:
	lfs	bx, [bp+dataP]
	inc	word ptr [bp+dataP]
	cmp	byte ptr fs:[bx], 0FFh
	jnz	short l_skipString

	push	[bp+rval]
	push	fs
	push	word ptr [bp+dataP]
	push	cs
	call	near ptr mapvm_if
	add	sp, 6
	mov	sp, bp
	pop	bp
	retf
mfunc_ifStringEquals endp

; Attributes: bp-based frame

mfunc_parseNumber proc far

	registerNumber= word ptr	-4
	value= word ptr	-2
	dataP= dword ptr  6

	push	bp
	mov	bp, sp
	mov	ax, 4
	call	someStackOperation
	lfs	bx, [bp+dataP]
	inc	word ptr [bp+dataP]
	mov	al, fs:[bx]
	sub	ah, ah
	mov	[bp+registerNumber], ax
	lea	ax, [bp+value]
	push	ss
	push	ax
	mov	ax, offset s_percentD
	push	ds
	push	ax
	mov	ax, offset mfunc_ioBuf
	mov	dx, seg	seg027
	push	dx
	push	ax
	call	sscanf
	add	sp, 0Ch
	mov	ax, [bp+value]
	mov	bx, [bp+registerNumber]
	shl	bx, 1
	mov	g_vm_registers[bx], ax
	mov	ax, word ptr [bp+dataP]
	mov	dx, word ptr [bp+dataP+2]
	mov	sp, bp
	pop	bp
	retf
mfunc_parseNumber endp

; Attributes: bp-based frame
mfunc_getCharacter proc	far

	slotNumber= word ptr	-2
	dataP= dword ptr	 6

	push	bp
	mov	bp, sp
	mov	ax, 2
	call	someStackOperation
	call	readSlotNumber
	mov	[bp+slotNumber], ax
	or	ax, ax
	jl	short loc_1A4CA
	mov	al, byte ptr [bp+slotNumber]
	mov	gs:g_userSlotNumber, al
loc_1A4CA:
	cmp	[bp+slotNumber], 0
	jl	short l_returnZero
	mov	ax, 1
	jmp	short l_return
l_returnZero:
	sub	ax, ax
l_return:
	push	ax
	push	word ptr [bp+dataP+2]
	push	word ptr [bp+dataP]
	push	cs
	call	near ptr mapvm_if
	add	sp, 6
	mov	sp, bp
	pop	bp
	retf
mfunc_getCharacter endp

; Attributes: bp-based frame
;
; Remove an amount of gold from a player. The amount is stored
; in the register specified.
;

mfunc_ifGiveGold proc far

	registerAmountLo= word ptr	-0Ah
	registerAmountHi= word ptr	-8
	registerNumber= word ptr	-6
	memberGoldLo= word ptr	-4
	memberGoldHi= word ptr	-2
	dataP= dword ptr  6

	push	bp
	mov	bp, sp
	mov	ax, 0Ah
	call	someStackOperation

	lfs	bx, [bp+dataP]
	inc	word ptr [bp+dataP]
	mov	al, fs:[bx]
	sub	ah, ah
	mov	[bp+registerNumber], ax
	mov	al, 78h	
	mul	gs:g_userSlotNumber
	mov	bx, ax
	mov	ax, word ptr gs:party.gold[bx]
	mov	dx, word ptr gs:(party.gold+2)[bx]
	mov	[bp+memberGoldLo], ax
	mov	[bp+memberGoldHi], dx

	mov	bx, [bp+registerNumber]
	shl	bx, 1
	mov	ax, g_vm_registers[bx]
	cwd
	mov	[bp+registerAmountLo], ax
	mov	[bp+registerAmountHi], dx

	mov	ax, [bp+memberGoldLo]
	mov	dx, [bp+memberGoldHi]
	cmp	[bp+registerAmountHi], dx
	ja	short l_notEnough
	jb	short l_removeGold
	cmp	[bp+registerAmountLo], ax
	ja	short l_notEnough

l_removeGold:
	mov	ax, [bp+registerAmountLo]
	mov	dx, [bp+registerAmountHi]
	mov	cx, ax
	mov	al, 78h	
	mul	gs:g_userSlotNumber
	mov	bx, ax
	sub	word ptr gs:party.gold[bx], cx
	sbb	word ptr gs:(party.gold+2)[bx], dx
	jmp	short l_setReturnValue

l_notEnough:
	mov	ax, offset s_youDontHaveEnoughGold
	push	ds
	push	ax
	call	printString
	add	sp, 4
	mov	ax, 3
	push	ax
	call	text_delayNoTable
	add	sp, 2

l_setReturnValue:
	mov	bx, [bp+registerNumber]
	shl	bx, 1
	mov	ax, g_vm_registers[bx]
	cwd
	cmp	dx, [bp+memberGoldHi]
	ja	short l_returnZero
	jb	short l_returnOne
	cmp	ax, [bp+memberGoldLo]
	ja	short l_returnZero

l_returnOne:
	mov	ax, 1
	jmp	short l_return

l_returnZero:
	sub	ax, ax

l_return:
	push	ax
	push	word ptr [bp+dataP+2]
	push	word ptr [bp+dataP]
	push	cs
	call	near ptr mapvm_if
	add	sp, 6
	mov	sp, bp
	pop	bp
	retf
mfunc_ifGiveGold endp

; Attributes: bp-based frame

mfunc_addGold proc far

	dataP= dword ptr  6

	push	bp
	mov	bp, sp
	lfs	bx, [bp+dataP]
	inc	word ptr [bp+dataP]
	mov	al, fs:[bx]
	sub	ah, ah
	mov	bx, ax
	shl	bx, 1
	mov	ax, g_vm_registers[bx]
	cwd
	mov	cx, ax
	mov	al, 78h	
	mul	gs:g_userSlotNumber
	mov	bx, ax
	add	word ptr gs:party.gold[bx], cx
	adc	word ptr gs:(party.gold+2)[bx], dx
	mov	ax, word ptr [bp+dataP]
	mov	dx, word ptr [bp+dataP+2]
	mov	sp, bp
	pop	bp
	retf
mfunc_addGold endp

; Attributes: bp-based frame

mfunc_ifRegisterLt proc far

	registerNumber= word ptr	-4
	comparisonAmount= word ptr	-2
	dataP= dword ptr  6

	push	bp
	mov	bp, sp
	mov	ax, 4
	call	someStackOperation
	lfs	bx, [bp+dataP]
	inc	word ptr [bp+dataP]
	mov	al, fs:[bx]
	sub	ah, ah
	mov	[bp+registerNumber], ax

	mov	bx, word ptr [bp+dataP]
	inc	word ptr [bp+dataP]
	mov	al, fs:[bx]
	mov	[bp+comparisonAmount], ax

	mov	bx, word ptr [bp+dataP]
	inc	word ptr [bp+dataP]
	mov	ah, fs:[bx]
	sub	al, al
	add	[bp+comparisonAmount], ax

	mov	ax, [bp+comparisonAmount]
	mov	bx, [bp+registerNumber]
	shl	bx, 1
	cmp	g_vm_registers[bx], ax
	jge	short l_setToZero
	mov	ax, 1
	jmp	short l_return
l_setToZero:
	sub	ax, ax
l_return:
	push	ax
	push	word ptr [bp+dataP+2]
	push	word ptr [bp+dataP]
	push	cs
	call	near ptr mapvm_if
	add	sp, 6
	mov	sp, bp
	pop	bp
	retf
mfunc_ifRegisterLt endp

; Attributes: bp-based frame

mfunc_ifRegisterEq proc far
	registerNumber= word ptr	-4
	comparisonAmount= word ptr	-2
	dataP= dword ptr  6

	push	bp
	mov	bp, sp
	mov	ax, 4
	call	someStackOperation
	lfs	bx, [bp+dataP]
	inc	word ptr [bp+dataP]
	mov	al, fs:[bx]
	sub	ah, ah
	mov	[bp+registerNumber], ax

	mov	bx, word ptr [bp+dataP]
	inc	word ptr [bp+dataP]
	mov	al, fs:[bx]
	mov	[bp+comparisonAmount], ax
	mov	bx, word ptr [bp+dataP]
	inc	word ptr [bp+dataP]
	mov	ah, fs:[bx]
	sub	al, al
	add	[bp+comparisonAmount], ax
	mov	ax, [bp+comparisonAmount]
	mov	bx, [bp+registerNumber]
	shl	bx, 1
	cmp	g_vm_registers[bx], ax
	jnz	short l_setToZero
	mov	ax, 1
	jmp	short l_return
l_setToZero:
	sub	ax, ax
l_return:
	push	ax
	push	word ptr [bp+dataP+2]
	push	word ptr [bp+dataP]
	push	cs
	call	near ptr mapvm_if
	add	sp, 6
	mov	sp, bp
	pop	bp
	retf
mfunc_ifRegisterEq endp

; Attributes: bp-based frame

mfunc_ifRegisterGe proc far

	registerNumber= word ptr	-4
	comparisonAmount= word ptr	-2
	dataP= dword ptr  6

	push	bp
	mov	bp, sp
	mov	ax, 4
	call	someStackOperation
	lfs	bx, [bp+dataP]
	inc	word ptr [bp+dataP]
	mov	al, fs:[bx]
	sub	ah, ah
	mov	[bp+registerNumber], ax
	mov	bx, word ptr [bp+dataP]
	inc	word ptr [bp+dataP]
	mov	al, fs:[bx]
	mov	[bp+comparisonAmount], ax
	mov	bx, word ptr [bp+dataP]
	inc	word ptr [bp+dataP]
	mov	ah, fs:[bx]
	sub	al, al
	add	[bp+comparisonAmount], ax
	mov	ax, [bp+comparisonAmount]
	mov	bx, [bp+registerNumber]
	shl	bx, 1
	cmp	g_vm_registers[bx], ax
	jl	short l_setToZero
	mov	ax, 1
	jmp	short l_return
l_setToZero:
	sub	ax, ax
l_return:
	push	ax
	push	word ptr [bp+dataP+2]
	push	word ptr [bp+dataP]
	push	cs
	call	near ptr mapvm_if
	add	sp, 6
	mov	sp, bp
	pop	bp
	retf
mfunc_ifRegisterGe endp

; Attributes: bp-based frame

mfunc_learnSpell proc far

	dataP= dword ptr  6

	push	bp
	mov	bp, sp
	lfs	bx, [bp+dataP]
	inc	word ptr [bp+dataP]
	mov	al, fs:[bx]
	sub	ah, ah
	push	ax
	mov	al, gs:g_userSlotNumber
	push	ax
	call	character_learnSpell
	add	sp, 4
	mov	ax, word ptr [bp+dataP]
	mov	dx, word ptr [bp+dataP+2]
	mov	sp, bp
	pop	bp
	retf
mfunc_learnSpell endp

; Attributes: bp-based frame

mfunc_setRegister proc far

	registerNumber=	word ptr -4
	setAmount= word ptr -2
	dataP=	dword ptr  6

	push	bp
	mov	bp, sp
	mov	ax, 4
	call	someStackOperation
	lfs	bx, [bp+dataP]
	inc	word ptr [bp+dataP]
	mov	al, fs:[bx]
	sub	ah, ah
	mov	[bp+registerNumber], ax

	mov	bx, word ptr [bp+dataP]
	inc	word ptr [bp+dataP]
	mov	al, fs:[bx]
	mov	[bp+setAmount], ax

	mov	bx, word ptr [bp+dataP]
	inc	word ptr [bp+dataP]
	mov	ah, fs:[bx]
	sub	al, al
	add	[bp+setAmount], ax

	mov	ax, [bp+setAmount]
	mov	bx, [bp+registerNumber]
	shl	bx, 1
	mov	g_vm_registers[bx], ax
	mov	ax, word ptr [bp+dataP]
	mov	dx, word ptr [bp+dataP+2]
	mov	sp, bp
	pop	bp
	retf
mfunc_setRegister endp

; Attributes: bp-based frame

mfunc_ifHasItem proc far

	itemNumber= word ptr	-2
	dataP= dword ptr  6

	push	bp
	mov	bp, sp
	mov	ax, 2
	call	someStackOperation
	lfs	bx, [bp+dataP]
	inc	word ptr [bp+dataP]
	mov	al, fs:[bx]
	sub	ah, ah
	mov	[bp+itemNumber], ax
	mov	al, 78h	
	mul	gs:g_userSlotNumber
	mov	bx, ax
	mov	al, gs:g_usedItemSlotNumber
	sub	ah, ah
	add	bx, ax
	mov	al, gs:party.inventory.itemNo[bx]
	cmp	ax, [bp+itemNumber]
	jnz	short l_setToZero
	mov	ax, 1
	jmp	short l_return
l_setToZero:
	sub	ax, ax
l_return:
	push	ax
	push	word ptr [bp+dataP+2]
	push	word ptr [bp+dataP]
	push	cs
	call	near ptr mapvm_if
	add	sp, 6
	mov	sp, bp
	pop	bp
	retf
mfunc_ifHasItem endp

; Attributes: bp-based frame
mfunc_packInventory proc	far

	dataP= dword ptr	 6

	push	bp
	mov	bp, sp
	mov	al, gs:g_userSlotNumber
	sub	ah, ah
	mov	gs:g_inventoryPackTarget, ax
	mov	al, gs:g_usedItemSlotNumber
	mov	gs:g_inventoryPackStart, ax
	call	inventory_pack
	mov	ax, word ptr [bp+dataP]
	mov	dx, word ptr [bp+dataP+2]
	mov	sp, bp
	pop	bp
	retf
mfunc_packInventory endp

; Attributes: bp-based frame

mfunc_addMonster proc far

	monsterIndex= word ptr	-4
	slotNumber= word ptr	-2
	dataP= dword ptr  6

	push	bp
	mov	bp, sp
	mov	ax, 4
	call	someStackOperation
	lfs	bx, [bp+dataP]
	inc	word ptr [bp+dataP]
	mov	al, fs:[bx]
	sub	ah, ah
	mov	[bp+monsterIndex], ax

	call	party_findEmptySlot
	mov	[bp+slotNumber], ax
	cmp	ax, 7
	jge	short l_setReturnValue

	mov	ax, monStruSize
	imul	[bp+monsterIndex]
	mov	bx, ax
	lea	ax, monsterBuf[bx]
	mov	dx, seg	seg023
	push	dx
	push	ax
	push	[bp+slotNumber]
	call	_sp_convertMonToSummon
	add	sp, 6
	mov	byte ptr g_printPartyFlag,	0

l_setReturnValue:
	cmp	[bp+slotNumber], 7
	jge	short l_returnZero
	mov	ax, 1
	jmp	short l_return

l_returnZero:
	sub	ax, ax

l_return:
	push	ax
	push	word ptr [bp+dataP+2]
	push	word ptr [bp+dataP]
	call	mapvm_if
	add	sp, 6
	mov	sp, bp
	pop	bp
	retf
mfunc_addMonster endp

; Attributes: bp-based frame
mfunc_ifMonsterInParty proc	far

	rval= word ptr	-4
	slotNumber= word ptr	-2
	dataP= dword ptr  6

	push	bp
	mov	bp, sp
	mov	ax, 4
	call	someStackOperation
	push	si

	mov	[bp+rval], 0
	mov	[bp+slotNumber], 0

l_loop:
	mov	ax, charSize
	imul	[bp+slotNumber]
	mov	si, ax
	cmp	gs:party.class[si], class_monster
	jnz	short l_next
	lea	ax, party._name[si]
	mov	dx, seg	seg027
	push	dx
	push	ax
	push	word ptr [bp+dataP+2]
	push	word ptr [bp+dataP]
	push	cs
	call	near ptr vm_strcmp
	add	sp, 8
	or	ax, ax
	jz	short l_next
	mov	[bp+rval], 1
	jmp	short l_skipString

l_next:
	inc	[bp+slotNumber]
	cmp	[bp+slotNumber], 7
	jl	short l_loop

l_skipString:
	lfs	bx, [bp+dataP]
	inc	word ptr [bp+dataP]
	cmp	byte ptr fs:[bx], 0FFh
	jnz	short l_skipString

	mov	al, byte ptr [bp+slotNumber]
	mov	gs:g_userSlotNumber, al
	push	[bp+rval]
	push	word ptr [bp+dataP+2]
	push	word ptr [bp+dataP]
	call	mapvm_if
	add	sp, 6

	pop	si
	mov	sp, bp
	pop	bp
	retf
mfunc_ifMonsterInParty endp

; Attributes: bp-based frame

mfunc_clearPrintOffset proc far

	dataP= dword ptr	 6

	push	bp
	mov	bp, sp
	call	text_clear
	push	word ptr [bp+dataP+2]
	push	word ptr [bp+dataP]
	call	mfunc_printOffset
	add	sp, 4
	mov	sp, bp
	pop	bp
	retf
mfunc_clearPrintOffset endp

; Attributes: bp-based frame

mfunc_ifIsNight	proc far

	dataP= dword ptr	 6

	push	bp
	mov	bp, sp
	cmp	gs:isNight, 1
	sbb	ax, ax
	neg	ax
	push	ax
	push	word ptr [bp+dataP+2]
	push	word ptr [bp+dataP]
	push	cs
	call	near ptr mapvm_if
	add	sp, 6
	mov	sp, bp
	pop	bp
	retf
mfunc_ifIsNight	endp

; Attributes: bp-based frame

mfunc_removeMonster proc far

	arg_0= dword ptr	 6

	push	bp
	mov	bp, sp
	mov	al, gs:g_userSlotNumber
	sub	ah, ah
	push	ax
	call	party_pack
	add	sp, 2
	mov	byte ptr g_printPartyFlag,	0
	mov	ax, word ptr [bp+arg_0]
	mov	dx, word ptr [bp+arg_0+2]
	mov	sp, bp
	pop	bp
	retf
mfunc_removeMonster endp

; Attributes: bp-based frame
;
; This function searches the party to see if a particular
; chronomancer quest flag bit is set. If the quest flag bit
; is set, then the rval local variable is set to 1. Otherwise, the
; rval variable is set to 0
;
; The bug is caused by the call to quest_partyHasFlagSet. That function
; performs the same function as this one. In fact, this entire function
; could be replaced with:
;
;	push	bp
	mov	bp, sp
;	lfs	bx, [bp+dataP]
;	mov	al, fs:[bx]
;	sub	ah, ah
;	push	ax
;	push	cs
	call	near ptr quest_partyHasFlagSet
	add	sp, 2
;	push	ax
;	push	word ptr [bp+dataP+2]
;	push	word ptr [bp+dataP]
;	mov	sp, bp
	pop	bp
;
; quest_partyHasFlagSet is called with either a 0 or 1 when it SHOULD be called
; by the questData byte from the level.
;
; I've replaced the call to this function in the vm_functionList list with a call to
; mfunc_notImplemented. From my decompiling of the levels, this opcode (3d) is never
; called so it should be safe to do this.

mfunc_buggedIfQuestFlagSet proc far

	questByteNumber= word ptr	-8
	questMaskIndex= word ptr	-6
	rval= word ptr	-4
	slotNumber= word ptr	-2
	dataP= dword ptr  6

	push	bp
	mov	bp, sp
	mov	ax, 8
	call	someStackOperation
	lfs	bx, [bp+dataP]
	mov	al, fs:[bx]
	sub	ah, ah
	and	ax, 7
	mov	[bp+questMaskIndex], ax

	inc	word ptr [bp+dataP]
	mov	al, fs:[bx]
	sub	ah, ah
	mov	cl, 3
	shr	ax, cl
	mov	[bp+questByteNumber], ax

	mov	[bp+rval], 0
	mov	[bp+slotNumber], 0
l_loop:
	mov	ax, charSize
	imul	[bp+slotNumber]
	mov	bx, ax
	add	bx, [bp+questByteNumber]
	mov	al, gs:party.chronoQuest[bx]
	sub	ah, ah
	mov	bx, [bp+questMaskIndex]
	mov	cl, byteMaskList[bx]
	sub	ch, ch
	test	ax, cx
	jz	short l_next
	mov	[bp+rval], 1
	jmp	short l_return

l_next:
	inc	[bp+slotNumber]
	cmp	[bp+slotNumber], 7
	jl	short l_loop

l_return:
	push	[bp+rval]
	push	cs
	call	near ptr quest_partyHasFlagSet
	add	sp, 2
	push	ax
	push	word ptr [bp+dataP+2]
	push	word ptr [bp+dataP]
	push	cs
	call	near ptr mapvm_if
	add	sp, 6
	mov	sp, bp
	pop	bp
	retf
mfunc_buggedIfQuestFlagSet endp

; This function	returns	1 if there is a	character
; in the party that has	the bit	set in chronoQuest
; that matches the passed in quest mask.
; Attributes: bp-based frame
quest_partyHasFlagSet proc	far

	questMaskIndex=	word ptr -8
	rval= word ptr -6
	slotNumber=	word ptr -4
	questByteNumber= word ptr	-2
	questData= word	ptr  6

	push	bp
	mov	bp, sp
	mov	ax, 8
	call	someStackOperation
	push	si

	mov	ax, [bp+questData]
	and	ax, 7
	mov	[bp+questMaskIndex], ax
	mov	ax, [bp+questData]
	mov	cl, 3
	sar	ax, cl
	mov	[bp+questByteNumber], ax
	mov	[bp+rval], 0
	mov	[bp+slotNumber], 0

l_loop:
	mov	ax, charSize
	imul	[bp+slotNumber]
	mov	si, ax
	cmp	byte ptr gs:party._name[si], 0
	jz	short l_next
	cmp	gs:party.class[si], class_monster
	jnb	short l_next
	mov	bx, [bp+questByteNumber]
	add	bx, si
	mov	al, gs:party.chronoQuest[bx]
	sub	ah, ah
	mov	bx, [bp+questMaskIndex]
	mov	cl, byteMaskList[bx]
	sub	ch, ch
	test	ax, cx
	jz	short l_next
	mov	[bp+rval], 1
	jmp	short l_return

l_next:
	inc	[bp+slotNumber]
	cmp	[bp+slotNumber], 7
	jl	short l_loop

l_return:
	mov	ax, [bp+rval]
	pop	si
	mov	sp, bp
	pop	bp
	retf
quest_partyHasFlagSet endp

; Attributes: bp-based frame

mfunc_ifQuestFlagNotSet proc far

	dataP= dword ptr  6

	push	bp
	mov	bp, sp
	lfs	bx, [bp+dataP]
	inc	word ptr [bp+dataP]
	mov	al, fs:[bx]
	sub	ah, ah
	push	ax
	push	cs
	call	near ptr quest_partyNotHasFlagSet
	add	sp, 2
	push	ax
	push	word ptr [bp+dataP+2]
	push	word ptr [bp+dataP]
	push	cs
	call	near ptr mapvm_if
	add	sp, 6
	mov	sp, bp
	pop	bp
	retf
mfunc_ifQuestFlagNotSet endp

; This function	returns	one if there is	a character
; in the party that does NOT have the quest mask
; set.
; Attributes: bp-based frame

quest_partyNotHasFlagSet proc far

	questMaskIndex= word ptr	-8
	rval= word ptr -6
	slotNumber=	word ptr -4
	questByteNumber= word ptr	-2
	questData= word	ptr  6

	push	bp
	mov	bp, sp
	mov	ax, 8
	call	someStackOperation
	push	si

	mov	ax, [bp+questData]
	and	ax, 7
	mov	[bp+questMaskIndex], ax

	mov	ax, [bp+questData]
	mov	cl, 3
	sar	ax, cl
	mov	[bp+questByteNumber], ax

	mov	[bp+rval], 0
	mov	[bp+slotNumber], 0

l_loop:
	mov	ax, charSize
	imul	[bp+slotNumber]
	mov	si, ax
	cmp	byte ptr gs:party._name[si], 0
	jz	short l_next
	cmp	gs:party.class[si], class_monster
	jnb	short l_next
	mov	bx, [bp+questByteNumber]
	add	bx, si
	mov	al, gs:party.chronoQuest[bx]
	sub	ah, ah
	mov	bx, [bp+questMaskIndex]
	mov	cl, byteMaskList[bx]
	sub	ch, ch
	test	ax, cx
	jnz	short l_next
	mov	[bp+rval], 1
	jmp	short l_return

l_next:
	inc	[bp+slotNumber]
	cmp	[bp+slotNumber], 7
	jl	short l_loop

l_return:
	mov	ax, [bp+rval]
	pop	si
	mov	sp, bp
	pop	bp
	retf
quest_partyNotHasFlagSet endp

; Attributes: bp-based frame

mfunc_setQuestFlag	proc far

	dataP= dword ptr  6

	push	bp
	mov	bp, sp
	lfs	bx, [bp+dataP]
	inc	word ptr [bp+dataP]
	mov	al, fs:[bx]
	sub	ah, ah
	push	ax
	push	cs
	call	near ptr quest_setFlag
	add	sp, 2
	mov	ax, word ptr [bp+dataP]
	mov	dx, word ptr [bp+dataP+2]
	mov	sp, bp
	pop	bp
	retf
mfunc_setQuestFlag	endp

; Attributes: bp-based frame
quest_setFlag proc	far

	questMaskIndex= word ptr	-6
	slotNumber=	word ptr -4
	questByteNumber= word ptr	-2
	questData= word ptr	 6

	push	bp
	mov	bp, sp
	mov	ax, 6
	call	someStackOperation
	push	si

	mov	ax, [bp+questData]
	and	ax, 7
	mov	[bp+questMaskIndex], ax

	mov	ax, [bp+questData]
	mov	cl, 3
	sar	ax, cl
	mov	[bp+questByteNumber], ax

	mov	[bp+slotNumber], 0

l_loop:
	mov	ax, charSize
	imul	[bp+slotNumber]
	mov	si, ax
	cmp	gs:party.class[si], class_monster
	jnb	short l_next
	cmp	byte ptr gs:party._name[si], 0
	jz	short l_next
	mov	bx, [bp+questMaskIndex]
	mov	al, byteMaskList[bx]
	mov	bx, [bp+questByteNumber]
	add	bx, si
	or	gs:party.chronoQuest[bx], al

l_next:
	inc	[bp+slotNumber]
	cmp	[bp+slotNumber], 7
	jl	short l_loop
	pop	si
	mov	sp, bp
	pop	bp
	retf
quest_setFlag endp

; Attributes: bp-based frame

mfunc_clearQuestFlag proc far

	questMaskIndex= word ptr	-8
	rval= word ptr	-6
	questByteNumber= word ptr	-2
	dataP= dword ptr  6

	push	bp
	mov	bp, sp
	mov	ax, 8
	call	someStackOperation
	push	si

	lfs	bx, [bp+dataP]
	mov	al, fs:[bx]
	sub	ah, ah
	and	ax, 7
	mov	[bp+questMaskIndex], ax

	inc	word ptr [bp+dataP]
	mov	al, fs:[bx]
	sub	ah, ah
	mov	cl, 3
	shr	ax, cl
	mov	[bp+questByteNumber], ax

	mov	[bp+rval], 0
l_loop:
	mov	ax, charSize
	imul	[bp+rval]
	mov	si, ax
	cmp	gs:party.class[si], class_monster
	jnb	short l_next
	cmp	byte ptr gs:party._name[si], 0
	jz	short l_next
	mov	bx, [bp+questMaskIndex]
	mov	al, flagMaskList[bx]
	mov	bx, [bp+questByteNumber]
	add	bx, si
	and	gs:party.chronoQuest[bx], al

l_next:
	inc	[bp+rval]
	cmp	[bp+rval], 7
	jl	short l_loop

	mov	ax, word ptr [bp+dataP]
	mov	dx, word ptr [bp+dataP+2]
	pop	si
	mov	sp, bp
	pop	bp
	retf
mfunc_clearQuestFlag endp

; Attributes: bp-based frame

mfunc_partyUnderLevel proc far

	dataP= dword ptr  6

	push	bp
	mov	bp, sp
	lfs	bx, [bp+dataP]
	inc	word ptr [bp+dataP]
	mov	al, fs:[bx]
	sub	ah, ah
	push	ax
	call	vm_partyUnderLevel
	add	sp, 2
	push	ax
	push	word ptr [bp+dataP+2]
	push	word ptr [bp+dataP]
	push	cs
	call	near ptr mapvm_if
	add	sp, 6
	mov	sp, bp
	pop	bp
	retf
mfunc_partyUnderLevel endp

; This function	returns	0 if there is a	character
; in the party whose level is less than	the passed
; in level. If there is	not it returns 1.
; Attributes: bp-based frame

vm_partyUnderLevel proc far

	rval= word ptr -4
	slotNumber= word ptr -2
	level= word ptr	 6

	push	bp
	mov	bp, sp
	mov	ax, 4
	call	someStackOperation
	push	si

	mov	[bp+rval], 1
	mov	[bp+slotNumber], 0

l_loop:
	mov	ax, charSize
	imul	[bp+slotNumber]
	mov	si, ax
	cmp	byte ptr gs:party._name[si], 0
	jz	short l_next
	mov	ax, [bp+level]
	cmp	gs:party.level[si], ax
	jnb	short l_next
	mov	[bp+rval], 0
	jmp	short l_return

l_next:
	inc	[bp+slotNumber]
	cmp	[bp+slotNumber], 7
	jl	short l_loop

l_return:
	mov	ax, [bp+rval]
	pop	si
	mov	sp, bp
	pop	bp
	retf
vm_partyUnderLevel endp

; Attributes: bp-based frame

mfunc_ifWildFace proc far

	sqN= word ptr	-6
	mapFace= word ptr	-4
	desiredFace= word ptr	-2
	dataP= dword ptr  6

	push	bp
	mov	bp, sp
	mov	ax, 6
	call	someStackOperation
	push	si

	lfs	bx, [bp+dataP]
	inc	word ptr [bp+dataP]
	mov	al, fs:[bx]
	sub	ah, ah
	mov	[bp+desiredFace], ax

	mov	si, g_direction
	shl	si, 1
	mov	ax, sq_north
	sub	ax, dirDeltaN[si]
	mov	[bp+sqN], ax

	mov	ax, dirDeltaE[si]
	add	ax, sq_east

	push	[bp+sqN]
	push	ax
	call	wild_getSquare
	add	sp, 4
	and	ax, 0Fh
	mov	[bp+mapFace], ax

	mov	ax, [bp+desiredFace]
	cmp	[bp+mapFace], ax
	jnz	short l_setToZero
	mov	ax, 1
	jmp	short l_return
l_setToZero:
	sub	ax, ax
l_return:
	push	ax
	push	word ptr [bp+dataP+2]
	push	word ptr [bp+dataP]
	push	cs
	call	near ptr mapvm_if
	add	sp, 6
	pop	si
	mov	sp, bp
	pop	bp
	retf
mfunc_ifWildFace endp

; Attributes: bp-based frame

mfunc_setWildFace proc far

	newFace= word ptr	-6
	sqE= word ptr	-4
	sqN= word ptr	-2
	dataP= dword ptr  6

	push	bp
	mov	bp, sp
	mov	ax, 6
	call	someStackOperation
	push	si

	lfs	bx, [bp+dataP]
	inc	word ptr [bp+dataP]
	mov	al, fs:[bx]
	sub	ah, ah
	mov	[bp+newFace], ax

	mov	si, g_direction
	shl	si, 1
	mov	ax, sq_north
	sub	ax, dirDeltaN[si]
	mov	[bp+sqN], ax

	mov	ax, dirDeltaE[si]
	add	ax, sq_east
	mov	[bp+sqE], ax

	cmp	gs:g_wildWrapFlag, 0
	jz	short l_skipWrap
	mov	al, gs:mapHeight
	sub	ah, ah
	push	ax
	push	[bp+sqN]
	call	wrapNumber
	add	sp, 4
	mov	[bp+sqN], ax
	mov	al, gs:mapWidth
	sub	ah, ah
	push	ax
	push	[bp+sqE]
	call	wrapNumber
	add	sp, 4
	mov	[bp+sqE], ax

l_skipWrap:
	cmp	[bp+sqN], 0
	jl	short l_return
	mov	al, gs:mapHeight
	sub	ah, ah
	cmp	ax, [bp+sqN]
	jb	short l_return
	cmp	[bp+sqE], 0
	jl	short l_return
	mov	al, gs:mapWidth
	cmp	ax, [bp+sqE]
	jb	short l_return
	mov	bx, [bp+sqN]
	shl	bx, 1
	shl	bx, 1
	lfs	bx, gs:rowOffset[bx]
	mov	si, [bp+sqE]
	mov	al, byte ptr [bp+newFace]
	mov	fs:[bx+si], al
l_return:
	mov	ax, word ptr [bp+dataP]
	mov	dx, word ptr [bp+dataP+2]
	pop	si
	mov	sp, bp
	pop	bp
	retf
mfunc_setWildFace endp

; Attributes: bp-based frame

mfunc_ifIsClass	proc far

	desiredClass= word ptr	-2
	dataP= dword ptr  6

	push	bp
	mov	bp, sp
	mov	ax, 2
	call	someStackOperation

	lfs	bx, [bp+dataP]
	inc	word ptr [bp+dataP]
	mov	al, fs:[bx]
	sub	ah, ah
	mov	[bp+desiredClass], ax

	mov	ax, charSize
	imul	gs:g_userSlotNumber
	mov	bx, ax
	mov	al, gs:party.class[bx]
	sub	ah, ah
	cmp	ax, [bp+desiredClass]
	jnz	short l_setToZero
	mov	ax, 1
	jmp	short l_return

l_setToZero:
	sub	ax, ax

l_return:
	push	ax
	push	word ptr [bp+dataP+2]
	push	word ptr [bp+dataP]
	push	cs
	call	near ptr mapvm_if
	add	sp, 6
	mov	sp, bp
	pop	bp
	retf
mfunc_ifIsClass	endp

; Attributes: bp-based frame
;
; DWORD var_102 & 104

mfunc_printOffset proc far

	var_104= word ptr -104h
	var_102= word ptr -102h
	stringBuffer= word ptr -100h
	dataP= dword ptr	 6

	push	bp
	mov	bp, sp
	mov	ax, 104h
	call	someStackOperation

	push	word ptr [bp+dataP+2]
	push	word ptr [bp+dataP]
	call	map_getDataOffsetP
	add	sp, 4
	mov	[bp+var_104], ax
	mov	[bp+var_102], dx
	add	[bp+dataP], 2
	lea	ax, [bp+stringBuffer]
	push	ss
	push	ax
	push	dx
	push	[bp+var_104]
	call	_mfunc_getString
	add	sp, 8
	lea	ax, [bp+stringBuffer]
	push	ss
	push	ax
	call	printString
	add	sp, 4
	mov	ax, word ptr [bp+dataP]
	mov	dx, word ptr [bp+dataP+2]
	mov	sp, bp
	pop	bp
	retf
mfunc_printOffset endp

; Attributes: bp-based frame

mfunc_clearTeleport proc far

	dataP= dword ptr	 6

	push	bp
	mov	bp, sp
	mov	ax, 0FEh
	push	ax
	call	bigpic_drawPictureNumber
	add	sp, 2
	push	word ptr [bp+dataP+2]
	push	word ptr [bp+dataP]
	push	cs
	call	near ptr mfunc_teleport
	add	sp, 4
	mov	sp, bp
	pop	bp
	retf
mfunc_clearTeleport endp

; Attributes: bp-based frame
;
; This function executes the level code based on the current square
; the party is on.
;
; There are some special values that affect function execution:
;   A sqN value of 7Fh executes the function regardless of the current sq_north value
;   A sqN value of FFh executes the function regardless of the current sq_north value iff
;     the vm_execute function is called as the result of a spell being cast. (spellFlag != 0)
;   A sqE value of FFh executes the function regardless of the current sq_east value

vm_execute proc far

	dataP= dword ptr -0Ch
	opcode=	word ptr -8
	functionCount= word	ptr -6
	sqN= word ptr -4
	sqE=	word ptr -2
	squareListP=	dword ptr  6
	spellFlag= word	ptr  0Ah

	push	bp
	mov	bp, sp
	mov	ax, 0Ch
	call	someStackOperation

	push	word ptr [bp+squareListP+2]
	push	word ptr [bp+squareListP]
	call	map_getDataOffsetP
	add	sp, 4
	mov	word ptr [bp+squareListP], ax
	mov	word ptr [bp+squareListP+2],	dx

	lfs	bx, [bp+squareListP]
	inc	word ptr [bp+squareListP]
	mov	al, fs:[bx]
	sub	ah, ah
	mov	[bp+functionCount],	ax
	mov	gs:mapRval, 0

l_loop:
	mov	ax, [bp+functionCount]
	dec	[bp+functionCount]
	or	ax, ax
	jz	l_returnRval

	lfs	bx, [bp+squareListP]
	mov	al, fs:[bx]
	sub	ah, ah
	mov	[bp+sqN], ax

	; Remove the high bit from the sqN value if a spell is cast. This is used
	; to convert values of FFh to 7Fh to pass the check at l_compareNorthCoordinate
	;
	cmp	[bp+spellFlag],	0
	jz	short l_compareNorthCoordinate
	xor	byte ptr [bp+sqN], 80h

l_compareNorthCoordinate:
	mov	al, fs:[bx+1]
	sub	ah, ah
	mov	[bp+sqE], ax

	cmp	[bp+sqN], 7Fh 			; A sqN value of 7Fh always succeeds
	jz	short l_compareEastCoordinate	
	mov	ax, [bp+sqN]
	cmp	sq_north, ax
	jnz	l_next

l_compareEastCoordinate:
	cmp	[bp+sqE], 0FFh			; A sqE value of FFh always succeeds
	jz	short l_getCodeAddress
	mov	ax, [bp+sqE]
	cmp	sq_east, ax
	jnz	l_next

l_getCodeAddress:
	mov	ax, word ptr [bp+squareListP]
	mov	dx, word ptr [bp+squareListP+2]
	add	ax, 2
	push	dx
	push	ax
	call	map_getDataOffsetP
	add	sp, 4
	mov	word ptr [bp+dataP], ax
	mov	word ptr [bp+dataP+2], dx

l_getOpcode:
	lfs	bx, [bp+dataP]
	inc	word ptr [bp+dataP]
	mov	al, fs:[bx]
	sub	ah, ah
	mov	[bp+opcode], ax
	cmp	ax, 0FFh
	jnz	short l_verifyOpcode
	mov	gs:breakAfterFunc, 0
	jmp	short l_checkReturn

l_verifyOpcode:
	mov	ax, [bp+opcode]
	and	ax, 80h
	mov	gs:breakAfterFunc, ax
	and	[bp+opcode], 7Fh
	cmp	[bp+opcode], 46h
	jbe	short l_executeOpcode
	mov	ax, offset s_badOpcode
	push	ds
	push	ax
	call	printString
	add	sp, 4
	mov	ax, 4000h
	push	ax
	call	getKey
	add	sp, 2
	jmp	short l_return

l_executeOpcode:
	mov	bx, [bp+opcode]
	shl	bx, 1
	shl	bx, 1
	mov	ax, word ptr vm_functionList[bx]
	mov	dx, word ptr (vm_functionList+2)[bx]
	mov	word ptr gs:g_currentVmFunction, ax
	mov	word ptr gs:g_currentVmFunction+2, dx
	push	word ptr [bp+dataP+2]
	push	word ptr [bp+dataP]
	call	gs:g_currentVmFunction
	add	sp, 4
	mov	word ptr [bp+dataP], ax
	mov	word ptr [bp+dataP+2], dx

l_checkReturn:
	cmp	gs:breakAfterFunc, 0
	jnz	l_getOpcode

	cmp	g_mapRval, 0
	jz	short l_next
	mov	ax, gs:mapRval
	jmp	short l_return

l_next:
	add	word ptr [bp+squareListP], 4
	jmp	l_loop

l_returnRval:
	mov	ax, gs:mapRval
	jmp	short $+2

l_return:
	mov	sp, bp
	pop	bp
	retf
vm_execute endp

; Attributes: bp-based frame

mfunc_notImplemented proc far

	dataP= dword ptr	 6

	push	bp
	mov	bp, sp
	mov	ax, offset s_notImplemented
	push	ds
	push	ax
	call	printString
	add	sp, 4
	mov	ax, 4000h
	push	ax
	call	getKey
	add	sp, 2
	mov	ax, word ptr [bp+dataP]
	mov	dx, word ptr [bp+dataP+2]
	mov	sp, bp
	pop	bp
	retf
mfunc_notImplemented endp


seg007 ends

; Segment type: Pure code
seg008 segment byte public 'CODE' use16
        assume cs:seg008
;org 0Ah
        assume es:nothing, ss:nothing, ds:dseg, fs:nothing, gs:seg027

; Entry	point for a battle
; Attributes: bp-based frame

bat_init proc far

	var_8= word ptr	-8
	currentSinger= word ptr	-6
	var_4= word ptr	-4
	currentSong= word ptr	-2

	push	bp
	mov	bp, sp
	mov	ax, 8
	call	someStackOperation

	mov	al, gs:g_currentSongPlusOne
	mov	gs:bat_curSong,	al
	mov	al, gs:g_currentSong
	sub	ah, ah
	mov	[bp+currentSong], ax

	mov	al, gs:g_currentSinger
	mov	[bp+currentSinger], ax
	call	endNoncombatSong

	push	cs
	call	near ptr bat_setOpponents

	mov	[bp+var_8], 0
	sub	al, al
	mov	gs:partyFrozenFlag, al
	mov	gs:runAwayFlag,	al

l_roundStart:
	push	cs
	call	near ptr bat_monSortGroups
	push	cs
	call	near ptr bat_setBigpic
	push	[bp+var_8]
	inc	[bp+var_8]
	push	cs
	call	near ptr bat_printOpponents
	add	sp, 2

	cmp	gs:partyFrozenFlag, 0
	jnz	short l_doRound

	push	cs
	call	near ptr bat_partyGetActions
	cmp	gs:runAwayFlag,	0
	jz	short l_doRound

partyRan:
	push	[bp+currentSong]
	push	[bp+currentSinger]
	mov	al, gs:bat_curSong
	sub	ah, ah
	push	ax
	call	bat_end
	add	sp, 6
	sub	ax, ax
	jmp	l_return

l_doRound:
	mov	gs:txt_numLines, 0Bh
	call	bat_doRound
	call	bat_partyDisbelieves
	cmp	gs:monDisbelieveFlag, 0
	jnz	short l_noDisbelieve
	call	bat_monGroupActive
	or	ax, ax
	jz	short l_noDisbelieve
	call	bat_monDisbelieve

l_noDisbelieve:
	call	bat_partyApplyPoison
	call	party_applyEquipmentEffects
	mov	al, gs:songRegenHP
	sub	ah, ah
	push	ax
	call	bat_partyApplyHpRegen
	add	sp, 2
	mov	al, gs:monDisbelieveFlag
	sub	ah, ah
	push	ax
	call	bat_postRound
	add	sp, 2
	push	cs
	call	near ptr bat_endCombatSong
	mov	byte ptr g_printPartyFlag,	0
	call	party_getLastSlot
	cmp	ax, 7
	jle	short l_partyAlive

party_died:
	push	[bp+currentSong]
	push	[bp+currentSinger]
	mov	al, gs:bat_curSong
	sub	ah, ah
	push	ax
	call	bat_end
	add	sp, 6
	mov	ax, 1
	jmp	short l_return

l_partyAlive:
	call	bat_monGroupActive
	or	ax, ax
	jz	short l_noMoreEnemies
	call	_return_zero
	or	ax, ax
	jz	l_roundStart

l_noMoreEnemies:
	cmp	g_partyAttackFlag, 0
	jz	short partyWon
	mov	ax, offset s_continueQuestion
	push	ds
	push	ax
	call	printStringWClear
	add	sp, 4
	call	getYesNo
	or	ax, ax
	jnz	l_roundStart
	push	[bp+currentSong]
	push	[bp+currentSinger]
	mov	al, gs:bat_curSong
	sub	ah, ah
	push	ax
	call	bat_end
	add	sp, 6
	sub	ax, ax
	jmp	short l_return

partyWon:
	call	bat_getReward
	mov	[bp+var_4], ax
	push	[bp+currentSong]
	push	[bp+currentSinger]
	mov	al, gs:bat_curSong
	sub	ah, ah
	push	ax
	call	bat_end
	add	sp, 6
	mov	ax, [bp+var_4]
	jmp	short l_return

l_return:
	mov	sp, bp
	pop	bp
	retf
bat_init endp

; Attributes: bp-based frame

bat_doRound proc far

	charNo=	word ptr -0Ch
	charPri= word ptr -0Ah
	monPri=	word ptr -8
	groupNo= word ptr -4
	monNo= word ptr	-2

	push	bp
	mov	bp, sp
	mov	ax, 0Ch
	call	someStackOperation
	call	bat_setPriorities

l_loop:
	lea	ax, [bp+charNo]
	push	ss
	push	ax
	push	cs
	call	near ptr bat_charGetNextPriority
	add	sp, 4
	mov	[bp+charPri], ax
	lea	ax, [bp+groupNo]
	push	ss
	push	ax
	lea	ax, [bp+monNo]
	push	ss
	push	ax
	call	bat_monGetNextPriority
	add	sp, 8
	mov	[bp+monPri], ax

	cmp	[bp+charPri], 0
	jnz	short l_comparePriority
	cmp	[bp+monPri], 0
	jz	l_return

l_comparePriority:
	cmp	[bp+charPri], ax
	jl	short l_monsterFirst
	push	[bp+charNo]
	push	cs
	call	near ptr bat_charAction
	add	sp, 2
	jmp	short l_afterAttack

l_monsterFirst:
	push	[bp+groupNo]
	push	[bp+monNo]
	call	bat_monAction
	add	sp, 4

l_afterAttack:
	cmp	gs:g_currentCharPosition, 0
	jz	short loc_1B2FC
	call	txt_newLine

loc_1B2FC:
	call	txt_newLine
	mov	byte ptr g_printPartyFlag,	0
	jmp	l_loop

l_return:
	mov	sp, bp
	pop	bp
	retf
bat_doRound endp

; Attributes: bp-based frame

bat_charAction proc far

	slotNumber=	word ptr  6

	push	bp
	mov	bp, sp

	mov	bx, [bp+slotNumber]
	mov	gs:bat_charPriority[bx], 0
	mov	ax, charSize
	imul	[bp+slotNumber]
	mov	bx, ax
	cmp	byte ptr gs:party._name[bx], 0
	jz	l_return

	mov	ax, charSize
	imul	[bp+slotNumber]
	mov	bx, ax
	test	gs:party.status[bx], stat_dead	or stat_stoned or stat_paralyzed
	jnz	l_return

	mov	ax, charSize
	imul	[bp+slotNumber]
	mov	bx, ax
	cmp	gs:party.class[bx], class_monster
	jb	short l_actionSwitch

	push	[bp+slotNumber]
	call	bat_summonAction
	add	sp, 2
	jmp	l_return

l_actionSwitch:
	mov	bx, [bp+slotNumber]
	mov	al, gs:g_charActionList[bx]
	sub	ah, ah
	sub	ax, 1
	cmp	ax, 7
	ja	l_return
	add	ax, ax
	xchg	ax, bx
	jmp	cs:off_1B3EA[bx]

off_1B3EA dw offset l_attack		; Attack
	  dw offset l_return		; Defend
	  dw offset l_attack		; Party attack
	  dw offset l_cast		; Cast
	  dw offset l_use		; Use
	  dw offset l_hide		; Hide
	  dw offset l_sing		; Song
	  dw offset l_possessed		; Possessed action

l_attack:
	mov	bx, [bp+slotNumber]
	mov	al, gs:g_batCharActionTarget[bx]
	sub	ah, ah
	push	ax
	push	bx
	push	cs
	call	near ptr bat_charMelee
	add	sp, 4
	jmp	short l_return

l_cast:
	push	[bp+slotNumber]
	push	cs
	call	near ptr bat_charCast
	add	sp, 2
	jmp	short l_return

l_use:
	push	[bp+slotNumber]
	push	cs
	call	near ptr bat_charUse
	add	sp, 2
	jmp	short l_return

l_hide:
	push	[bp+slotNumber]
	push	cs
	call	near ptr bat_charHide
	add	sp, 2
	jmp	short l_return

l_sing:
	push	[bp+slotNumber]
	push	cs
	call	near ptr bat_charSing
	add	sp, 2
	jmp	short l_return

l_possessed:
	push	[bp+slotNumber]
	push	cs
	call	near ptr bat_charPossessedAttack
	add	sp, 2

l_return:
	mov	sp, bp
	pop	bp
	retf
bat_charAction endp

; Attributes: bp-based frame

bat_monAction	proc far

	var_6= word ptr	-6
	var_4= word ptr	-4
	var_2= word ptr	-2
	monsterNumber= word ptr	 6
	groupNumber= word ptr  8

	push	bp
	mov	bp, sp
	mov	ax, 6
	call	someStackOperation
	push	si

	mov	bx, [bp+monsterNumber]
	mov	cl, 6
	shl	bx, cl
	mov	ax, [bp+groupNumber]
	shl	ax, 1
	add	bx, ax
	mov	gs:bat_monPriorityList[bx], 0
	call	random
	and	ax, 6
	mov	[bp+var_6], ax
	mov	ax, monStruSize
	imul	[bp+monsterNumber]
	mov	si, ax
	add	si, [bp+var_6]
	mov	al, gs:monGroups.attackType._type[si]
	sub	ah, ah
	mov	[bp+var_2], ax
	mov	al, gs:monGroups.attackType.damage[si]
	mov	[bp+var_4], ax
	cmp	[bp+var_2], 80h
	jge	short l_checkMelee

	push	[bp+var_2]
	push	[bp+groupNumber]
	push	[bp+monsterNumber]
	push	cs
	call	near ptr bat_monCast
	add	sp, 6
	jmp	short l_return

l_checkMelee:
	mov	ax, [bp+var_2]
	sub	ax, 0F0h
	and 	ax, 7Fh
	mov	[bp+var_6], ax
	cmp	[bp+var_6], 0Ah
	jge	short l_specialAttack

	push	[bp+var_4]
	push	[bp+var_6]
	push	[bp+groupNumber]
	push	[bp+monsterNumber]
	push	cs
	call	near ptr bat_monMelee
	add	sp, 8
	jmp	short l_return

l_specialAttack:
	mov	ax, [bp+var_6]
	cmp	ax, 0Ah
	jz	short l_summon
	cmp	ax, 10h
	jz	short l_breathAttack
	cmp	ax, 13h
	jz	short l_tarjanSpecial
	jmp	short l_return

l_summon:
	push	[bp+var_4]
	push	[bp+groupNumber]
	push	[bp+monsterNumber]
	push	cs
	call	near ptr bat_monSummonHelp
	add	sp, 6
	jmp	short l_return

l_breathAttack:
	push	[bp+var_4]
	push	[bp+groupNumber]
	push	[bp+monsterNumber]
	push	cs
	call	near ptr bat_monBreathe
	add	sp, 6
	jmp	short l_return

l_tarjanSpecial:
	push	cs
	call	near ptr bat_monTarjanSpecial
	jmp	short l_return

l_return:
	pop	si
	mov	sp, bp
	pop	bp
	retf
bat_monAction	endp

; Attributes: bp-based frame

bat_monCast proc far

	slotNumber= word ptr	 6
	spellNumber= word ptr	 0Ah

	push	bp
	mov	bp, sp

	mov	ax, 7
	push	ax
	push	cs
	call	near ptr bat_getRandomChar
	add	sp, 2
	mov	gs:bat_curTarget, al
	sub	ax, ax
	push	ax
	mov	ax, 1
	push	ax
	push	[bp+spellNumber]
	mov	ax, [bp+slotNumber]
	or	al, 80h
	push	ax
	call	doCastSpell
	add	sp, 8

	mov	sp, bp
	pop	bp
	retf
bat_monCast endp


; Attributes: bp-based frame

bat_monSummonHelp proc far

	stringBufferP= dword ptr -104h
	stringBuffer= word ptr -100h
	slotNumber= word ptr	 6
	arg_4= word ptr	 0Ah

	push	bp
	mov	bp, sp
	mov	ax, 104h
	call	someStackOperation
	push	si

	push	[bp+slotNumber]
	lea	ax, [bp+stringBuffer]
	push	ss
	push	ax
	push	cs
	call	near ptr bat_monGetName
	add	sp, 6
	mov	word ptr [bp+stringBufferP], ax
	mov	word ptr [bp+stringBufferP+2], dx
	mov	ax, offset s_summonsHelp
	push	ds
	push	ax
	push	dx
	push	word ptr [bp+stringBufferP]
	call	strcat
	add	sp, 8
	mov	word ptr [bp+stringBufferP], ax
	mov	word ptr [bp+stringBufferP+2], dx
	call	random
	sub	ah, ah
	cmp	ax, [bp+arg_4]
	jnb	short l_noHelp

	mov	ax, monStruSize
	imul	[bp+slotNumber]
	mov	bx, ax
	mov	al, gs:monGroups.groupSize[bx]
	and	al, 1Fh
	cmp	al, 1Fh
	jz	short l_noHelp

	test	gs:disbelieveFlags, disb_nohelp
	jz	short loc_1B5B0

l_noHelp:
	mov	ax, offset s_noneAppears
	push	ds
	push	ax
	push	word ptr [bp+stringBufferP+2]
	push	word ptr [bp+stringBufferP]
	call	strcat
	add	sp, 8
	mov	word ptr [bp+stringBufferP], ax
	mov	word ptr [bp+stringBufferP+2], dx
	jmp	l_return

loc_1B5B0:
	mov	ax, offset s_anotherJoins
	push	ds
	push	ax
	push	word ptr [bp+stringBufferP+2]
	push	word ptr [bp+stringBufferP]
	call	strcat
	add	sp, 8
	mov	word ptr [bp+stringBufferP], ax
	mov	word ptr [bp+stringBufferP+2], dx
	mov	ax, monStruSize
	imul	[bp+slotNumber]
	mov	si, ax
	inc	gs:monGroups.groupSize[si]
	mov	al, gs:monGroups.hpDice[si]
	sub	ah, ah
	push	ax
	push	cs
	call	near ptr randomYdX
	add	sp, 2
	mov	cx, gs:monGroups.hpBase[si]
	add	cx, ax
	mov	bl, gs:monGroups.groupSize[si]
	and	bx, 1Fh
	shl	bx, 1
	mov	ax, [bp+slotNumber]
	mov	dx, cx
	mov	cl, 6
	shl	ax, cl
	add	bx, ax
	mov	gs:monHpList[bx], dx
	mov	ax, monStruSize
	imul	[bp+slotNumber]
	mov	bx, ax
	mov	bl, gs:monGroups.groupSize[bx]
	and	bx, 1Fh
	shl	bx, 1
	mov	ax, [bp+slotNumber]
	shl	ax, cl
	add	bx, ax
	mov	gs:bat_monPriorityList[bx], 0

l_return:
	lea	ax, [bp+stringBuffer]
	push	ss
	push	ax
	call	printString
	add	sp, 4

	pop	si
	mov	sp, bp
	pop	bp
	retf
bat_monSummonHelp endp

; Attributes: bp-based frame

bat_monBreathe proc far

	argumentsP= dword ptr -114h
	loopCounter= word ptr -110h
	arguments= word ptr -10Eh
	var_10C= byte ptr -10Ch
	var_10A= byte ptr -10Ah
	target=	word ptr -106h
	stringBufferP= dword ptr -104h
	stringBuffer= word ptr -100h
	slotNumber= word ptr	 6
	arg_4= byte ptr	 0Ah

	push	bp
	mov	bp, sp
	mov	ax, 114h
	call	someStackOperation
	push	di
	push	si

	push	[bp+slotNumber]
	lea	ax, [bp+stringBuffer]
	push	ss
	push	ax
	push	cs
	call	near ptr bat_monGetName
	add	sp, 6
	mov	word ptr [bp+stringBufferP], ax
	mov	word ptr [bp+stringBufferP+2], dx
	mov	ax, 7
	push	ax
	push	cs
	call	near ptr bat_getRandomChar
	add	sp, 2
	mov	[bp+target], ax
	lea	ax, [bp+arguments]
	mov	word ptr [bp+argumentsP], ax
	mov	word ptr [bp+argumentsP+2], ss

	mov	[bp+loopCounter], 0
l_loop:
	mov	bx, [bp+loopCounter]
	mov	al, byte ptr breathAttack.effectStrIndex[bx]
	lfs	si, [bp+argumentsP]
	mov	fs:[bx+si], al
	inc	[bp+loopCounter]
	cmp	[bp+loopCounter], 7
	jl	short l_loop

	mov	ax, monStruSize
	imul	[bp+slotNumber]
	mov	bx, ax
	mov	al, gs:monGroups.breathFlag[bx]
	mov	[bp+var_10C], al
	sub	ah, ah
	xor	al, 0Ah
	push	ax
	push	word ptr [bp+stringBufferP+2]
	push	word ptr [bp+stringBufferP]
	mov	ax, offset s_firesBreathes
	push	ds
	push	ax
	call	str_pluralize
	add	sp, 0Ah
	mov	word ptr [bp+stringBufferP], ax
	mov	word ptr [bp+stringBufferP+2], dx

	lfs	bx, dword ptr [bp+stringBufferP]
	inc	word ptr [bp+stringBufferP]
	mov	byte ptr fs:[bx], 0

	mov	al, [bp+arg_4]
	mov	[bp+var_10A], al
	mov	al, byte ptr [bp+target]
	mov	gs:bat_curTarget, al
	lea	ax, [bp+stringBuffer]
	push	ss
	push	ax
	call	printString
	add	sp, 4
	mov	ax, monStruSize
	imul	[bp+slotNumber]
	mov	bx, ax
	mov	al, gs:monGroups.breathRange[bx]
	sub	ah, ah
	push	ax
	sub	sp, 8
	lea	si, [bp+arguments]
	mov	di, sp
	push	ss
	pop	es
	assume es:nothing
	movsw
	movsw
	movsw
	movsb
	push	[bp+slotNumber]
	call	bat_doBreathAttack
	add	sp, 0Ch

	pop	si
	pop	di
	mov	sp, bp
	pop	bp
	retf
bat_monBreathe endp

; Attributes: bp-based frame

bat_monMelee proc far

	groupDistance= byte ptr -120h
	newDistance= word ptr -11Eh
	amountToAdvance= word ptr -11Ch
	pluralFlag= word ptr -11Ah
	loopCounter= word ptr -118h
	groupName= word ptr -116h
	stringBufferP= dword ptr -106h
	currentDistance= word ptr -102h
	stringBuffer= word ptr -100h
	monNo= word ptr	 6
	arg_2= word ptr  8
	arg_4= word ptr  0Ah
	arg_6= word ptr	 0Ch

	push	bp
	mov	bp, sp
	mov	ax, 120h
	call	someStackOperation
	push	si

	lea	ax, [bp+groupName]
	push	ss
	push	ax
	mov	ax, monStruSize
	imul	[bp+monNo]
	mov	bx, ax
	lea	ax, monGroups._name[bx]
	mov	dx, seg	seg027
	push	dx
	push	ax
	call	unmaskString
	add	sp, 8

	lea	ax, [bp+stringBuffer]
	mov	word ptr [bp+stringBufferP], ax
	mov	word ptr [bp+stringBufferP+2], ss

	mov	ax, monStruSize
	imul	[bp+monNo]
	mov	si, ax
	mov	al, gs:monGroups.distance[si]
	and	al, 0Fh
	cmp	al, 2
	jb	l_inMeleeRange

	; A value of 0C0 in packedGenAc indicates that the source's name
	; is unique. (e.g. Tarjan)
	mov	al, gs:monGroups.packedGenAc[si]
	and	al, 0C0h
	cmp	al, 0C0h
	jnz	short l_addIndefiniteArticle

	mov	[bp+pluralFlag], 0
	jmp	short l_advance

l_addIndefiniteArticle:
	mov	ax, monStruSize
	imul	[bp+monNo]
	mov	bx, ax
	mov	al, gs:monGroups.groupSize[bx]
	and	al, 1Fh
	cmp	al, 2
	jnb	short l_pluralAdvance
	mov	[bp+pluralFlag], 0
	lfs	bx, [bp+stringBufferP]
	inc	word ptr [bp+stringBufferP]
	mov	byte ptr fs:[bx], 'A'
	mov	al, byte ptr [bp+groupName]
	cbw
	push	ax
	push	cs
	call	near ptr str_startsWithVowel
	add	sp, 2
	or	ax, ax
	jz	short l_startsWithConsonant
	lfs	bx, [bp+stringBufferP]
	inc	word ptr [bp+stringBufferP]
	mov	byte ptr fs:[bx], 'n'

l_startsWithConsonant:
	lfs	bx, [bp+stringBufferP]
	inc	word ptr [bp+stringBufferP]
	mov	byte ptr fs:[bx], ' '
	jmp	short l_advance

l_pluralAdvance:
	mov	[bp+pluralFlag], 1
	mov	ax, offset s_the
	push	ds
	push	ax
	push	word ptr [bp+stringBufferP+2]
	push	word ptr [bp+stringBufferP]
	call	strcat
	add	sp, 8
	mov	word ptr [bp+stringBufferP], ax
	mov	word ptr [bp+stringBufferP+2], dx

l_advance:
	push	[bp+pluralFlag]
	push	word ptr [bp+stringBufferP+2]
	push	word ptr [bp+stringBufferP]
	lea	ax, [bp+groupName]
	push	ss
	push	ax
	call	str_pluralize
	add	sp, 0Ah
	mov	word ptr [bp+stringBufferP], ax
	mov	word ptr [bp+stringBufferP+2], dx
	push	[bp+pluralFlag]
	push	dx
	push	ax
	mov	ax, offset s_advances
	push	ds
	push	ax
	call	str_pluralize
	add	sp, 0Ah
	mov	word ptr [bp+stringBufferP], ax
	mov	word ptr [bp+stringBufferP+2], dx
	mov	ax, monStruSize
	imul	[bp+monNo]
	mov	bx, ax
	mov	al, gs:monGroups.distance[bx]
	mov	[bp+groupDistance], al
	sub	ah, ah
	mov	si, ax
	mov	cl, 4
	shr	ax, cl
	mov	[bp+amountToAdvance], ax
	mov	ax, si
	and	ax, 0Fh
	mov	[bp+currentDistance], ax
	mov	ax, [bp+amountToAdvance]
	cmp	[bp+currentDistance], ax
	jle	short l_setToMeleeRange
	mov	ax, [bp+currentDistance]
	sub	ax, [bp+amountToAdvance]
	jmp	short l_setDistance

l_setToMeleeRange:
	mov	ax, 1

l_setDistance:
	mov	[bp+newDistance], ax
	mov	al, byte ptr [bp+newDistance]
	mov	cl, [bp+groupDistance]
	and	cl, 0F0h
	add	al, cl
	mov	cx, ax
	mov	ax, monStruSize
	imul	[bp+monNo]
	mov	bx, ax
	mov	gs:monGroups.distance[bx], cl

	mov	[bp+loopCounter], 0
l_clearPriorityLoop:
	mov	bx, [bp+monNo]
	mov	cl, 6
	shl	bx, cl
	mov	ax, [bp+loopCounter]
	shl	ax, 1
	add	bx, ax
	mov	gs:bat_monPriorityList[bx], 0
	inc	[bp+loopCounter]
	cmp	[bp+loopCounter], 20h 
	jl	short l_clearPriorityLoop
	jmp	l_return

l_inMeleeRange:
	push	[bp+monNo]
	push	word ptr [bp+stringBufferP+2]
	push	word ptr [bp+stringBufferP]
	push	cs
	call	near ptr bat_monGetName
	add	sp, 6
	mov	word ptr [bp+stringBufferP], ax
	mov	word ptr [bp+stringBufferP+2], dx
	call	random
	and	ax, 1
	mov	cx, ax
	mov	ax, monStruSize
	imul	[bp+monNo]
	mov	bx, ax
	mov	al, gs:monGroups.flags[bx]
	sub	ah, ah
	and	ax, mon_attackStr
	shl	ax, 1
	add	ax, cx
	mov	bx, ax
	shl	bx, 1
	shl	bx, 1
	push	word ptr (monMeleeAttString+2)[bx]
	push	word ptr monMeleeAttString[bx]
	push	word ptr [bp+stringBufferP+2]
	push	word ptr [bp+stringBufferP]
	call	strcat
	add	sp, 8
	mov	word ptr [bp+stringBufferP], ax
	mov	word ptr [bp+stringBufferP+2], dx
	mov	word ptr [bp+stringBufferP], ax
	mov	word ptr [bp+stringBufferP+2], dx
	lfs	bx, [bp+stringBufferP]
	inc	word ptr [bp+stringBufferP]
	mov	byte ptr fs:[bx], ' '
	mov	ax, 3
	push	ax
	push	cs
	call	near ptr bat_getRandomChar
	add	sp, 2
	mov	gs:bat_curTarget, al
	sub	ah, ah
	push	ax
	push	word ptr [bp+stringBufferP+2]
	push	word ptr [bp+stringBufferP]
	push	cs
	call	near ptr bat_getAttackerName
	add	sp, 6
	mov	word ptr [bp+stringBufferP], ax
	mov	word ptr [bp+stringBufferP+2], dx

	; Push the special attack value
	push	[bp+arg_4]

	push	[bp+arg_6]
	mov	al, gs:bat_curTarget
	sub	ah, ah
	push	ax
	push	[bp+monNo]
	push	cs
	call	near ptr bat_monMeleeRoll
	add	sp, 8
	or	ax, ax
	jnz	short l_attackSucceeds
	mov	ax, offset s_butMisses
	push	ds
	push	ax
	push	word ptr [bp+stringBufferP+2]
	push	word ptr [bp+stringBufferP]
	call	strcat
	add	sp, 8
	mov	word ptr [bp+stringBufferP], ax
	mov	word ptr [bp+stringBufferP+2], dx
	jmp	l_return

l_attackSucceeds:
	sub	ax, ax
	push	ax
	push	word ptr [bp+stringBufferP+2]
	push	word ptr [bp+stringBufferP]
	push	cs
	call	near ptr bat_charPrintMeleeDamage
	add	sp, 6
	mov	word ptr [bp+stringBufferP], ax
	mov	word ptr [bp+stringBufferP+2], dx
	mov	al, gs:bat_curTarget
	sub	ah, ah
	push	ax
	push	cs
	call	near ptr bat_damageHp
	add	sp, 2
	or	ax, ax
	jz	short l_noKill
	push	word ptr [bp+stringBufferP+2]
	push	word ptr [bp+stringBufferP]
	push	cs
	call	near ptr bat_appendSpecialAttackString
	add	sp, 4
	mov	word ptr [bp+stringBufferP], ax
	mov	word ptr [bp+stringBufferP+2], dx
	mov	ax, 1
	push	ax
	mov	ax, 3
	push	ax
	mov	al, gs:bat_curTarget
	sub	ah, ah
	push	ax
	push	dx
	push	word ptr [bp+stringBufferP]
	call	printCharPronoun
	add	sp, 0Ah
	mov	word ptr [bp+stringBufferP], ax
	mov	word ptr [bp+stringBufferP+2], dx
	jmp	l_return

l_noKill:
	mov	ax, offset s_periodNlNl
	push	ds
	push	ax
	push	word ptr [bp+stringBufferP+2]
	push	word ptr [bp+stringBufferP]
	call	strcat
	add	sp, 8
	mov	word ptr [bp+stringBufferP], ax
	mov	word ptr [bp+stringBufferP+2], dx

l_return:
	lfs	bx, [bp+stringBufferP]
	inc	word ptr [bp+stringBufferP]
	mov	byte ptr fs:[bx], 0
	lea	ax, [bp+stringBuffer]
	push	ss
	push	ax
	call	printString
	add	sp, 4
	call	text_delayWithTable

	pop	si
	mov	sp, bp
	pop	bp
	retf
bat_monMelee endp


; Attributes: bp-based frame

bat_monTarjanSpecial proc far

	counter =	word ptr -2

	push	bp
	mov	bp, sp
	mov	ax, 2
	call	someStackOperation
	mov	[bp+counter], 0

l_loop:
	inc	[bp+counter]
	mov	ax, 15h
	push	ax
	mov	ax, 80h
	push	ax
	call	summon_execute
	add	sp, 4

	cmp	[bp+counter], 0Ah
	jl	l_loop

	mov	sp, bp
	pop	bp
	retf
bat_monTarjanSpecial endp


; Attributes: bp-based frame

bat_monGetName proc far

	nameBuffer=	word ptr -10h
	stringBufferP= dword ptr  6
	slotNumber= word ptr	 0Ah

	push	bp
	mov	bp, sp
	mov	ax, 10h
	call	someStackOperation

	lea	ax, [bp+nameBuffer]
	push	ss
	push	ax
	mov	ax, monStruSize
	imul	[bp+slotNumber]
	mov	bx, ax
	lea	ax, monGroups._name[bx]
	mov	dx, seg	seg027
	push	dx
	push	ax
	call	unmaskString
	add	sp, 8
	lfs	bx, [bp+stringBufferP]
	inc	word ptr [bp+stringBufferP]
	mov	byte ptr fs:[bx], 'A'
	mov	al, byte ptr [bp+nameBuffer]
	cbw
	push	ax
	push	cs
	call	near ptr str_startsWithVowel
	add	sp, 2
	or	ax, ax
	jz	short l_startsWithConsonant

	lfs	bx, [bp+stringBufferP]
	inc	word ptr [bp+stringBufferP]
	mov	byte ptr fs:[bx], 'n'

l_startsWithConsonant:
	lfs	bx, [bp+stringBufferP]
	inc	word ptr [bp+stringBufferP]
	mov	byte ptr fs:[bx], ' '
	sub	ax, ax
	push	ax
	push	word ptr [bp+stringBufferP+2]
	push	word ptr [bp+stringBufferP]
	lea	ax, [bp+nameBuffer]
	push	ss
	push	ax
	call	str_pluralize
	add	sp, 0Ah
	mov	word ptr [bp+stringBufferP], ax
	mov	word ptr [bp+stringBufferP+2], dx
	lfs	bx, [bp+stringBufferP]
	inc	word ptr [bp+stringBufferP]
	mov	byte ptr fs:[bx], ' '
	mov	ax, word ptr [bp+stringBufferP]
	mov	dx, word ptr [bp+stringBufferP+2]

	mov	sp, bp
	pop	bp
	retf
bat_monGetName endp

; Attributes: bp-based frame

bat_getRandomChar proc far

	currentSlot= word ptr	-4
	counter= word ptr -2
	_mask= word ptr	 6

	push	bp
	mov	bp, sp
	mov	ax, 4
	call	someStackOperation

	mov	[bp+counter], 0
l_loop:
	call	random
	and	ax, [bp+_mask]
	mov	[bp+currentSlot], ax
	push	ax
	push	cs
	call	near ptr bat_charIsAttackable
	add	sp, 2
	or	ax, ax
	jz	short l_next

	mov	ax, [bp+currentSlot]
	jmp	short l_return

l_next:
	inc	[bp+counter]
	cmp	[bp+counter], 7
	jl	short l_loop

l_returnZero:
	sub	ax, ax

l_return:
	mov	sp, bp
	pop	bp
	retf
bat_getRandomChar endp


; Attributes: bp-based frame

bat_monMeleeRoll proc far

	var_4= word ptr	-4
	var_2= word ptr	-2
	monNo= word ptr	 6
	target=	word ptr  8
	field_17= word ptr  0Ah
	spAttack = word ptr 0Ch

	push	bp
	mov	bp, sp
	mov	ax, 4
	call	someStackOperation
	push	si

	mov	gs:specialAttackVal, 0
	mov	gs:damageAmount, 0
	mov	bx, [bp+target]
	cmp	gs:g_characterMeleeDistance[bx], 0
	jnz	l_returnZero

	mov	ax, charSize
	imul	bx
	mov	bx, ax
	mov	al, gs:party.ac[bx]
	cbw
	mov	bx, [bp+monNo]
	mov	cl, gs:monSpellToHitPenalty[bx]
	sub	ch, ch
	add	ax, cx
	mov	[bp+var_2], ax
	cmp	ax, 3Fh
	jle	short l_underMax
	mov	[bp+var_2], 3Fh

l_underMax:
	mov	ax, monStruSize
	imul	bx
	mov	si, ax
	mov	al, gs:monGroups.toHitHi[si]
	sub	ah, ah
	push	ax
	mov	al, gs:monGroups.toHitLo[si]
	push	ax
	push	cs
	call	near ptr randomBetweenXandY
	add	sp, 4
	mov	bx, [bp+monNo]
	mov	cl, gs:monAttackBonus[bx]
	sub	ch, ch
	add	cx, ax
	mov	[bp+var_4], cx
	mov	ax, [bp+var_2]
	cmp	cx, ax
	jl	short l_returnZero

	; Add monster special attack
	mov	ax, [bp+spAttack]
	mov	gs:specialAttackVal, ax

	push	[bp+field_17]
	push	cs
	call	near ptr randomYdX
	add	sp, 2
	mov	bx, [bp+monNo]
	mov	cl, gs:monAttackBonus[bx]
	sub	ch, ch
	add	cx, ax
	mov	gs:damageAmount, cx
	mov	ax, 1
	jmp	short l_return

l_returnZero:
	sub	ax, ax

l_return:
	pop	si
	mov	sp, bp
	pop	bp
	retf
bat_monMeleeRoll endp

; Attributes: bp-based frame

bat_charIsAttackable proc far

	slotNumber= word ptr	 6

	push	bp
	mov	bp, sp

	cmp	[bp+slotNumber], 7
	jz	l_returnZero
	mov	ax, charSize
	imul	[bp+slotNumber]
	mov	bx, ax
	cmp	byte ptr gs:party._name[bx], 0
	jz	l_returnZero

	mov	ax, charSize
	imul	[bp+slotNumber]
	mov	bx, ax
	cmp	gs:party.class[bx], class_illusion
	jnz	short l_notIllusion
	cmp	gs:monDisbelieveFlag, 0
	jz	l_returnZero

l_notIllusion:
	mov	bx, [bp+slotNumber]
	cmp	gs:g_characterMeleeDistance[bx], 0
	jnz	l_returnZero

	mov	ax, charSize
	imul	bx
	mov	bx, ax
	mov	al, gs:party.status[bx]
	and	al, 0Ch
	mov	cx, ax
	cmp	cl, 1
	sbb	ax, ax
	neg	ax
	jmp	short l_return

l_returnZero:
	sub	ax, ax

l_return:
	mov	sp, bp
	pop	bp
	retf
bat_charIsAttackable endp

; Attributes: bp-based frame
bat_summonAction proc	far

	var_C= word ptr	-0Ah
	attDamage= word	ptr -8h
	attType= word ptr -6
	slotP= dword ptr -4
	slotNumber=	word ptr  6

	push	bp
	mov	bp, sp
	mov	ax, 0Ch
	call	someStackOperation
	push	si

	mov	ax, charSize
	imul	[bp+slotNumber]
	add	ax, offset party
	mov	word ptr [bp+slotP], ax
	mov	word ptr [bp+slotP+2], seg seg027

	lfs	bx, [bp+slotP]
	cmp	fs:[bx+summonStat_t.class], class_illusion
	jnz	short l_notIllusion

	cmp	gs:monDisbelieveFlag, 0
	jnz	l_return

l_notIllusion:
	call	random
	and	ax, 6
	mov	si, ax
	lfs	bx, [bp+slotP]
	mov	al, fs:[bx+si+summonStat_t.attacks._type]
	sub	ah, ah
	mov	[bp+attType], ax
	mov	al, fs:[bx+si+summonStat_t.attacks.damage]
	mov	[bp+attDamage],	ax

	cmp	[bp+attType], 80h
	jge	short l_meleeCheck

	push	ax
	push	[bp+attType]
	push	[bp+slotNumber]
	push	cs
	call	near ptr bat_summonCast
	add	sp, 6
	jmp	short l_return

l_meleeCheck:
	mov	ax, [bp+attType]
	sub	ax, 0F0h
	and	ax, 7Fh
	mov	[bp+var_C], ax
	cmp	[bp+var_C], 0Ah
	jge	short loc_1BD1F
	push	[bp+attDamage]
	push	[bp+var_C]
	push	[bp+slotNumber]
	push	cs
	call	near ptr bat_summonMelee
	add	sp, 6
	jmp	short l_return

loc_1BD1F:
	mov	ax, [bp+var_C]
	cmp	ax, 10h
	jz	short l_breathe
	cmp	ax, 11h
	jz	short l_sing
	jmp	short l_return

l_breathe:
	push	[bp+attDamage]
	push	[bp+slotNumber]
	push	cs
	call	near ptr bat_summonBreathAttack
	add	sp, 4
	jmp	short l_return

l_sing:
	push	[bp+attDamage]
	push	[bp+slotNumber]
	push	cs
	call	near ptr bat_doCombatSong
	add	sp, 4

l_return:
	pop	si
	mov	sp, bp
	pop	bp
	retf
bat_summonAction endp

; Attributes: bp-based frame

bat_summonCast proc far

	target=	word ptr -6
	slotP= dword ptr -4
	slotNumber=	word ptr  6
	spellNumber= word ptr  8

	push	bp
	mov	bp, sp
	mov	ax, 6
	call	someStackOperation

	mov	ax, charSize
	imul	[bp+slotNumber]
	add	ax, offset party
	mov	word ptr [bp+slotP], ax
	mov	word ptr [bp+slotP+2], seg seg027
	mov	bx, [bp+spellNumber]
	test	spellCastFlags[bx], 20h
	jz	short l_checkHostile

	mov	ax, 7
	push	ax
	push	cs
	call	near ptr bat_getRandomChar
	add	sp, 2
	mov	[bp+target], ax
	jmp	short l_doCast

l_checkHostile:
	lfs	bx, [bp+slotP]
	cmp	fs:[bx+summonStat_t.hostileFlag], 0
	jz	short l_targetEnemy
	mov	ax, 7
	push	ax
	push	cs
	call	near ptr bat_getRandomChar
	add	sp, 2
	jmp	short l_skipSelfTarget

l_targetEnemy:
	mov	ax, 80h				; Target is 1st monster group

l_skipSelfTarget:
	mov	[bp+target], ax
	mov	ax, [bp+slotNumber]
	cmp	[bp+target], ax
	jz	short l_return

l_doCast:
	mov	al, byte ptr [bp+target]
	mov	gs:bat_curTarget, al
	sub	ax, ax
	push	ax
	mov	ax, 1
	push	ax
	push	[bp+spellNumber]
	push	[bp+slotNumber]
	call	doCastSpell
	add	sp, 8

l_return:
	mov	sp, bp
	pop	bp
	retf
bat_summonCast endp

; Attributes: bp-based frame

bat_summonMelee proc far

	target= word ptr	-6
	slotP= dword ptr -4
	slotNumber= word ptr	 6
	attackType= word ptr	 8
	attackDamage= word ptr	 0Ah

	push	bp
	mov	bp, sp
	mov	ax, 6
	call	someStackOperation

	cmp	[bp+slotNumber], 4
	jge	short l_return

	mov	ax, charSize
	imul	[bp+slotNumber]
	add	ax, offset party
	mov	word ptr [bp+slotP], ax
	mov	word ptr [bp+slotP+2], seg seg027

	lfs	bx, [bp+slotP]
	cmp	fs:[bx+summonStat_t.hostileFlag], 0
	jz	short l_targetEnemy

	mov	ax, 7
	push	ax
	push	cs
	call	near ptr bat_getRandomChar
	add	sp, 2
	jmp	short l_doMelee

l_targetEnemy:
	mov	ax, 80h				; 1st monster group

l_doMelee:
	mov	[bp+target], ax
	mov	ax, [bp+attackDamage]
	mov	gs:summonMeleeDamage, ax
	mov	ax, [bp+attackType]
	mov	gs:summonMeleeType, ax
	push	[bp+target]
	push	[bp+slotNumber]
	push	cs
	call	near ptr bat_charMelee
	add	sp, 4

l_return:
	mov	sp, bp
	pop	bp
	retf
bat_summonMelee endp

; Attributes: bp-based frame

bat_summonBreathAttack proc far

	stringBufferP = dword ptr -114h
	stringBuffer = word ptr -110h
	argP= dword ptr	-10h
	counter= word ptr -0Ah
	argList= byte ptr -8
	slotP= dword ptr -4
	slotNumber=	word ptr  6
	damage=	byte ptr  8

	push	bp
	mov	bp, sp
	mov	ax, 114h
	call	someStackOperation
	push	di
	push	si

	; Get the breather's name
	push	[bp+slotNumber]
	lea	ax, [bp+stringBuffer]
	push	ss
	push	ax
	lea	ax, [bp+stringBuffer]
	push	ss
	push	ax
	push	cs
	call	near ptr bat_getAttackerName
	add	sp, 6
	mov	word ptr [bp+stringBufferP], ax
	mov	word ptr [bp+stringBufferP+2], dx

	mov	ax, charSize
	imul	[bp+slotNumber]
	add	ax, offset party
	mov	word ptr [bp+slotP], ax
	mov	word ptr [bp+slotP+2], seg seg027

	lfs	bx, [bp+slotP]
	cmp	fs:[bx+summonStat_t.hostileFlag], 0
	jz	short l_targetEnemy

	mov	ax, 7
	push	ax
	push	cs
	call	near ptr bat_getRandomChar
	add	sp, 2
	jmp	short l_targetSet

l_targetEnemy:
	mov	al, 80h

l_targetSet:
	mov	gs:bat_curTarget, al
	lea	ax, [bp+argList]
	mov	word ptr [bp+argP], ax
	mov	word ptr [bp+argP+2], ss

	mov	[bp+counter], 0
l_setAttackDataLoop:
	mov	bx, [bp+counter]
	mov	al, byte ptr breathAttack.effectStrIndex[bx]
	lfs	si, [bp+argP]
	mov	fs:[bx+si], al
	inc	[bp+counter]
	cmp	[bp+counter], 7
	jl	short l_setAttackDataLoop

	lfs	bx, [bp+slotP]
	mov	al, fs:[bx+summonStat_t.breathFlag]

	; Add the fire/breath string
	sub	ah, ah
	xor	al, 0Ah
	push	ax
	push	word ptr [bp+stringBufferP+2]
	push	word ptr [bp+stringBufferP]
	mov	ax, offset s_firesBreathes
	push	ds
	push	ax
	call	str_pluralize
	add	sp, 0Ah
	mov	word ptr [bp+stringBufferP], ax
	mov	word ptr [bp+stringBufferP+2], dx

	; NULL terminate the string
	lfs	bx, dword ptr [bp+stringBufferP]
	inc	word ptr [bp+stringBufferP]
	mov	byte ptr fs:[bx], 0

	lea	ax, [bp+stringBuffer]
	push	ss
	push	ax
	call	printString
	add	sp, 4
	
	mov	al, [bp+damage]
	lfs	bx, [bp+slotP]
	mov	al, fs:[bx+summonStat_t.breathRange]
	sub	ah, ah
	push	ax
	sub	sp, 8
	lea	si, [bp+argList]
	mov	di, sp
	push	ss
	pop	es
	movsw
	movsw
	movsw
	movsb
	push	[bp+slotNumber]
	call	bat_doBreathAttack
	add	sp, 0Ch

	pop	si
	pop	di
	mov	sp, bp
	pop	bp
	retf
bat_summonBreathAttack endp

; Attributes: bp-based frame

bat_charMelee proc far

	stringBufferP= dword ptr -10Ch
	var_108= word ptr -108h
	stringBuffer= word ptr -106h
	var_6= word ptr	-6
	var_4= dword ptr -4
	slotNumber= word ptr 6
	attackTarget= word ptr 8

	push	bp
	mov	bp, sp
	mov	ax, 10Ch
	call	someStackOperation
	push	si

	cmp	[bp+attackTarget], 80h
	jge	short l_enemyTarget

	mov	ax, charSize
	imul	[bp+attackTarget]
	mov	si, ax
	cmp	gs:party.class[si], class_monster
	jnz	short l_targetMember
	mov	gs:party.hostileFlag[si], 1

l_targetMember:
	mov	ax, charSize
	imul	[bp+attackTarget]
	mov	bx, ax
	test	gs:party.status[bx], stat_dead	or stat_stoned
	jnz	l_return
	jmp	short loc_1BF3E

l_enemyTarget:
	mov	ax, [bp+attackTarget]
	and	ax, 3
	mov	cx, monStruSize
	imul	cx
	mov	bx, ax
	test	gs:monGroups.groupSize[bx], 1Fh
	jz	l_return

loc_1BF3E:
	mov	ax, charSize
	imul	[bp+slotNumber]
	mov	bx, ax
	lea	ax, party._name[bx]
	mov	dx, seg	seg027
	push	dx
	push	ax
	lea	ax, [bp+stringBuffer]
	push	ss
	push	ax
	call	strcat
	add	sp, 8
	mov	word ptr [bp+stringBufferP], ax
	mov	word ptr [bp+stringBufferP+2], dx
	lfs	bx, dword ptr [bp+stringBufferP]
	inc	word ptr [bp+stringBufferP]
	mov	byte ptr fs:[bx], ' '

	mov	ax, 1
	push	ax
	push	[bp+slotNumber]
	call	character_itemTypeCanBeUsed
	add	sp, 4

	or	ax, ax
	jz	short loc_1BF8B

	mov	[bp+var_6], 0
	jmp	short loc_1BFBF

loc_1BF8B:
	mov	ax, charSize
	imul	[bp+slotNumber]
	mov	si, ax
	cmp	gs:party.class[si], class_monster
	jb	short loc_1BFBA
	add	ax, offset party

	mov	word ptr [bp+var_4], ax
	mov	word ptr [bp+var_4+2], seg seg027
	lfs	bx, [bp+var_4]
	mov	al, fs:[bx+(character_t.spells+0Ah)]
	sub	ah, ah
	shl	ax, 1
	mov	[bp+var_6], ax
	jmp	short loc_1BFBF
loc_1BFBA:
	mov	[bp+var_6], 2
loc_1BFBF:
	call	random
	and	ax, 1
	add	[bp+var_6], ax
	mov	bx, [bp+var_6]
	shl	bx, 1
	shl	bx, 1
	
	push	word ptr (monMeleeAttString+2)[bx]
	push	word ptr monMeleeAttString[bx]
	push	word ptr [bp+stringBufferP+2]
	push	word ptr [bp+stringBufferP]
	call	strcat
	add	sp, 8
	mov	word ptr [bp+stringBufferP], ax
	mov	word ptr [bp+stringBufferP+2], dx
	lfs	bx, dword ptr [bp+stringBufferP]
	inc	word ptr [bp+stringBufferP]
	mov	byte ptr fs:[bx], ' '

	push	[bp+attackTarget]
	push	word ptr [bp+stringBufferP+2]
	push	word ptr [bp+stringBufferP]
	call	bat_getAttackerName
	add	sp, 6
	mov	word ptr [bp+stringBufferP], ax
	mov	word ptr [bp+stringBufferP+2], dx

	push	[bp+attackTarget]
	push	[bp+slotNumber]
	push	cs
	call	near ptr bat_charExecuteMeleeAttack
	add	sp, 4
	mov	[bp+var_108], ax
	or	ax, ax
	jnz	short loc_1C04B

	mov	ax, offset s_butMisses
	push	ds
	push	ax
	push	word ptr [bp+stringBufferP+2]
	push	word ptr [bp+stringBufferP]
	call	strcat
	add	sp, 8
	mov	word ptr [bp+stringBufferP], ax
	mov	word ptr [bp+stringBufferP+2], dx
	jmp	short loc_1C0B3

loc_1C04B:
	push	[bp+var_108]
	push	word ptr [bp+stringBufferP+2]
	push	word ptr [bp+stringBufferP]
	push	cs
	call	near ptr bat_charPrintMeleeDamage
	add	sp, 6
	mov	word ptr [bp+stringBufferP], ax
	mov	word ptr [bp+stringBufferP+2], dx

	push	[bp+attackTarget]
	push	cs
	call	near ptr bat_damageHp
	add	sp, 2
	or	ax, ax
	jz	short loc_1C0A7

	push	word ptr [bp+stringBufferP+2]
	push	word ptr [bp+stringBufferP]
	push	cs
	call	near ptr bat_appendSpecialAttackString
	add	sp, 4
	mov	word ptr [bp+stringBufferP], ax
	mov	word ptr [bp+stringBufferP+2], dx

	mov	ax, 1
	push	ax
	mov	ax, 3
	push	ax
	push	[bp+attackTarget]
	push	dx
	push	word ptr [bp+stringBufferP]
	call	printCharPronoun
	add	sp, 0Ah
	mov	word ptr [bp+stringBufferP], ax
	mov	word ptr [bp+stringBufferP+2], dx
	jmp	short loc_1C0B3

loc_1C0A7:
	mov	ax, offset s_periodNlNl
	push	ds
	push	ax
	push	word ptr [bp+stringBufferP+2]
	push	word ptr [bp+stringBufferP]
	call	strcat
	add	sp, 8
	mov	word ptr [bp+stringBufferP], ax
	mov	word ptr [bp+stringBufferP+2], dx

loc_1C0B3:
	lfs	bx, dword ptr [bp+stringBufferP]
	inc	word ptr [bp+stringBufferP]
	mov	byte ptr fs:[bx], 0
	mov	byte ptr fs:[bx], 0
	lea	ax, [bp+stringBuffer]
	push	ss
	push	ax
	call	printString
	add	sp, 4

	mov	bx, [bp+slotNumber]
	mov	gs:g_characterMeleeDistance[bx], 0
	mov	byte ptr g_printPartyFlag,	0

	call	text_delayWithTable

l_return:
	pop	si
	mov	sp, bp
	pop	bp
	retf
bat_charMelee endp


; Attributes: bp-based frame

bat_getAttackerName proc far

	unmaskedName=	word ptr -10h
	stringBufferP= dword ptr  6
	slotNumber= word ptr	 0Ah

	push	bp
	mov	bp, sp
	mov	ax, 10h
	call	someStackOperation

	cmp	[bp+slotNumber], 80h
	jge	short l_enemyAttacker
	mov	ax, charSize
	imul	[bp+slotNumber]
	mov	bx, ax
	lea	ax, party._name[bx]
	mov	dx, seg	seg027
	push	dx
	push	ax
	push	[bp+stringBufferP]
	call	strcat
	add	sp, 8
	mov	word ptr [bp+stringBufferP], ax
	mov	word ptr [bp+stringBufferP+2], dx
	jmp	short l_return

l_enemyAttacker:
	and	[bp+slotNumber], 3
	lfs	bx, dword ptr [bp+stringBufferP]
	inc	word ptr [bp+stringBufferP]
	mov	byte ptr fs:[bx], 'a'
	lea	ax, [bp+unmaskedName]
	push	ss
	push	ax
	mov	ax, monStruSize
	imul	[bp+slotNumber]
	mov	bx, ax
	lea	ax, monGroups._name[bx]
	mov	dx, seg	seg027
	push	dx
	push	ax
	call	unmaskString
	add	sp, 8
	mov	al, byte ptr [bp+unmaskedName]
	cbw
	push	ax
	call	str_startsWithVowel
	add	sp, 2
	or	ax, ax
	jz	short l_singular
	lfs	bx, dword ptr [bp+stringBufferP]
	inc	word ptr [bp+stringBufferP]
	mov	byte ptr fs:[bx], 'n'

l_singular:
	lfs	bx, dword ptr [bp+stringBufferP]
	inc	word ptr [bp+stringBufferP]
	mov	byte ptr fs:[bx], ' '
	sub	ax, ax
	push	ax
	push	word ptr [bp+stringBufferP+2]
	push	word ptr [bp+stringBufferP]
	lea	ax, [bp+unmaskedName]
	push	ss
	push	ax
	call	str_pluralize
	add	sp, 0Ah
	mov	word ptr [bp+stringBufferP], ax
	mov	word ptr [bp+stringBufferP+2], dx

l_return:
	mov	ax, word ptr [bp+stringBufferP]
	mov	dx, word ptr [bp+stringBufferP+2]

	mov	sp, bp
	pop	bp
	retf
bat_getAttackerName endp

; This function	returns	1 if the passed	string starts
; with a vowel.	This is	for proper use of a/an in
; strings.
; Attributes: bp-based frame

str_startsWithVowel proc far

	loopCounter= word ptr	-2
	firstLetter= word ptr	 6

	push	bp
	mov	bp, sp
	mov	ax, 2
	call	someStackOperation

	push	[bp+firstLetter]
	call	toUpper
	add	sp, 2
	mov	[bp+firstLetter], ax

	mov	[bp+loopCounter], 0
l_loop:
	mov	bx, [bp+loopCounter]
	mov	al, vowelList[bx]
	cbw
	cmp	ax, [bp+firstLetter]
	jz	short l_returnOne

	inc	[bp+loopCounter]
	cmp	[bp+loopCounter], 6
	jl	short l_loop

l_returnZero:
	sub	ax, ax
	jmp	short l_return

l_returnOne:
	mov	ax, 1

l_return:
	mov	sp, bp
	pop	bp
	retf
str_startsWithVowel endp

; Attributes: bp-based frame

bat_charCast proc far

	slotNumber=	word ptr  6

	push	bp
	mov	bp, sp

	mov	bx, [bp+slotNumber]
	mov	al, gs:byte_42276[bx]
	mov	gs:bat_curTarget, al
	mov	ax, 1
	push	ax
	push	ax
	mov	al, gs:g_batCharActionTarget[bx]
	sub	ah, ah
	push	ax
	push	bx
	call	doCastSpell
	add	sp, 8

	mov	sp, bp
	pop	bp
	retf
bat_charCast endp


; Attributes: bp-based frame

bat_charUse proc far

	slotNumber=	word ptr  6

	push	bp
	mov	bp, sp

	mov	ax, 1
	push	ax
	mov	bx, [bp+slotNumber]
	mov	al, gs:g_batCharActionTarget[bx]
	sub	ah, ah
	push	ax
	mov	al, gs:byte_42276[bx]
	push	ax
	mov	al, gs:byte_42334[bx]
	push	ax
	push	bx
	call	item_doSpell
	add	sp, 0Ah

	mov	sp, bp
	pop	bp
	retf
bat_charUse endp

; Attributes: bp-based frame

bat_charHide proc far

	stringBufferP= dword ptr -108h
	stringBuffer= word ptr -104h
	tmpBufferP= dword ptr	-4
	arg_0= word ptr	 6

	push	bp
	mov	bp, sp
	mov	ax, 108h
	call	someStackOperation

	mov	ax, charSize
	imul	[bp+arg_0]
	mov	bx, ax
	lea	ax, party._name[bx]
	mov	dx, seg	seg027
	push	dx
	push	ax
	lea	ax, [bp+stringBuffer]
	push	ss
	push	ax
	call	strcat
	add	sp, 8
	mov	word ptr [bp+stringBufferP], ax
	mov	word ptr [bp+stringBufferP+2], dx
	mov	ax, offset s_jumpsIntoShadows
	push	ds
	push	ax
	push	dx
	push	word ptr [bp+stringBufferP]
	call	strcat
	add	sp, 8
	mov	word ptr [bp+stringBufferP], ax
	mov	word ptr [bp+stringBufferP+2], dx

	mov	ax, itemEff_alwaysHide
	push	ax
	push	[bp+arg_0]
	call	character_isEffectEquipped
	add	sp, 4
	or	ax, ax
	jz	short l_hideSuccess

	call	random
	mov	cx, ax
	mov	ax, charSize
	imul	[bp+arg_0]
	mov	bx, ax
	cmp	gs:(party.specAbil+2)[bx], cl
	jbe	short l_hideFailed

l_hideSuccess:
	mov	ax, offset s_andSucceeds
	mov	word ptr [bp+tmpBufferP], ax
	mov	word ptr [bp+tmpBufferP+2], ds
	mov	bx, [bp+arg_0]
	inc	gs:g_characterMeleeDistance[bx]
	jmp	short l_return

l_hideFailed:
	mov	ax, offset s_butIsDiscovered
	mov	word ptr [bp+tmpBufferP], ax
	mov	word ptr [bp+tmpBufferP+2], ds
	mov	bx, [bp+arg_0]
	mov	gs:g_characterMeleeDistance[bx], 0

l_return:
	push	word ptr [bp+tmpBufferP+2]
	push	word ptr [bp+tmpBufferP]
	push	word ptr [bp+stringBufferP+2]
	push	word ptr [bp+stringBufferP]
	call	strcat
	add	sp, 8
	lea	ax, [bp+stringBuffer]
	push	ss
	push	ax
	call	printString
	add	sp, 4
	mov	sp, bp
	pop	bp
	retf
bat_charHide endp

; Attributes: bp-based frame

bat_charSing proc far

	stringBufferP= dword ptr -108h
	stringBuffer= word ptr -102h
	canSingFlag= word ptr	-2
	slotNumber= word ptr	 6

	push	bp
	mov	bp, sp
	mov	ax, 108h
	call	someStackOperation

	mov	[bp+canSingFlag], 0
	mov	ax, charSize
	imul	[bp+slotNumber]
	mov	bx, ax
	lea	ax, party._name[bx]
	mov	dx, seg	seg027
	push	dx
	push	ax
	lea	ax, [bp+stringBuffer]
	push	ss
	push	ax
	call	strcat
	add	sp, 8
	mov	word ptr [bp+stringBufferP], ax
	mov	word ptr [bp+stringBufferP+2], dx

	mov	ax, itemEff_freeSinging
	push	ax
	push	[bp+slotNumber]
	call	character_isEffectEquipped
	add	sp, 4
	or	ax, ax
	jnz	short loc_1C384

	mov	[bp+canSingFlag], 1
	jmp	short loc_1C3AA

loc_1C384:
	mov	ax, charSize
	imul	[bp+slotNumber]
	mov	bx, ax
	cmp	gs:party.specAbil[bx],	0
	jz	short loc_1C3AA

	mov	[bp+canSingFlag], 1
	mov	ax, charSize
	imul	[bp+slotNumber]
	mov	bx, ax
	dec	gs:party.specAbil[bx]

loc_1C3AA:
	cmp	[bp+canSingFlag], 0
	jz	short loc_1C3F4
	mov	ax, offset s_plays
	push	ds
	push	ax
	push	word ptr [bp+stringBufferP+2]
	push	word ptr [bp+stringBufferP]
	call	strcat
	add	sp, 8
	mov	word ptr [bp+stringBufferP], ax
	mov	word ptr [bp+stringBufferP+2], dx
	lea	ax, [bp+stringBuffer]
	push	ss
	push	ax
	call	printString
	add	sp, 4
	mov	bx, [bp+slotNumber]
	mov	al, gs:g_batCharActionTarget[bx]
	sub	ah, ah
	push	ax
	push	bx
	call	bat_doCombatSong
	add	sp, 4
	jmp	short l_return
loc_1C3F4:
	mov	ax, offset s_lost
	push	ds
	push	ax
	push	word ptr [bp+stringBufferP+2]
	push	word ptr [bp+stringBufferP]
	call	strcat
	add	sp, 8
	mov	word ptr [bp+stringBufferP], ax
	mov	word ptr [bp+stringBufferP+2], dx
	mov	ax, 0
	push	ax
	mov	ax, 6
	push	ax
	push	[bp+slotNumber]
	push	dx
	push	word ptr [bp+stringBufferP]
	call	printCharPronoun
	add	sp, 0Ah
	mov	word ptr [bp+stringBufferP], ax
	mov	word ptr [bp+stringBufferP+2], dx
	mov	ax, offset s_voice
	push	ds
	push	ax
	push	dx
	push	word ptr [bp+stringBufferP]
	call	strcat
	add	sp, 8
	mov	word ptr [bp+stringBufferP], ax
	mov	word ptr [bp+stringBufferP+2], dx
	lea	ax, [bp+stringBuffer]
	push	ss
	push	ax
	call	printString
	add	sp, 4

l_return:
	mov	sp, bp
	pop	bp
	retf
bat_charSing endp

; Attributes: bp-based frame

bat_charPossessedAttack proc far

	slotNumber= word ptr	 6

	push	bp
	mov	bp, sp

	mov	ax, charSize
	imul	[bp+slotNumber]
	mov	bx, ax
	test	gs:party.status[bx], stat_nuts
	jz	short l_checkHostile

	call	random
	test	al, 1
	jnz	short l_partyTarget

l_checkHostile:
	mov	ax, charSize
	imul	[bp+slotNumber]
	mov	bx, ax
	cmp	gs:party.hostileFlag[bx], 0
	jz	short l_checkEnemyGroup

l_partyTarget:
	mov	ax, 7
	push	ax
	call	bat_getRandomChar
	add	sp, 2
	mov	bx, [bp+slotNumber]
	mov	gs:g_batCharActionTarget[bx], al
	jmp	short l_doAttack

l_checkEnemyGroup:
	cmp	byte ptr gs:monGroups._name, 0
	jz	short l_return

l_enemyTarget:
	mov	bx, [bp+slotNumber]
	mov	gs:g_batCharActionTarget[bx], 80h

l_doAttack:
	push	[bp+slotNumber]
	push	cs
	call	near ptr bat_charMelee
	add	sp, 4

l_return:
	mov	sp, bp
	pop	bp
	retf
bat_charPossessedAttack endp

; This function	returns	the highest priority in	the
; party. The character number with the highest
; priority is returned via membuf.
; Attributes: bp-based frame

bat_charGetNextPriority proc far

	char= word ptr -6
	slotNumber=	word ptr -4
	highestPriority= word ptr -2
	membuf=	dword ptr  6

	push	bp
	mov	bp, sp
	mov	ax, 6
	call	someStackOperation
	push	si

	mov	[bp+highestPriority], 0
	mov	[bp+char], 0

	mov	[bp+slotNumber], 0
l_loop:
	mov	bx, [bp+slotNumber]
	mov	al, gs:bat_charPriority[bx]
	sub	ah, ah
	mov	si, ax
	cmp	[bp+highestPriority], si
	jnb	short l_next
	mov	[bp+highestPriority], si
	mov	ax, bx
	mov	[bp+char], ax

l_next:
	inc	[bp+slotNumber]
	cmp	[bp+slotNumber], 7
	jl	short l_loop

l_return:
	lfs	bx, [bp+membuf]
	mov	ax, [bp+char]
	mov	fs:[bx], ax
	mov	ax, [bp+highestPriority]

	pop	si
	mov	sp, bp
	pop	bp
	retf
bat_charGetNextPriority endp

; This function	returns	the highest attack priority
; in the monster groups. The monster group and
; monster index	is returned in rGroup and rMon
; respectively.
; Attributes: bp-based frame

bat_monGetNextPriority proc far

	highMon= word ptr -0Ch
	monNo= word ptr	-0Ah
	groupNo= word ptr -8
	highPri= word ptr -6
	highGroup= word	ptr -4
	groupSize= word ptr	-2
	rGroup=	dword ptr  6
	rMon= dword ptr	 0Ah

	push	bp
	mov	bp, sp
	mov	ax, 0Ch
	call	someStackOperation
	push	si

	sub	ax, ax
	mov	[bp+highMon], ax
	mov	[bp+highGroup],	ax
	mov	[bp+highPri], ax
	mov	[bp+groupNo], ax

l_groupLoop:
	mov	ax, monStruSize
	imul	[bp+groupNo]
	mov	bx, ax
	mov	al, gs:monGroups.groupSize[bx]
	sub	ah, ah
	and	ax, 1Fh
	mov	[bp+groupSize], ax
	or	ax, ax
	jz	short l_groupLoopNext
	mov	[bp+monNo], 0

l_monsterLoop:
	mov	bx, [bp+groupNo]
	mov	cl, 6
	shl	bx, cl
	mov	ax, [bp+monNo]
	shl	ax, 1
	add	bx, ax
	mov	si, gs:bat_monPriorityList[bx]
	cmp	[bp+highPri], si
	jge	short l_monsterLoopNext
	mov	[bp+highPri], si
	mov	ax, [bp+groupNo]
	mov	[bp+highGroup],	ax
	mov	ax, [bp+monNo]
	mov	[bp+highMon], ax

l_monsterLoopNext:
	inc	[bp+monNo]
	mov	ax, [bp+groupSize]
	cmp	[bp+monNo], ax
	jl	short l_monsterLoop

l_groupLoopNext:
	inc	[bp+groupNo]
	cmp	[bp+groupNo], 4
	jl	short l_groupLoop

	lfs	bx, [bp+rGroup]
	mov	ax, [bp+highGroup]
	mov	fs:[bx], ax
	lfs	bx, [bp+rMon]
	mov	ax, [bp+highMon]
	mov	fs:[bx], ax
	mov	ax, [bp+highPri]

	pop	si
	mov	sp, bp
	pop	bp
	retf
bat_monGetNextPriority endp


; Attributes: bp-based frame

bat_setPriorities proc far

	monsterPriorityLo= word ptr	-0Eh
	loopCounter= word ptr	-0Ch
	currentMonster= word ptr	-0Ah
	monsterPriorityHi= word ptr	-8
	monsterGroupSize= word ptr	-6
	summonSlotP= dword ptr -4

	push	bp
	mov	bp, sp
	mov	ax, 0Eh
	call	someStackOperation
	push	si

	cmp	gs:partyFrozenFlag, 0
	jz	short l_getCharPriorities

	mov	[bp+loopCounter], 0
l_partyFrozenLoop:
	mov	bx, [bp+loopCounter]
	mov	gs:bat_charPriority[bx], 0
	inc	[bp+loopCounter]
	cmp	[bp+loopCounter], 7
	jl	short l_partyFrozenLoop
	mov	gs:partyFrozenFlag, 0
	jmp	l_getMonsterPriorities

l_getCharPriorities:
	mov	[bp+loopCounter], 0

l_characterLoop:
	mov	ax, charSize
	imul	[bp+loopCounter]
	mov	bx, ax
	cmp	byte ptr gs:party._name[bx], 0
	jz	l_getMonsterPriorities

	mov	ax, charSize
	imul	[bp+loopCounter]
	mov	si, ax
	cmp	gs:party.class[si], class_monster
	jb	short l_notSummon
	add	ax, offset party
	mov	word ptr [bp+summonSlotP], ax
	mov	word ptr [bp+summonSlotP+2], seg seg027
	lfs	bx, [bp+summonSlotP]
	mov	al, fs:[bx+18h]
	sub	ah, ah
	push	ax
	mov	al, fs:[bx+17h]
	push	ax
	push	cs
	call	near ptr randomBetweenXandY
	add	sp, 4
	mov	bx, [bp+loopCounter]
	mov	fs:bat_charPriority[bx], al
	jmp	l_characterLoopNext

l_notSummon:
	mov	bx, [bp+loopCounter]
	cmp	gs:g_charActionList[bx], 6
	jnz	short loc_1C696

	mov	gs:bat_charPriority[bx], 0FFh
	jmp	short l_characterLoopNext

loc_1C696:
	mov	ax, charSize
	imul	[bp+loopCounter]
	mov	si, ax
	mov	bl, gs:party.class[si]
	sub	bh, bh
	mov	al, byte_475AE[bx]
	mov	bx, [bp+loopCounter]
	mov	gs:bat_charPriority[bx], al
	call	random_2d16
	mov	cx, gs:party.level[si]
	shr	cx, 1
	mov	dl, gs:party.dexterity[si]
	shl	dl, 1
	add	cl, dl
	add	cl, al
	mov	bx, [bp+loopCounter]
	add	gs:bat_charPriority[bx], cl
	mov	bx, [bp+loopCounter]
	cmp	gs:bat_charPriority[bx], 0FFh
	jbe	short l_setMinimumPriority
	mov	gs:bat_charPriority[bx], 0FFh
	jmp	short l_characterLoopNext

l_setMinimumPriority:
	mov	bx, [bp+loopCounter]
	cmp	gs:bat_charPriority[bx], 0
	jnz	short l_characterLoopNext
	mov	gs:bat_charPriority[bx], 1

l_characterLoopNext:
	inc	[bp+loopCounter]
	cmp	[bp+loopCounter], 7
	jl	l_characterLoop

l_getMonsterPriorities:
	mov	[bp+loopCounter], 0

l_monsterGroupLoop:
	mov	ax, monStruSize
	imul	[bp+loopCounter]
	mov	si, ax
	mov	al, gs:monGroups.groupSize[si]
	sub	ah, ah
	and	ax, 1Fh
	mov	[bp+monsterGroupSize], ax
	or	ax, ax
	jz	short l_monsterGroupNext
	mov	al, gs:monGroups.oppPriorityLo[si]
	sub	ah, ah
	mov	[bp+monsterPriorityLo], ax
	mov	al, gs:monGroups.oppPriorityHi[si]
	mov	[bp+monsterPriorityHi], ax
	mov	[bp+currentMonster], 0

l_monsterLoop:
	push	[bp+monsterPriorityHi]
	push	[bp+monsterPriorityLo]
	push	cs
	call	near ptr randomBetweenXandY
	add	sp, 4
	mov	bx, [bp+loopCounter]
	mov	cl, 6
	shl	bx, cl
	mov	cx, [bp+currentMonster]
	shl	cx, 1
	add	bx, cx
	mov	gs:bat_monPriorityList[bx], ax
	inc	[bp+currentMonster]
	mov	ax, [bp+monsterGroupSize]
	cmp	[bp+currentMonster], ax
	jl	short l_monsterLoop

l_monsterGroupNext:
	inc	[bp+loopCounter]
	cmp	[bp+loopCounter], 4
	jl	short l_monsterGroupLoop

l_return:
	pop	si
	mov	sp, bp
	pop	bp
	retf
bat_setPriorities endp

; Attributes: bp-based frame

bat_setOpponents proc far

	var_E= word ptr	-0Eh
	currentGroupSize= word ptr	-0Ch
	monsterDataP= dword ptr -0Ah
	currentMonsterIndex= word ptr	-6
	currentGroupIndex= word ptr	-4
	monsterTypeIndex= word ptr	-2

	push	bp
	mov	bp, sp
	mov	ax, 0Eh
	call	someStackOperation
	push	si

	push	cs
	call	near ptr bat_reset
	mov	gs:byte_422A4, 1

	cmp	gs:bat_curSong,	0
	jz	short l_skipSongConversion

	mov	al, gs:g_currentSong
	sub	ah, ah
	push	ax
	mov	al, charSize
	mul	gs:g_currentSinger
	mov	bx, ax
	push	gs:party.level[bx]
	push	cs
	call	near ptr bat_convertSongToCombat
	add	sp, 4

l_skipSongConversion:
	cmp	g_partyAttackFlag, 0
	jz	short l_notPartyAttack

	sub	ax, ax
	push	ax
	push	cs
	call	near ptr bat_monResetGroups
	add	sp, 2
	jmp	l_return

l_notPartyAttack:
	cmp	gs:g_nonRandomBattleFlag, 0
	jnz	short l_getGroup

l_getGroupCount:
	call	random
	and	al, 3
	mov	g_monsterGroupCount, al
	cmp	al, g_levelNumber
	ja	short l_getGroupCount
	inc	g_monsterGroupCount

l_getGroup:
	mov	[bp+currentGroupIndex], 0

l_setGroupLoop:
	cmp	gs:g_nonRandomBattleFlag, 0
	jz	short l_selectRandomMonsterGroup

	mov	ax, monStruSize
	imul	[bp+currentGroupIndex]
	mov	si, ax
	mov	al, byte ptr gs:monGroups._name[si]	; Monster type index is stored in the
	sub	ah, ah					; first byte of the _name field for
	mov	[bp+monsterTypeIndex], ax		; hardcoded encounters
	mov	ax, monStruSize
	imul	[bp+monsterTypeIndex]
	add	ax, offset monsterBuf
	mov	word ptr [bp+monsterDataP], ax
	mov	word ptr [bp+monsterDataP+2], seg seg023
	mov	al, gs:monGroups.groupSize[si]
	sub	ah, ah
	and	ax, 1Fh
	mov	[bp+currentGroupSize], ax
	lfs	bx, [bp+monsterDataP]
	mov	al, fs:[bx+mon_t.groupSize]
	sub	ah, ah
	and	ax, 0E0h
	mov	[bp+var_E], ax
	jmp	short l_copyMonsterData

l_selectRandomMonsterGroup:
	mov	ax, 23
	push	ax
	sub	ax, ax
	push	ax
	push	cs
	call	near ptr randomBetweenXandY
	add	sp, 4
	mov	[bp+monsterTypeIndex], ax
	mov	ax, monStruSize
	imul	[bp+monsterTypeIndex]
	add	ax, offset monsterBuf
	mov	word ptr [bp+monsterDataP], ax
	mov	word ptr [bp+monsterDataP+2], seg seg023
	lfs	bx, [bp+monsterDataP]
	test	fs:[bx+mon_t.flags], mon_noSummon
	jnz	short l_selectRandomMonsterGroup

	cmp	byte ptr fs:[bx], 0
	jz	short l_selectRandomMonsterGroup

	mov	al, fs:[bx+mon_t.groupSize]
	sub	ah, ah
	and	ax, 0E0h
	mov	[bp+var_E], ax
	test	fs:[bx+mon_t.groupSize], 1Fh
	jz	short l_setMinimumGroupSize

	mov	al, fs:[bx+mon_t.groupSize]
	sub	ah, ah
	and	ax, 1Fh
	push	ax
	mov	ax, 1
	push	ax
	push	cs
	call	near ptr randomBetweenXandY
	add	sp, 4
	jmp	short l_setGroupSize

l_setMinimumGroupSize:
	mov	ax, 1

l_setGroupSize:
	mov	[bp+currentGroupSize], ax

l_copyMonsterData:
	mov	ax, monStruSize
	imul	[bp+currentGroupIndex]
	mov	bx, ax
	lea	ax, monGroups._name[bx]
	mov	dx, seg	seg027
	push	dx
	push	ax
	push	word ptr [bp+monsterDataP+2]
	push	word ptr [bp+monsterDataP]
	call	bat_monCopyBuffer
	add	sp, 8
	mov	al, byte ptr [bp+var_E]
	or	al, byte ptr [bp+currentGroupSize]
	mov	cx, ax
	mov	ax, monStruSize
	imul	[bp+currentGroupIndex]
	mov	bx, ax
	mov	gs:monGroups.groupSize[bx], cl

	mov	[bp+currentMonsterIndex], 0
l_setGroupHpLoop:
	mov	ax, monStruSize
	imul	[bp+currentGroupIndex]
	mov	si, ax
	mov	al, gs:monGroups.hpDice[si]
	sub	ah, ah
	push	ax
	push	cs
	call	near ptr randomYdX
	add	sp, 2
	mov	cx, gs:monGroups.hpBase[si]
	add	cx, ax
	mov	bx, [bp+currentGroupIndex]
	mov	ax, cx
	mov	cl, 6
	shl	bx, cl
	mov	cx, [bp+currentMonsterIndex]
	shl	cx, 1
	add	bx, cx
	mov	gs:monHpList[bx], ax
	inc	[bp+currentMonsterIndex]
	mov	ax, [bp+currentGroupSize]
	cmp	[bp+currentMonsterIndex], ax
	jl	short l_setGroupHpLoop

	inc	[bp+currentGroupIndex]
	mov	al, g_monsterGroupCount
	sub	ah, ah
	cmp	ax, [bp+currentGroupIndex]
	ja	l_setGroupLoop

	cmp	g_monsterGroupCount, 4
	jnb	short l_return

	mov	al, g_monsterGroupCount
	sub	ah, ah
	push	ax
	push	cs
	call	near ptr bat_monResetGroups
	add	sp, 2

l_return:
	pop	si
	mov	sp, bp
	pop	bp
	retf
bat_setOpponents endp

; Attributes: bp-based frame

bat_monResetGroups proc far

	var_2= word ptr	-2
	arg_0= word ptr	 6

	push	bp
	mov	bp, sp
	mov	ax, 2
	call	someStackOperation
	mov	ax, [bp+arg_0]
	mov	[bp+var_2], ax
	jmp	short loc_1C9AD
loc_1C9AA:
	inc	[bp+var_2]
loc_1C9AD:
	cmp	[bp+var_2], 3
	jge	short loc_1C9D5
	mov	ax, monStruSize
	push	ax
	sub	ax, ax
	push	ax
	getMonP	[bp+var_2], bx
	lea	ax, monGroups._name[bx]
	mov	dx, seg	seg027
	push	dx
	push	ax
	call	memset
	add	sp, 8
	jmp	short loc_1C9AA
loc_1C9D5:
	mov	sp, bp
	pop	bp
	retf
bat_monResetGroups endp

; Attributes: bp-based frame

bat_monSortGroups proc far

	var_4= word ptr	-4
	var_2= word ptr	-2

	push	bp
	mov	bp, sp
	mov	ax, 4
	call	someStackOperation
	push	si
loc_1C9E5:
	mov	[bp+var_4], 0
	mov	[bp+var_2], 3
	jmp	short loc_1C9F4
loc_1C9F1:
	dec	[bp+var_2]
loc_1C9F4:
	cmp	[bp+var_2], 0
	jle	short loc_1CA37
	getMonP	[bp+var_2], si
	test	gs:monGroups.groupSize[si], 1Fh
	jz	short loc_1CA35
	mov	al, gs:monGroups.distance[si]-30h
	and	al, 0Fh
	mov	cl, gs:monGroups.distance[si]
	and	cl, 0Fh
	cmp	al, cl
	jbe	short loc_1CA35
	mov	[bp+var_4], 1
	mov	ax, [bp+var_2]
	dec	ax
	push	ax
	push	[bp+var_2]
	push	cs
	call	near ptr bat_monSwapGroups
	add	sp, 4
loc_1CA35:
	jmp	short loc_1C9F1
loc_1CA37:
	cmp	[bp+var_4], 0
	jnz	short loc_1C9E5
	pop	si
	mov	sp, bp
	pop	bp
	retf
bat_monSortGroups endp

; Attributes: bp-based frame

bat_monSwapGroups proc far

	var_40=	word ptr -40h
	arg_0= word ptr	 6
	arg_2= word ptr	 8

	push	bp
	mov	bp, sp
	mov	ax, 40h
	call	someStackOperation
	mov	ax, 64
	push	ax
	mov	bx, [bp+arg_0]
	mov	cl, 6
	shl	bx, cl
	lea	ax, monHpList[bx]
	mov	dx, seg	seg027
	push	dx
	push	ax
	lea	ax, [bp+var_40]
	push	ss
	push	ax
	call	memcpy
	add	sp, 0Ah
	mov	ax, 64
	push	ax
	mov	bx, [bp+arg_2]
	mov	cl, 6
	shl	bx, cl
	lea	ax, monHpList[bx]
	mov	dx, seg	seg027
	push	dx
	push	ax
	mov	bx, [bp+arg_0]
	shl	bx, cl
	lea	ax, monHpList[bx]
	push	dx
	push	ax
	call	memcpy
	add	sp, 0Ah
	mov	ax, 64
	push	ax
	lea	ax, [bp+var_40]
	push	ss
	push	ax
	mov	bx, [bp+arg_2]
	mov	cl, 6
	shl	bx, cl
	lea	ax, monHpList[bx]
	mov	dx, seg	seg027
	push	dx
	push	ax
	call	memcpy
	add	sp, 0Ah
	mov	ax, monStruSize
	push	ax
	getMonP	[bp+arg_0], bx
	lea	ax, monGroups._name[bx]
	mov	dx, seg	seg027
	push	dx
	push	ax
	lea	ax, [bp+var_40]
	push	ss
	push	ax
	call	memcpy
	add	sp, 0Ah
	mov	ax, monStruSize
	push	ax
	getMonP	[bp+arg_2], bx
	lea	ax, monGroups._name[bx]
	mov	dx, seg	seg027
	push	dx
	push	ax
	getMonP	[bp+arg_0], bx
	lea	ax, monGroups._name[bx]
	mov	dx, seg	seg027
	push	dx
	push	ax
	call	memcpy
	add	sp, 0Ah
	mov	ax, monStruSize
	push	ax
	lea	ax, [bp+var_40]
	push	ss
	push	ax
	getMonP	[bp+arg_2], bx
	lea	ax, monGroups._name[bx]
	mov	dx, seg	seg027
	push	dx
	push	ax
	call	memcpy
	add	sp, 0Ah
	mov	sp, bp
	pop	bp
	retf
bat_monSwapGroups endp

; Attributes: bp-based frame
bat_printOpponents proc	far

	var_10C= word ptr -10Ch
	var_C= word ptr	-0Ch
	var_A= word ptr	-0Ah
	var_8= word ptr	-8
	var_6= word ptr	-6
	var_4= word ptr	-4
	var_2= word ptr	-2
	arg_0= word ptr	 6

	push	bp
	mov	bp, sp
	mov	ax, 10Ch
	call	someStackOperation
	cmp	gs:byte_4228B, 0
	jnz	short loc_1CB98
	mov	gs:byte_4228B, 0
	cmp	[bp+arg_0], 0
	jnz	short loc_1CB89
	call	bat_monGroupActive
	or	ax, ax
	jz	short loc_1CB63
	mov	ax, 6
	push	ax
	mov	ax, 1
	push	ax
	push	cs
	call	near ptr randomBetweenXandY
	add	sp, 4
	jmp	short loc_1CB65
loc_1CB63:
	sub	ax, ax
loc_1CB65:
	mov	[bp+var_C], ax
	mov	bx, ax
	shl	bx, 1
	shl	bx, 1
	push	word ptr (battleCryString+2)[bx]
	push	word ptr battleCryString[bx]
	call	printStringWClear
	add	sp, 4
	cmp	[bp+var_C], 0
	jnz	short loc_1CB87
	jmp	loc_1CC83
loc_1CB87:
	jmp	short loc_1CB96
loc_1CB89:
	mov	ax, offset aYouStillFace
	push	ds
	push	ax
	call	printStringWClear
	add	sp, 4
loc_1CB96:
	jmp	short loc_1CBA2
loc_1CB98:
	mov	gs:byte_4228B, 0
loc_1CBA2:
	lea	ax, [bp+var_10C]
	mov	[bp+var_8], ax
	mov	[bp+var_6], ss
	test	gs:monGroups.groupSize,	1Fh
	jnz	short loc_1CBCA
	mov	ax, offset aHostilePartyMembers
	push	ds
	push	ax
	call	printString
	add	sp, 4
	jmp	loc_1CC83
	jmp	short loc_1CBE0
loc_1CBCA:
	sub	ax, ax
	push	ax
	push	[bp+var_6]
	push	[bp+var_8]
	push	cs
	call	near ptr bat_monPrintGroup
	add	sp, 6
	mov	[bp+var_8], ax
	mov	[bp+var_6], dx
loc_1CBE0:
	mov	[bp+var_A], 1
	jmp	short loc_1CBEA
loc_1CBE7:
	inc	[bp+var_A]
loc_1CBEA:
	cmp	[bp+var_A], 4
	jle	short loc_1CBF3
	jmp	loc_1CC83
loc_1CBF3:
	getMonP	[bp+var_A], bx
	test	gs:monGroups.groupSize[bx], 1Fh
	jz	short loc_1CC0D
	cmp	[bp+var_A], 4
	jnz	short loc_1CC30
loc_1CC0D:
	mov	ax, offset a__1
	push	ds
	push	ax
	push	[bp+var_6]
	push	[bp+var_8]
	call	strcat
	add	sp, 8
	lea	ax, [bp+var_10C]
	push	ss
	push	ax
	call	printString
	add	sp, 4
	jmp	short loc_1CC83
loc_1CC30:
	getMonP	[bp+var_A], bx
	test	gs:stru_42372.groupSize[bx], 1Fh
	jz	short loc_1CC4A
	cmp	[bp+var_A], 2
	jnz	short loc_1CC4F
loc_1CC4A:
	mov	ax, offset aAnd_1
	jmp	short loc_1CC52
loc_1CC4F:
	mov	ax, offset asc_473AE
loc_1CC52:
	mov	[bp+var_4], ax
	mov	[bp+var_2], ds
	push	ds
	push	ax
	push	[bp+var_6]
	push	[bp+var_8]
	call	strcat
	add	sp, 8
	mov	[bp+var_8], ax
	mov	[bp+var_6], dx
	push	[bp+var_A]
	push	dx
	push	ax
	push	cs
	call	near ptr bat_monPrintGroup
	add	sp, 6
	mov	[bp+var_8], ax
	mov	[bp+var_6], dx
	jmp	loc_1CBE7
loc_1CC83:
	mov	sp, bp
	pop	bp
	retf
bat_printOpponents endp

; This function	prints a group that the	party faces
; in combat. The format	is:
; XX Name (YY')
; Where:
;   XX - Number	of monsters in the group
;   YY - Distance to the group
; Attributes: bp-based frame

bat_monPrintGroup proc far

	var_16=	word ptr -16h
	var_14=	word ptr -14h
	arg_0= dword ptr  6
	arg_4= word ptr	 0Ah

	push	bp
	mov	bp, sp
	mov	ax, 16h
	call	someStackOperation
	getMonP	[bp+arg_4], bx
	mov	al, gs:monGroups.groupSize[bx]
	sub	ah, ah
	and	ax, 1Fh
	mov	[bp+var_16], ax
	mov	ax, 2
	push	ax
	mov	ax, [bp+var_16]
	cwd
	push	dx
	push	ax
	push	word ptr [bp+arg_0+2]
	push	word ptr [bp+arg_0]
	call	itoa
	add	sp, 0Ah
	mov	word ptr [bp+arg_0], ax
	mov	word ptr [bp+arg_0+2], dx
	lfs	bx, [bp+arg_0]
	inc	word ptr [bp+arg_0]
	mov	byte ptr fs:[bx], 20h
	lea	ax, [bp+var_14]
	push	ss
	push	ax
	getMonP	[bp+arg_4], bx
	lea	ax, monGroups._name[bx]
	mov	dx, seg	seg027
	push	dx
	push	ax
	call	unmaskString
	add	sp, 8
	mov	ax, [bp+var_16]
	dec	ax
	push	ax
	push	word ptr [bp+arg_0+2]
	push	word ptr [bp+arg_0]
	lea	ax, [bp+var_14]
	push	ss
	push	ax
	call	str_pluralize
	add	sp, 0Ah
	mov	word ptr [bp+arg_0], ax
	mov	word ptr [bp+arg_0+2], dx
	lfs	bx, [bp+arg_0]
	inc	word ptr [bp+arg_0]
	mov	byte ptr fs:[bx], 20h ;	' '
	lfs	bx, [bp+arg_0]
	inc	word ptr [bp+arg_0]
	mov	byte ptr fs:[bx], 28h
	mov	ax, 2
	push	ax
	getMonP	[bp+arg_4], bx
	mov	al, gs:monGroups.distance[bx]
	sub	ah, ah
	and	ax, 0Fh
	sub	dx, dx
	mov	cx, ax
	mov	bx, dx
	shl	ax, 1
	rcl	dx, 1
	shl	ax, 1
	rcl	dx, 1
	add	ax, cx
	adc	dx, bx
	shl	ax, 1
	rcl	dx, 1
	push	dx
	push	ax
	push	word ptr [bp+arg_0+2]
	push	word ptr [bp+arg_0]
	call	itoa
	add	sp, 0Ah
	mov	word ptr [bp+arg_0], ax
	mov	word ptr [bp+arg_0+2], dx
	lfs	bx, [bp+arg_0]
	inc	word ptr [bp+arg_0]
	mov	byte ptr fs:[bx], 27h
	lfs	bx, [bp+arg_0]
	inc	word ptr [bp+arg_0]
	mov	byte ptr fs:[bx], 29h
	mov	ax, word ptr [bp+arg_0]
	mov	dx, word ptr [bp+arg_0+2]
	jmp	short $+2
	mov	sp, bp
	pop	bp
	retf
bat_monPrintGroup endp

; Attributes: bp-based frame

bat_setBigpic proc far

	var_26=	word ptr -26h
	var_24=	dword ptr -24h
	var_20=	word ptr -20h
	var_10=	word ptr -10h

	push	bp
	mov	bp, sp
	mov	ax, 26h	
	call	someStackOperation
	mov	al, gs:monGroups.groupSize
	sub	ah, ah
	and	ax, 1Fh
	mov	[bp+var_26], ax
	or	ax, ax
	jnz	short loc_1CDC3
	mov	ax, 21h	
	push	ax
	call	bigpic_drawPictureNumber
	add	sp, 2
	mov	ax, offset aParty
	push	ds
	push	ax
	call	setTitle
	add	sp, 4
	jmp	short loc_1CE1C
loc_1CDC3:
	lea	ax, [bp+var_20]
	push	ss
	push	ax
	mov	ax, offset monGroups
	mov	dx, seg	seg027
	push	dx
	push	ax
	call	unmaskString
	add	sp, 8
	mov	ax, [bp+var_26]
	dec	ax
	push	ax
	lea	ax, [bp+var_10]
	push	ss
	push	ax
	lea	ax, [bp+var_20]
	push	ss
	push	ax
	call	str_pluralize
	add	sp, 0Ah
	mov	word ptr [bp+var_24], ax
	mov	word ptr [bp+var_24+2],	dx
	lfs	bx, [bp+var_24]
	mov	byte ptr fs:[bx], 0
	lea	ax, [bp+var_10]
	push	ss
	push	ax
	call	setTitle
	add	sp, 4
	mov	al, gs:monGroups.picIndex
	sub	ah, ah
	push	ax
	call	bigpic_drawPictureNumber
	add	sp, 2
loc_1CE1C:
	mov	sp, bp
	pop	bp
	retf
bat_setBigpic endp

; Attributes: bp-based frame

bat_monCopyBuffer proc far

	arg_0= word ptr	 6
	arg_2= word ptr	 8
	arg_4= word ptr	 0Ah
	arg_6= word ptr	 0Ch

	push	bp
	mov	bp, sp
	xor	ax, ax
	call	someStackOperation
	mov	ax, monStruSize
	push	ax
	push	[bp+arg_2]
	push	[bp+arg_0]
	push	[bp+arg_6]
	push	[bp+arg_4]
	call	memcpy
	add	sp, 0Ah
	mov	sp, bp
	pop	bp
	retf
bat_monCopyBuffer endp

; Attributes: bp-based frame

bat_convertSongToCombat	proc far

	arg_0= word ptr	 6
	arg_2= word ptr	 8

	push	bp
	mov	bp, sp
	xor	ax, ax
	call	someStackOperation
	mov	ax, [bp+arg_2]
	jmp	short loc_1CEC0
loc_1CE55:
	mov	gs:songCanRun, 1
	or	gs:disbelieveFlags, disb_nohelp
	jmp	short loc_1CEDA
loc_1CE6B:
	cmp	[bp+arg_0], 60
	jle	short loc_1CE75
	mov	al, 0Fh
	jmp	short loc_1CE7C
loc_1CE75:
	mov	ax, [bp+arg_0]
	sar	ax, 1
	sar	ax, 1
loc_1CE7C:
	mov	gs:g_songAcBonus,	al
	or	al, al
	jnz	short loc_1CE8D
	inc	gs:g_songAcBonus
loc_1CE8D:
	jmp	short loc_1CEDA
loc_1CE8F:
	mov	ax, [bp+arg_0]
	cmp	ax, 0Fh
	jle	short loc_1CE9E
	mov	ax, 0Fh
loc_1CE9E:
	mov	gs:songRegenHP,	al
	jmp	short loc_1CEDA
loc_1CEA4:
	mov	gs:songExtraAttack, 1
	jmp	short loc_1CEDA
loc_1CEB0:
	mov	gs:songHalfDamage, 1
	jmp	short loc_1CEDA
loc_1CEBC:
	jmp	short loc_1CEDA
	jmp	short loc_1CEDA
loc_1CEC0:
	or	ax, ax
	jz	short loc_1CE55
	cmp	ax, song_sanctuary
	jz	short loc_1CE6B
	cmp	ax, song_bringaround
	jz	short loc_1CE8F
	cmp	ax, song_duotime
	jz	short loc_1CEA4
	cmp	ax, song_shield
	jz	short loc_1CEB0
	jmp	short loc_1CEBC
loc_1CEDA:
	mov	sp, bp
	pop	bp
	retf
bat_convertSongToCombat	endp

; Attributes: bp-based frame

bat_doCombatSong proc far

	l_songLevel= word ptr	-2
	partySlotNumber= word ptr	 6
	songNumber= word ptr	 8

	push	bp
	mov	bp, sp
	mov	ax, 2
	call	someStackOperation

	push	[bp+songNumber]
	push	[bp+partySlotNumber]
	call	song_playSong
	add	sp, 4

	mov	ax, charSize
	imul	[bp+partySlotNumber]
	mov	bx, ax
	cmp	gs:party.class[bx], class_monster
	jb	short l_getCharSongLevel		; If singer is not a character
	mov	[bp+l_songLevel], 1			; set song level to 1
	jmp	short loc_1CF2C

l_getCharSongLevel:
	mov	ax, charSize
	imul	[bp+partySlotNumber]
	mov	bx, ax	; Song level is
	mov	ax, gs:party.level[bx]			; character level
	sub	ax, 15
	sbb	cx, cx
	and	ax, cx
	add	ax, 15			; with a max value of 15
	mov	[bp+l_songLevel], ax
loc_1CF2C:
	mov	ax, [bp+songNumber]
	jmp	l_songSwitch

l_sirrobin:
	mov	gs:songCanRun, 1
	or	gs:disbelieveFlags, disb_nohelp
	jmp	l_return

l_sanctuary:
	mov	al, charSize
	mul	gs:g_currentSinger
	mov	bx, ax
	cmp	gs:party.level[bx], 60
	jnb	short loc_1CF7E
	mov	al, charSize
	mul	gs:g_currentSinger
	mov	bx, ax
	mov	ax, gs:party.level[bx]
	shr	ax, 1
	shr	ax, 1
	jmp	short loc_1CF80
loc_1CF7E:
	mov	al, 0Fh
loc_1CF80:
	mov	gs:g_songAcBonus,	al
	or	al, al
	jnz	short loc_1CF91
	inc	gs:g_songAcBonus
loc_1CF91:
	jmp	short l_return

l_bringaround:
	mov	al, byte ptr [bp+l_songLevel]
	mov	gs:songRegenHP,	al
	or	al, al
	jnz	short loc_1CFA7
	inc	gs:songRegenHP
loc_1CFA7:
	jmp	short l_return

l_duotime:
	mov	gs:songExtraAttack, 1
	jmp	short l_return

l_overture:
	mov	gs:bat_curTarget, 80h
	mov	ax, 237
	push	ax
	push	[bp+partySlotNumber]
	call	_batchSpellCast
	add	sp, 4
	jmp	short l_return

l_shield:
	mov	gs:songHalfDamage, 1
	mov	al, byte ptr [bp+l_songLevel]
	mov	gs:partySpellAcBonus, al

l_songSwitch:
	or	ax, ax
	jz	l_sirrobin
	cmp	ax, song_sanctuary
	jz	l_sanctuary
	cmp	ax, song_bringaround
	jz	short l_bringaround
	cmp	ax, song_duotime
	jz	short l_duotime
	cmp	ax, song_overture
	jz	short l_overture
	cmp	ax, song_shield
	jz	short l_shield
l_return:
	mov	sp, bp
	pop	bp
	retf
bat_doCombatSong endp


; Attributes: bp-based frame

bat_endCombatSong proc far
	push	bp
	mov	bp, sp

	cmp	gs:g_currentSongPlusOne, 0
	jz	short l_return
	mov	gs:g_currentSongPlusOne, 0
	mov	al, gs:g_currentSong
	sub	ah, ah
	jmp	short l_songSwitch
l_sirrobin:
	and	gs:disbelieveFlags, 0FDh
	jmp	short l_endAndReturn
l_shield:
	mov	gs:songHalfDamage, 0
	mov	gs:partySpellAcBonus, 0
	jmp	short l_endAndReturn
l_sanctuary:
	mov	gs:g_songAcBonus,	0
l_bringaround:
	mov	gs:songRegenHP,	0
	jmp	short l_endAndReturn
l_duotime:
	mov	gs:songExtraAttack, 0
	jmp	short l_endAndReturn
l_songSwitch:
	or	ax, ax
	jz	short l_sirrobin
	cmp	ax, song_sanctuary
	jz	short l_sanctuary
	cmp	ax, song_bringaround
	jz	short l_bringaround
	cmp	ax, song_duotime
	jz	short l_duotime
	cmp	ax, song_shield
	jz	short l_shield
l_endAndReturn:
	call	sound_stop
l_return:
	mov	sp, bp
	pop	bp
	retf
bat_endCombatSong endp

; Attributes: bp-based frame

bat_reset proc far

	counter= word ptr -2

	push	bp
	mov	bp, sp
	mov	ax, 2
	call	someStackOperation

	mov	[bp+counter], 0
l_resetMonsterDataLoop:
	mov	ax, 40h	
	push	ax
	sub	ax, ax
	push	ax
	mov	bx, [bp+counter]
	mov	cl, 6
	shl	bx, cl
	lea	ax, monHpList[bx]
	mov	dx, seg	seg027
	push	dx
	push	ax
	call	memset
	add	sp, 8

	mov	ax, 40h	
	push	ax
	sub	ax, ax
	push	ax
	mov	bx, [bp+counter]
	mov	cl, 6
	shl	bx, cl
	lea	ax, bat_monPriorityList[bx]
	mov	dx, seg	seg027
	push	dx
	push	ax
	call	memset
	add	sp, 8

	mov	ax, 40h	
	push	ax
	sub	ax, ax
	push	ax
	mov	bx, [bp+counter]
	mov	cl, 6
	shl	bx, cl
	lea	ax, bat_monBeenHitList[bx]
	mov	dx, seg	seg027
	push	dx
	push	ax
	call	memset
	add	sp, 8

	sub	al, al
	mov	bx, [bp+counter]
	mov	gs:g_monFreezeAcPenalty[bx], al
	mov	bx, [bp+counter]
	mov	gs:byte_41E50[bx], al
	mov	bx, [bp+counter]
	mov	gs:monSpellToHitPenalty[bx], al
	mov	bx, [bp+counter]
	mov	gs:monAttackBonus[bx], al
	inc	[bp+counter]
	cmp	[bp+counter], 4
	jl	l_resetMonsterDataLoop

	mov	[bp+counter], 0
l_resetCharacterDataLoop:
	mov	bx, [bp+counter]
	mov	gs:g_charActionList[bx], 2
	sub	al, al
	mov	bx, [bp+counter]
	mov	gs:vorpalPlateBonus[bx], al
	mov	bx, [bp+counter]
	mov	gs:g_strengthSpellBonus[bx], al
	mov	bx, [bp+counter]
	mov	gs:byte_42444[bx], al
	mov	bx, [bp+counter]
	mov	gs:g_characterMeleeDistance[bx], al
	mov	bx, [bp+counter]
	mov	gs:bat_charPriority[bx], al
	inc	[bp+counter]
	cmp	[bp+counter], 7
	jl	short l_resetCharacterDataLoop

	sub	al, al
	mov	gs:g_divineDamageBonus, al
	mov	gs:g_charFreezeToHitBonus, al
	mov	gs:g_charFreezeAcPenalty, al
	mov	gs:partySpellAcBonus, al
	mov	gs:g_monsterWOFBonus, al
	mov	gs:monFrozenFlag, al
	mov	gs:byte_422A4, al
	mov	gs:byte_41E63, al
	mov	gs:disbelieveFlags, al
	mov	gs:monDisbelieveFlag, al
	mov	gs:antiMagicFlag, al
	mov	gs:partyFrozenFlag, al
	mov	gs:songHalfDamage, al
	mov	gs:songCanRun, al
	mov	gs:songExtraAttack, al
	mov	gs:byte_4229A, al
	mov	gs:songRegenHP,	al
	sub	ax, ax
	mov	gs:batRewardHi,	ax
	mov	gs:batRewardLo,	ax

	mov	sp, bp
	pop	bp
	retf
bat_reset endp

; This function	returns	a random number	between	the
; low and the high
;
; Attributes: bp-based frame
randomBetweenXandY proc	far

	var_6= word ptr	-6
	var_4= word ptr	-4
	_mask= word ptr	-2
	_low= word ptr	6
	_high= word ptr	 8

	push	bp
	mov	bp, sp
	mov	ax, 6
	call	someStackOperation
	mov	ax, [bp+_high]
	sub	ax, [bp+_low]
	mov	[bp+var_4], ax
	or	ax, ax
	jg	short loc_1D246
	mov	ax, [bp+_low]
	jmp	short loc_1D26E
loc_1D246:
	push	[bp+var_4]
	push	cs
	call	near ptr getRndDiceMask
	add	sp, 2
	mov	[bp+_mask], ax
loc_1D253:
	call	random
	and	ax, [bp+_mask]
	mov	[bp+var_6], ax
	mov	ax, [bp+var_4]
	cmp	[bp+var_6], ax
	jg	short loc_1D253
	mov	ax, [bp+var_6]
	add	ax, [bp+_low]
	jmp	short $+2
loc_1D26E:
	mov	sp, bp
	pop	bp
	retf
randomBetweenXandY endp

; Attributes: bp-based frame

getRndDiceMask proc far

	var_2= word ptr	-2
	arg_1= byte ptr	 7

	push	bp
	mov	bp, sp
	mov	ax, 2
	call	someStackOperation
	push	si
	mov	[bp+arg_1], 0
	mov	[bp+var_2], 0
	jmp	short loc_1D2D2
loc_1D2CF:
	inc	[bp+var_2]
loc_1D2D2:
	cmp	[bp+var_2], 8
	jge	short loc_1D2F1
	mov	bx, [bp+var_2]
	mov	al, diceMaskList[bx]
	sub	ah, ah
	mov	si, ax
	cmp	[bp+6],	si
	ja	short loc_1D2EF
	jmp	short loc_1D2FE
loc_1D2EF:
	jmp	short loc_1D2CF
loc_1D2F1:
	mov	ax, offset aBadDiceMaskRange
	push	ds
	push	ax
	call	printMessageAndExit
	add	sp, 4
loc_1D2FE:
	pop	si
	mov	sp, bp
	pop	bp
	retf
getRndDiceMask endp

; This function	unpacks	a single byte into the number
; of dice to roll and the sides	of the dice. A random
; number between 1DX and YDX is	returned
; Attributes: bp-based frame
randomYdX proc	far

	rval= word ptr -8
	counter= word ptr -6
	ndice= word ptr	-4
	dieval=	word ptr -2
	die= word ptr  6

	push	bp
	mov	bp, sp
	mov	ax, 8
	call	someStackOperation
	mov	[bp+rval], 0
	mov	ax, [bp+die]
	mov	cl, 5
	sar	ax, cl
	and	ax, 7
	mov	[bp+dieval], ax
	mov	ax, [bp+die]
	and	ax, 1Fh
	mov	[bp+ndice], ax
	mov	[bp+counter], 0
	jmp	short loc_1D333
loc_1D330:
	inc	[bp+counter]
loc_1D333:
	mov	ax, [bp+ndice]
	cmp	[bp+counter], ax
	jg	short loc_1D356
	call	random
	mov	bx, [bp+dieval]
	mov	cl, diceMaskList[bx]
	sub	ch, ch
	and	cx, ax
	inc	cx
	add	[bp+rval], cx
	jmp	short loc_1D330
loc_1D356:
	mov	ax, [bp+rval]
	jmp	short $+2
	mov	sp, bp
	pop	bp
	retf
randomYdX endp

; Attributes: bp-based frame

bat_partyFightAction proc far
	push	bp
	mov	bp, sp
	xor	ax, ax
	call	someStackOperation
	sub	ax, ax
	jmp	short $+2
	mov	sp, bp
	pop	bp
	retf
bat_partyFightAction endp

; Attributes: bp-based frame

bat_partyAdvanceAction proc far

	var_2= word ptr	-2

	push	bp
	mov	bp, sp
	mov	ax, 2
	call	someStackOperation
	push	si
	mov	[bp+var_2], 0
	jmp	short loc_1D387
loc_1D384:
	inc	[bp+var_2]
loc_1D387:
	cmp	[bp+var_2], 4
	jge	short loc_1D3A8
	getMonP	[bp+var_2], si
	test	gs:monGroups.groupSize[si], 1Fh
	jz	short loc_1D3A6
	dec	gs:monGroups.distance[si]
loc_1D3A6:
	jmp	short loc_1D384
loc_1D3A8:
	mov	ax, offset aThePartyAdvances
	push	ds
	push	ax
	call	printStringWClear
	add	sp, 4
	mov	[bp+var_2], 0
	jmp	short loc_1D3BF
loc_1D3BC:
	inc	[bp+var_2]
loc_1D3BF:
	cmp	[bp+var_2], 7
	jge	short loc_1D3D4
	mov	bx, [bp+var_2]
	mov	gs:g_charActionList[bx], 2
	jmp	short loc_1D3BC
loc_1D3D4:
	mov	ax, 1
	jmp	short $+2
	pop	si
	mov	sp, bp
	pop	bp
	retf
bat_partyAdvanceAction endp

; Attributes: bp-based frame

bat_partyRunAction proc far

	var_2= word ptr	-2

	push	bp
	mov	bp, sp
	mov	ax, 2
	call	someStackOperation
	cmp	gs:songCanRun, 0
	jz	short loc_1D404
	mov	gs:runAwayFlag,	1
	mov	ax, 1
	jmp	short loc_1D46D
loc_1D404:
	mov	[bp+var_2], 0
	jmp	short loc_1D40E
loc_1D40B:
	inc	[bp+var_2]
loc_1D40E:
	cmp	[bp+var_2], 7
	jge	short loc_1D44C
	getCharP	[bp+var_2], bx
	cmp	byte ptr gs:party._name[bx], 0
	jz	short loc_1D44A
	mov	ax, itemEff_alwaysRunAway
	push	ax
	push	[bp+var_2]
	call	character_isEffectEquipped
	add	sp, 4
	or	ax, ax
	jnz	short loc_1D44A
	mov	gs:runAwayFlag,	1
	mov	ax, 1
	jmp	short loc_1D46D
loc_1D44A:
	jmp	short loc_1D40B
loc_1D44C:
	call	random
	sub	ah, ah
	mov	[bp+var_2], ax
	cmp	ax, 0C0h 
	jg	short loc_1D45F
	mov	al, 1
	jmp	short loc_1D461
loc_1D45F:
	sub	al, al
loc_1D461:
	mov	gs:runAwayFlag,	al
	sub	ah, ah
	jmp	short $+2
loc_1D46D:
	mov	sp, bp
	pop	bp
	retf
bat_partyRunAction endp

; Attributes: bp-based frame

bat_charAttackAction proc far

	targetNumber= word ptr	-2
	slotNumber= word ptr	 6

	push	bp
	mov	bp, sp
	mov	ax, 2
	call	someStackOperation
	mov	ax, offset s_attack
	push	ds
	push	ax
	mov	ax, 2
	push	ax
	push	cs
	call	near ptr bat_charGetActionTarget
	add	sp, 6
	cmp	ax, 0
	jl	l_returnZero

	mov	bx, [bp+slotNumber]
	mov	gs:g_batCharActionTarget[bx], al
	mov	ax, 1
	jmp	short l_return

l_returnZero:
	sub	ax, ax

l_return:
	mov	sp, bp
	pop	bp
	retf
bat_charAttackAction endp

; Attributes: bp-based frame

bat_charDefendAction proc far
	push	bp
	mov	bp, sp
	mov	ax, 1
	mov	sp, bp
	pop	bp
	retf
bat_charDefendAction endp

; Attributes: bp-based frame

bat_charCastAction proc far

	var_2= word ptr	-2
	slotNumber= word ptr	 6

	push	bp
	mov	bp, sp
	mov	ax, 2
	call	someStackOperation

	mov	ax, 1
	push	ax
	push	[bp+slotNumber]
	call	getSpellNumber
	add	sp, 4

	mov	[bp+var_2], ax
	or	ax, ax
	jl	l_returnZero

	mov	al, byte ptr g_curSpellNumber
	mov	bx, [bp+slotNumber]
	mov	gs:g_batCharActionTarget[bx], al
	cmp	[bp+var_2], 4
	jg	short loc_1D52D

	mov	ax, offset s_castAt
	push	ds
	push	ax
	push	[bp+var_2]
	push	cs
	call	near ptr bat_charGetActionTarget
	add	sp, 6
	or	ax,ax
	jge	l_bat_charCastAction_gotTarget

	mov	ax, 0				; Return 0 if no target selected.
	jmp	l_return

l_bat_charCastAction_gotTarget:
	mov	bx, [bp+slotNumber]
	mov	gs:byte_42276[bx], al
	mov	ax, 1
	jmp	short l_return

loc_1D52D:
	mov	al, byte ptr [bp+var_2]
	mov	bx, [bp+slotNumber]
	mov	gs:byte_42276[bx], al

l_returnOne:
	mov	ax, 1
	jmp	short l_return

l_returnZero:	
	sub	ax, ax

l_return:
	mov	sp, bp
	pop	bp
	retf
bat_charCastAction endp

; Attributes: bp-based frame

bat_charUseAction proc far

	var_F8=	word ptr -0F8h
	var_36=	word ptr -36h
	var_34=	word ptr -34h
	var_4= word ptr	-4
	var_2= word ptr	-2
	arg_0= word ptr	 6

	push	bp
	mov	bp, sp
	mov	ax, 0F8h 
	call	someStackOperation
	lea	ax, [bp+var_34]
	push	ss
	push	ax
	lea	ax, [bp+var_F8]
	push	ss
	push	ax
	push	[bp+arg_0]
	call	inventory_getItemList
	add	sp, 0Ah
	mov	[bp+var_36], ax
	or	ax, ax
	jnz	short loc_1D570
	jmp	loc_1D643
loc_1D570:
	push	ax
	lea	ax, [bp+var_34]
	push	ss
	push	ax
	mov	ax, offset s_whichItem
	push	ds
	push	ax
	call	text_scrollingWindow
	add	sp, 0Ah
	mov	[bp+var_4], ax
	or	ax, ax
	jge	short loc_1D58F
	sub	ax, ax
	jmp	loc_1D663
loc_1D58F:
	push	[bp+var_4]
	push	[bp+arg_0]
	call	inventory_canBeUsed
	add	sp, 4
	or	ax, ax
	jz	short loc_1D61F
	mov	al, byte ptr g_curSpellNumber
	mov	bx, [bp+arg_0]
	mov	gs:g_batCharActionTarget[bx], al
	mov	al, byte ptr [bp+var_4]
	mov	bx, [bp+arg_0]
	mov	gs:byte_42334[bx], al
	mov	bx, g_curSpellNumber
	mov	al, spellCastFlags[bx]
	sub	ah, ah
	and	ax, 7
	mov	[bp+var_2], ax
	cmp	ax, 4
	jge	short loc_1D609
	mov	ax, offset s_nlUseOn
	push	ds
	push	ax
	push	[bp+var_2]
	push	cs
	call	near ptr bat_charGetActionTarget
	add	sp, 6

	or	ax, ax
	jl	l_bat_useItem_opt_return_zero

	mov	bx, [bp+arg_0]
	mov	gs:byte_42276[bx], al
	mov	ax, 1
	jmp	short loc_1D605
	sub	ax, ax
loc_1D605:
	jmp	short loc_1D663
	jmp	short loc_1D618
loc_1D609:
	mov	al, byte ptr [bp+var_2]
	mov	bx, [bp+arg_0]
	mov	gs:byte_42276[bx], al
loc_1D618:
	mov	ax, 1
	jmp	short loc_1D663
loc_1D61F:
	mov	ax, offset aYouCanTUseThatItem_
	push	ds
	push	ax
	call	printStringWClear
	add	sp, 4
	wait4IO
	call	text_clear
	sub	ax, ax
	jmp	short loc_1D663
loc_1D641:
	jmp	short loc_1D663
loc_1D643:
	mov	ax, offset s_pocketsAreEmpty
	mov	dx, seg	dseg
	push	dx
	push	ax
	call	printStringWClear
	add	sp, 4
	wait4IO
l_bat_useItem_opt_return_zero:
	sub	ax, ax
	jmp	short $+2
loc_1D663:
	mov	sp, bp
	pop	bp
	retf
bat_charUseAction endp

; Attributes: bp-based frame

bat_charHideAction proc far
	push	bp
	mov	bp, sp
	mov	ax, 1
	mov	sp, bp
	pop	bp
	retf
bat_charHideAction endp

; Attributes: bp-based frame

bat_charSingAction proc far

	var_2= word ptr	-2
	arg_0= word ptr	 6

	push	bp
	mov	bp, sp
	mov	ax, 2
	call	someStackOperation
	call	text_clear
	sub	ax, ax
	push	ax
	push	[bp+arg_0]
	call	song_getSong
	add	sp, 4
	mov	[bp+var_2], ax
	or	ax, ax
	jl	short loc_1D6AE
	mov	al, byte ptr [bp+var_2]
	mov	bx, [bp+arg_0]
	mov	gs:g_batCharActionTarget[bx], al
loc_1D6AE:
	cmp	[bp+var_2], 0
	jl	short loc_1D6B9
	mov	ax, 1
	jmp	short loc_1D6BB
loc_1D6B9:
	sub	ax, ax
loc_1D6BB:
	jmp	short $+2
	mov	sp, bp
	pop	bp
	retf
bat_charSingAction endp

; Attributes: bp-based frame
bat_charPartyAttackAction proc	far

	arg_0= word ptr	 6

	push	bp
	mov	bp, sp
	mov	ax, offset s_attack
	push	ds
	push	ax
	mov	ax, 1
	push	ax
	push	cs
	call	near ptr bat_charGetActionTarget
	add	sp, 6
	cmp	ax, 0
	jl	l_returnZero

	mov	bx, [bp+arg_0]
	mov	gs:g_batCharActionTarget[bx], al
	mov	ax, 1
	jmp	short l_return

l_returnZero:
	sub	ax, ax

l_return:
	mov	sp, bp
	pop	bp
	retf
bat_charPartyAttackAction endp

; Attributes: bp-based frame

bat_partyGetActions proc far

	charNo=	word ptr -138h
	var_136= word ptr -136h
	var_36=	word ptr -36h
	var_22=	word ptr -22h
	var_20=	word ptr -20h
	var_16=	word ptr -16h
	var_14=	word ptr -14h
	var_12=	word ptr -12h
	var_10=	word ptr -10h
	var_6= word ptr	-6
	var_4= dword ptr -4

	push	bp
	mov	bp, sp
	mov	ax, 138h
	call	someStackOperation
	push	si
	cmp	g_partyAttackFlag, 0
	jz	short loc_1D720
	jmp	loc_1D7BE
loc_1D720:
	call	bat_monGroupActive
	or	ax, ax
	jnz	short loc_1D72C
	jmp	loc_1D7BE
loc_1D72C:
	call	_return_zero
	or	ax, ax
	jz	short loc_1D738
	jmp	loc_1D7BE
loc_1D738:
	lea	ax, [bp+var_10]
	push	ss
	push	ax
	push	cs
	call	near ptr bat_partyCanAdvance
	add	sp, 4
	lea	ax, [bp+var_36]
	push	ss
	push	ax
	lea	ax, [bp+var_20]
	push	ss
	push	ax
	lea	ax, [bp+var_10]
	push	ss
	push	ax
	mov	ax, offset aWillYourGallantBand
	push	ds
	push	ax
	call	printVarString
	add	sp, 10h
	mov	[bp+var_14], ax
loc_1D763:
	mov	[bp+var_22], 1
	push	[bp+var_14]
	call	getKey
	add	sp, 2
	mov	[bp+var_6], ax
	mov	[bp+var_16], 0
loc_1D77B:
	mov	si, [bp+var_16]
	cmp	byte ptr [bp+si+var_20], 0
	jz	short loc_1D7B8
	mov	al, byte ptr [bp+si+var_20]
	cbw
	cmp	ax, [bp+var_6]
	jz	short loc_1D797
	shl	si, 1
	mov	ax, [bp+var_6]
	cmp	[bp+si+var_36],	ax
	jnz	short loc_1D7B3
loc_1D797:
	mov	bx, [bp+var_16]
	shl	bx, 1
	shl	bx, 1
	call	off_475D0[bx]
	mov	[bp+var_12], ax
	or	ax, ax
	jz	short loc_1D7AE
	jmp	loc_1D996
	jmp	short loc_1D7B3
loc_1D7AE:
	mov	[bp+var_22], 0
loc_1D7B3:
	inc	[bp+var_16]
	jmp	short loc_1D77B
loc_1D7B8:
	cmp	[bp+var_22], 0
	jnz	short loc_1D763
loc_1D7BE:
	mov	[bp+charNo], 0
	jmp	short loc_1D7CA
loc_1D7C6:
	inc	[bp+charNo]
loc_1D7CA:
	cmp	[bp+charNo], 7
	jl	short loc_1D7D4
	jmp	loc_1D97D
loc_1D7D4:
	getCharP	[bp+charNo], bx
	cmp	byte ptr gs:party._name[bx], 0
	jnz	short loc_1D7EC
	jmp	loc_1D97D
loc_1D7EC:
	call	text_clear
	getCharP	[bp+charNo], si
	cmp	gs:party.class[si], class_monster
	jb	short loc_1D809
	jmp	loc_1D97A
loc_1D809:
	test	gs:party.status[si], stat_dead	or stat_stoned or stat_paralyzed
	jz	short loc_1D814
	jmp	loc_1D97A
loc_1D814:
	test	gs:party.status[si], stat_possessed or	stat_nuts
	jz	short loc_1D827
	cmp	gs:(party.specAbil+3)[si], 0
	jz	short loc_1D827
	jmp	loc_1D96C
loc_1D827:
	call	text_clear
	getCharP	[bp+charNo], bx
	lea	ax, party._name[bx]
	mov	dx, seg	seg027
	push	dx
	push	ax
	lea	ax, [bp+var_136]
	push	ss
	push	ax
	call	strcat
	add	sp, 8
	mov	word ptr [bp+var_4], ax
	mov	word ptr [bp+var_4+2], dx
	mov	ax, offset aHasTheseOptionsThisBa
	push	ds
	push	ax
	push	dx
	push	word ptr [bp+var_4]
	call	strcat
	add	sp, 8
	mov	word ptr [bp+var_4], ax
	mov	word ptr [bp+var_4+2], dx
	mov	bx, [bp+charNo]
	cmp	gs:g_characterMeleeDistance[bx], 0
	jz	short loc_1D89A
	mov	al, gs:g_characterMeleeDistance[bx]
	add	al, '1'
	mov	byte_4724A, al
	mov	ax, offset byte_4724A
	push	ds
	push	ax
	push	dx
	push	word ptr [bp+var_4]
	call	strcat
	add	sp, 8
	mov	word ptr [bp+var_4], ax
	mov	word ptr [bp+var_4+2], dx
loc_1D89A:
	mov	ax, offset a@defend@partyAttack@c
	push	ds
	push	ax
	push	word ptr [bp+var_4+2]
	push	word ptr [bp+var_4]
	call	strcat
	add	sp, 8
	mov	word ptr [bp+var_4], ax
	mov	word ptr [bp+var_4+2], dx
	lfs	bx, [bp+var_4]
	inc	word ptr [bp+var_4]
	mov	byte ptr fs:[bx], 0
	push	[bp+charNo]
	lea	ax, [bp+var_10]
	push	ss
	push	ax
	push	cs
	call	near ptr bat_charGetAction
	add	sp, 6
	lea	ax, [bp+var_36]
	push	ss
	push	ax
	lea	ax, [bp+var_20]
	push	ss
	push	ax
	lea	ax, [bp+var_10]
	push	ss
	push	ax
	lea	ax, [bp+var_136]
	push	ss
	push	ax
	call	printVarString
	add	sp, 10h
	mov	[bp+var_14], ax
	mov	ax, offset aSelectAnOption_
	push	ds
	push	ax
	call	printString
	add	sp, 4
	mov	[bp+var_22], 1
	push	[bp+var_14]
	call	getKey
	add	sp, 2
	mov	[bp+var_6], ax
	mov	[bp+var_16], 0
loc_1D912:
	mov	si, [bp+var_16]
	cmp	byte ptr [bp+si+var_20], 0
	jz	short loc_1D961
	mov	al, byte ptr [bp+si+var_20]
	cbw
	cmp	ax, [bp+var_6]
	jz	short loc_1D92E
	shl	si, 1
	mov	ax, [bp+var_6]
	cmp	[bp+si+var_36],	ax
	jnz	short loc_1D95C
loc_1D92E:
	mov	al, byte ptr [bp+var_16]
	inc	al
	mov	bx, [bp+charNo]
	mov	gs:g_charActionList[bx], al
	push	[bp+charNo]
	mov	bx, [bp+var_16]
	shl	bx, 1
	shl	bx, 1
	call	off_475DC[bx]
	add	sp, 2
	cmp	ax, 1
	sbb	cx, cx
	neg	cx
	mov	[bp+var_22], cx
loc_1D95C:
	inc	[bp+var_16]
	jmp	short loc_1D912
loc_1D961:
	cmp	[bp+var_22], 0
	jz	short loc_1D96A
	jmp	loc_1D827
loc_1D96A:
	jmp	short loc_1D97A
loc_1D96C:
	mov	bx, [bp+charNo]
	mov	gs:g_charActionList[bx], 8
loc_1D97A:
	jmp	loc_1D7C6
loc_1D97D:
	mov	ax, offset s_useTheseCommands?
	push	ds
	push	ax
	call	printStringWClear
	add	sp, 4
	call	getYesNo
	or	ax, ax
	jnz	short loc_1D996
	jmp	loc_1D7BE
loc_1D996:
	pop	si
	mov	sp, bp
	pop	bp
	retf
bat_partyGetActions endp

; Attributes: bp-based frame
bat_partyCanAdvance proc	far

	arg_0= dword ptr  6

	push	bp
	mov	bp, sp
	xor	ax, ax
	call	someStackOperation
	lfs	bx, [bp+arg_0]
	mov	byte ptr fs:[bx], 1
	push	cs
	call	near ptr bat_monGroupInMeleeRange
	lfs	bx, [bp+arg_0]
	mov	fs:[bx+1], al
	lfs	bx, [bp+arg_0]
	mov	byte ptr fs:[bx+2], 1
	mov	sp, bp
	pop	bp
	retf
bat_partyCanAdvance endp


; This function	returns	0 if there is a	monster
; group	in melee range.	1 otherwise. This is used
; to determine whether the party should	be given
; the "Advance"	option in battle.
; Attributes: bp-based frame

bat_monGroupInMeleeRange proc far

	var_2= word ptr	-2

	push	bp
	mov	bp, sp
	mov	ax, 2
	call	someStackOperation
	push	si
	mov	[bp+var_2], 3
	jmp	short loc_1D9D9
loc_1D9D6:
	dec	[bp+var_2]
loc_1D9D9:
	cmp	[bp+var_2], 0
	jl	short loc_1DA04
	getMonP	[bp+var_2], si
	test	gs:monGroups.groupSize[si], 1Fh
	jz	short loc_1DA02
	mov	al, gs:monGroups.distance[si]
	and	al, 0Fh
	cmp	al, 2
	jnb	short loc_1DA02
	sub	ax, ax
	jmp	short loc_1DA09
loc_1DA02:
	jmp	short loc_1D9D6
loc_1DA04:
	mov	ax, 1
	jmp	short $+2
loc_1DA09:
	pop	si
	mov	sp, bp
	pop	bp
	retf
bat_monGroupInMeleeRange endp

; Attributes: bp-based frame
bat_charGetAction proc	far

	arg_0= dword ptr  6
	arg_4= word ptr	 0Ah

	push	bp
	mov	bp, sp
	xor	ax, ax
	call	someStackOperation
	cmp	g_partyAttackFlag, 0
	jnz	short loc_1DA49
	test	gs:monGroups.groupSize,	1Fh
	jz	short loc_1DA49
	cmp	[bp+arg_4], 4
	jl	short loc_1DA45
	mov	bx, [bp+arg_4]
	cmp	gs:g_characterMeleeDistance[bx], 0
	jz	short loc_1DA49
loc_1DA45:
	mov	al, 1
	jmp	short loc_1DA4B
loc_1DA49:
	sub	al, al
loc_1DA4B:
	lfs	bx, [bp+arg_0]
	mov	fs:[bx], al
	lfs	bx, [bp+arg_0]
	mov	byte ptr fs:[bx+1], 1
	mov	byte ptr fs:[bx+2], 1
	getCharP	[bp+arg_4], bx
	mov	ax, gs:party.currentSppt[bx]
	lfs	bx, [bp+arg_0]
	or	ax, ax
	jz	l_bat_charGetAction_sppts
	mov	al, 1

l_bat_charGetAction_sppts:
	mov	fs:[bx+3], al
	mov	byte ptr fs:[bx+4], 1
	mov	bx, [bp+arg_4]
	cmp	gs:g_characterMeleeDistance[bx], 9
	jnb	short loc_1DAA7
	getCharP	bx, bx
	cmp	gs:party.class[bx], class_rogue
	jnz	short loc_1DAA7
	mov	al, 1
	jmp	short loc_1DAA9
loc_1DAA7:
	sub	al, al
loc_1DAA9:
	lfs	bx, [bp+arg_0]
	mov	fs:[bx+5], al
	getCharP	[bp+arg_4], bx
	cmp	gs:party.class[bx], class_bard
	jnz	short loc_1DADB
	mov	ax, itType_instrument
	push	ax
	push	[bp+arg_4]
	call	character_hasTypeEquipped
	add	sp, 4
	or	ax, ax
	jz	short loc_1DADB
	mov	al, 1
	jmp	short loc_1DADD
loc_1DADB:
	sub	al, al
loc_1DADD:
	lfs	bx, [bp+arg_0]
	mov	fs:[bx+6], al
	mov	sp, bp
	pop	bp
	retf
bat_charGetAction endp

; Attributes: bp-based frame

bat_charGetActionTarget proc far

	var_228= byte ptr -228h
	var_11E= byte ptr -11Eh
	var_11C= word ptr -11Ch
	var_11A= byte ptr -11Ah
	var_119= byte ptr -119h
	var_10E= word ptr -10Eh
	var_E= word ptr	-0Eh
	var_C= dword ptr -0Ch
	var_8= word ptr	-8
	var_6= word ptr	-6
	var_4= word ptr	-4
	var_2= word ptr	-2
	arg_0= word ptr	 6
	stringOff= word	ptr  8
	stringSeg= word	ptr  0Ah

	push	bp
	mov	bp, sp
	mov	ax, 11Eh
	call	someStackOperation
	push	si
	mov	ax, 0FFFFh
	mov	[bp+var_8], ax
	mov	[bp+var_2], ax
	mov	[bp+var_6], 0
	mov	[bp+var_11C], 0
	jmp	short loc_1DB0E
loc_1DB0A:
	inc	[bp+var_11C]
loc_1DB0E:
	cmp	[bp+var_11C], 0Ch
	jge	short loc_1DB20
	mov	si, [bp+var_11C]
	mov	[bp+si+var_11A], 20h 
	jmp	short loc_1DB0A
loc_1DB20:
	push	[bp+stringSeg]
	push	[bp+stringOff]
	call	printStringWClear
	add	sp, 4
	mov	ax, [bp+arg_0]
	jmp	loc_1DD02
loc_1DB34:
	call	party_findEmptySlot
	mov	[bp+var_8], ax
	cmp	ax, 1
	jg	short loc_1DB46
	sub	ax, ax
	jmp	loc_1DD93
loc_1DB46:
	mov	al, byte ptr [bp+var_8]
	add	al, monStruSize
	mov	byte ptr aMember17+0Bh,	al
	mov	ax, offset aMember17
	push	ds
	push	ax
	call	printString
	add	sp, 4
	mov	[bp+var_4], 2000h
	jmp	loc_1DD20
loc_1DB63:
	push	cs
	call	near ptr bat_monGroupCount
	mov	[bp+var_2], ax
	cmp	ax, 1
	jg	short loc_1DB75
	mov	ax, 80h
	jmp	loc_1DD93
loc_1DB75:
	mov	[bp+var_4], 0
	mov	[bp+var_11C], 0
	jmp	short loc_1DB86
loc_1DB82:
	inc	[bp+var_11C]
loc_1DB86:
	mov	ax, [bp+var_2]
	cmp	[bp+var_11C], ax
	jge	short loc_1DC09
	lea	ax, [bp+var_10E]
	mov	word ptr [bp+var_C], ax
	mov	word ptr [bp+var_C+2], ss
	mov	al, gs:txt_numLines
	sub	ah, ah
	mov	si, ax
	mov	bx, si
	shl	bx, 1
	mov	ax, (bitMask16bit+2)[bx]
	or	[bp+var_4], ax
	mov	al, byte ptr [bp+var_11C]
	add	al, 41h	
	mov	[bp+var_11E], al
	mov	[bp+si+var_119], al
	lfs	bx, [bp+var_C]
	inc	word ptr [bp+var_C]
	mov	al, [bp+var_11E]
	mov	fs:[bx], al
	lfs	bx, [bp+var_C]
	inc	word ptr [bp+var_C]
	mov	byte ptr fs:[bx], 29h
	push	[bp+var_11C]
	push	word ptr [bp+var_C+2]
	push	word ptr [bp+var_C]
	push	cs
	call	near ptr bat_monPrintGroup
	add	sp, 6
	mov	word ptr [bp+var_C], ax
	mov	word ptr [bp+var_C+2], dx
	lfs	bx, [bp+var_C]
	mov	byte ptr fs:[bx], 0
	lea	ax, [bp+var_10E]
	push	ss
	push	ax
	call	printString
	add	sp, 4
	jmp	loc_1DB82
loc_1DC09:
	jmp	loc_1DD20
loc_1DC0C:
	call	party_findEmptySlot
	mov	[bp+var_8], ax
	push	cs
	call	near ptr bat_monGroupCount
	mov	[bp+var_2], ax
	mov	[bp+var_4], 2000h
	mov	[bp+var_11C], 0
	jmp	short loc_1DC2C
loc_1DC28:
	inc	[bp+var_11C]
loc_1DC2C:
	mov	ax, [bp+var_2]
	cmp	[bp+var_11C], ax
	jge	short loc_1DCAF
	lea	ax, [bp+var_10E]
	mov	word ptr [bp+var_C], ax
	mov	word ptr [bp+var_C+2], ss
	mov	al, gs:txt_numLines
	sub	ah, ah
	mov	si, ax
	mov	bx, si
	shl	bx, 1
	mov	ax, (bitMask16bit+2)[bx]
	or	[bp+var_4], ax
	mov	al, byte ptr [bp+var_11C]
	add	al, 41h	
	mov	[bp+var_11E], al
	mov	[bp+si+var_119], al
	lfs	bx, [bp+var_C]
	inc	word ptr [bp+var_C]
	mov	al, [bp+var_11E]
	mov	fs:[bx], al
	lfs	bx, [bp+var_C]
	inc	word ptr [bp+var_C]
	mov	byte ptr fs:[bx], 29h
	push	[bp+var_11C]
	push	word ptr [bp+var_C+2]
	push	word ptr [bp+var_C]
	push	cs
	call	near ptr bat_monPrintGroup
	add	sp, 6
	mov	word ptr [bp+var_C], ax
	mov	word ptr [bp+var_C+2], dx
	lfs	bx, [bp+var_C]
	mov	byte ptr fs:[bx], 0
	lea	ax, [bp+var_10E]
	push	ss
	push	ax
	call	printString
	add	sp, 4
	jmp	loc_1DC28
loc_1DCAF:
	cmp	[bp+var_2], 0
	jz	short loc_1DCCE
	mov	ax, offset aOr
	push	ds
	push	ax
	push	word ptr [bp+var_C+2]
	push	word ptr [bp+var_C]
	call	strcat
	add	sp, 8
	mov	word ptr [bp+var_C], ax
	mov	word ptr [bp+var_C+2], dx
loc_1DCCE:
	cmp	[bp+var_8], 1
	jle	short loc_1DCEB
	mov	al, byte ptr [bp+var_8]
	add	al, monStruSize
	mov	byte ptr aMember17+0Bh,	al
	mov	ax, offset aMember17
	push	ds
	push	ax
	call	printString
	add	sp, 4
	jmp	short loc_1DCF8
loc_1DCEB:
	mov	ax, offset aMember1
	push	ds
	push	ax
	call	printString
	add	sp, 4
loc_1DCF8:
	jmp	short loc_1DD20
loc_1DCFA:
	mov	ax, 80h
	jmp	loc_1DD93
	jmp	short loc_1DD20
loc_1DD02:
	or	ax, ax
	jl	short loc_1DCFA
	cmp	ax, target_partyMember
	jg	short loc_1DD0E
	jmp	loc_1DB34
loc_1DD0E:
	cmp	ax, 2
	jnz	short loc_1DD16
	jmp	loc_1DB63
loc_1DD16:
	cmp	ax, 3
	jnz	short loc_1DD1E
	jmp	loc_1DC0C
loc_1DD1E:
	jmp	short loc_1DCFA
loc_1DD20:
	push	[bp+var_4]
	call	getKey
	add	sp, 2
	mov	[bp+var_E], ax
	cmp	ax, 10Eh
	jl	short loc_1DD43
	cmp	ax, 119h
	jg	short loc_1DD43
	mov	si, ax
	mov	al, [bp+si+var_228]
	sub	ah, ah
	mov	[bp+var_E], ax
loc_1DD43:
	cmp	[bp+var_6], 0
	jz	short loc_1DD54
	cmp	[bp+var_E], 1Bh
	jnz	short loc_1DD54
	mov	ax, 0FFFFh
	jmp	short loc_1DD93
loc_1DD54:
	cmp	[bp+var_E], 30h	
	jle	short loc_1DD6D
	mov	ax, [bp+var_8]
	add	ax, 31h	
	cmp	ax, [bp+var_E]
	jle	short loc_1DD6D
	mov	ax, [bp+var_E]
	sub	ax, 31h	
	jmp	short loc_1DD93
loc_1DD6D:
	cmp	[bp+var_E], 41h	
	jl	short loc_1DD86
	mov	ax, [bp+var_2]
	add	ax, 41h	
	cmp	ax, [bp+var_E]
	jle	short loc_1DD86
	mov	ax, [bp+var_E]
	add	ax, 3Fh	
	jmp	short loc_1DD93
loc_1DD86:
	cmp	[bp+var_E], 1Bh
	jnz	short loc_1DD91
	mov	ax, 0FFFFh
	jmp	short loc_1DD93
loc_1DD91:
	jmp	short loc_1DD20
loc_1DD93:
	pop	si
	mov	sp, bp
	pop	bp
	retf
bat_charGetActionTarget endp

; Attributes: bp-based frame

bat_monGroupCount proc far

	var_2= word ptr	-2

	push	bp
	mov	bp, sp
	mov	ax, 2
	call	someStackOperation
	mov	[bp+var_2], 0
	jmp	short loc_1DDAD
loc_1DDAA:
	inc	[bp+var_2]
loc_1DDAD:
	cmp	[bp+var_2], 4
	jge	short loc_1DDCE
	getMonP	[bp+var_2], bx
	test	gs:monGroups.groupSize[bx], 1Fh
	jnz	short loc_1DDCC
	mov	ax, [bp+var_2]
	jmp	short loc_1DDD3
loc_1DDCC:
	jmp	short loc_1DDAA
loc_1DDCE:
	mov	ax, 4
	jmp	short $+2
loc_1DDD3:
	mov	sp, bp
	pop	bp
	retf
bat_monGroupCount endp

; Calculating melee success
; -------------------------
; 1. Determine the target's AC
;    a. Party member
;	targetAc = member.ac
;    b. Monster
;       targetAc = monsterType.ac + monsterType.acBonus + monsterType.advanceSpeedBonus - freezeSpell.penalty
;
; 2. Subtract equipped weapon (if any) toHit bonus from targetAc
;    targetAc -= weapon.toHitBonus
;
; 3. Add monster-cast Word of Fear bonus
;    targetAc += monster.wofBonus
;
; 4. Determine source attack value
;    a. Summon
;       sourceAttack = random(summon.toHitLo, summon.toHitHi)
;    b. Character
;       i.  sourceAttack = MAX((level >> 4), 255)
;       ii. Subtract (strength >> 1) from targetAc
;           targetAc -= (strength >> 1)
;
; 5. Calculate pre-bonus attackSuccess
;    attackSuccessFlag = targetAc - sourceAttack
;
; 6. Apply bonues
;    attackSuccessFlag -= (classToHitBonus + freezeSpellToHitBonus + 2d8 + strengthSpellBonus)
;
; 7. If (attackSuccessFlag > 0)
;    Attack fails
;
; Attributes: bp-based frame

bat_charExecuteMeleeAttack proc far

	monkLevel=	word ptr -1Ch
	summonP=	dword ptr -1Ah
	numberOfAttacks=	word ptr -16h
	damageDice=	word ptr -14h
	vorpalLoopCounter=	word ptr -12h
	sourceToHitValue=	word ptr -10h
	weaponBonusDamage=	word ptr -0Eh
	monsterTargetGroup= word ptr	-0Ch
	targetGroupDistance= word ptr	-0Ah
	attackSuccessFlag= word ptr	-8h
	equippedWeaponSlot= word ptr	-6
	targetAc= word ptr	-4
	loopCounter= word ptr	-2
	slotNumber= word ptr	 6
	actionTarget= word ptr	 8

	push	bp
	mov	bp, sp
	mov	ax, 1Ch
	call	someStackOperation
	push	si

	cmp	[bp+actionTarget], 80h
	jge	short l_monsterTarget

	mov	ax, charSize
	imul	[bp+actionTarget]
	mov	bx, ax		; if target is party member
	mov	al, gs:party.ac[bx]				;   then targetAc = member AC
	cbw
	mov	[bp+targetAc], ax
	jmp	l_getSourceAttackValue

l_monsterTarget:
	mov	ax, [bp+actionTarget]
	and	ax, 3
	mov	[bp+monsterTargetGroup], ax
	mov	ax, monStruSize
	imul	[bp+monsterTargetGroup]
	mov	ax, ax
	mov	al, gs:monGroups.distance[bx]
	sub	ah, ah
	and	ax, 0Fh
	mov	[bp+targetGroupDistance], ax			; if targetGroupDistance == 0
	or	ax, ax						;   then goto l_inMeleeRange
	jz	short l_inMeleeRange

	mov	bx, [bp+slotNumber]				; else if characterMeleeDistance < targetGroupDistance
	mov	al, gs:g_characterMeleeDistance[bx]		;   then return MISSED
	sub	ah, ah
	mov	cx, [bp+targetGroupDistance]
	dec	cx
	cmp	ax, cx
	jb	l_returnZero

l_inMeleeRange:
	mov	ax, monStruSize
	imul	[bp+monsterTargetGroup]
	mov	si, ax
	mov	al, gs:monGroups.packedGenAc[si]
	sub	ah, ah
	and	ax, 3Fh
	mov	[bp+targetAc], ax				; targetAc = monsterType.Ac

	mov	al, gs:monGroups.flags[si]			; Apply a bonus/penalty to the
	sub	ah, ah						; targetAc based on the monster
	mov	cl, 6						; flags.
	shr	ax, cl						;
	and	ax, 3						; I have no idea why this isn't
	mov	bx, ax						; just part of the monster's base
	mov	al, g_monsterAcBonusList[bx]			; AC.
	cbw
	add	[bp+targetAc], ax				; targetAc += AcBonus

	mov	al, gs:monGroups.distance[si]			; Apply a bonus/penalty to the
	sub	ah, ah						; targetAc based on the monster's
	mov	cl, 4						; advance speed.
	shr	ax, cl						;
	mov	bx, ax						; Again, no idea why this wasn't
	mov	al, g_monsterAdvanceSpeedAcBonusList[bx]	; just included in the base AC.
	cbw
	add	[bp+targetAc], ax				; targetAc += advanceSpeedBonus

	mov	bx, [bp+monsterTargetGroup]			; Apply Freeze Foes penalty to
	mov	al, gs:g_monFreezeAcPenalty[bx]			; targetAc
	sub	ah, ah						;
	sub	[bp+targetAc], ax				; targetAc -= freezeAcPenalty

l_getSourceAttackValue:
	mov	ax, itType_weapon
	push	ax
	push	[bp+slotNumber]
	call	character_getTypeEquippedSlot
	add	sp, 4
	mov	[bp+equippedWeaponSlot], ax
	or	ax, ax
	jl	short l_noWeaponEquipped

	mov	bx, ax						; Set the special attack value
	mov	al, itemTypeList[bx]				; for the equipped weapon
	sub	ah, ah						; e.g. stoning, criticial hit
	mov	cl, 4
	shr	ax, cl
	mov	gs:specialAttackVal, ax

	mov	al, item_acBonWeapDam[bx]			; Some weapons provide an to-hit bonus
	sub	ah, ah						; to the attacker. Deduct the bonus amount
	shr	ax, cl						; from the target's AC.
	mov	[bp+weaponBonusDamage], ax			;
	sub	[bp+targetAc], ax				; targetAc -= weapon to-hit bonus
	jmp	short loc_1DFC8

l_noWeaponEquipped:
	mov	[bp+weaponBonusDamage], 0
	mov	gs:specialAttackVal, 0

loc_1DFC8:
	mov	al, gs:g_monsterWOFBonus			; Add bonus from monsters casting
	sub	ah, ah						; Word of Fear. The added value
	add	ax, [bp+targetAc]				; was getting written to an unused
	mov	[bp+targetAc], ax				; stack var. Write to targetAc to fix

	mov	ax, charSize
	imul	[bp+slotNumber]
	mov	si, ax
	cmp	gs:party.class[si], class_monster
	jb	short l_getCharacterToHit

	add	ax, offset party				; Summon toHit value is a random number
	mov	word ptr [bp+summonP], ax			; between the monster type's toHitLo
	mov	word ptr [bp+summonP+2], seg seg027		; and toHitHi values.
	lfs	bx, [bp+summonP]
	mov	al, fs:[bx+summonStat_t.toHitHi]
	sub	ah, ah
	push	ax
	mov	al, fs:[bx+summonStat_t.toHitLo]
	push	ax
	push	cs
	call	near ptr randomBetweenXandY
	add	sp, 4
	mov	[bp+sourceToHitValue], ax
	mov	ax, [bp+targetAc]				; attackSuccessFlag = targetAc - sourceToHitValue
	sub	ax, [bp+sourceToHitValue]
	mov	[bp+attackSuccessFlag], ax
	jmp	short l_applyToHitBonuses

l_getCharacterToHit:
	mov	ax, charSize
	imul	[bp+slotNumber]
	mov	bx, ax			; Charcter toHitValue uses the level as the base.
	mov	ax, gs:party.level[bx]				; sourceToHitValue = level >> 2
	shr	ax, 1
	shr	ax, 1
	mov	[bp+sourceToHitValue], ax
	cmp	ax, 0FFh					; Maximum toHit base of 255. Indicates a character
	jle	short l_applyStrengthBonus			; level > 1020. That's a LOT of grinding...
	mov	[bp+sourceToHitValue], 0FFh

l_applyStrengthBonus:
	mov	ax, charSize
	imul	[bp+slotNumber]
	mov	bx, ax			; Subtract (strength >> 1) from targetAc.
	mov	al, gs:party.strength[bx]			;
	sub	ah, ah						;
	shr	ax, 1						;
	mov	cx, [bp+targetAc]				; targetAc -= (strength >> 1)
	sub	cx, ax						;
	sub	cx, [bp+sourceToHitValue]			; attackSuccessFlag = targetAc - sourceToHitValue
	mov	[bp+attackSuccessFlag], cx

l_applyToHitBonuses:
	call	random_2d8
	mov	cx, ax						;   in cx

	mov	ax, charSize
	imul	[bp+slotNumber]
	mov	bx, ax			; Store a bonus based on class
	mov	bl, gs:party.class[bx]				;   .
	sub	bh, bh						;   .
	mov	al, g_classToHitBonus[bx]			;   .
	cbw							;   in ax

	mov	bx, [bp+slotNumber]				; Store strenghth spell bonus
	mov	dl, gs:g_strengthSpellBonus[bx]			;   .
	sub	dh, dh						;   in dx
	add	ax, dx						; ax += dx
	add	ax, cx						; ax += cx
	mov	cl, gs:g_charFreezeToHitBonus			; Store freeze foes toHit bonus
	sub	ch, ch						;   in cx
	add	ax, cx						; ax += cx
	sub	[bp+attackSuccessFlag], ax			; attackSuccessFlag -= ax
	cmp	[bp+attackSuccessFlag], 0			; if (attackSuccessFlag > 0)
	jg	l_returnZero					;   attack fails

	; -------------------------------------------
	; Begin damage calculation
	; -------------------------------------------
	mov	ax, charSize
	imul	bx
	mov	bx, ax
	cmp	gs:party.class[bx], class_monster
	jb	short l_calcCharacterDamage

	mov	ax, gs:summonMeleeType
	mov	gs:specialAttackVal, ax
	mov	ax, gs:summonMeleeDamage
	mov	[bp+damageDice], ax
	jmp	short l_hiddenRogueOneAttack

l_calcCharacterDamage:
	cmp	[bp+equippedWeaponSlot], 0
	jl	short l_unarmedMonkDamage

	mov	bx, [bp+equippedWeaponSlot]
	mov	al, itemDamageDice[bx]
	sub	ah, ah
	mov	[bp+damageDice], ax
	jmp	short l_hiddenRogueOneAttack

l_unarmedMonkDamage:
	mov	ax, charSize
	imul	[bp+slotNumber]
	mov	si, ax		; Monk damage dice is determined by
	cmp	gs:party.class[si], class_monk		; g_monkDamageDice[MAX(15, level >> 2)]
	jnz	short l_unarmedNonMonkDamage
	mov	ax, gs:party.level[si]
	shr	ax, 1
	shr	ax, 1
	mov	[bp+monkLevel], ax
	cmp	ax, 0Fh
	jle	short l_skipMax
	mov	[bp+monkLevel], 0Fh
l_skipMax:
	mov	bx, [bp+monkLevel]
	mov	al, g_monkDamageDice[bx]
	sub	ah, ah
	mov	[bp+damageDice], ax
	jmp	short l_hiddenRogueOneAttack

l_unarmedNonMonkDamage:
	mov	[bp+damageDice], 20h 

l_hiddenRogueOneAttack:
	mov	ax, charSize
	imul	[bp+slotNumber]
	mov	bx, ax
	cmp	gs:party.class[bx], class_rogue
	jnz	short l_notRogue

	mov	bx, [bp+slotNumber]			; Rogue's only get one attack when
	cmp	gs:g_characterMeleeDistance[bx], 0	; they attack from the shadows
	jnz	short l_notRogue
	sub	ax, ax
	jmp	short l_countAttackNumber

l_notRogue:
	mov	ax, charSize
	imul	[bp+slotNumber]
	mov	bx, ax
	mov	al, gs:party.numAttacks[bx]
	sub	ah, ah

l_countAttackNumber:
	mov	[bp+loopCounter], ax
	mov	al, gs:songExtraAttack
	sub	ah, ah
	add	[bp+loopCounter], ax
	inc	[bp+loopCounter]
	mov	ax, [bp+loopCounter]
	mov	[bp+numberOfAttacks], ax
	mov	gs:damageAmount, 0

l_calculateDamageLoop:
	push	[bp+damageDice]
	push	cs
	call	near ptr randomYdX
	add	sp, 2
	mov	bx, [bp+slotNumber]
	mov	cl, gs:g_strengthSpellBonus[bx]
	sub	ch, ch
	add	cx, ax
	mov	al, gs:g_divineDamageBonus
	sub	ah, ah
	add	cx, ax
	add	cx, [bp+weaponBonusDamage]
	add	gs:damageAmount, cx

	mov	[bp+vorpalLoopCounter], 0
l_addVorpalPlateBonus:
	mov	bx, [bp+slotNumber]
	mov	al, gs:vorpalPlateBonus[bx]
	sub	ah, ah
	cmp	ax, [bp+vorpalLoopCounter]
	jbe	short l_calculateDamageNext

	call	random
	and	ax, 3					; AND ax with 3 to get 0-3
	inc	ax					; increment result to get 1-4
	add	gs:damageAmount, ax
	inc	[bp+vorpalLoopCounter]
	jmp	short l_addVorpalPlateBonus

l_calculateDamageNext:
	dec	[bp+loopCounter]
	cmp	[bp+loopCounter], 0
	jg	short l_calculateDamageLoop

	mov	bx, [bp+slotNumber]
	cmp	gs:g_characterMeleeDistance[bx], 0
	jz	short l_checkHunterCrit

	call	random
	mov	cx, ax
	mov	ax, charSize
	imul	[bp+slotNumber]
	mov	bx, ax
	cmp	gs:(party.specAbil+2)[bx], cl
	jbe	short l_failHiddenCrit
	mov	ax, speAtt_criticalHit
	jmp	short l_saveHiddenCrit
l_failHiddenCrit:
	sub	ax, ax
l_saveHiddenCrit:
	mov	gs:specialAttackVal, ax
	jmp	short l_returnSuccess

l_checkHunterCrit:
	mov	ax, charSize
	imul	[bp+slotNumber]
	mov	si, ax
	cmp	gs:party.class[si], class_hunter
	jnz	short l_returnSuccess

	call	random
	cmp	gs:party.specAbil[si],	al
	jbe	short l_zeroSpecialAttack
	mov	ax, speAtt_criticalHit
	jmp	short l_setSpecialAttack

l_zeroSpecialAttack:
	sub	ax, ax

l_setSpecialAttack:
	mov	gs:specialAttackVal, ax

l_returnSuccess:
	mov	ax, [bp+numberOfAttacks]
	jmp	short l_return

l_returnZero:
	sub	ax, ax

l_return:
	pop	si
	mov	sp, bp
	pop	bp
	retf
bat_charExecuteMeleeAttack endp

; Attributes: bp-based frame
bat_charPrintMeleeDamage proc	far

	dmgLo= word ptr	 6
	dmgHi= word ptr	 8
	multiAttackFlag= word ptr  0Ah

	push	bp
	mov	bp, sp
	xor	ax, ax
	call	someStackOperation
	cmp	[bp+multiAttackFlag], 1
	jg	short loc_1E2A7
	mov	ax, offset aAndHitsFor
	push	ds
	push	ax
	push	[bp+dmgHi]
	push	[bp+dmgLo]
	call	strcat
	add	sp, 8
	mov	[bp+dmgLo], ax
	mov	[bp+dmgHi], dx
	jmp	short loc_1E2F4
loc_1E2A7:
	mov	ax, offset aAndHits
	push	ds
	push	ax
	push	[bp+dmgHi]
	push	[bp+dmgLo]
	call	strcat
	add	sp, 8
	mov	[bp+dmgLo], ax
	mov	[bp+dmgHi], dx
	sub	ax, ax
	push	ax
	mov	ax, [bp+multiAttackFlag]
	cwd
	push	dx
	push	ax
	push	[bp+dmgHi]
	push	[bp+dmgLo]
	call	itoa
	add	sp, 0Ah
	mov	[bp+dmgLo], ax
	mov	[bp+dmgHi], dx
	mov	ax, offset aTimesFor
	push	ds
	push	ax
	push	dx
	push	[bp+dmgLo]
	call	strcat
	add	sp, 8
	mov	[bp+dmgLo], ax
	mov	[bp+dmgHi], dx
loc_1E2F4:
	sub	ax, ax
	push	ax
	mov	ax, gs:damageAmount
	cwd
	push	dx
	push	ax
	push	[bp+dmgHi]
	push	[bp+dmgLo]
	call	itoa
	add	sp, 0Ah
	mov	[bp+dmgLo], ax
	mov	[bp+dmgHi], dx
	mov	ax, gs:damageAmount
	dec	ax
	push	ax
	push	dx
	push	[bp+dmgLo]
	mov	ax, offset aPointSOfDamage
	push	ds
	push	ax
	call	str_pluralize
	add	sp, 0Ah
	mov	[bp+dmgLo], ax
	mov	[bp+dmgHi], dx
	jmp	short $+2
	mov	sp, bp
	pop	bp
	retf
bat_charPrintMeleeDamage endp

; Attributes: bp-based frame

bat_appendSpecialAttackString proc far

	arg_0= word ptr	 6
	arg_2= word ptr	 8

	push	bp
	mov	bp, sp
	xor	ax, ax
	call	someStackOperation
	mov	bx, gs:specialAttackVal
	shl	bx, 1
	shl	bx, 1
	push	word ptr (specialAttString+2)[bx]
	push	word ptr specialAttString[bx]
	push	[bp+arg_2]
	push	[bp+arg_0]
	call	strcat
	add	sp, 8
	jmp	short $+2
	mov	sp, bp
	pop	bp
	retf
bat_appendSpecialAttackString endp

; Attributes: bp-based frame

bat_damageHp proc far

	arg_0= word ptr	 6

	push	bp
	mov	bp, sp
	xor	ax, ax
	call	someStackOperation
	cmp	[bp+arg_0], 80h
	jge	short loc_1E3A1
	push	[bp+arg_0]
	push	cs
	call	near ptr bat_charDamageHp
	add	sp, 2
	jmp	short loc_1E3B1
	jmp	short loc_1E3B1
loc_1E3A1:
	mov	ax, [bp+arg_0]
	and	ax, 7Fh
	push	ax
	push	cs
	call	near ptr bat_monDamageHp
	add	sp, 2
	jmp	short $+2
loc_1E3B1:
	mov	sp, bp
	pop	bp
	retf
bat_damageHp endp


; Attributes: bp-based frame

bat_monDamageHp proc far

	monNo= word ptr	-4
	groupSize= word	ptr -2
	groupNo= word ptr  6

	push	bp
	mov	bp, sp
	mov	ax, 4
	call	someStackOperation
	getMonP	[bp+groupNo], bx
	mov	al, gs:monGroups.groupSize[bx]
	sub	ah, ah
	and	ax, 1Fh
	mov	[bp+groupSize],	ax
	or	ax, ax
	jnz	short loc_1E3E1
	sub	ax, ax
	jmp	short loc_1E459
loc_1E3E1:
	mov	[bp+monNo], 0
	jmp	short loc_1E3EB
loc_1E3E8:
	inc	[bp+monNo]
loc_1E3EB:
	mov	ax, [bp+groupSize]
	cmp	[bp+monNo], ax
	jge	short loc_1E41E
	mov	bx, [bp+groupNo]
	mov	cl, 6
	shl	bx, cl
	mov	ax, [bp+monNo]
	shl	ax, 1
	add	bx, ax
	test	byte ptr gs:bat_monBeenHitList[bx], 1
	jz	short loc_1E41C
	push	[bp+monNo]
	push	[bp+groupNo]
	push	cs
	call	near ptr bat_monApplySpecialEffect
	add	sp, 4
	jmp	short loc_1E459
loc_1E41C:
	jmp	short loc_1E3E8
loc_1E41E:
	mov	[bp+monNo], 0
	jmp	short loc_1E428
loc_1E425:
	inc	[bp+monNo]
loc_1E428:
	mov	ax, [bp+groupSize]
	cmp	[bp+monNo], ax
	jge	short loc_1E44A
	mov	bx, [bp+groupNo]
	mov	cl, 6
	shl	bx, cl
	mov	ax, [bp+monNo]
	shl	ax, 1
	add	bx, ax
	or	byte ptr gs:bat_monBeenHitList[bx], 1
	jmp	short loc_1E425
loc_1E44A:
	sub	ax, ax
	push	ax
	push	[bp+groupNo]
	push	cs
	call	near ptr bat_monApplySpecialEffect
	add	sp, 4
	jmp	short $+2
loc_1E459:
	mov	sp, bp
	pop	bp
	retf
bat_monDamageHp endp


; Attributes: bp-based frame

bat_monApplySpecialEffect proc far

	var_4= dword ptr -4
	groupNo= word ptr  6
	monNo= word ptr	 8

	push	bp
	mov	bp, sp
	mov	ax, 4
	call	someStackOperation
	mov	bx, [bp+groupNo]
	mov	cl, 6
	shl	bx, cl
	mov	ax, [bp+monNo]
	shl	ax, 1
	add	bx, ax
	and	gs:bat_monBeenHitList[bx], 0FEh
	cmp	gs:specialAttackVal, speAtt_stoning
	jz	short loc_1E495
	cmp	gs:specialAttackVal, speAtt_criticalHit
	jnz	short loc_1E4A7
loc_1E495:
	push	[bp+monNo]
	push	[bp+groupNo]
	push	cs
	call	near ptr bat_monKill
	add	sp, 4
	mov	ax, 1
	jmp	short loc_1E4ED
loc_1E4A7:
	mov	ax, [bp+groupNo]
	mov	cl, 6
	shl	ax, cl
	mov	cx, [bp+monNo]
	shl	cx, 1
	add	ax, cx
	add	ax, offset monHpList
	mov	word ptr [bp+var_4], ax
	mov	word ptr [bp+var_4+2], seg seg027
	mov	ax, gs:damageAmount
	lfs	bx, [bp+var_4]
	sub	fs:[bx], ax
	lfs	bx, [bp+var_4]
	cmp	word ptr fs:[bx], 0
	jg	short loc_1E4E9
	push	[bp+monNo]
	push	[bp+groupNo]
	push	cs
	call	near ptr bat_monKill
	add	sp, 4
	mov	ax, 1
	jmp	short loc_1E4ED
loc_1E4E9:
	sub	ax, ax
	jmp	short $+2
loc_1E4ED:
	mov	sp, bp
	pop	bp
	retf
bat_monApplySpecialEffect endp

; Attributes: bp-based frame

bat_monKill proc far

	mon= word ptr -2
	groupNo= word ptr  6
	monNo= word ptr	 8

	push	bp
	mov	bp, sp
	mov	ax, 2
	call	someStackOperation
	push	si
	mov	ax, [bp+monNo]
	mov	[bp+mon], ax
	jmp	short loc_1E508
loc_1E505:
	inc	[bp+mon]
loc_1E508:
	getMonP	[bp+groupNo], bx
	mov	al, gs:monGroups.groupSize[bx]
	sub	ah, ah
	and	ax, 1Fh
	cmp	ax, [bp+mon]
	jb	short loc_1E54F
	mov	si, [bp+groupNo]
	mov	cl, 6
	shl	si, cl
	mov	ax, [bp+mon]
	shl	ax, 1
	add	si, ax
	mov	ax, gs:(monHpList+2)[si]
	mov	gs:monHpList[si], ax
	mov	ax, gs:(bat_monPriorityList+2)[si]
	mov	gs:bat_monPriorityList[si], ax
	jmp	short loc_1E505
loc_1E54F:
	getMonP	[bp+groupNo], si
	dec	gs:monGroups.groupSize[si]
	test	gs:monGroups.groupSize[si], 1Fh
	jnz	short loc_1E56E
	and	gs:monGroups.flags[si],	0FEh
loc_1E56E:
	getMonP	[bp+groupNo], si
	mov	ah, gs:monGroups.rewardMid[si]
	sub	al, al
	mov	dl, gs:monGroups.rewardHi[si]
	sub	dh, dh
	mov	cl, 10h
	shl	dx, cl
	add	ax, dx
	mov	cl, gs:monGroups.rewardLo[si]
	sub	ch, ch
	add	ax, cx
	sub	dx, dx
	add	gs:batRewardLo,	ax
	adc	gs:batRewardHi,	dx
	pop	si
	mov	sp, bp
	pop	bp
	retf
bat_monKill endp

; Attributes: bp-based frame

bat_charDamageHp proc far

	slotNumber= word ptr	 6

	push	bp
	mov	bp, sp
	push	si

	mov	ax, charSize
	imul	[bp+slotNumber]
	mov	si, ax
	cmp	byte ptr gs:party._name[si], 0
	jz	l_returnZero

	test	gs:party.status[si], stat_dead
	jz	short loc_1E5FA

	cmp	gs:specialAttackVal, speAtt_possess
	jnz	l_returnZero

	push	[bp+slotNumber]
	push	cs
	call	near ptr bat_charApplySpecialEffect
	add	sp, 2
	jmp	short l_return

loc_1E5FA:
	test	gs:party.status[si], stat_stoned
	jnz	l_returnZero

	mov	ax, gs:damageAmount
	cmp	gs:party.currentHP[si], ax
	jnb	short loc_1E647

	or	gs:party.status[si], stat_dead
	mov	gs:party.currentHP[si], 0
	mov	gs:party.hostileFlag[si], 0
	mov	ax, 1
	jmp	short l_return

loc_1E647:
	mov	ax, gs:damageAmount
	mov	cx, ax
	sub	gs:party.currentHP[si], cx
	push	[bp+slotNumber]
	push	cs
	call	near ptr bat_charApplySpecialEffect
	add	sp, 2
	jmp	short l_return

l_returnZero:
	sub	ax, ax

l_return:
	pop	si
	mov	sp, bp
	pop	bp
	retf
bat_charDamageHp endp

; Attributes: bp-based frame

bat_charApplySpecialEffect proc far

	loopCounter= word ptr	-2
	charNo=	word ptr  6

	push	bp
	mov	bp, sp
	mov	ax, 2
	call	someStackOperation
	push	si

	mov	ax, gs:specialAttackVal
	cmp	ax, 9
	ja	l_returnZero
	add	ax, ax
	xchg	ax, bx
	jmp	cs:l_offsetTable[bx]

l_offsetTable	dw offset l_returnZero
		dw offset l_poisonAttack
		dw offset l_levelDrainAttack
		dw offset l_nutsAttack
		dw offset l_ageAttack
		dw offset l_possessAttack
		dw offset l_stoneAttack
		dw offset l_criticalAttack
		dw offset l_unequipAttack
		dw offset consumeSppt

l_poisonAttack:
	mov	ax, charSize
	imul	[bp+charNo]
	mov	bx, ax
	or	gs:party.status[bx], stat_poisoned
	jmp	l_returnOne

l_levelDrainAttack:
	mov	ax, charSize
	imul	[bp+charNo]
	mov	bx, ax
	cmp	gs:party.class[bx], class_monster
	jnb	l_returnZero

	mov	ax, charSize
	imul	[bp+charNo]
	mov	bx, ax
	cmp	gs:party.level[bx], 1
	jbe	short l_setXp

	mov	ax, charSize
	imul	[bp+charNo]
	mov	bx, ax
	dec	gs:party.level[bx]

l_setXp:
	mov	ax, charSize
	imul	[bp+charNo]
	mov	si, ax
	mov	ax, gs:party.level[si]
	dec	ax
	push	ax
	push	[bp+charNo]
	call	getLevelXp
	add	sp, 4
	cwd
	mov	word ptr gs:party.experience[si], ax
	mov	word ptr gs:(party.experience+2)[si], dx
	jmp	l_returnOne

l_nutsAttack:
	mov	ax, charSize
	imul	[bp+charNo]
	mov	bx, ax
	or	gs:party.status[bx], stat_nuts
	jmp	l_returnOne

l_ageAttack:
	mov	ax, charSize
	imul	[bp+charNo]
	mov	bx, ax
	cmp	gs:party.class[bx], class_monster
	jnb	l_returnZero

	mov	ax, charSize
	imul	[bp+charNo]
	mov	bx, ax
	test	gs:party.status[bx], stat_old
	jnz	l_returnZero

	mov	ax, charSize
	imul	[bp+charNo]
	mov	si, ax
	mov	ax, 5
	push	ax
	lea	ax, party.savedST[si]
	mov	dx, seg	seg027
	push	dx
	push	ax
	lea	ax, party.strength[si]
	push	dx
	push	ax
	push	cs
	call	near ptr character_applyAgeStatus
	add	sp, 0Ah
	mov	ax, charSize
	imul	[bp+charNo]
	mov	bx, ax
	or	gs:party.status[bx], stat_old
	jmp	l_returnOne

l_possessAttack:
	mov	ax, charSize
	imul	[bp+charNo]
	mov	si, ax
	mov	gs:party.currentHP[si], 64h 
	and	gs:party.status[si], stat_poisoned or stat_old	or stat_stoned or stat_paralyzed or stat_possessed or stat_nuts	or stat_unknown
	or	gs:party.status[si], stat_possessed
	jmp	l_returnOne

l_stoneAttack:
	mov	ax, charSize
	imul	[bp+charNo]
	mov	si, ax
	mov	gs:party.currentHP[si], 0
	mov	gs:party.hostileFlag[si], 0
	or	gs:party.status[si], stat_stoned
	jmp	l_returnOne

l_criticalAttack:
	mov	ax, charSize
	imul	[bp+charNo]
	mov	si, ax
	or	gs:party.status[si], stat_dead
	mov	gs:party.currentHP[si], 0
	mov	gs:party.hostileFlag[si], 0
	jmp	l_returnOne

l_unequipAttack:
	mov	[bp+loopCounter], 0

l_unequipLoop:
	mov	ax, charSize
	imul	[bp+charNo]
	mov	si, ax
	add	si, [bp+loopCounter]
	mov	al, gs:party.inventory.itemNo[si]
	sub	ah, ah
	mov	bx, ax
	cmp	itemTypeList[bx], 1
	jnz	short l_unequipLoopNext

	and	gs:party.inventory.itemFlags[si], 0FCh

l_unequipLoopNext:
	add	[bp+loopCounter], 3
	cmp	[bp+loopCounter], 24h	
	jl	short l_unequipLoop
	jmp	short l_returnOne

consumeSppt:
	mov	ax, charSize
	imul	[bp+charNo]
	mov	bx, ax
	mov	gs:party.currentSppt[bx], 0

l_returnOne:
	mov	ax, 1
	jmp	short l_return

l_returnZero:
	sub	ax, ax

l_return:
	pop	si
	mov	sp, bp
	pop	bp
	retf
bat_charApplySpecialEffect endp

; Attributes: bp-based frame

character_applyAgeStatus proc far

	arg_0= dword ptr  6
	arg_4= dword ptr  0Ah
	arg_8= word ptr	 0Eh

	push	bp
	mov	bp, sp
	xor	ax, ax
	call	someStackOperation
	jmp	short loc_1E89E
loc_1E89B:
	dec	[bp+arg_8]
loc_1E89E:
	cmp	[bp+arg_8], 0
	jl	short loc_1E8BF
	lfs	bx, [bp+arg_0]
	mov	al, fs:[bx]
	lfs	bx, [bp+arg_4]
	inc	word ptr [bp+arg_4]
	mov	fs:[bx], al
	lfs	bx, [bp+arg_0]
	inc	word ptr [bp+arg_0]
	mov	byte ptr fs:[bx], 1
	jmp	short loc_1E89B
loc_1E8BF:
	mov	sp, bp
	pop	bp
	retf
character_applyAgeStatus endp

; Attributes: bp-based frame

party_died proc far
	push	bp
	mov	bp, sp
	xor	ax, ax
	call	someStackOperation
	mov	byte ptr g_printPartyFlag,	0
	mov	gs:byte_42296, 0FFh
	mov	ax, 57
	push	ax
	call	bigpic_drawPictureNumber
	add	sp, 2
	mov	ax, offset aSorryBud
	push	ds
	push	ax
	call	setTitle
	add	sp, 4
	mov	ax, offset aAlasYourPartyHasExp
	push	ds
	push	ax
	call	printStringWClear
	add	sp, 4
	wait4IO
	sub	al, al
	mov	gs:g_nonRandomBattleFlag, al
	mov	g_partyAttackFlag, al
	sub	ah, ah
	mov	g_locationNumber, ax
	mov	sq_north, 0Bh
	mov	sq_east, 0Fh
	mov	g_direction, 0
	mov	ax, 1
	jmp	short $+2
	mov	sp, bp
	pop	bp
locret_1E958:
	retf
party_died endp


seg008 ends

; Segment type: Pure code
seg009 segment word public 'CODE' use16
        assume cs:seg009
;org 9
        assume es:nothing, ss:nothing, ds:dseg, fs:nothing, gs:seg027
align 2

random_2d16 proc far
	push	bp
	mov	bp, sp
	xor	ax, ax
	call	someStackOperation
	push	si
	call	random
	and	ax, 15
	mov	si, ax
	call	random
	and	ax, 15
	add	ax, si
	add	ax, 2
	jmp	short $+2
	pop	si
	mov	sp, bp
	pop	bp
	retf
random_2d16 endp

; Attributes: bp-based frame

random_2d8	proc far
	push	bp
	mov	bp, sp
	xor	ax, ax
	call	someStackOperation
	push	si
	call	random
	and	ax, 7
	mov	si, ax
	call	random
	and	ax, 7
	add	ax, si
	add	ax, 2
	jmp	short $+2
	pop	si
	mov	sp, bp
	pop	bp
	retf
random_2d8	endp

; Attributes: bp-based frame

random_1d8	proc far
	push	bp
	mov	bp, sp
	xor	ax, ax
	call	someStackOperation
	call	random
	and	ax, 7
	inc	ax
	jmp	short $+2
	mov	sp, bp
	pop	bp
	retf
random_1d8	endp

; Attributes: bp-based frame
bat_giveExperience proc	far

	rostSize= word ptr -8
	var_6= word ptr	-6
	var_4= word ptr	-4
	var_2= word ptr	-2
	arg_0= word ptr	 6
	arg_2= word ptr	 8

	push	bp
	mov	bp, sp
	mov	ax, 8
	call	someStackOperation
	push	si
	call	party_getLastSlot
	inc	ax
	mov	[bp+rostSize], ax
	cmp	ax, 7
	jle	short loc_1E9E4
	sub	ax, ax
	cwd
	jmp	short loc_1EA3B
loc_1E9E4:
	mov	ax, [bp+rostSize]
	cwd
	push	dx
	push	ax
	push	[bp+arg_2]
	push	[bp+arg_0]
	call	__32bitDivide
	mov	[bp+var_4], ax
	mov	[bp+var_2], dx
	mov	[bp+var_6], 0
	jmp	short loc_1EA05
loc_1EA02:
	inc	[bp+var_6]
loc_1EA05:
	mov	ax, [bp+rostSize]
	cmp	[bp+var_6], ax
	jge	short loc_1EA33
	getCharP	[bp+var_6], si
	cmp	gs:party.class[si], class_monster
	jnb	short loc_1EA31
	mov	ax, [bp+var_4]
	mov	dx, [bp+var_2]
	add	word ptr gs:party.experience[si], ax
	adc	word ptr gs:(party.experience+2)[si], dx
loc_1EA31:
	jmp	short loc_1EA02
loc_1EA33:
	mov	ax, [bp+var_4]
	mov	dx, [bp+var_2]
	jmp	short $+2
loc_1EA3B:
	pop	si
	mov	sp, bp
	pop	bp
	retf
bat_giveExperience endp

; Attributes: bp-based frame

bat_giveGold proc far

	var_8= word ptr	-8
	var_6= word ptr	-6
	var_4= word ptr	-4
	var_2= word ptr	-2
	arg_0= word ptr	 6
	arg_2= word ptr	 8

	push	bp
	mov	bp, sp
	mov	ax, 8
	call	someStackOperation
	push	si
	call	party_getLastSlot
	inc	ax
	mov	[bp+var_8], ax
	cmp	ax, 7
	jle	short loc_1EA5F
	sub	ax, ax
	cwd
	jmp	short loc_1EAB6
loc_1EA5F:
	mov	ax, [bp+var_8]
	cwd
	push	dx
	push	ax
	push	[bp+arg_2]
	push	[bp+arg_0]
	call	__32bitDivide
	mov	[bp+var_4], ax
	mov	[bp+var_2], dx
	mov	[bp+var_6], 0
	jmp	short loc_1EA80
loc_1EA7D:
	inc	[bp+var_6]
loc_1EA80:
	mov	ax, [bp+var_8]
	cmp	[bp+var_6], ax
	jge	short loc_1EAAE
	getCharP	[bp+var_6], si
	cmp	gs:party.class[si], class_illusion
	jnb	short loc_1EAAC
	mov	ax, [bp+var_4]
	mov	dx, [bp+var_2]
	add	word ptr gs:party.gold[si], ax
	adc	word ptr gs:(party.gold+2)[si], dx
loc_1EAAC:
	jmp	short loc_1EA7D
loc_1EAAE:
	mov	ax, [bp+var_4]
	mov	dx, [bp+var_2]
	jmp	short $+2
loc_1EAB6:
	pop	si
	mov	sp, bp
	pop	bp
	retf
bat_giveGold endp

; Attributes: bp-based frame

bat_partyDisbelieves proc far

	groupNo= word ptr -2

	push	bp
	mov	bp, sp
	mov	ax, 2
	call	someStackOperation
	push	si
	mov	[bp+groupNo], 3
	jmp	short loc_1EAD1
loc_1EACE:
	dec	[bp+groupNo]
loc_1EAD1:
	cmp	[bp+groupNo], 0
	jge	short loc_1EADA
	jmp	loc_1EB64
loc_1EADA:
	getMonP	[bp+groupNo], si
	test	gs:monGroups.groupSize[si], 1Fh
	jz	short loc_1EB61
	test	gs:monGroups.flags[si],	10h
	jz	short loc_1EB61
	mov	gs:bat_curTarget, 0
;	test	gs:byte_4240E, 81h
	test	gs:disbelieveFlags, disb_disruptill OR disb_disbelieve
	jnz	short loc_1EB20
	sub	ax, ax
	push	ax
	mov	ax, 80h
	push	ax
	call	savingThrowCheck
	add	sp, 4
	cmp	ax, 2
	jnz	short loc_1EB61
loc_1EB20:
	mov	gs:specialAttackVal, speAtt_stoning
	getMonP	[bp+groupNo], bx
	mov	gs:monGroups.groupSize[bx], 1
	push	[bp+groupNo]
	call	bat_monDamageHp
	add	sp, 2
	mov	ax, offset aThePartyDisbelieves_
	push	ds
	push	ax
	call	printString
	add	sp, 4
	delayWithTable
loc_1EB61:
	jmp	loc_1EACE
loc_1EB64:
	and	gs:disbelieveFlags, 0FEh
	pop	si
	mov	sp, bp
	pop	bp
	retf
bat_partyDisbelieves endp

; Attributes: bp-based frame

bat_monDisbelieve proc far

	charNo=	word ptr -2

	push	bp
	mov	bp, sp
	mov	ax, 2
	call	someStackOperation
	push	si
	mov	[bp+charNo], 0
	jmp	short loc_1EB89
loc_1EB86:
	inc	[bp+charNo]
loc_1EB89:
	cmp	[bp+charNo], 7
	jge	short loc_1EBEB
	getCharP	[bp+charNo], si
	cmp	byte ptr gs:party._name[si], 0
	jz	short loc_1EBE9
	cmp	gs:party.class[si], class_illusion
	jnz	short loc_1EBE9
	mov	gs:bat_curTarget, 80h
	sub	ax, ax
	push	ax
	push	ax
	call	savingThrowCheck
	add	sp, 4
	or	ax, ax
	jz	short loc_1EBE9
	inc	gs:monDisbelieveFlag
	mov	ax, offset aTheyDisbelieve
	push	ds
	push	ax
	call	printString
	add	sp, 4
	delayWithTable
	jmp	short loc_1EBEB
loc_1EBE9:
	jmp	short loc_1EB86
loc_1EBEB:
	pop	si
	mov	sp, bp
	pop	bp
	retf
bat_monDisbelieve endp

; Attributes: bp-based frame
bat_partyApplyPoison proc	far

	charNo=	word ptr -4
	var_2= word ptr	-2

	push	bp
	mov	bp, sp
	mov	ax, 4
	call	someStackOperation
	push	si
	mov	bl, g_levelNumber
	sub	bh, bh
	mov	al, poisonDmg[bx]
	cbw
	mov	[bp+var_2], ax
	mov	[bp+charNo], 0
	jmp	short loc_1EC19
loc_1EC16:
	inc	[bp+charNo]
loc_1EC19:
	cmp	[bp+charNo], 7
	jge	short loc_1EC66
	getCharP	[bp+charNo], si
	test	gs:party.status[si], stat_poisoned
	jz	short loc_1EC64
	mov	ax, [bp+var_2]
	cmp	gs:party.currentHP[si], ax
	ja	short loc_1EC52
	and	gs:party.status[si], 0FEh
	or	gs:party.status[si], stat_dead
	mov	gs:party.currentHP[si], 0
	jmp	short loc_1EC64
loc_1EC52:
	mov	ax, [bp+var_2]
	mov	cx, ax
	getCharP	[bp+charNo], bx
	sub	gs:party.currentHP[bx], cx
loc_1EC64:
	jmp	short loc_1EC16
loc_1EC66:
	pop	si
	mov	sp, bp
	pop	bp
	retf
bat_partyApplyPoison endp

; Attributes: bp-based frame

party_applyEquipmentEffects proc far

	var_4= word ptr	-4
	var_2= word ptr	-2

	push	bp
	mov	bp, sp
	mov	ax, 4
	call	someStackOperation
	push	si
	mov	[bp+var_4], 0
	jmp	short loc_1EC81
loc_1EC7E:
	inc	[bp+var_4]
loc_1EC81:
	cmp	[bp+var_4], 7
	jl	short loc_1EC8A
	jmp	loc_1ED56
loc_1EC8A:
	getCharP	[bp+var_4], bx
	test	gs:party.status[bx], 0Ch
	jz	short loc_1ECA1
	jmp	loc_1ED53
loc_1ECA1:
	mov	[bp+var_2], 0
	mov	ax, itemEff_anotherSpptRegen
	push	ax
	push	[bp+var_4]
	call	character_isEffectEquipped
	add	sp, 4
	or	ax, ax
	jnz	short loc_1ECBC
	inc	[bp+var_2]
loc_1ECBC:
	mov	ax, itemEff_regenSppt
	push	ax
	push	[bp+var_4]
	call	character_isEffectEquipped
	add	sp, 4
	or	ax, ax
	jnz	short loc_1ECD2
	inc	[bp+var_2]
loc_1ECD2:
	getCharP	[bp+var_4], si
	mov	ax, [bp+var_2]
	add	gs:party.currentSppt[si], ax
	mov	ax, gs:party.maxSppt[si]
	cmp	gs:party.currentSppt[si], ax
	jbe	short loc_1ECF7
	mov	gs:party.currentSppt[si], ax
loc_1ECF7:
	cmp	gs:g_currentSongPlusOne, 0
	jz	short loc_1ED1E
	cmp	gs:g_currentSong, 3
	jnz	short loc_1ED1E
	mov	al, gs:g_currentSinger
	sub	ah, ah
	cmp	ax, [bp+var_4]
	jz	short loc_1ED31
loc_1ED1E:
	mov	ax, itemEff_regenHP
	push	ax
	push	[bp+var_4]
	call	character_isEffectEquipped
	add	sp, 4
	or	ax, ax
	jnz	short loc_1ED53
loc_1ED31:
	getCharP	[bp+var_4], si
	inc	gs:party.currentHP[si]
	mov	ax, gs:party.maxHP[si]
	cmp	gs:party.currentHP[si], ax
	jbe	short loc_1ED53
	mov	gs:party.currentHP[si], ax
loc_1ED53:
	jmp	loc_1EC7E
loc_1ED56:
	mov	byte ptr g_printPartyFlag,	0
	pop	si
	mov	sp, bp
	pop	bp
	retf
party_applyEquipmentEffects endp

; Attributes: bp-based frame

bat_partyApplyHpRegen proc far

	var_2= word ptr	-2
	arg_0= word ptr	 6

	push	bp
	mov	bp, sp
	mov	ax, 2
	call	someStackOperation
	push	si
	cmp	[bp+arg_0], 0
	jz	short loc_1EDC8
	mov	[bp+var_2], 0
	jmp	short loc_1ED81
loc_1ED7E:
	inc	[bp+var_2]
loc_1ED81:
	cmp	[bp+var_2], 7
	jge	short loc_1EDBE
	getCharP	[bp+var_2], si
	test	gs:party.status[si], stat_dead	or stat_stoned
	jnz	short loc_1EDA3
	mov	ax, [bp+arg_0]
	add	gs:party.currentHP[si], ax
loc_1EDA3:
	getCharP	[bp+var_2], si
	mov	ax, gs:party.maxHP[si]
	cmp	gs:party.currentHP[si], ax
	jbe	short loc_1EDBC
	mov	gs:party.currentHP[si], ax
loc_1EDBC:
	jmp	short loc_1ED7E
loc_1EDBE:
	mov	byte ptr g_printPartyFlag,	0
loc_1EDC8:
	pop	si
	mov	sp, bp
	pop	bp
	retf
bat_partyApplyHpRegen endp

; Attributes: bp-based frame

party_applySpptRegen proc far

	var_2= word ptr	-2

	push	bp
	mov	bp, sp
	mov	ax, 2
	call	someStackOperation
	push	si
	mov	[bp+var_2], 0
	jmp	short loc_1EDE3
loc_1EDE0:
	inc	[bp+var_2]
loc_1EDE3:
	cmp	[bp+var_2], 7
	jge	short loc_1EE1A
	getCharP	[bp+var_2], si
	test	gs:party.status[si], stat_dead	or stat_stoned
	jnz	short loc_1EE18
	mov	ax, gs:party.maxSppt[si]
	cmp	gs:party.currentSppt[si], ax
	jnb	short loc_1EE18
	inc	gs:party.currentSppt[si]
	mov	byte ptr g_printPartyFlag,	0
loc_1EE18:
	jmp	short loc_1EDE0
loc_1EE1A:
	pop	si
	mov	sp, bp
	pop	bp
	retf
party_applySpptRegen endp

; Attributes: bp-based frame

bat_postRound proc far

	var_6= word ptr	-6
	counter= word ptr -4
	var_2= word ptr	-2
	arg_0= word ptr	 6

	push	bp
	mov	bp, sp
	mov	ax, 6
	call	someStackOperation
	push	si
	cmp	[bp+arg_0], 0
	jz	short loc_1EE5D
	mov	[bp+counter], 0
	jmp	short loc_1EE3B
loc_1EE38:
	inc	[bp+counter]
loc_1EE3B:
	cmp	[bp+counter], 7
	jge	short loc_1EE5D
	getCharP	[bp+counter], si
	cmp	gs:party.class[si], class_illusion
	jnz	short loc_1EE5B
	or	gs:party.status[si], stat_dead
loc_1EE5B:
	jmp	short loc_1EE38
loc_1EE5D:
	call	party_getLastSlot
	mov	[bp+var_2], ax
	cmp	ax, 7
	jl	short loc_1EE6D
	jmp	loc_1EF62
loc_1EE6D:
	mov	[bp+counter], 0
loc_1EE72:
	call	party_getLastSlot
	cmp	ax, [bp+counter]
	jge	short loc_1EE7F
	jmp	loc_1EF62
loc_1EE7F:
	getCharP	[bp+counter], bx
	test	gs:party.status[bx], stat_dead	or stat_stoned or stat_paralyzed
	jnz	short loc_1EE96
	jmp	loc_1EF5C
loc_1EE96:
	mov	al, gs:byte_4255E
	sub	ah, ah
	cmp	ax, [bp+counter]
	jnz	short loc_1EEAE
	mov	gs:bat_curSong,	ah
loc_1EEAE:
	mov	al, gs:byte_4255E
	sub	ah, ah
	cmp	ax, [bp+counter]
	jbe	short loc_1EEC2
	dec	gs:byte_4255E
loc_1EEC2:
	mov	al, gs:g_currentSinger
	sub	ah, ah
	cmp	ax, [bp+counter]
	jnz	short loc_1EED6
	call	bat_endCombatSong
loc_1EED6:
	mov	al, gs:g_currentSinger
	sub	ah, ah
	cmp	ax, [bp+counter]
	jbe	short loc_1EEEA
	dec	gs:g_currentSinger
loc_1EEEA:
	push	[bp+counter]
	push	cs
	call	near ptr bat_partyPackBonuses
	add	sp, 2
	mov	ax, offset newCharBuffer
	mov	dx, seg	seg027
	push	dx
	push	ax
	getCharP	[bp+counter], bx
	lea	ax, party._name[bx]
	mov	dx, seg	seg027
	push	dx
	push	ax
	call	copyCharacterBuf
	add	sp, 8
	push	[bp+counter]
	call	party_pack
	add	sp, 2
	cmp	gs:newCharBuffer.class,	class_illusion
	jz	short loc_1EF5A
	cmp	gs:newCharBuffer.specAbil+3, 0
	jnz	short loc_1EF5A
	call	party_findEmptySlot
	mov	[bp+var_6], ax
	getCharP	[bp+var_6], bx
	lea	ax, party._name[bx]
	mov	dx, seg	seg027
	push	dx
	push	ax
	mov	ax, offset newCharBuffer
	push	dx
	push	ax
	call	copyCharacterBuf
	add	sp, 8
loc_1EF5A:
	jmp	short loc_1EF5F
loc_1EF5C:
	inc	[bp+counter]
loc_1EF5F:
	jmp	loc_1EE72
loc_1EF62:
	push	cs
	call	near ptr bat_monCountGroups
	or	ax, ax
	jle	short loc_1EF6F
	mov	[bp+counter], 0
loc_1EF6F:
	push	cs
	call	near ptr bat_monCountGroups
	cmp	ax, [bp+counter]
	jl	short loc_1EFB5
	getMonP	[bp+counter], bx
	test	gs:monGroups.groupSize[bx], 1Fh
	jnz	short loc_1EFB0
	mov	ax, [bp+counter]
	mov	[bp+var_2], ax
	jmp	short loc_1EF97
loc_1EF94:
	inc	[bp+var_2]
loc_1EF97:
	cmp	[bp+var_2], 3
	jge	short loc_1EFAE
	push	[bp+var_2]
	mov	ax, [bp+var_2]
	inc	ax
	push	ax
	push	cs
	call	near ptr bat_monMoveGroup
	add	sp, 4
	jmp	short loc_1EF94
loc_1EFAE:
	jmp	short loc_1EFB3
loc_1EFB0:
	inc	[bp+counter]
loc_1EFB3:
	jmp	short loc_1EF6F
loc_1EFB5:
	pop	si
	mov	sp, bp
	pop	bp
	retf
bat_postRound endp

; Attributes: bp-based frame

bat_monCountGroups proc far

	var_2= word ptr	-2

	push	bp
	mov	bp, sp
	mov	ax, 2
	call	someStackOperation
	mov	[bp+var_2], 3
	jmp	short loc_1EFCF
loc_1EFCC:
	dec	[bp+var_2]
loc_1EFCF:
	cmp	[bp+var_2], 0
	jl	short loc_1EFF0
	getMonP	[bp+var_2], bx
	test	gs:monGroups.groupSize[bx], 1Fh
	jz	short loc_1EFEE
	mov	ax, [bp+var_2]
	jmp	short loc_1EFF5
loc_1EFEE:
	jmp	short loc_1EFCC
loc_1EFF0:
	mov	ax, 0FFFFh
	jmp	short $+2
loc_1EFF5:
	mov	sp, bp
	pop	bp
	retf
bat_monCountGroups endp

; This function	copies the monster group to a
; different slot and zeroes the	vacated	slot.
; Attributes: bp-based frame

bat_monMoveGroup proc far

	arg_0= word ptr	 6
	arg_2= word ptr	 8

	push	bp
	mov	bp, sp
	xor	ax, ax
	call	someStackOperation
	getMonP	[bp+arg_2], bx
	lea	ax, monGroups._name[bx]
	mov	dx, seg	seg027
	push	dx
	push	ax
	getMonP	[bp+arg_0], bx
	lea	ax, monGroups._name[bx]
	mov	dx, seg	seg027
	push	dx
	push	ax
	call	bat_monCopyBuffer
	add	sp, 8
	mov	ax, 40h	
	push	ax
	mov	bx, [bp+arg_0]
	mov	cl, 6
	shl	bx, cl
	lea	ax, monHpList[bx]
	mov	dx, seg	seg027
	push	dx
	push	ax
	mov	bx, [bp+arg_2]
	shl	bx, cl
	lea	ax, monHpList[bx]
	push	dx
	push	ax
	call	memcpy
	add	sp, 0Ah
	mov	ax, monStruSize
	push	ax
	sub	ax, ax
	push	ax
	getMonP	[bp+arg_0], bx
	lea	ax, monGroups._name[bx]
	mov	dx, seg	seg027
	push	dx
	push	ax
	call	memset
	add	sp, 8
	mov	ax, 40h	
	push	ax
	sub	ax, ax
	push	ax
	mov	bx, [bp+arg_0]
	mov	cl, 6
	shl	bx, cl
	lea	ax, monHpList[bx]
	mov	dx, seg	seg027
	push	dx
	push	ax
	call	memset
	add	sp, 8
	mov	sp, bp
	pop	bp
	retf
bat_monMoveGroup endp

; Attributes: bp-based frame
bat_partyPackBonuses proc	far

	var_2= word ptr	-2
	arg_0= word ptr	 6

	push	bp
	mov	bp, sp
	mov	ax, 2
	call	someStackOperation
	mov	ax, [bp+arg_0]
	mov	[bp+var_2], ax
	jmp	short loc_1F0AD
loc_1F0AA:
	inc	[bp+var_2]
loc_1F0AD:
	cmp	[bp+var_2], 6
	jge	short loc_1F0F9
	mov	bx, [bp+var_2]
	mov	al, gs:(byte_42444+1)[bx]
	mov	gs:byte_42444[bx], al
	mov	bx, [bp+var_2]
	mov	al, gs:(g_strengthSpellBonus+1)[bx]
	mov	gs:g_strengthSpellBonus[bx], al
	mov	bx, [bp+var_2]
	mov	al, gs:(vorpalPlateBonus+1)[bx]
	mov	gs:vorpalPlateBonus[bx], al
	mov	bx, [bp+var_2]
	mov	al, gs:(g_characterMeleeDistance+1)[bx]
	mov	gs:g_characterMeleeDistance[bx], al
	jmp	short loc_1F0AA
loc_1F0F9:
	mov	gs:byte_42444+6, 0
	mov	gs:g_strengthSpellBonus+6, 0
	mov	gs:vorpalPlateBonus+6, 0
	mov	gs:g_characterMeleeDistance+6, 0
	mov	sp, bp
	pop	bp
	retf
bat_partyPackBonuses endp

; Attributes: bp-based frame

bat_monGroupActive proc far

	groupNo= word ptr -2

	push	bp
	mov	bp, sp
	mov	ax, 2
	call	someStackOperation
	mov	[bp+groupNo], 0
	jmp	short loc_1F13A
loc_1F137:
	inc	[bp+groupNo]
loc_1F13A:
	cmp	[bp+groupNo], 4
	jge	short loc_1F15B
	getMonP	[bp+groupNo], bx
	test	gs:monGroups.groupSize[bx], 1Fh
	jz	short loc_1F159
	mov	ax, 1
	jmp	short loc_1F15F
loc_1F159:
	jmp	short loc_1F137
loc_1F15B:
	sub	ax, ax
	jmp	short $+2
loc_1F15F:
	mov	sp, bp
	pop	bp
	retf
bat_monGroupActive endp

; Attributes: bp-based frame

_return_zero proc far
	push	bp
	mov	bp, sp
	xor	ax, ax
	call	someStackOperation
	sub	ax, ax
	jmp	short $+2
	mov	sp, bp
	pop	bp
	retf
_return_zero endp

; Attributes: bp-based frame

bat_end	proc far

	var_2= word ptr	-2
	song= word ptr	6
	arg_2= word ptr	 8
	arg_4= word ptr	 0Ah

	push	bp
	mov	bp, sp
	mov	ax, 2
	call	someStackOperation
	push	si
	sub	al, al
	mov	gs:g_nonRandomBattleFlag, al
	mov	byte_4EECC, al
	mov	g_partyAttackFlag, al
	mov	[bp+var_2], 0
	jmp	short loc_1F1A5
loc_1F1A2:
	inc	[bp+var_2]
loc_1F1A5:
	cmp	[bp+var_2], 4
	jge	short loc_1F1C5
	getMonP	[bp+var_2], si
	mov	byte ptr gs:monGroups._name[si], 0
	mov	gs:monGroups.groupSize[si], 0
	jmp	short loc_1F1A2
loc_1F1C5:
	cmp	[bp+song], 0
	jz	short loc_1F1EF
	push	[bp+arg_2]
	call	_charCanPlaySong
	add	sp, 2
	or	ax, ax
	jz	short loc_1F1EF
	push	[bp+arg_4]
	push	[bp+arg_2]
	call	song_playSong
	add	sp, 4
	call	song_doNoncombatEffect
	jmp	short loc_1F1F4
loc_1F1EF:
	call	sound_stop
loc_1F1F4:
	call	bat_reset
	pop	si
	mov	sp, bp
	pop	bp
	retf
bat_end	endp

; Attributes: bp-based frame

bat_getReward proc far

	var_114= word ptr -114h
	var_112= word ptr -112h
	var_110= word ptr -110h
	var_10E= word ptr -10Eh
	var_10C= word ptr -10Ch
	var_10A= word ptr -10Ah
	var_108= dword ptr -108h
	var_104= word ptr -104h
	var_102= word ptr -102h
	var_100= word ptr -100h

	func_enter
	_chkstk	114h
	delayNoTable	2
	call	text_clear
	mov	gs:trapIndex, 0
	mov	ax, gs:batRewardLo
	or	ax, gs:batRewardHi
	jnz	short loc_1F239
	sub	ax, ax
	jmp	loc_1F565
loc_1F239:
	cmp	inDungeonMaybe, 0
	jz	short loc_1F255
	cmp	byte_4EECC, 0
	jz	short loc_1F255
	push	cs
	call	near ptr bat_doChest
loc_1F255:
	call	party_getLastSlot
	cmp	ax, 7
	jle	short loc_1F265
	mov	ax, 1
	jmp	loc_1F565
loc_1F265:
	mov	ax, gs:batRewardLo
	or	ax, gs:batRewardHi
	jnz	short loc_1F279
	sub	ax, ax
	jmp	loc_1F565
loc_1F279:
	mov	ax, offset aEachCharacterReceive
	push	ds
	push	ax
	lea	ax, [bp+var_100]
	push	ss
	push	ax
	call	strcat
	add	sp, 8
	mov	word ptr [bp+var_108], ax
	mov	word ptr [bp+var_108+2], dx
	sub	ax, ax
	push	ax
	push	gs:batRewardHi
	push	gs:batRewardLo
	push	cs
	call	near ptr bat_giveExperience
	add	sp, 4
	push	dx
	push	ax
	push	word ptr [bp+var_108+2]
	push	word ptr [bp+var_108]
	call	itoa
	add	sp, 0Ah
	mov	word ptr [bp+var_108], ax
	mov	word ptr [bp+var_108+2], dx
	mov	ax, offset s_experiencePoinsForV
	push	ds
	push	ax
	push	dx
	push	word ptr [bp+var_108]
	call	strcat
	add	sp, 8
	mov	word ptr [bp+var_108], ax
	mov	word ptr [bp+var_108+2], dx
	cmp	gs:trapIndex, 0
	jz	short loc_1F2F1
	sub	ax, ax
	cwd
	jmp	short loc_1F30A
loc_1F2F1:
	mov	ax, 5
	cwd
	push	dx
	push	ax
	push	gs:batRewardHi
	push	gs:batRewardLo
	call	__32bitDivide
loc_1F30A:
	mov	[bp+var_10E], ax
	mov	[bp+var_10C], dx
loc_1F319:
	mov	ax, 34h	
	push	ax
	call	bigpic_drawPictureNumber
	add	sp, 2
	mov	ax, offset aTreasure
	push	ds
	push	ax
	call	setTitle
	add	sp, 4
	sub	ax, ax
	push	ax
	push	[bp+var_10C]
	push	[bp+var_10E]
	push	cs
	call	near ptr bat_giveGold
	add	sp, 4
	push	dx
	push	ax
	push	word ptr [bp+var_108+2]
	push	word ptr [bp+var_108]
	call	itoa
	add	sp, 0Ah
	mov	word ptr [bp+var_108], ax
	mov	word ptr [bp+var_108+2], dx
	mov	ax, offset aInGold_
	push	ds
	push	ax
	push	dx
	push	word ptr [bp+var_108]
	call	strcat
	add	sp, 8
	mov	word ptr [bp+var_108], ax
	mov	word ptr [bp+var_108+2], dx
	mov	[bp+var_112], 0
	jmp	short loc_1F384
loc_1F380:
	inc	[bp+var_112]
loc_1F384:
	cmp	[bp+var_112], 4
	jl	short loc_1F38E
	jmp	loc_1F547
loc_1F38E:
	mov	al, g_levelNumber
	sub	ah, ah
	sub	ax, 9
	neg	ax
	push	ax
	sub	ax, ax
	push	ax
	call	randomBetweenXandY
	add	sp, 4
	or	ax, ax
	jz	short loc_1F3B0
	jmp	loc_1F544
loc_1F3B0:
	cmp	gs:trapIndex, 0
	jnz	short loc_1F3C8
	delayNoTable	1
loc_1F3C8:
	call	random
	sub	ah, ah
	cmp	ax, 224
	jl	short loc_1F3E9
	cmp	ax, 240
	jge	short loc_1F3E9
	mov	ax, 195
loc_1F3E9:
	mov	[bp+var_104], ax
	mov	bl, g_levelNumber
	sub	bh, bh
	mov	al, byteMaskList[bx]
	sub	ah, ah
	mov	bx, [bp+var_104]
	mov	cl, itemLevMask[bx]
	sub	ch, ch
	test	ax, cx
	jz	short loc_1F3C8
	mov	al, g_itemBaseCount[bx]
	mov	[bp+var_10A], ax
	cmp	ax, 1
	jz	short loc_1F43A
	cmp	ax, 0FFh
	jz	short loc_1F43A
	push	ax
	mov	ax, 1
	push	ax
	call	randomBetweenXandY
	add	sp, 4
	mov	[bp+var_10A], ax
loc_1F43A:
	call	random
	test	al, 7
	jnz	short loc_1F448
	mov	ax, 80h
	jmp	short loc_1F44A
loc_1F448:
	sub	ax, ax
loc_1F44A:
	mov	[bp+var_110], ax
	mov	ax, 7
	push	ax
	call	bat_getRandomChar
	add	sp, 2
	mov	[bp+var_102], ax
	mov	[bp+var_114], 0
	jmp	short loc_1F46A
loc_1F466:
	inc	[bp+var_114]
loc_1F46A:
	cmp	[bp+var_114], 7
	jl	short loc_1F474
	jmp	loc_1F544
loc_1F474:
	push	[bp+var_102]
	push	cs
	call	near ptr bat_charGetReward
	add	sp, 2
	or	ax, ax
	jnz	short loc_1F486
	jmp	loc_1F535
loc_1F486:
	push	[bp+var_10A]
	push	[bp+var_110]
	push	[bp+var_104]
	push	[bp+var_102]
	call	inventory_addItem
	add	sp, 8
	or	ax, ax
	jnz	short loc_1F4A5
	jmp	loc_1F535
loc_1F4A5:
	getCharP	[bp+var_102], bx
	lea	ax, party._name[bx]
	mov	dx, seg	seg027
	push	dx
	push	ax
	push	word ptr [bp+var_108+2]
	push	word ptr [bp+var_108]
	call	strcat
	add	sp, 8
	mov	word ptr [bp+var_108], ax
	mov	word ptr [bp+var_108+2], dx
	mov	ax, offset aFoundA
	push	ds
	push	ax
	push	dx
	push	word ptr [bp+var_108]
	call	strcat
	add	sp, 8
	mov	word ptr [bp+var_108], ax
	mov	word ptr [bp+var_108+2], dx
	push	[bp+var_110]
	push	[bp+var_104]
	push	dx
	push	ax
	call	inventory_getItemName
	add	sp, 8
	mov	word ptr [bp+var_108], ax
	mov	word ptr [bp+var_108+2], dx
	lea	ax, [bp+var_100]
	push	ss
	push	ax
	call	printString
	add	sp, 4
	lea	ax, [bp+var_100]
	mov	word ptr [bp+var_108], ax
	mov	word ptr [bp+var_108+2], ss
	lfs	bx, [bp+var_108]
	mov	byte ptr fs:[bx], 0
	delayNoTable	2
	jmp	short loc_1F544
	jmp	short loc_1F541
loc_1F535:
	dec	[bp+var_102]
	jns	short loc_1F541
	mov	[bp+var_102], 6
loc_1F541:
	jmp	loc_1F466
loc_1F544:
	jmp	loc_1F380
loc_1F547:
	lea	ax, [bp+var_100]
	push	ss
	push	ax
	call	printString
	add	sp, 4
	delayNoTable	8
	sub	ax, ax
	jmp	short $+2
loc_1F565:
	mov	sp, bp
	pop	bp
	retf
bat_getReward endp

; Attributes: bp-based frame
bat_charGetReward proc	far

	arg_0= word ptr	 6

	push	bp
	mov	bp, sp
	xor	ax, ax
	call	someStackOperation
	getCharP	[bp+arg_0], bx
	cmp	byte ptr gs:party._name[bx], 0
	jnz	short loc_1F58B
	sub	ax, ax
	jmp	short loc_1F5B9
loc_1F58B:
	getCharP	[bp+arg_0], bx
	cmp	gs:party.class[bx], class_monster
	jb	short loc_1F59F
	sub	ax, ax
	jmp	short loc_1F5B9
loc_1F59F:
	getCharP	[bp+arg_0], bx
	mov	al, gs:party.status[bx]
	and	al, stat_dead or stat_stoned or	stat_paralyzed
	mov	cx, ax
	cmp	cl, 1
	sbb	ax, ax
	neg	ax
	jmp	short $+2
loc_1F5B9:
	mov	sp, bp
	pop	bp
	retf
bat_charGetReward endp

; Attributes: bp-based frame

chest_examine proc far

	slotNumber= word ptr -106h
	stringBufferP= dword ptr -104h
	stringBuffer= word ptr -100h

	push	bp
	mov	bp, sp
	mov	ax, 106h
	call	someStackOperation
	push	si
	mov	ax, offset s_whoWillExamine
	push	ds
	push	ax
	call	printStringWClear
	add	sp, 4
	call	readSlotNumber
	mov	[bp+slotNumber], ax
	or	ax, ax
	jl	l_returnZero

	mov	ax, charSize
	imul	[bp+slotNumber]
	mov	bx, ax
	cmp	gs:party.class[bx], class_monster
	jnb	l_returnZero

	mov	bx, [bp+slotNumber]
	mov	al, byteMaskList[bx]
	sub	ah, ah
	test	gs:g_chestExamined, ax
	jz	short l_newExaminer

	mov	ax, offset s_alreadyExamined
	push	ds
	push	ax
	call	printStringWClear
	add	sp, 4
	jmp	l_returnZero

l_newExaminer:
	mov	bx, [bp+slotNumber]
	mov	al, byteMaskList[bx]
	sub	ah, ah
	or	gs:g_chestExamined, ax

	mov	ax, charSize
	imul	bx
	mov	bx, ax
	test	gs:party.status[bx], 1Ch
	jnz	l_returnZero
	mov	ax, charSize
	imul	[bp+slotNumber]
	mov	si, ax

	cmp	gs:party.class[si], class_rogue
	jnz	short l_foundNothing
	call	random

	cmp	gs:(party.specAbil+1)[si], al
	jnb	short l_foundTrap

l_foundNothing:
	mov	ax, offset s_foundNothing
	push	ds
	push	ax
	call	printStringWClear
	add	sp, 4
	jmp	short l_returnZero

l_foundTrap:
	mov	ax, offset s_looksLike
	push	ds
	push	ax
	lea	ax, [bp+stringBuffer]
	push	ss
	push	ax
	call	strcat
	add	sp, 8
	mov	word ptr [bp+stringBufferP], ax
	mov	word ptr [bp+stringBufferP+2], dx
	mov	bx, gs:trapIndex
	mov	al, g_chestTrapIndexToName[bx]
	cbw
	mov	bx, ax
	shl	bx, 1
	shl	bx, 1
	push	word ptr (g_chestTrapName+2)[bx]
	push	word ptr g_chestTrapName[bx]
	push	dx
	push	word ptr [bp+stringBufferP]
	call	strcat
	add	sp, 8
	mov	word ptr [bp+stringBufferP], ax
	mov	word ptr [bp+stringBufferP+2], dx
	lea	ax, [bp+stringBuffer]
	push	ss
	push	ax
	call	printStringWClear
	add	sp, 4

l_returnZero:
	sub	ax, ax

l_return:
	pop	si
	mov	sp, bp
	pop	bp
	retf
chest_examine endp

; Attributes: bp-based frame

chest_setOffTrap proc far

	var_108= word ptr -108h
	stringBufferP= dword ptr -106h
	var_102= word ptr -102h
	stringBuffer= word ptr -100h
	arg_0= word ptr	 6

	push	bp
	mov	bp, sp
	mov	ax, 108h
	call	someStackOperation
	push	si

	mov	ax, offset s_youSetOff
	push	ds
	push	ax
	lea	ax, [bp+stringBuffer]
	push	ss
	push	ax
	call	strcat
	add	sp, 8
	mov	word ptr [bp+stringBufferP], ax
	mov	word ptr [bp+stringBufferP+2], dx

	mov	bx, gs:trapIndex
	mov	al, g_chestTrapIndexToName[bx]
	cbw
	mov	bx, ax
	shl	bx, 1
	shl	bx, 1
	push	word ptr (g_chestTrapName+2)[bx]
	push	word ptr g_chestTrapName[bx]
	push	dx
	push	word ptr [bp+stringBufferP]
	call	strcat
	add	sp, 8
	mov	word ptr [bp+stringBufferP], ax
	mov	word ptr [bp+stringBufferP+2], dx

	mov	bx, gs:trapIndex
	mov	al, g_chestTrapDice[bx]
	sub	ah, ah
	push	ax
	call	randomYdX
	add	sp, 2
	mov	[bp+var_108], ax
	mov	si, gs:trapIndex
	shl	si, 1
	mov	al, byte ptr g_chestTrapSaveData.lo[si]
	mov	gs:monGroups.breathSaveLo, al
	mov	al, g_chestTrapSaveData.hi[si]
	mov	gs:monGroups.breathSaveHi, al
	mov	bx, gs:trapIndex
	test	g_chestTrapFlags[bx], 80h
	jz	short l_affectWholeParty

	push	[bp+var_108]
	push	[bp+arg_0]
	push	cs
	call	near ptr chest_doTrap
	add	sp, 4
	jmp	short l_return

l_affectWholeParty:
	mov	[bp+var_102], 0
l_damageLoop:
	push	[bp+var_108]
	push	[bp+var_102]
	call	chest_doTrap
	add	sp, 4
	inc	[bp+var_102]
	cmp	[bp+var_102], 7
	jl	short l_damageLoop

l_return:
	mov	gs:trapIndex, 0
	lea	ax, [bp+stringBuffer]
	push	ss
	push	ax
	call	printString
	add	sp, 4
	mov	byte ptr g_printPartyFlag,	0
	mov	ax, 4000h
	push	ax
	call	getKey
	add	sp, 2
	mov	ax, 1

	pop	si
	mov	sp, bp
	pop	bp
	retf
chest_setOffTrap endp

; Attributes: bp-based frame
chest_doTrap proc	far

	arg_0= word ptr	 6
	arg_2= word ptr	 8

	push	bp
	mov	bp, sp
	push	si

	mov	ax, charSize
	imul	[bp+arg_0]
	mov	si, ax
	cmp	byte ptr gs:party._name[si], 0
	jz	short l_return

	test	gs:party.status[si], stat_dead
	jnz	short l_return

	mov	al, byte ptr [bp+arg_0]
	mov	gs:bat_curTarget, al
	mov	bx, gs:trapIndex
	mov	al, g_chestTrapFlags[bx]
	sub	ah, ah
	and	ax, 7Fh
	mov	gs:specialAttackVal, ax
	mov	ax, [bp+arg_2]
	mov	gs:damageAmount, ax
	sub	ax, ax
	push	ax
	mov	ax, 80h
	push	ax
	call	savingThrowCheck
	add	sp, 4
	or	ax, ax
	jz	short l_return

	mov	ax, 1
	sar	gs:damageAmount, 1
	push	[bp+arg_0]
	call	bat_damageHp
	add	sp, 2

l_return:
	pop	si
	mov	sp, bp
	pop	bp
	retf
chest_doTrap endp

; Attributes: bp-based frame
chest_open proc	far

	push	bp
	mov	bp, sp
	mov	ax, 2
	call	someStackOperation
	push	si
	push	di


	mov	ax, offset s_whoWillOpen
	push	ds
	push	ax
	call	printStringWClear
	add	sp, 4
	call	readSlotNumber
	mov	di, ax
	or	ax, ax
	jl	l_returnZero

	mov	ax, charSize
	imul	di
	mov	si, ax
	test	gs:party.status[si], 7Ch
	jnz	l_returnZero

	cmp	gs:party.class[si], class_monster
	jnb	l_returnZero

	call	random
	test	al, 80h
	jz	short l_noTrap

	push	di
	push	cs
	call	near ptr chest_setOffTrap
	add	sp, 2
	jmp	short l_returnOne

l_noTrap:
	mov	gs:trapIndex, 0
	mov	gs:word_42560, 1

l_returnOne:
	mov	ax, 5
	push	ax
	call	text_delayNoTable
	add	sp, 2
	mov	ax, 1
	jmp	short l_return

l_returnZero:
	sub	ax, ax

l_return:
	pop	di
	pop	si
	mov	sp, bp
	pop	bp
	retf
chest_open endp



; Attributes: bp-based frame

chest_disarm proc far

	stringBuffer=	word ptr -28h

	push	bp
	mov	bp, sp
	mov	ax, 28h
	call	someStackOperation
	push	si
	push	di


	mov	ax, offset s_whoWillDisarm
	push	ds
	push	ax
	call	printStringWClear
	add	sp, 4
	call	readSlotNumber
	mov	di, ax
	or	ax, ax
	jl	l_returnZero

	mov	ax, charSize
	imul	di
	mov	bx, ax
	test	gs:party.status[bx], 1Ch
	jnz	l_returnZero

	mov	ax, offset s_enterTrapName
	push	ds
	push	ax
	call	printStringWClear
	add	sp, 4
	mov	ax, 28h	
	push	ax
	lea	ax, [bp+stringBuffer]
	push	ss
	push	ax
	call	readString
	add	sp, 6
	mov	bx, gs:trapIndex
	mov	al, g_chestTrapIndexToName[bx]
	cbw
	mov	bx, ax
	shl	bx, 1
	shl	bx, 1
	push	word ptr (g_chestTrapName+2)[bx]
	push	word ptr g_chestTrapName[bx]
	lea	ax, [bp+stringBuffer]
	push	ss
	push	ax
	push	cs
	call	near ptr chest_trapStrcmp
	add	sp, 8
	or	ax, ax
	jz	short l_setOffTrap

	mov	ax, charSize
	imul	di
	mov	si, ax
	cmp	gs:party.class[si], class_rogue
	jnz	short l_disarmFailed

	call	random
	cmp	gs:party.specAbil[si],	al
	jb	short l_disarmFailed

	mov	ax, offset s_youDisarmedIt
	push	ds
	push	ax
	call	printStringWClear
	add	sp, 4
	mov	gs:trapIndex, 0
	jmp	short l_returnOne

l_disarmFailed:
	mov	ax, offset s_disarmFailed
	push	ds
	push	ax
	call	printStringWClear
	add	sp, 4
	jmp	short l_returnZero

l_setOffTrap:
	push	di
	push	cs
	call	near ptr chest_setOffTrap
	add	sp, 2

l_returnOne:
	mov	ax, 1
	jmp	short l_return

l_returnZero:
	sub	ax, ax

l_return:
	pop	di
	pop	si
	mov	sp, bp
	pop	bp
	retf
chest_disarm endp



; Attributes: bp-based frame

chest_trapZap proc far




	push	bp
	mov	bp, sp
	push	di
	push	si

	mov	ax, offset s_whoWillCastTrzp
	push	ds
	push	ax
	call	printStringWClear
	add	sp, 4
	call	readSlotNumber
	mov	di, ax
	or	ax, ax
	jl	l_returnZero

	mov	ax, charSize
	imul	di
	mov	si, ax
	test	gs:party.status[si], 7Ch
	jnz	l_returnZero

	cmp	gs:party.class[si], class_monster
	jnb	l_returnZero

	mov	ax, 2
	push	ax
	push	di
	call	character_learnedSpell
	add	sp, 4
	or	ax, ax
	jz	short l_dontKnowSpell

	cmp	gs:party.currentSppt[si], 2
	jnb	short l_castSpell

	mov	ax, offset s_needTwoSpellPoints
	push	ds
	push	ax
	call	printStringWClear
	add	sp, 4
	jmp	l_returnZero

l_castSpell:
	sub	gs:party.currentSppt[si], 2
	mov	gs:trapIndex, 0
	mov	byte ptr g_printPartyFlag,	0
	mov	ax, offset s_youDisarmedIt
	push	ds
	push	ax
	call	printStringWClear
	add	sp, 4
	mov	ax, 4000h
	push	ax
	call	getKey
	add	sp, 2
	mov	ax, 1
	jmp	short l_return

l_dontKnowSpell:
	mov	ax, offset s_dontKnowThatSpell_
	push	ds
	push	ax
	call	printStringWClear
	add	sp, 4

l_returnZero:
	sub	ax, ax

l_return:
	pop	si
	pop	di
	mov	sp, bp
	pop	bp
	retf
chest_trapZap endp




; Attributes: bp-based frame

chest_returnOne	proc far
	push	bp
	mov	bp, sp
	xor	ax, ax
	call	someStackOperation
	mov	ax, 1
	jmp	short $+2
	mov	sp, bp
	pop	bp
	retf
chest_returnOne	endp


; Attributes: bp-based frame

chest_trapStrcmp proc far

	arg_0= dword ptr  6
	arg_4= dword ptr  0Ah

	push	bp
	mov	bp, sp
	mov	ax, 2
	call	someStackOperation
	push	si


	sub	dx, dx
loc_1FB2A:
	cmp	dx, 28h
	jge	short l_returnOne

	mov	bx, dx
	lfs	si, [bp+arg_4]
	mov	al, fs:[bx+si]
	cbw
	lfs	si, [bp+arg_0]
	mov	cx, ax
	mov	al, fs:[bx+si]
	cbw
	or	ax, cx
	jz	short l_returnOne

	push	dx
	lfs	si, [bp+arg_4]
	mov	al, fs:[bx+si]
	cbw
	push	ax
	call	toUpper
	add	sp, 2
	mov	bx, dx
	lfs	si, [bp+arg_0]
	mov	cx, ax
	mov	al, fs:[bx+si]
	cbw
	push	ax
	mov	si, cx
	call	toUpper
	add	sp, 2
	pop	dx
	cmp	ax, si
	jnz	short l_returnZero

l_loopNext:
	inc	dx
	jmp	short loc_1FB2A

l_returnOne:
	mov	ax, 1
	jmp	short l_return

l_returnZero:
	sub	ax, ax

l_return:
	pop	si
	mov	sp, bp
	pop	bp
	retf
chest_trapStrcmp endp




; Attributes: bp-based frame

bat_doChest proc far

	validOptionMouse=	word ptr -30h
	printPromptFlag=	word ptr -1Ch
	loopCounter=	word ptr -1Ah
	mouseBitmask=	word ptr -18h
	validOptionKeys=	word ptr -16h
	inKey= word ptr	-0Ch
	optionList= word ptr	-0Ah

	push	bp
	mov	bp, sp
	mov	ax, 30h
	call	someStackOperation
	push	si

	mov	ax, 35h	
	push	ax
	call	bigpic_drawPictureNumber
	add	sp, 2

	mov	ax, offset s_chest
	push	ds
	push	ax
	call	setTitle
	add	sp, 4

	call	random
	and	ax, 3
	mov	cl, g_levelNumber
	sub	ch, ch
	shl	cx, 1
	shl	cx, 1
	add	cx, ax
	mov	gs:trapIndex, cx
	mov	gs:g_chestExamined, 0

	sub	si, si
l_initOptionListLoop:
	mov	byte ptr [bp+si+optionList],	1
	inc	si
	cmp	si, 0Ah
	jl	short l_initOptionListLoop

l_chestLoop:
	call	text_clear
	lea	ax, [bp+validOptionMouse]
	push	ss
	push	ax
	lea	ax, [bp+validOptionKeys]
	push	ss
	push	ax
	lea	ax, [bp+optionList]
	push	ss
	push	ax
	mov	ax, offset s_chestPrompt
	push	ds
	push	ax
	call	printVarString
	add	sp, 10h
	mov	[bp+mouseBitmask], ax

l_getKey:
	mov	[bp+printPromptFlag], 1
	push	[bp+mouseBitmask]
	call	getKey
	add	sp, 2
	mov	[bp+inKey], ax
	mov	[bp+loopCounter], 0

l_searchOptionsLoop:
	mov	si, [bp+loopCounter]
	cmp	byte ptr [bp+si+validOptionKeys], 0
	jz	short l_chestLoopNext

	mov	al, byte ptr [bp+si+validOptionKeys]
	cbw
	cmp	ax, [bp+inKey]
	jz	short l_keyFound

	shl	si, 1
	mov	ax, [bp+inKey]
	cmp	[bp+si+validOptionMouse],	ax
	jnz	short l_searchOptionsNext

l_keyFound:
	mov	bx, [bp+loopCounter]
	shl	bx, 1
	shl	bx, 1
	call	g_chestActionFunctions[bx]
	or	ax, ax
	jz	short l_markReprintPrompt

	call	text_clear
	jmp	short l_return

l_markReprintPrompt:
	mov	[bp+printPromptFlag], 0
	mov	ax, 2
	push	ax
	call	text_delayNoTable
	add	sp, 2

l_searchOptionsNext:
	inc	[bp+loopCounter]
	jmp	short l_searchOptionsLoop

l_chestLoopNext:
	cmp	[bp+printPromptFlag], 0
	jnz	short l_getKey
	jmp	l_chestLoop

l_return:
	pop	si
	mov	sp, bp
	pop	bp
	retf
bat_doChest endp


seg009 ends

; Segment type: Pure code
seg010 segment word public 'CODE' use16
        assume cs:seg010
;org 9
        assume es:nothing, ss:nothing, ds:dseg, fs:nothing, gs:seg027
align 2

noncombatCast proc far

	castSlotNumber= word ptr	-6
	spellTargetFlag= word ptr	-4
	var_2= word ptr	-2
	inFunctionKey= word ptr	 6

	push	bp
	mov	bp, sp
	mov	ax, 6
	call	someStackOperation

	cmp	[bp+inFunctionKey], 0
	jz	short l_askForCaster
	mov	ax, [bp+inFunctionKey]
	sub	ax, dosKeys_F1
	mov	cl, 8
	sar	ax, cl
	mov	[bp+castSlotNumber], ax
	jmp	short l_checkCaster
l_askForCaster:
	mov	ax, offset s_whoWillCast
	push	ds
	push	ax
	call	printStringWClear
	add	sp, 4
	call	readSlotNumber
	mov	[bp+castSlotNumber], ax
l_checkCaster:
	cmp	[bp+castSlotNumber], 0
	jl	l_returnOne

	mov	ax, charSize
	imul	[bp+castSlotNumber]
	mov	bx, ax
	test	gs:party.status[bx], stat_dead	or stat_stoned or stat_paralyzed
	jnz	l_returnZero

	mov	ax, charSize
	imul	[bp+castSlotNumber]
	mov	bx, ax
	mov	bl, gs:party.class[bx]
	sub	bh, bh
	cmp	mageSpellIndex[bx], 0FFh
	jnz	short l_isSpellCaster

	mov	ax, offset s_notSpellcaster
	push	ds
	push	ax
	call	printString
	add	sp, 4
	mov	ax, 4000h
	push	ax
	call	getKey
	add	sp, 2
	jmp	short l_returnZero
l_isSpellCaster:
	sub	ax, ax
	push	ax
	push	[bp+castSlotNumber]
	push	cs
	call	near ptr getSpellNumber
	add	sp, 4
	mov	[bp+spellTargetFlag], ax
	or	ax, ax
	jl	l_returnZero

	cmp	[bp+spellTargetFlag], 4
	jge	short l_doCast
	mov	ax, offset s_castAt
	push	ds
	push	ax
	push	[bp+spellTargetFlag]
	call	bat_charGetActionTarget
	add	sp, 6
	mov	[bp+var_2], ax
	or	ax, ax
	jl	l_returnZero
	mov	al, byte ptr [bp+var_2]
	mov	gs:bat_curTarget, al
l_doCast:
	call	text_clear
	mov	ax, 1
	push	ax
	sub	ax, ax
	push	ax
	push	g_curSpellNumber
	push	[bp+castSlotNumber]
	push	cs
	call	near ptr doCastSpell
	add	sp, 8
	mov	ax, 2
	push	ax
	call	text_delayNoTable
	add	sp, 2
l_returnOne:
	mov	ax, 1
	jmp	short l_return
l_returnZero:
	sub	ax, ax
l_return:
	mov	sp, bp
	pop	bp
	retf
noncombatCast endp

; Attributes: bp-based frame

; Returns:
;   0FFFFh if failed
;   spell targeting flag if successful

getSpellNumber proc far

	var_306= word ptr -306h
	var_304= word ptr -304h
	var_106= word ptr -106h
	var_104= word ptr -104h
	var_102= word ptr -102h
	var_100= word ptr -100h
	partySlotNumber= word ptr	 6

	push	bp
	mov	bp, sp
	mov	ax, 306h
	call	someStackOperation
	push	si

	mov	ax, charSize
	imul	[bp+partySlotNumber]
	mov	bx, ax
	test	gs:party.status[bx], stat_dead	or stat_stoned or stat_paralyzed
	jnz	l_returnFailed

	mov	al, spell_mouseClicked
	sub	ah, ah
	or	ax, ax
	jnz	loc_mouse_spell_select

	push	[bp+partySlotNumber]
	call	text_castSpell
	add	sp, 2
	cmp	ax, 0FFFFh
	jz	l_return
	jmp	l_spellFound

loc_mouse_spell_select:
	mov	[bp+var_106], 0
	mov	[bp+var_104], 0
	jmp	short loc_1FDC6
loc_1FDC2:
	inc	[bp+var_104]
loc_1FDC6:
	cmp	[bp+var_104], 7Eh
	jge	short loc_1FE1A
	push	[bp+var_104]
	push	[bp+partySlotNumber]
	call	character_learnedSpell
	add	sp, 4

	or	ax, ax
	jz	short loc_1FE18
	mov	si, [bp+var_106]
	shl	si, 1
	mov	ax, [bp+var_104]
	mov	[bp+si+var_100], ax
	mov	bx, [bp+var_104]
	mov	cl, 3
	shl	bx, cl
	mov	ax, word ptr spellString.fullName[bx]
	mov	dx, word ptr (spellString.fullName+2)[bx]
	mov	si, [bp+var_106]
	inc	[bp+var_106]
	shl	si, 1
	shl	si, 1
	mov	[bp+si+var_306], ax
	mov	[bp+si+var_304], dx
loc_1FE18:
	jmp	short loc_1FDC2
loc_1FE1A:
	cmp	[bp+var_106], 0
	jz	short loc_1FE3E
	push	[bp+var_106]
	lea	ax, [bp+var_306]
	push	ss
	push	ax
	mov	ax, offset s_spellToCast
	push	ds
	push	ax
	call	text_scrollingWindow
	add	sp, 0Ah
	mov	[bp+var_102], ax
	jmp	short loc_1FE5F
loc_1FE3E:
	mov	ax, offset s_dontKnowAnySpells
	push	ds
	push	ax
	call	printString
	add	sp, 4
	mov	ax, 4000h
	push	ax
	call	getKey
	add	sp, 2
	jmp	short l_returnFailed
loc_1FE5F:
	cmp	[bp+var_102], 0
	jl	short l_returnFailed
	mov	si, [bp+var_102]
	shl	si, 1
	mov	ax, [bp+si+var_100]

l_spellFound:
	mov	g_curSpellNumber, ax
	push	ax
	push	[bp+partySlotNumber]
	push	cs
	call	near ptr getSpptRequired
	add	sp, 4
	mov	cx, ax
	mov	ax, charSize
	imul	[bp+partySlotNumber]
	mov	bx, ax
	cmp	gs:party.currentSppt[bx], cx
	jnb	short l_enoughSppt

	mov	ax, offset s_notEnoughSppt
	push	ds
	push	ax
	call	printStringWClear
	add	sp, 4
	mov	ax, 4000h
	push	ax
	call	getKey
	add	sp, 2
	jmp	short l_returnFailed

l_enoughSppt:
	mov	bx, g_curSpellNumber
	mov	al, spellCastFlags[bx]
	sub	ah, ah
	and	ax, 7
	jmp	short l_return
l_returnFailed:
	mov	ax, 0FFFFh
l_return:
	pop	si
	mov	sp, bp
	pop	bp
	retf
getSpellNumber endp

; This function	gets the spell points required for
; a particular spell. It takes into account equipment
; that the player has equipped.

; Attributes: bp-based frame

getSpptRequired	proc far

	sppt= word ptr	-2
	partySlotNumber= word ptr  6
	spellIndexNumber= word ptr	 8

	push	bp
	mov	bp, sp
	mov	ax, 2
	call	someStackOperation

	mov	bx, [bp+spellIndexNumber]
	mov	al, spptRequired[bx]
	sub	ah, ah
	mov	[bp+sppt], ax
	mov	ax, itemEff_quaterSpptUse
	push	ax
	push	[bp+partySlotNumber]
	call	character_isEffectEquipped
	add	sp, 4
	or	ax, ax
	jnz	short l_checkHalf
	mov	ax, [bp+sppt]
	sar	ax, 1
	sar	ax, 1
	jmp	short l_return
l_checkHalf:
	mov	ax, itemEff_halfSpptUsage
	push	ax
	push	[bp+partySlotNumber]
	call	character_isEffectEquipped
	add	sp, 4
	or	ax, ax
	jnz	short l_returnSppt
	mov	ax, [bp+sppt]
	sar	ax, 1
	jmp	short l_return
l_returnSppt:
	mov	ax, [bp+sppt]
	jmp	short $+2
l_return:
	mov	sp, bp
	pop	bp
	retf
getSpptRequired	endp

; Attributes: bp-based frame

doCastSpell proc far

	stringBuf= word ptr -108h
	stringBufP= dword ptr -8
	partySlotNumber=	word ptr  6
	spellNumber= word ptr  8
	itemUsedFlag= word ptr	 0Ah
	useSppt= word ptr	 0Ch

	push	bp
	mov	bp, sp
	mov	ax, 108h
	call	someStackOperation

	push	[bp+partySlotNumber]
	lea	ax, [bp+stringBuf]
	push	ss
	push	ax
	call	bat_getAttackerName
	add	sp, 6
	mov	word ptr [bp+stringBufP], ax
	mov	word ptr [bp+stringBufP+2], dx
	lfs	bx, dword ptr [bp+stringBufP]
	inc	word ptr [bp+stringBufP]
	mov	byte ptr fs:[bx], ' '

	cmp	[bp+spellNumber], 7Eh 
	jge	short l_spptCheck

	mov	ax, offset s_castsASpell
	push	ds
	push	ax
	push	word ptr [bp+stringBufP+2]
	push	word ptr [bp+stringBufP]
	call	strcat
	add	sp, 8
	mov	word ptr [bp+stringBufP], ax
	mov	word ptr [bp+stringBufP+2], dx
	lfs	bx, dword ptr [bp+stringBufP]
	inc	word ptr [bp+stringBufP]
	mov	byte ptr fs:[bx], ' '

	; Append full spell name to output string
	mov	bx, [bp+spellNumber]
	mov	cl, 3
	shl	bx, cl
	push	word ptr (spellString.fullName+2)[bx]
	push	word ptr spellString.fullName[bx]
	push	word ptr [bp+stringBufP+2]
	push	word ptr [bp+stringBufP]
	call	strcat
	add	sp, 8
	mov	word ptr [bp+stringBufP], ax
	mov	word ptr [bp+stringBufP+2], dx

l_spptCheck:
	cmp	[bp+useSppt], 0
	jz	short l_castIt
	push	[bp+spellNumber]
	push	[bp+partySlotNumber]
	push	cs
	call	near ptr _sp_checkSPPT
	add	sp, 4
	or	ax, ax
	jz	short l_fizzled
	mov	al, gs:sq_antiMagicFlag
	sub	ah, ah
	or	ax, ax
	jz	short l_castIt

l_fizzled:
	lfs	bx, dword ptr [bp+stringBufP]
	inc	word ptr [bp+stringBufP]
	mov	byte ptr fs:[bx], 0
	lea	ax, [bp+stringBuf]
	push	ss
	push	ax
	call	printString
	add	sp, 4

	call	printSpellFizzled

	sub	ax, ax
	jmp	short l_return
l_castIt:
	lea	ax, [bp+stringBuf]
	push	ss
	push	ax
	call	printString
	add	sp, 4
	push	[bp+itemUsedFlag]
	push	[bp+spellNumber]
	push	[bp+partySlotNumber]
	push	cs
	call	near ptr spell_cast
	add	sp, 6
	mov	ax, 1
l_return:
	mov	sp, bp
	pop	bp
	retf
doCastSpell endp

; Attributes: bp-based frame

sp_lightSpell proc far

	spellEffect= word ptr	-2
	spellNumber= word ptr	 8

	push	bp
	mov	bp, sp
	mov	ax, 2
	call	someStackOperation

	mov	bx, [bp+spellNumber]
	mov	al, spellEffectFlags[bx]
	sub	ah, ah
	mov	[bp+spellEffect], ax
	mov	bx, ax
	mov	al, lightDistList[bx]
	mov	lightDistance, al
	mov	al, lightDurList[bx]
	mov	lightDuration, al
	sub	ax, ax
	push	ax
	call	icon_activate
	add	sp, 2
	mov	bx, [bp+spellEffect]
	mov	al, lightDetectList[bx]
	mov	gs:gl_detectSecretDoorFlag, al
	mov	ax, offset s_elipsisNl
	push	ds
	push	ax
	call	printString
	add	sp, 4
	mov	ax, 2
	push	ax
	call	text_delayNoTable
	add	sp, 2

	mov	sp, bp
	pop	bp
	retf
sp_lightSpell endp

; Attributes: bp-based frame

sp_possessChar proc far

	var_2= word ptr	-2

	push	bp
	mov	bp, sp
	mov	ax, 2
	call	someStackOperation
	push	si

	mov	al, gs:bat_curTarget
	sub	ah, ah
	mov	[bp+var_2], ax
	mov	ax, charSize
	imul	[bp+var_2]
	mov	si, ax
	test	gs:party.status[si], stat_dead
	jz	short l_return
	and	gs:party.status[si], stat_poisoned or stat_old	or stat_stoned or stat_paralyzed or stat_possessed or stat_nuts	or stat_unknown
	or	gs:party.status[si], stat_possessed
	mov	gs:party.currentHP[si], 100
l_return:
	pop	si
	mov	sp, bp
	pop	bp
	retf
sp_possessChar endp

; Attributes: bp-based frame

sp_damageSpell proc far

	attP= word ptr -10h
	var_E= word ptr	-0Eh
	var_C= word ptr	-0Ch
	counter= word ptr -0Ah
	attStru= byte ptr -8
	partySlotNumber=	word ptr  6
	spellNumber= word ptr  8

	push	bp
	mov	bp, sp
	mov	ax, 10h
	call	someStackOperation
	push	di
	push	si

	mov	bx, [bp+spellNumber]
	mov	al, spellEffectFlags[bx]
	sub	ah, ah
	mov	[bp+var_C], ax
	lea	ax, [bp+attStru]
	mov	[bp+attP], ax
	mov	[bp+var_E], ss
	mov	[bp+counter], 0
	jmp	short loc_20100
loc_200FD:
	inc	[bp+counter]
loc_20100:
	cmp	[bp+counter], 7
	jge	short loc_20118
	mov	si, [bp+var_C]
	mov	bx, [bp+counter]
	mov	al, byte ptr damageSpellData.effectStrIndex[bx+si]
	lfs	si, dword ptr [bp+attP]
	mov	fs:[bx+si], al
	jmp	short loc_200FD
loc_20118:
	mov	bx, [bp+spellNumber]
	mov	al, spellExtraFlags[bx]
	sub	ah, ah
	push	ax
	sub	sp, 8
	lea	si, [bp+attStru]
	mov	di, sp
	push	ss
	pop	es
	movsw
	movsw
	movsw
	movsb
	push	[bp+partySlotNumber]
	push	cs
	call	near ptr bat_doBreathAttack
	add	sp, 0Ch
	pop	si
	pop	di
	mov	sp, bp
	pop	bp
	retf
sp_damageSpell endp

; Attributes: bp-based frame

bat_doBreathAttack proc	far

	var_11A= word ptr -11Ah
	var_118= word ptr -118h
	outputStringP= dword ptr -116h
	counter= word ptr -112h
	var_110= word ptr -110h
	target=	word ptr -10Eh
	var_10C= word ptr -10Ch
	partyAttackRval= word ptr -10Ah
	var_108= word ptr -108h
	stringBuf= word ptr -106h
	var_6= word ptr	-6
	var_4= word ptr	-4
	var_2= word ptr	-2
	partySlotNumber=	word ptr  6
	specialAttackIndex= byte ptr	 8
	arg_3= byte ptr	 9
	arg_4= byte ptr	 0Ah
	arg_5= byte ptr	 0Bh
	arg_6= byte ptr	 0Ch
	breathFlags= byte ptr	 0Dh
	levelMultiplier= byte ptr	 0Eh
	spellRange= word ptr	 10h

	push	bp
	mov	bp, sp
	mov	ax, 11Ah
	call	someStackOperation

	cmp	[bp+levelMultiplier], 0
	jnz	short l_allFoesCheck

	; Set levelMultiplier to 1 if source is an enemy
	cmp	[bp+partySlotNumber], 80h 
	jl	short l_partyMultiplier

	mov	[bp+levelMultiplier], 1
	jmp	short l_allFoesCheck

l_partyMultiplier:
	mov	ax, charSize
	imul	[bp+partySlotNumber]
	mov	bx, ax
	push	gs:party.level[bx]
	push	cs
	call	near ptr lib_maxFF
	add	sp, 2
	mov	[bp+levelMultiplier], al

l_allFoesCheck:
	mov	[bp+partyAttackRval], 0
	test	[bp+breathFlags], breath_allFoes		; if breathFlags & breathAllFoes
	jz	short l_oneGroupCheck

	cmp	[bp+partySlotNumber], 80h 			;   if source.isEnemy
	jge	short l_stripAllFoesFlag			;     breathFlags &= !breathAllFoes

	mov	gs:bat_curTarget, 80h				;   else
	jmp	short l_oneGroupCheck				;     currentTarget = first enemy group

l_stripAllFoesFlag:
	and	[bp+breathFlags], 7Fh

l_oneGroupCheck:
	mov	al, gs:bat_curTarget
	sub	ah, ah
	or	ax, [bp+partySlotNumber]
	cmp	ax, 80h
	jnb	short loc_201B9
	test	[bp+breathFlags], breath_oneGroup
	jz	short loc_201B9

	mov	ax, [bp+partySlotNumber]
	jmp	short loc_201BC
loc_201B9:
	mov	ax, 0FFh
loc_201BC:
	mov	[bp+var_11A], ax

	mov	[bp+var_110], 0
loc_201C6:
	cmp	gs:bat_curTarget, 80h
	jnb	l_targetIsEnemy
	test	[bp+breathFlags], breath_oneGroup
	jz	short loc_201E0
	mov	ax, 6
	jmp	short loc_201E6
loc_201E0:
	mov	al, gs:bat_curTarget
	sub	ah, ah
loc_201E6:
	mov	[bp+target], ax
	mov	ax, offset s_atTheParty
	push	ds
	push	ax
	lea	ax, [bp+stringBuf]
	push	ss
	push	ax
	call	strcat
	add	sp, 8
	mov	word ptr [bp+outputStringP], ax
	mov	word ptr [bp+outputStringP+2], dx
	inc	[bp+partyAttackRval]
	push	[bp+spellRange]
	push	[bp+partySlotNumber]
	push	cs
	call	near ptr bat_isPartyInRange
	add	sp, 4
	or	ax, ax
	jnz	loc_20324

	mov	ax, offset s_partyTooFarAway
	push	ds
	push	ax
	push	word ptr [bp+outputStringP+2]
	push	word ptr [bp+outputStringP]
	call	strcat
	add	sp, 8
	mov	word ptr [bp+outputStringP], ax
	mov	word ptr [bp+outputStringP+2], dx
	lea	ax, [bp+stringBuf]
	push	ss
	push	ax
	call	printString
	add	sp, 4
	mov	byte ptr g_printPartyFlag,	0
	call	text_delayWithTable
	mov	ax, [bp+partyAttackRval]
	dec	ax
	jmp	l_return

l_targetIsEnemy:
	mov	al, gs:bat_curTarget
	sub	ah, ah
	and	ax, 3
	mov	cx, monStruSize
	mul	cx
	mov	bx, ax
	test	gs:monGroups.groupSize[bx], 1Fh
	jz	l_enemyGroupGone
loc_20289:
	test	[bp+breathFlags], breath_oneGroup
	jz	short loc_202B1
	mov	al, gs:bat_curTarget
	sub	ah, ah
	and	ax, 3
	mul	cx
	mov	bx, ax
	mov	al, gs:monGroups.groupSize[bx]
	sub	ah, ah
	and	ax, 1Fh
	dec	ax
	jmp	short loc_202B3
loc_202B1:
	sub	ax, ax
loc_202B3:
	mov	[bp+target], ax

	; strcat(stringBuf, "at")
	mov	ax, offset s_at
	push	ds
	push	ax
	lea	ax, [bp+stringBuf]
	push	ss
	push	ax
	call	strcat
	add	sp, 8
	mov	word ptr [bp+outputStringP], ax
	mov	word ptr [bp+outputStringP+2], dx

	push	[bp+target]
	mov	al, gs:bat_curTarget
	sub	ah, ah
	push	ax
	push	dx
	push	word ptr [bp+outputStringP]
	push	cs
	call	near ptr strcatTargetName
	add	sp, 8
	mov	word ptr [bp+outputStringP], ax
	mov	word ptr [bp+outputStringP+2], dx
	mov	ax, offset s_elipsisNl
	push	ds
	push	ax
	push	dx
	push	word ptr [bp+outputStringP]
	call	strcat
	add	sp, 8
	mov	word ptr [bp+outputStringP], ax
	mov	word ptr [bp+outputStringP+2], dx
	jmp	short loc_20324
l_enemyGroupGone:
	mov	[bp+target], 0FFFFh
	cmp	[bp+breathFlags], breath_allFoes
	jnb	short loc_20324
	mov	ax, [bp+partyAttackRval]
	jmp	l_return

loc_20324:
	cmp	[bp+target], 0
	jl	loc_2086F
loc_2032E:
	mov	gs:damageAmount, 0
	mov	[bp+counter], 0
	jmp	short loc_20345
loc_20341:
	inc	[bp+counter]
loc_20345:
	mov	al, [bp+levelMultiplier]
	sub	ah, ah
	cmp	ax, [bp+counter]
	jbe	short loc_20379
	mov	al, [bp+arg_6]
	push	ax
	call	randomYdX
	add	sp, 2
	add	gs:damageAmount, ax
	cmp	gs:damageAmount, 20000
	jle	short loc_20377
	mov	gs:damageAmount, 20000
	jmp	short loc_20379
loc_20377:
	jmp	short loc_20341
loc_20379:
	cmp	gs:bat_curTarget, 80h
	jb	short loc_203AA

	mov	ax, offset s_one
	push	ds
	push	ax
	push	word ptr [bp+outputStringP+2]
	push	word ptr [bp+outputStringP]
	call	strcat
	add	sp, 8
	mov	word ptr [bp+outputStringP], ax
	mov	word ptr [bp+outputStringP+2], dx
	mov	[bp+var_2], 1
	jmp	loc_2047F
loc_203AA:
	mov	ax, [bp+target]
	cmp	[bp+var_11A], ax
	jz	loc_2047A
	mov	bx, ax
	cmp	gs:g_characterMeleeDistance[bx], 0
	jnz	loc_2047A
	mov	al, [bp+specialAttackIndex]
	sub	ah, ah
	push	ax
	push	bx
	push	cs
	call	near ptr bat_charIsBreathAttackable
	add	sp, 4
	or	ax, ax
	jz	loc_2047A
	mov	ax, charSize
	imul	[bp+target]
	mov	bx, ax
	lea	ax, party._name[bx]
	mov	dx, seg	seg027
	push	dx
	push	ax
	push	word ptr [bp+outputStringP+2]
	push	word ptr [bp+outputStringP]
	call	strcat
	add	sp, 8
	mov	word ptr [bp+outputStringP], ax
	mov	word ptr [bp+outputStringP+2], dx
	lfs	bx, dword ptr [bp+outputStringP]
	inc	word ptr [bp+outputStringP]
	mov	byte ptr fs:[bx], ' '
	mov	ax, itemEff_breathDefense
	push	ax
	push	[bp+target]
	call	character_isEffectEquipped
	add	sp, 4
	or	ax, ax
	jl	short loc_20467
	test	[bp+breathFlags], breath_isBreath
	jz	short loc_20467
	mov	ax, offset s_repelledAttack
	push	ds
	push	ax
	push	word ptr [bp+outputStringP+2]
	push	word ptr [bp+outputStringP]
	call	strcat
	add	sp, 8
	mov	word ptr [bp+outputStringP], ax
	mov	word ptr [bp+outputStringP+2], dx
	mov	byte ptr g_printPartyFlag,	0
	mov	[bp+var_2], 0
	jmp	short loc_20478
loc_20467:
	mov	al, byte ptr [bp+target]
	mov	gs:bat_curTarget, al
	mov	[bp+var_2], 1
loc_20478:
	jmp	short loc_2047F
loc_2047A:
	mov	[bp+var_2], 0

loc_2047F:
	cmp	[bp+var_2], 0
	jz	loc_2050C

	cmp	[bp+arg_5], 0
	jz	short loc_2050C

	cmp	gs:bat_curTarget, 80h
	jnb	short loc_204B0

	mov	al, charSize
	mul	gs:bat_curTarget
	mov	bx, ax
	mov	al, gs:party.repelFlags[bx]
	sub	ah, ah
	jmp	short loc_204CF
loc_204B0:
	mov	al, gs:bat_curTarget
	sub	ah, ah
	and	ax, 7Fh
	mov	cx, monStruSize
	mul	cx
	mov	bx, ax
	mov	al, gs:monGroups.repelFlags[bx]
	sub	ah, ah
loc_204CF:
	mov	[bp+var_10C], ax
	mov	al, [bp+arg_5]
	sub	ah, ah
	test	[bp+var_10C], ax
	jnz	short loc_2050C
	mov	ax, offset s_repelledAttack
	push	ds
	push	ax
	push	word ptr [bp+outputStringP+2]
	push	word ptr [bp+outputStringP]
	call	strcat
	add	sp, 8
	mov	word ptr [bp+outputStringP], ax
	mov	word ptr [bp+outputStringP+2], dx
	mov	[bp+var_2], 0
loc_2050C:
	cmp	[bp+var_2], 0
	jz	loc_20810

	push	[bp+spellRange]
	push	[bp+partySlotNumber]
	push	cs
	call	near ptr bat_isPartyInRange
	add	sp, 4
	mov	[bp+var_4], ax
	or	ax, ax
	jz	l_printTooFarAway

	cmp	ax, 2
	jnz	short loc_2053B

	mov	gs:byte_41E63, 4
loc_2053B:
	mov	al, [bp+breathFlags]
	sub	ah, ah
	and	ax, 2
	push	ax
	push	[bp+partySlotNumber]
	push	cs
	call	near ptr savingThrowCheck
	add	sp, 4
	mov	[bp+var_118], ax
	or	ax, ax
	jz	loc_207D4

	cmp	ax, 1
	jnz	short loc_20567
	sar	gs:damageAmount, 1

loc_20567:
	test	[bp+breathFlags], 3
	jz	short loc_2058E
	cmp	gs:bat_curTarget, 80h
	jnb	short loc_2058E
	cmp	gs:songHalfDamage, 0
	jz	short loc_2058E
	sar	gs:damageAmount, 1
loc_2058E:
	cmp	gs:bat_curTarget, 80h
	jnb	short loc_205B0
	mov	al, charSize
	mul	gs:bat_curTarget
	mov	bx, ax
	mov	al, gs:party.strongElement[bx]
	sub	ah, ah
	jmp	short loc_205CF
loc_205B0:
	mov	al, gs:bat_curTarget
	sub	ah, ah
	and	ax, 3
	mov	cx, monStruSize
	mul	cx
	mov	bx, ax
	mov	al, gs:monGroups.strongElement[bx]
	sub	ah, ah
loc_205CF:
	mov	[bp+var_108], ax
	mov	al, [bp+arg_3]
	sub	ah, ah
	and	[bp+var_108], ax

	mov	[bp+counter], 0
loc_205E4:
	mov	bx, [bp+counter]
	mov	al, byteMaskList[bx]
	sub	ah, ah
	test	[bp+var_108], ax
	jz	short loc_2060D
	sar	gs:damageAmount, 1
loc_2060D:
	inc	[bp+counter]
	cmp	[bp+counter], 7
	jl	short loc_205E4

loc_2060F:
	cmp	gs:bat_curTarget, 80h
	jnb	short loc_20631
	mov	al, charSize
	mul	gs:bat_curTarget
	mov	bx, ax
	mov	al, gs:party.weakElement[bx]
	sub	ah, ah
	jmp	short loc_20650
loc_20631:
	mov	al, gs:bat_curTarget
	sub	ah, ah
	and	ax, 3
	mov	cx, monStruSize
	mul	cx
	mov	bx, ax
	mov	al, gs:monGroups.weakElement[bx]
	sub	ah, ah
loc_20650:
	mov	[bp+var_6], ax
	mov	al, [bp+arg_3]
	sub	ah, ah
	and	[bp+var_6], ax

	mov	[bp+counter], 0
loc_20663:
	mov	bx, [bp+counter]
	mov	al, byteMaskList[bx]
	sub	ah, ah
	test	[bp+var_6], ax
	jz	short loc_2068B
	shl	gs:damageAmount, 1
loc_2068B:
	inc	[bp+counter]
	cmp	[bp+counter], 7
	jl	short loc_20663

loc_2068D:
	mov	ax, gs:damageAmount
	mov	cl, [bp+specialAttackIndex]
	sub	ch, ch
	or	ax, cx
	jz	loc_207B5
loc_206A1:
	mov	ax, offset s_is
	push	ds
	push	ax
	push	word ptr [bp+outputStringP+2]
	push	word ptr [bp+outputStringP]
	call	strcat
	add	sp, 8
	mov	word ptr [bp+outputStringP], ax
	mov	word ptr [bp+outputStringP+2], dx
	mov	bl, [bp+arg_4]
	sub	bh, bh
	and	bl, 0FEh
	shl	bx, 1
	push	word ptr (breathEffectStr+2)[bx]
	push	word ptr breathEffectStr[bx]
	push	dx
	push	ax
	call	strcat
	add	sp, 8
	mov	word ptr [bp+outputStringP], ax
	mov	word ptr [bp+outputStringP+2], dx
	mov	ax, offset a_for
	push	ds
	push	ax
	push	word ptr [bp+outputStringP+2]
	push	word ptr [bp+outputStringP]
	call	strcat
	add	sp, 8
	mov	word ptr [bp+outputStringP], ax
	mov	word ptr [bp+outputStringP+2], dx
	xor	ax, ax
	push	ax
	mov	ax, gs:damageAmount
	cwd
	push	dx
	push	ax
	push	word ptr [bp+outputStringP+2]
	push	word ptr [bp+outputStringP]
	call	itoa
	add	sp, 0Ah
	mov	word ptr [bp+outputStringP], ax
	mov	word ptr [bp+outputStringP+2], dx
	mov	ax, gs:damageAmount
	dec	ax
	push	ax
	push	dx
	push	word ptr [bp+outputStringP]
	mov	ax, offset aPointSOfDamage
	push	ds
	push	ax
	call	str_pluralize
	add	sp, 0Ah
	mov	word ptr [bp+outputStringP], ax
	mov	word ptr [bp+outputStringP+2], dx
	mov	al, [bp+specialAttackIndex]
	sub	ah, ah
	mov	gs:specialAttackVal, ax
	mov	al, gs:bat_curTarget
	push	ax
	call	bat_damageHp
	add	sp, 2
	or	ax, ax
	jz	short loc_207A7
	push	word ptr [bp+outputStringP+2]
	push	word ptr [bp+outputStringP]
	call	bat_appendSpecialAttackString
	add	sp, 4
	mov	word ptr [bp+outputStringP], ax
	mov	word ptr [bp+outputStringP+2], dx
	mov	ax, 1
	push	ax
	mov	ax, 3
	push	ax
	mov	al, gs:bat_curTarget
	sub	ah, ah
	push	ax
	push	dx
	push	word ptr [bp+outputStringP]
	call	printCharPronoun
	add	sp, 0Ah
	mov	word ptr [bp+outputStringP], ax
	mov	word ptr [bp+outputStringP+2], dx
	jmp	short loc_207D2
loc_207A7:
	mov	ax, offset s_periodNlNl
	push	ds
	push	ax
	push	word ptr [bp+outputStringP+2]
	push	word ptr [bp+outputStringP]
	call	strcat
	add	sp, 8
	mov	word ptr [bp+outputStringP], ax
	mov	word ptr [bp+outputStringP+2], dx
	jmp	short loc_207D2
loc_207B5:
	mov	ax, offset s_repelledAttack
	push	ds
	push	ax
	push	word ptr [bp+outputStringP+2]
	push	word ptr [bp+outputStringP]
	call	strcat
	add	sp, 8
	mov	word ptr [bp+outputStringP], ax
	mov	word ptr [bp+outputStringP+2], dx
loc_207D2:
	jmp	short loc_207F1
loc_207D4:
	mov	ax, offset s_repelledAttack
	push	ds
	push	ax
	push	word ptr [bp+outputStringP+2]
	push	word ptr [bp+outputStringP]
	call	strcat
	add	sp, 8
	mov	word ptr [bp+outputStringP], ax
	mov	word ptr [bp+outputStringP+2], dx
loc_207F1:
	jmp	short loc_20810
l_printTooFarAway:
	mov	ax, offset s_wasTooFarAway
	push	ds
	push	ax
	push	word ptr [bp+outputStringP+2]
	push	word ptr [bp+outputStringP]
	call	strcat
	add	sp, 8
	mov	word ptr [bp+outputStringP], ax
	mov	word ptr [bp+outputStringP+2], dx
loc_20810:
	lfs	bx, [bp+outputStringP]
	mov	byte ptr fs:[bx], 0
	lea	ax, [bp+stringBuf]
	push	ss
	push	ax
	call	printString
	add	sp, 4
	mov	byte ptr g_printPartyFlag,	0
	call	text_delayWithTable
	lea	ax, [bp+stringBuf]
	mov	word ptr [bp+outputStringP], ax
	mov	word ptr [bp+outputStringP+2], ss
	lfs	bx, [bp+outputStringP]
	mov	byte ptr fs:[bx], 0
	cmp	gs:bat_curTarget, 80h
	jnb	short loc_20868
	test	[bp+breathFlags], 40h
	jnz	short loc_20868
	mov	[bp+target], 0FFFFh
loc_20868:
	dec	[bp+target]
	jmp	loc_20324
loc_2086F:
	test	[bp+breathFlags], breath_allFoes
	jz	short loc_20896
	test	gs:bat_curTarget, 80h
	jz	short loc_20896
	cmp	gs:bat_curTarget, 83h
	jz	short loc_20896
	mov	[bp+var_110], 1
	inc	gs:bat_curTarget
	jmp	short loc_2089C
loc_20896:
	mov	[bp+var_110], 0
loc_2089C:
	cmp	[bp+var_110], 0
	jnz	loc_201C6
l_return:
	mov	sp, bp
	pop	bp
	retf
bat_doBreathAttack endp

; Attributes: bp-based frame

bat_charIsBreathAttackable proc far
        partySlotNumber=        word ptr  6
        specialAttackIndex= word ptr  8

	push	bp
	mov	bp, sp
	mov	ax, charSize
	imul	[bp+partySlotNumber]
	mov	bx, ax

        cmp     byte ptr gs:party._name[bx], 0			; if partySlot.isEmpty
	jz	l_return_zero					;   return 0
	mov	ax, charSize
	imul	[bp+partySlotNumber]
	mov	bx, ax
        test    gs:party.status[bx], stat_dead or stat_stoned	; if !partySlot.isDead and !partySlot.isStoned
	jz	l_return_one					;   return 1

	mov	ax, charSize
	imul	[bp+partySlotNumber]
	mov	bx, ax		; Character is either dead or stoned
        test    gs:party.status[bx], stat_stoned		; if partySlot.isStoned
	jnz	l_return_zero					;   return 0

								; Character is dead
        cmp     [bp+specialAttackIndex], speAtt_possess		; if specialAttackIndex != speAtt_possess
        jnz     short l_return_zero				;   return 0
l_return_one:
	mov	ax, 1
	jmp	l_return
l_return_zero:
        sub     ax, ax
l_return:
	mov	sp, bp
	pop	bp
        retf
bat_charIsBreathAttackable endp

; Attributes: bp-based frame
sp_trapZap proc	far

	_sq_east= word ptr -0Ah
	loopCounter= word ptr	-8
	_sq_north= word	ptr -6
	dungeonSquareP= dword ptr -4

	push	bp
	mov	bp, sp
	mov	ax, 0Ah
	call	someStackOperation

	mov	ax, sq_north
	mov	[bp+_sq_north],	ax
	mov	ax, sq_east
	mov	[bp+_sq_east], ax
	cmp	inDungeonMaybe, 0
	jz	l_return
	mov	[bp+loopCounter], 4
l_loop:
	mov	al, g_dunHeight
	sub	ah, ah
	push	ax
	mov	ax, [bp+_sq_north]
	mov	bx, g_direction
	shl	bx, 1
	sub	ax, dirDeltaN[bx]
	push	ax
	call	wrapNumber
	add	sp, 4
	mov	[bp+_sq_north],	ax
	mov	al, g_dunWidth
	sub	ah, ah
	push	ax
	mov	bx, g_direction
	shl	bx, 1
	mov	ax, dirDeltaE[bx]
	add	ax, [bp+_sq_east]
	push	ax
	call	wrapNumber
	add	sp, 4
	mov	[bp+_sq_east], ax
	mov	bx, [bp+_sq_north]
	shl	bx, 1
	shl	bx, 1
	mov	ax, word ptr gs:rowOffset[bx]
	mov	dx, word ptr gs:(rowOffset+2)[bx]
	mov	cx, [bp+_sq_east]
	mov	bx, cx
	shl	cx, 1
	shl	cx, 1
	add	cx, bx
	add	ax, cx
	add	ax, 2
	mov	word ptr [bp+dungeonSquareP], ax
	mov	word ptr [bp+dungeonSquareP+2], dx
	lfs	bx, [bp+dungeonSquareP]
	and	byte ptr fs:[bx], 0EFh
	dec	[bp+loopCounter]
	cmp	[bp+loopCounter], 0
	jg	l_loop
l_return:
	mov	sp, bp
	pop	bp
	retf
sp_trapZap endp

; Attributes: bp-based frame

sp_freezeFoes proc far

	spellCaster=	word ptr  6
	spellIndexNumber= word ptr	 8

	push	bp
	mov	bp, sp

	push	[bp+spellCaster]
	push	cs
	call	near ptr spellSavingThrowHelper
	add	sp, 2
	or	ax, ax
	jz	short l_return

	cmp	[bp+spellCaster], 80h
	jge	short l_monCaster
	mov	bx, [bp+spellIndexNumber]
	mov	al, spellEffectFlags[bx]
	mov	bl, gs:bat_curTarget
	and	bx, 3
	add	gs:g_monFreezeAcPenalty[bx], al
	add	gs:g_charFreezeToHitBonus, 2
	jmp	short l_return
l_monCaster:
	mov	bx, [bp+spellIndexNumber]
	mov	al, spellEffectFlags[bx]
	add	gs:g_charFreezeAcPenalty, al
l_return:
	mov	sp, bp
	pop	bp
	retf
sp_freezeFoes endp


; Attributes: bp-based frame

spellSavingThrowHelper proc far

        spellCaster= word ptr  6

	push	bp
	mov	bp, sp

        cmp     [bp+spellCaster], 80h
        jl      short l_partyCaster

        mov     gs:bat_curTarget, 0		; Saving throw target is first party slot
        sub     ax, ax				; Saving throw type is 0 for spell
        push    ax
        push    [bp+spellCaster]
	push	cs
	call	near ptr savingThrowCheck
	add	sp, 4
        or      ax, ax
        jnz     short l_firstCharFailedSave
        sub     ax, ax
        jmp     short l_return
l_firstCharFailedSave:
        cmp     gs:partySecondSlot._name, 0
        jnz     short l_secondCharExists
        mov     ax, 1
        jmp     short l_return
l_secondCharExists:
        mov     gs:bat_curTarget, 1
l_partyCaster:
        sub     ax, ax				; Saving throw type is 0 for spell
        push    ax
        push    [bp+spellCaster]
	push	cs
	call	near ptr savingThrowCheck
	add	sp, 4
l_return:
	mov	sp, bp
	pop	bp
        retf
spellSavingThrowHelper endp

; Attributes: bp-based frame

; Returns:
;   0 - saving throw succeeded
;   1 - saving throw failed
;   2 - saving throw failed badly
;

savingThrowCheck proc far

	targetSaveValue= word ptr	-6
	sourceSaveValue= word ptr	-4
	saveDifference= word ptr	-2
	saveSource= word ptr	 6
	saveType= word ptr	 8

	push	bp
	mov	bp, sp
	mov	ax, 6
	call	someStackOperation

	sub	ax, ax
	push	ax
	push	[bp+saveSource]
	push	cs
	call	near ptr _savingThrowCheck
	add	sp, 4
	mov	[bp+sourceSaveValue], ax

	mov	gs:byte_4228E, 0			; Doesnt seem to do anything

	push	[bp+saveType]
	mov	al, gs:bat_curTarget
	sub	ah, ah
	push	ax
	push	cs
	call	near ptr _savingThrowCheck
	add	sp, 4
	mov	[bp+targetSaveValue], ax

	; Always seems to be zero. byte_41E63 isnt set anywhere
	mov	al, gs:byte_41E63
	sub	ah, ah

	add	ax, [bp+targetSaveValue]
	push	ax
	push	cs
	call	near ptr lib_maxFF
	add	sp, 2
	mov	[bp+targetSaveValue], ax
	mov	gs:byte_41E63, 0
	mov	ax, [bp+sourceSaveValue]
	sub	ax, [bp+targetSaveValue]
	mov	[bp+saveDifference], ax
	or	ax, ax
	jge	short l_saveFailed
	sub	ax, ax
	jmp	short l_return
l_saveFailed:
	cmp	[bp+saveDifference], 4
	jle	short l_return_one
	mov	ax, 2
	jmp	short l_return
l_return_one:
	mov	ax, 1
l_return:
	mov	sp, bp
	pop	bp
	retf
savingThrowCheck endp

; Attributes: bp-based frame

_savingThrowCheck proc far

	saveHi= word ptr	-0Ah
	partySaveValue= word ptr	-8
	saveLo= word ptr	-6
	charP= dword ptr -4
	indexNo= word ptr  6
	savingThrowType= word ptr	 8

	push	bp
	mov	bp, sp
	mov	ax, 0Ah
	call	someStackOperation
	push	si

	cmp	[bp+indexNo], 80h
	jl	short l_isPartyMember
	and	[bp+indexNo], 7Fh

	; This block looks to be useless. byte_4228E doesnt have any
	; value besides 0 written to it. Might be a bug.
	cmp	gs:byte_4228E, 0
	jz	short l_enemySave
	mov	al, gs:byte_4228E
	sub	ah, ah
	jmp	l_return

l_enemySave:
	cmp	[bp+savingThrowType], 0

	; FIXED - This was "jz short l_monSpellSave". This matches behavior on the
	; Apple II. The function was using the wrong hi/lo values for spells.
	; This pretty much made the final battles with Rock Demons impossible.
	;
	jnz	short l_monSpellSave
	mov	ax, monStruSize
	imul	[bp+indexNo]
	mov	si, ax
	mov	al, gs:monGroups.breathSaveLo[si]
	sub	ah, ah
	mov	[bp+saveLo], ax
	mov	al, gs:monGroups.breathSaveHi[si]
	mov	[bp+saveHi], ax
	jmp	short loc_20B8D
l_monSpellSave:
	mov	ax, monStruSize
	imul	[bp+indexNo]
	mov	si, ax
	mov	al, gs:monGroups.spellSaveLo[si]
	sub	ah, ah
	mov	[bp+saveLo], ax
	mov	al, gs:monGroups.spellSaveHi[si]
	mov	[bp+saveHi], ax
loc_20B8D:
	push	[bp+saveHi]
	push	[bp+saveLo]
	call	randomBetweenXandY
	add	sp, 4
	jmp	l_return

	; This line is unreachable in the code. It might be correct
	; to check for an antimagic square. 
	; jmp	l_antiMagicCheck

l_isPartyMember:
	mov	ax, charSize
	imul	[bp+indexNo]
	mov	si, ax
	cmp	gs:party.class[si], class_monster
	jb	short l_partyMemberNotMonster
	add	ax, offset party
	mov	word ptr [bp+charP], ax
	mov	word ptr [bp+charP+2], seg seg027
	cmp	[bp+savingThrowType], 0
	jnz	short l_partyMonSpellSave
	lfs	bx, [bp+charP]
	mov	al, fs:[bx+summonStat_t.breathSaveLo]
	sub	ah, ah
	mov	[bp+saveLo], ax
	mov	al, fs:[bx+summonStat_t.breathSaveHi]
	mov	[bp+saveHi], ax
	jmp	short l_partyMonRandomSaveValue
l_partyMonSpellSave:
	lfs	bx, [bp+charP]
	mov	al, fs:[bx+summonStat_t.spellSaveLo]
	sub	ah, ah
	mov	[bp+saveLo], ax
	mov	al, fs:[bx+summonStat_t.spellSaveHi]
	mov	[bp+saveHi], ax
l_partyMonRandomSaveValue:
	push	[bp+saveHi]
	push	[bp+saveLo]
	call	randomBetweenXandY
	add	sp, 4
	mov	[bp+partySaveValue], ax
	jmp	short l_antiMagicCheck
l_partyMemberNotMonster:
	mov	ax, charSize
	imul	[bp+indexNo]
	mov	bx, ax
	mov	ax, gs:party.level[bx]
	shr	ax, 1
	mov	[bp+partySaveValue], ax
	mov	ax, itemEff_alwaysHide
	push	ax
	push	[bp+indexNo]
	call	character_isEffectEquipped
	add	sp, 4
	or	ax, ax
	jnz	short l_noLuckBonus
	add	[bp+partySaveValue], 2
l_noLuckBonus:
	mov	ax, charSize
	imul	[bp+indexNo]
	mov	si, ax
	mov	ax, 41h	
	push	ax
	call	randomYdX
	add	sp, 2
	mov	bl, gs:party.class[si]
	sub	bh, bh
	mov	cl, classSavingBonus[bx]
	sub	ch, ch
	mov	dl, gs:party.luck[si]
	sub	dh, dh
	add	cx, dx
	add	cx, ax
	add	[bp+partySaveValue], cx
l_antiMagicCheck:
	mov	al, gs:antiMagicFlag
	sub	ah, ah
	add	ax, [bp+partySaveValue]
	push	ax
	push	cs
	call	near ptr lib_maxFF
	add	sp, 2
l_return:
	pop	si
	mov	sp, bp
	pop	bp
	retf
_savingThrowCheck endp

; This function	returns	the passed value or 255
; depending on which is	lower. This is equivalent
; to the C statement:
; (val)	<= 255 ? (val) : 255
; Attributes: bp-based frame

lib_maxFF proc far

	val= word ptr  6

	push	bp
	mov	bp, sp

	mov	ax, [bp+val]
	cmp	ax, 255
	jle	short l_return
	mov	ax, 255

l_return:
	mov	sp, bp
	pop	bp
	retf
lib_maxFF endp

; Attributes: bp-based frame

sp_compassSpell	proc far

	spellIndexNumber= word ptr	 8

	push	bp
	mov	bp, sp

	mov	bx, [bp+spellIndexNumber]
	mov	al, spellEffectFlags[bx]
	mov	compassDuration, al
	mov	ax, icon_compass
	push	ax
	call	icon_activate
	add	sp, 2
	mov	sp, bp
	pop	bp
	retf
sp_compassSpell	endp


; Attributes: bp-based frame

sp_healSpell proc far

	partySlotNumber=	word ptr  6
	spellNo= word ptr  8

	push	bp
	mov	bp, sp

	cmp	[bp+partySlotNumber], 80h
	jge	short l_return
	mov	bx, [bp+spellNo]
	mov	al, spellExtraFlags[bx]
	sub	ah, ah
	cmp	ax, heal_allFlag
	jge	short l_healAll
	push	bx
	mov	al, gs:bat_curTarget
	push	ax
	push	[bp+partySlotNumber]
	push	cs
	call	near ptr _doHeal
	add	sp, 6
	jmp	short l_return
l_healAll:
	mov	gs:bat_curTarget, 0
l_healAllLoop:
	push	[bp+spellNo]
	mov	al, gs:bat_curTarget
	sub	ah, ah
	push	ax
	push	[bp+partySlotNumber]
	push	cs
	call	near ptr _doHeal
	add	sp, 6
	inc	gs:bat_curTarget
	cmp	gs:bat_curTarget, 7
	jb	short l_healAllLoop
l_return:
	mov	sp, bp
	pop	bp
	retf
sp_healSpell endp

; Attributes: bp-based frame

_doHeal	proc far

	hpToHeal= word ptr -4
	effectFlag= word ptr -2
	partySlotNumber=	word ptr  6
	target=	word ptr  8
	spellNo= word ptr  0Ah

	push	bp
	mov	bp, sp
	mov	ax, 6
	call	someStackOperation
	push	si

	mov	bx, [bp+spellNo]
	mov	al, spellEffectFlags[bx]
	sub	ah, ah
	mov	[bp+effectFlag], ax
	mov	[bp+hpToHeal], 0

	cmp	ax, heal_fullHeal	; effectFlag < 0xfd means to heal effectFlagd4
					; hit points.
	jge	short l_quickFixCheck
	push	ax
	push	cs
	call	near ptr rnd_Xd4
	add	sp, 2
	mov	[bp+hpToHeal], ax
	jmp	short l_healHp

l_quickFixCheck:
	; Heal 8 points of damage. This is the magician spell
	; quick fix
	cmp	[bp+effectFlag], 0FEh 
	jnz	short l_healTimesLevel
	mov	[bp+hpToHeal], 8
	jmp	short l_healHp

l_healTimesLevel:
	; Heal Xd4 where X is the casters level
	mov	ax, charSize
	imul	[bp+partySlotNumber]
	mov	bx, ax
	mov	ax, gs:party.level[bx]
	sub	ax, 0FFh
	sbb	cx, cx
	and	ax, cx
	add	ax, 0FFh
	push	ax
	push	cs
	call	near ptr rnd_Xd4
	add	sp, 2
	mov	[bp+hpToHeal], ax

l_healHp:
	mov	ax, charSize
	imul	[bp+target]
	mov	si, ax
	mov	ax, [bp+hpToHeal]
	add	gs:party.currentHP[si], ax
	mov	ax, gs:party.maxHP[si]
	cmp	gs:party.currentHP[si], ax
	ja	short l_setToMaxHp
	cmp	[bp+effectFlag], heal_fullHeal
	jnz	short l_cureStatus
l_setToMaxHp:
	mov	ax, charSize
	imul	[bp+target]
	mov	si, ax
	mov	ax, gs:party.maxHP[si]
	mov	gs:party.currentHP[si], ax
l_cureStatus:
	mov	bx, [bp+spellNo]
	mov	al, spellExtraFlags[bx]
	sub	ah, ah
	and	ax, 7Fh
	jmp	l_switchStatus

l_fleshrestore:
	; Clears stat_poisoned, state_paralyzed, and stat_nuts
	mov	ax, charSize
	imul	[bp+target]
	mov	bx, ax
	and	gs:party.status[bx], 0AEh
	jmp	l_return

l_cureStoned:
	; Clears stat_dead and stat_stoned if not stoned
	mov	ax, charSize
	imul	[bp+target]
	mov	bx, ax
	test	gs:party.status[bx], stat_stoned
	jz	short l_stonedReturn
	mov	ax, charSize
	imul	[bp+target]
	mov	bx, ax
	and	gs:party.status[bx], 0F3h
	push	[bp+target]
	push	cs
	call	near ptr _sp_postHeal
	add	sp, 2
l_stonedReturn:
	jmp	l_return

l_curePossession:
	; Clears stat_possessed
	mov	ax, charSize
	imul	[bp+target]
	mov	bx, ax
	test	gs:party.status[bx], stat_possessed
	jz	short l_curePossessionReturn
	mov	ax, charSize
	imul	[bp+target]
	mov	bx, ax
	and	gs:party.status[bx], 0DFh
	push	[bp+target]
	push	cs
	call	near ptr _sp_postHeal
	add	sp, 2
l_curePossessionReturn:
	jmp	l_return

l_cureDeath:
	; Clears stat_dead if dead
	mov	ax, charSize
	imul	[bp+target]
	mov	bx, ax
	test	gs:party.status[bx], stat_dead
	jz	short l_cureDeathReturn
	mov	ax, charSize
	imul	[bp+target]
	mov	bx, ax
	and	gs:party.status[bx], 0FBh
	push	[bp+target]
	push	cs
	call	near ptr _sp_postHeal
	add	sp, 2
l_cureDeathReturn:
	jmp	short l_return

l_cureOld:
	; Clears stat_old if old
	mov	ax, charSize
	imul	[bp+target]
	mov	si, ax
	test	gs:party.status[si], stat_old
	jz	short l_cureOldReturn
	and	gs:party.status[si], 0FDh
	mov	ax, 5
	push	ax
	lea	ax, party.strength[si]
	mov	dx, seg	seg027
	push	dx
	push	ax
	lea	ax, party.savedST[si]
	push	dx
	push	ax
	call	character_applyAgeStatus
	add	sp, 0Ah
l_cureOldReturn:
	jmp	short l_return

l_healall:
	; Clears stat_nuts, stat_paralyzed, stat_dead and stat_poisoned
	mov	ax, charSize
	imul	[bp+target]
	mov	si, ax
	and	gs:party.status[si], 0AAh
	mov	gs:party.hostileFlag[si], 0
	jmp	short l_return

	; Following two lines were unreachable. 
	;mov	byte ptr g_printPartyFlag,	0
	;jmp	short l_return
l_switchStatus:
	cmp	ax, 6
	ja	short l_return
	add	ax, ax
	xchg	ax, bx
	jmp	cs:statusJumpTable[bx]
statusJumpTable	dw offset l_return
		dw offset l_fleshrestore
		dw offset l_cureStoned
		dw offset l_curePossession
		dw offset l_cureDeath
		dw offset l_cureOld
		dw offset l_healall
l_return:
	pop	si
	mov	sp, bp
	pop	bp
	retf
_doHeal	endp

; This function	does some standard cleanup after
; healing. If currentHP	is zero	then it	sets it
; to one like after a Beyond Death spell. It
; calms	summoned members and sets the attack priority
; for the round	to zero.
; Attributes: bp-based frame

_sp_postHeal proc far

	partySlotNumber=	word ptr  6

	push	bp
	mov	bp, sp

	mov	ax, charSize
	imul	[bp+partySlotNumber]
	mov	bx, ax
	cmp	gs:party.currentHP[bx], 0
	jnz	short l_notDead
	mov	ax, charSize
	imul	[bp+partySlotNumber]
	mov	bx, ax
	mov	gs:party.currentHP[bx], 1
l_notDead:
	mov	ax, charSize
	imul	[bp+partySlotNumber]
	mov	bx, ax
	mov	gs:party.hostileFlag[bx], 0
	mov	bx, [bp+partySlotNumber]
	mov	gs:g_charActionList[bx], 0
	mov	sp, bp
	pop	bp
	retf
_sp_postHeal endp


; Attributes: bp-based frame

sp_levitation proc far

	spellIndexNumber= word ptr	 8

	push	bp
	mov	bp, sp

	mov	bx, [bp+spellIndexNumber]
	mov	al, spellEffectFlags[bx]
	mov	levitationDuration, al
	mov	ax, icon_levitation
	push	ax
	call	icon_activate
	add	sp, 2
	mov	sp, bp
	pop	bp
	retf
sp_levitation endp

; Attributes: bp-based frame

sp_summonSpell proc far

	spellCaster= word ptr	 6
	spellIndexNumber= word ptr	 8

	push	bp
	mov	bp, sp

	mov	bx, [bp+spellIndexNumber]
	mov	al, spellEffectFlags[bx]
	sub	ah, ah
	push	ax
	push	[bp+spellCaster]
	call	summon_execute
	add	sp, 4

	mov	sp, bp
	pop	bp
	retf
sp_summonSpell endp

; Attributes: bp-based frame

sp_teleport proc far

	var_116= word ptr -116h
	var_16=	dword ptr -16h
	counter= word ptr -12h
	var_10=	dword ptr -10h
	var_C= word ptr	-0Ch
	var_A= word ptr	-0Ah
	var_8= word ptr	-8
	teleDeltaList= word ptr	-6
	spellCaster= word ptr	 6
	spellIndexNumber= word ptr	 8

	push	bp
	mov	bp, sp
	mov	ax, 116h
	call	someStackOperation
	push	di
	push	si

	mov	word ptr [bp+var_16], offset g_rosterCharacterBuffer
	mov	word ptr [bp+var_16+2],	seg seg022
	cmp	inDungeonMaybe, 0
	jnz	short loc_20FCB
	push	[bp+spellIndexNumber]
	push	[bp+spellCaster]
	push	cs
	call	near ptr printSpellFizzled
	jmp	l_return
loc_20FCB:
	mov	g_sameSquareFlag, 0
	mov	[bp+var_A], 0
	mov	[bp+counter], 0
	jmp	short loc_20FE5
loc_20FE2:
	inc	[bp+counter]
loc_20FE5:
	cmp	[bp+counter], 3
	jge	short loc_20FF7
	mov	si, [bp+counter]
	shl	si, 1
	mov	[bp+si+teleDeltaList], 0
	jmp	short loc_20FE2
loc_20FF7:
	call	text_clear
	mov	ax, offset s_teleportMenu
	push	ds
	push	ax
	lea	ax, [bp+var_116]
	push	ss
	push	ax
	call	strcat
	add	sp, 8
	mov	word ptr [bp+var_10], ax
	mov	word ptr [bp+var_10+2], dx
	mov	al, gs:txt_numLines
	sub	ah, ah
	mov	[bp+var_C], ax
	mov	al, g_levelFlags
	and	ax, 10h
	push	ax
	push	dx
	push	word ptr [bp+var_10]
	mov	ax, offset s_downUp
	push	ds
	push	ax
	call	str_pluralize
	add	sp, 0Ah
	mov	word ptr [bp+var_10], ax
	mov	word ptr [bp+var_10+2], dx
	lfs	bx, [bp+var_10]
	mov	byte ptr fs:[bx], 0
	lea	ax, [bp+var_116]
	push	ss
	push	ax
	call	printString
	add	sp, 4
	mov	al, byte ptr [bp+var_C]
	add	al, 3
	mov	gs:txt_numLines, al
	mov	[bp+counter], 0
	jmp	short loc_21071
loc_2106E:
	inc	[bp+counter]
loc_21071:
	cmp	[bp+counter], 3
	jge	short loc_210A1
	mov	ax, [bp+counter]
	cmp	[bp+var_A], ax
	jnz	short loc_21084
	mov	ax, 1
	jmp	short loc_21086
loc_21084:
	sub	ax, ax
loc_21086:
	push	ax
	mov	si, [bp+counter]
	shl	si, 1
	push	[bp+si+teleDeltaList]
	push	cs
	push	cs
	call	near ptr _sp_teleportPrintNum
	add	sp, 4
	inc	gs:txt_numLines
	jmp	short loc_2106E
loc_210A1:
	sub	ax, ax
	push	ax
	call	getKey
	add	sp, 2
	mov	[bp+var_8], ax
	jmp	short loc_210E5
loc_210B1:
	inc	[bp+var_A]
	jmp	short loc_210FB
loc_210B6:
	mov	si, [bp+var_A]
	shl	si, 1
	mov	ax, word_484CC[si]
	cmp	[bp+si+teleDeltaList], ax
	jge	short loc_210C7
	inc	[bp+si+teleDeltaList]
loc_210C7:
	jmp	short loc_210FB
loc_210C9:
	mov	si, [bp+var_A]
	shl	si, 1
	mov	ax, word_484CC[si]
	neg	ax
	cmp	[bp+si+teleDeltaList], ax
	jle	short loc_210DC
	dec	[bp+si+teleDeltaList]
loc_210DC:
	jmp	short loc_210FB
loc_210DE:
	jmp	l_return
loc_210E1:
	jmp	short loc_210FB
	jmp	short loc_210FB
loc_210E5:
	cmp	ax, dosKeys_ESC
	jz	short loc_210DE
	cmp	ax, ' '
	jz	short loc_210B1
	cmp	ax, dosKeys_upArrow
	jz	short loc_210B6
	cmp	ax, dosKeys_downArrow
	jz	short loc_210C9
	jmp	short loc_210E1
loc_210FB:
	cmp	[bp+var_A], 3
	jge	short loc_21104
	jmp	loc_20FF7
loc_21104:
	mov	ax, offset s_confirmTeleport
	push	ds
	push	ax
	call	printString
	add	sp, 4
	call	getYesNo
	or	ax, ax
	jnz	short loc_21136
	mov	ax, offset s_cancelTeleport
	push	ds
	push	ax
	call	printString
	add	sp, 4
	mov	ax, 4000h
	push	ax
	call	getKey
	add	sp, 2
	jmp	l_return
loc_21136:
	mov	ax, g_dunLevelNum
	add	ax, [bp+teleDeltaList+4]
	push	ax
	mov	ax, sq_east
	add	ax, [bp+teleDeltaList+2]
	push	ax
	mov	ax, sq_north
	add	ax, [bp+teleDeltaList]
	push	ax
	push	cs
	call	near ptr _sp_doTeleport
	add	sp, 6
	or	ax, ax
	jz	loc_211F3
loc_21168:
	mov	ax, offset s_successfulTeleport
	push	ds
	push	ax
	call	printString
	add	sp, 4
	mov	ax, [bp+teleDeltaList]
	add	sq_north, ax
	mov	ax, [bp+teleDeltaList+2]
	add	sq_east, ax
	mov	ax, [bp+teleDeltaList+4]
	add	g_dunLevelNum,	ax
	mov	di, g_dunLevelNum
	lfs	bx, [bp+var_16]
	mov	al, fs:[bx+di+12h]
	sub	ah, ah
	mov	si, ax
	cmp	dunLevelIndex, si
	jz	short loc_211F1
	mov	dunLevelIndex, si
	mov	g_mapRval, 4
	mov	al, fs:[bx+dun_t.deltaSqN]
	cbw
	add	sq_north, ax
	mov	al, fs:[bx+dun_t.deltaSqE]
	cbw
	add	sq_east, ax
	mov	gs:levelChangedFlag, 1
loc_211F1:
	jmp	short l_return
loc_211F3:
	mov	ax, offset s_failedTeleport
	push	ds
	push	ax
	call	printString
	add	sp, 4
l_return:
	pop	si
	pop	di
	mov	sp, bp
	pop	bp
	retf
sp_teleport endp

; Attributes: bp-based frame

_sp_doTeleport proc far

	var_1A=	dword ptr -1Ah
	var_16=	word ptr -16h
	var_14=	dword ptr -14h
	var_10=	word ptr -10h
	var_E= dword ptr -0Eh
	var_A= word ptr	-0Ah
	var_8= word ptr	-8
	var_6= word ptr	-6
	var_4= dword ptr -4
	sqN= word ptr  6
	sqE= word ptr  8
	level= word ptr	 0Ah

	mov	sp, bp
	pop	bp
	push	si

	cmp	[bp+level], 0
	jl	short loc_2121E
	cmp	[bp+level], 7
	jle	short loc_21223
loc_2121E:
	sub	ax, ax
	jmp	loc_2136C
loc_21223:
	mov	word ptr [bp+var_E], offset g_rosterCharacterBuffer
	mov	word ptr [bp+var_E+2], seg seg022
	lfs	bx, [bp+var_E]
	mov	al, fs:[bx+dun_t.deltaSqN]
	cbw
	add	ax, [bp+sqN]
	mov	[bp+var_16], ax
	mov	al, fs:[bx+dun_t.deltaSqE]
	cbw
	add	ax, [bp+sqE]
	mov	[bp+var_A], ax
	mov	si, [bp+level]
	test	fs:[bx+si+dun_t.dunLevel], 80h
	jz	short loc_21255
	sub	ax, ax
	jmp	loc_2136C
loc_21255:
	mov	si, [bp+level]
	mov	al, fs:[bx+si+dun_t.dunLevel]
	sub	ah, ah
	cmp	ax, dunLevelIndex
	jnz	short loc_21276
	mov	ax, bx
	mov	dx, word ptr [bp+var_E+2]
	mov	word ptr [bp+var_14], ax
	mov	word ptr [bp+var_14+2],	dx
	jmp	short loc_212A2
loc_21276:
	mov	ax, 0FA0h
	push	ax
	call	_mallocMaybe
	add	sp, 2
	mov	word ptr [bp+var_14], ax
	mov	word ptr [bp+var_14+2],	dx
	push	dx
	push	ax
	mov	si, [bp+level]
	lfs	bx, [bp+var_E]
	mov	al, fs:[bx+si+dun_t.dunLevel]
	sub	ah, ah
	add	ax, 0Ah
	push	ax
	call	map_read
	add	sp, 6
loc_212A2:
	lfs	bx, [bp+var_14]
	mov	al, fs:[bx+dun_t.deltaSqN]
	cbw
	sub	[bp+var_16], ax
	mov	al, fs:[bx+dun_t.deltaSqE]
	cbw
	sub	[bp+var_A], ax
	cmp	[bp+var_16], 0
	jl	short loc_212D5
	mov	al, fs:[bx+dun_t._height]
	sub	ah, ah
	cmp	ax, [bp+var_16]
	jbe	short loc_212D5
	cmp	[bp+var_A], 0
	jl	short loc_212D5
	mov	al, fs:[bx+dun_t._width]
	cmp	ax, [bp+var_A]
	ja	short loc_212F6
loc_212D5:
	mov	ax, word ptr [bp+var_E]
	mov	dx, word ptr [bp+var_E+2]
	cmp	bx, ax
	jnz	short loc_212E4
	cmp	word ptr [bp+var_14+2],	dx
	jz	short loc_212F2
loc_212E4:
	push	word ptr [bp+var_14+2]
	push	word ptr [bp+var_14]
	call	_freeMaybe
	add	sp, 4
loc_212F2:
	sub	ax, ax
	jmp	short loc_2136C
loc_212F6:
	mov	ax, word ptr [bp+var_14]
	mov	dx, word ptr [bp+var_14+2]
	add	ax, 24h	
	mov	[bp+var_8], ax
	mov	[bp+var_6], dx
	mov	ax, [bp+var_16]
	shl	ax, 1
	add	ax, [bp+var_8]
	mov	word ptr [bp+var_1A], ax
	mov	word ptr [bp+var_1A+2],	dx
	lfs	bx, [bp+var_1A]
	mov	ah, fs:[bx+1]
	sub	al, al
	mov	cl, fs:[bx]
	sub	ch, ch
	add	ax, cx
	add	ax, word ptr [bp+var_14]
	mov	word ptr [bp+var_4], ax
	mov	word ptr [bp+var_4+2], dx
	mov	si, [bp+var_A]
	mov	ax, si
	shl	si, 1
	shl	si, 1
	add	si, ax
	lfs	bx, [bp+var_4]
	mov	al, fs:[bx+si+4]
	and	al, 20h
	cmp	al, 1
	sbb	cx, cx
	neg	cx
	mov	[bp+var_10], cx
	mov	ax, word ptr [bp+var_E]
	mov	dx, word ptr [bp+var_E+2]
	cmp	word ptr [bp+var_14], ax
	jnz	short loc_21359
	cmp	word ptr [bp+var_14+2],	dx
	jz	short loc_21367
loc_21359:
	push	word ptr [bp+var_14+2]
	push	word ptr [bp+var_14]
	call	_freeMaybe
	add	sp, 4
loc_21367:
	mov	ax, [bp+var_10]
	jmp	short $+2
loc_2136C:
	pop	si
	mov	sp, bp
	pop	bp
	retf
_sp_doTeleport endp

; Attributes: bp-based frame

_sp_teleportPrintNum proc far

	var_24=	dword ptr -24h
	var_20=	word ptr -20h
	arg_0= word ptr	 6
	arg_2= word ptr	 8

	push	bp
	mov	bp, sp
	mov	ax, 24h
	call	someStackOperation

	sub	ax, ax
	push	ax
	mov	ax, [bp+arg_0]
	cwd
	push	dx
	push	ax
	lea	ax, [bp+var_20]
	push	ss
	push	ax
	call	itoa
	add	sp, 0Ah
	mov	word ptr [bp+var_24], ax
	mov	word ptr [bp+var_24+2], dx
	cmp	[bp+arg_2], 0
	jz	short loc_213A8
	lfs	bx, [bp+var_24]
	inc	word ptr [bp+var_24]
	mov	byte ptr fs:[bx], '<'
loc_213A8:
	lfs	bx, [bp+var_24]
	mov	byte ptr fs:[bx], 0
	mov	gs:g_currentCharPosition, 30h 
	lea	ax, [bp+var_20]
	push	ss
	push	ax
	call	text_writeString
	add	sp, 4

	mov	sp, bp
	pop	bp
	retf
_sp_teleportPrintNum endp

; Attributes: bp-based frame
sp_farFoes proc	far

	stringBuf= word ptr	-58h
	loopCounter= word ptr	-8
	stringBufP= dword ptr	-6
	newDistance= word ptr	-2
	spellCaster= word ptr	 6
	spellIndexNumber= word ptr	 8

	push	bp
	mov	bp, sp
	mov	ax, 5Ah
	call	someStackOperation

	push	[bp+spellCaster]
	push	cs
	call	near ptr spellSavingThrowHelper
	add	sp, 2
	or	ax, ax
	jz	l_return
	test	byte ptr [bp+spellCaster], 80h
	jz	short l_monCaster

	mov	[bp+loopCounter], 0
l_loopEnter:
	mov	ax, monStruSize
	imul	[bp+loopCounter]
	mov	bx, ax
	mov	al, gs:monGroups.distance[bx]
	sub	ah, ah
	and	ax, 0Fh
	mov	bx, [bp+spellIndexNumber]
	mov	cl, spellEffectFlags[bx]
	sub	ch, ch
	add	ax, cx
	mov	[bp+newDistance], ax
	cmp	ax, 9
	jle	short l_notTooFar
	mov	[bp+newDistance], 9
l_notTooFar:
	push	[bp+newDistance]
	push	[bp+loopCounter]
	push	cs
	call	near ptr _sp_setMonDistance
	add	sp, 4
	inc	[bp+loopCounter]
	cmp	[bp+loopCounter], 4
	jl	short l_loopEnter
	jmp	short l_outputString
l_monCaster:
	mov	al, gs:bat_curTarget
	sub	ah, ah
	and	ax, 3
	mov	[bp+loopCounter], ax
	mov	ax, monStruSize
	imul	[bp+loopCounter]
	mov	bx, ax
	mov	al, gs:monGroups.distance[bx]
	sub	ah, ah
	and	ax, 0Fh
	mov	bx, [bp+spellIndexNumber]
	mov	cl, spellEffectFlags[bx]
	sub	ch, ch
	add	ax, cx
	mov	[bp+newDistance], ax
	cmp	ax, 9
	jle	short l_partyNotTooFar
	mov	[bp+newDistance], 9
l_partyNotTooFar:
	push	[bp+newDistance]
	push	[bp+loopCounter]
	push	cs
	call	near ptr _sp_setMonDistance
	add	sp, 4
l_outputString:
	mov	ax, offset s_andTheFoesAre
	push	ds
	push	ax
	lea	ax, [bp+stringBuf]
	push	ss
	push	ax
	call	strcat
	add	sp, 8
	mov	word ptr [bp+stringBufP], ax
	mov	word ptr [bp+stringBufP+2], dx

	mov	ax, offset s_fartherAway
	push	ds
	push	ax
	push	dx
	push	word ptr [bp+stringBufP]
	call	strcat
	add	sp, 8
	mov	word ptr [bp+stringBufP], ax
	mov	word ptr [bp+stringBufP+2], dx

	lea	ax, [bp+stringBuf]
	push	ss
	push	ax
	call	printString
	add	sp, 4
l_return:
	call	text_delayWithTable
	mov	sp, bp
	pop	bp
	retf
sp_farFoes endp

; Attributes: bp-based frame
_sp_setMonDistance proc	far

	monsterGroupIndex= word ptr	 6
	newDistance= byte ptr	 8

	push	bp
	mov	bp, sp
	push	si

	mov	ax, monStruSize
	imul	[bp+monsterGroupIndex]
	mov	si, ax
	cmp	byte ptr gs:monGroups._name[si], 0
	jz	short l_return
	mov	al, gs:monGroups.distance[si]
	and	al, 0F0h
	or	al, [bp+newDistance]
	mov	gs:monGroups.distance[si], al
l_return:
	pop	si
	mov	sp, bp
	pop	bp
	retf
_sp_setMonDistance endp


; Attributes: bp-based frame

sp_vorpalPlating proc far

	spellIndexNumber= word ptr	 8

	push	bp
	mov	bp, sp

	mov	bx, [bp+spellIndexNumber]
	mov	al, spellEffectFlags[bx]
	mov	bl, gs:bat_curTarget
	and	bx, 7Fh
	add	gs:vorpalPlateBonus[bx], al

	mov	sp, bp
	pop	bp
	retf
sp_vorpalPlating endp

; Attributes: bp-based frame

sp_areaEnchant proc far

	spellIndexNumber= word ptr	 8

	push	bp
	mov	bp, sp

	mov	bx, [bp+spellIndexNumber]
	mov	al, spellEffectFlags[bx]
	mov	detectDuration, al
	mov	al, spellExtraFlags[bx]
	mov	g_detectType, al
	mov	ax, icon_areaEnchant
	push	ax
	call	icon_activate
	add	sp, 2
	mov	sp, bp
	pop	bp
	retf
sp_areaEnchant endp

; Attributes: bp-based frame

sp_shieldSpell proc far

	spellCaster= word ptr	 6
	spellIndexNumber= word ptr	 8

	push	bp
	mov	bp, sp

	cmp	[bp+spellCaster], 80h
	jl	short l_partyCaster
	mov	bx, [bp+spellIndexNumber]
	mov	al, spellExtraFlags[bx]
	mov	bx, [bp+spellCaster]
	and	bx, 3
	sub	gs:g_monFreezeAcPenalty[bx], al
	jmp	short loc_215BE
l_partyCaster:
	mov	bx, [bp+spellIndexNumber]
	mov	al, spellEffectFlags[bx]
	mov	shieldDuration, al
	mov	al, spellExtraFlags[bx]
	mov	shieldAcBonus, al
	mov	ax, icon_shield
	push	ax
	call	icon_activate
	add	sp, 2
	mov	byte ptr g_printPartyFlag,	0
loc_215BE:
	mov	sp, bp
	pop	bp
	retf
sp_shieldSpell endp

; Attributes: bp-based frame

sp_strengthBonus proc far

	spellCaster= word ptr	 6
	spellIndexNumber= word ptr	 8

	push	bp
	mov	bp, sp

	test	byte ptr [bp+spellCaster], 80h
	jz	short l_partCaster
	mov	bx, [bp+spellIndexNumber]
	mov	al, spellEffectFlags[bx]
	mov	bx, [bp+spellCaster]
	and	bx, 3
	mov	gs:monAttackBonus[bx], al
	jmp	short l_return
l_partCaster:
	mov	bx, [bp+spellIndexNumber]
	mov	al, spellEffectFlags[bx]
	mov	bl, gs:bat_curTarget
	and	bx, 7
	mov	gs:g_strengthSpellBonus[bx], al
l_return:
	mov	sp, bp
	pop	bp
	retf
sp_strengthBonus endp

; Attributes: bp-based frame
;
; XXX - Revisit

sp_phaseDoor proc far

	var_8= word ptr	-8
	var_6= dword ptr -6
	var_2= word ptr	-2
	spellCaster= word ptr	 6
	spellIndexNumber= word ptr	 8

	push	bp
	mov	bp, sp
	mov	ax, 8
	call	someStackOperation

	cmp	inDungeonMaybe, 0
	jz	loc_216E2
	push	sq_north
	push	sq_east
	call	dun_getWalls
	add	sp, 4
	mov	[bp+var_2], ax
	mov	ax, g_direction
	dec	ax
	push	ax
	push	[bp+var_2]
	call	dungeon_getWallInDirection
	add	sp, 4
	mov	[bp+var_8], ax
	mov	al, byte ptr [bp+var_8]
	and	al, 0Fh
	cmp	al, 9
	jb	short loc_21671
	push	[bp+spellIndexNumber]
	push	[bp+spellCaster]
	push	cs
	call	near ptr printSpellFizzled
	jmp	short l_return
loc_21671:
	mov	gs:wallIsPhased, 1
	mov	bx, [bp+spellIndexNumber]
	cmp	spellEffectFlags[bx], 80h
	jb	short loc_216E0
	mov	bx, sq_north
	shl	bx, 1
	shl	bx, 1
	mov	ax, word ptr gs:rowOffset[bx]
	mov	dx, word ptr gs:(rowOffset+2)[bx]
	mov	cx, sq_east
	mov	bx, cx
	shl	cx, 1
	shl	cx, 1
	add	cx, bx
	add	ax, cx
	mov	word ptr [bp+var_6], ax
	mov	word ptr [bp+var_6+2], dx
	test	byte ptr g_direction, 2
	jz	short loc_216C8
	inc	word ptr [bp+var_6]
loc_216C8:
	test	byte ptr g_direction, 1
	jz	short loc_216D9
	lfs	bx, [bp+var_6]
	and	byte ptr fs:[bx], 0F0h
	jmp	short loc_216E0
loc_216D9:
	lfs	bx, [bp+var_6]
	and	byte ptr fs:[bx], 0Fh
loc_216E0:
	jmp	short l_return
loc_216E2:
	push	[bp+spellIndexNumber]
	push	[bp+spellCaster]
	push	cs
	call	near ptr printSpellFizzled
l_return:
	mov	sp, bp
	pop	bp
	retf
sp_phaseDoor endp


; Attributes: bp-based frame
sp_acBonus proc	far

	spellCaster= word ptr	 6
	spellIndexNumber= word ptr	 8

	push	bp
	mov	bp, sp

	cmp	[bp+spellCaster], 80h
	jge	short l_monCaster
	mov	bx, [bp+spellIndexNumber]
	mov	al, spellEffectFlags[bx]
	add	gs:partySpellAcBonus, al
	jmp	short l_return
l_monCaster:
	mov	bx, [bp+spellIndexNumber]
	mov	al, spellEffectFlags[bx]
	mov	bx, [bp+spellCaster]
	and	bx, 3
	sub	gs:g_monFreezeAcPenalty[bx], al
l_return:
	mov	sp, bp
	pop	bp
	retf
sp_acBonus endp


; Attributes: bp-based frame

sp_disbelieve proc far

	var_2= word ptr	-2
	spellCaster= word ptr	 6
	spellIndexNumber= word ptr	 8

	push	bp
	mov	bp, sp
	mov	ax, 2
	call	someStackOperation
	push	si

	cmp	[bp+spellCaster], 80h
	jge	short l_monCaster
	mov	bx, [bp+spellIndexNumber]
	mov	al, spellEffectFlags[bx]
	or	gs:disbelieveFlags, al

	cmp	gs:disbelieveFlags, disb_disruptill
	jb	l_return

	mov	[bp+var_2], 0
l_loopEnter:
	mov	ax, charSize
	imul	[bp+spellCaster]
	mov	si, ax
	cmp	gs:(party.specAbil+3)[si], 0
	jz	short l_nextChar
	mov	ax, 0Ch
	push	ax
	mov	ax, offset s_dopplganger
	push	ds
	push	ax
	lea	ax, party._name[si]
	mov	dx, seg	seg027
	push	dx
	push	ax
	call	memcpy
	add	sp, 0Ah
l_nextChar:
	inc	[bp+var_2]
	cmp	[bp+var_2], 7
	jl	short l_loopEnter
	jmp	short l_return

l_monCaster:
	mov	bx, [bp+spellIndexNumber]
	test	spellEffectFlags[bx], disb_nosummon
	jz	short l_monDisbelieve
	or	gs:disbelieveFlags, disb_nosummon
	jmp	short l_return
l_monDisbelieve:
	mov	al, byte ptr [bp+spellCaster]
	mov	gs:monDisbelieveFlag, al
l_return:
	pop	si
	mov	sp, bp
	pop	bp
	retf
sp_disbelieve endp


; Attributes: bp-based frame

; XXX - Not low hanging fruit
; DWORD - var_114 & var_116
; UNUSED - var_A & var_C

sp_scrySight proc far

	var_11A= word ptr -11Ah
	var_118= word ptr -118h
	var_116= word ptr -116h
	var_114= word ptr -114h
	var_112= word ptr -112h
	var_110= dword ptr -110h
	var_10C= word ptr -10Ch
	var_C= word ptr	-0Ch
	var_A= word ptr	-0Ah
	var_8= word ptr	-8
	var_6= word ptr	-6
	var_4= word ptr	-4
	var_2= word ptr	-2

	push	bp
	mov	bp, sp
	mov	ax, 11Ah
	call	someStackOperation
	push	si

	mov	[bp+var_6], 0
	mov	word ptr [bp+var_110], offset g_rosterCharacterBuffer
	mov	word ptr [bp+var_110+2], seg seg022
	lfs	bx, [bp+var_110]
	mov	al, fs:(g_rosterCharacterBuffer+11h)[bx]
	sub	ah, ah
	mov	[bp+var_118], ax
	mov	ax, offset s_youFace
	push	ds
	push	ax
	lea	ax, [bp+var_10C]
	push	ss
	push	ax
	call	strcat
	add	sp, 8
	mov	[bp+var_116], ax
	mov	[bp+var_114], dx
	mov	bx, g_direction
	shl	bx, 1
	shl	bx, 1
	push	word ptr (dirStringList+2)[bx]
	push	word ptr dirStringList[bx]
	push	dx
	push	ax
	call	strcat
	add	sp, 8
	mov	[bp+var_116], ax
	mov	[bp+var_114], dx
	cmp	[bp+var_118], 0
	jz	loc_218D5
loc_21840:
	mov	ax, [bp+var_6]
	inc	[bp+var_6]
	cmp	ax, 1
	sbb	cx, cx
	neg	cx
	push	cx
	push	dx
	push	[bp+var_116]
	mov	ax, offset s_andAre
	push	ds
	push	ax
	call	str_pluralize
	add	sp, 0Ah
	mov	[bp+var_116], ax
	mov	[bp+var_114], dx
	sub	ax, ax
	push	ax
	mov	ax, [bp+var_118]
	cwd
	push	dx
	push	ax
	push	[bp+var_114]
	push	[bp+var_116]
	call	itoa
	add	sp, 0Ah
	mov	[bp+var_116], ax
	mov	[bp+var_114], dx
	mov	ax, [bp+var_118]
	dec	ax
	push	ax
	push	dx
	push	[bp+var_116]
	mov	ax, offset s_levels
	push	ds
	push	ax
	call	str_pluralize
	add	sp, 0Ah
	mov	[bp+var_116], ax
	mov	[bp+var_114], dx
	mov	al, g_levelFlags
	and	al, 10h
	cmp	al, 1
	sbb	cx, cx
	neg	cx
	push	cx
	push	dx
	push	[bp+var_116]
	mov	ax, offset s_aboveBelow
	push	ds
	push	ax
	call	str_pluralize
	add	sp, 0Ah
	mov	[bp+var_116], ax
	mov	[bp+var_114], dx
loc_218D5:
	lfs	bx, [bp+var_110]
	mov	al, fs:[bx+dun_t.deltaSqN]
	cbw
	add	ax, sq_north
	mov	[bp+var_2], ax
	mov	si, [bp+var_118]
	mov	bl, fs:[bx+si+12h]
	sub	bh, bh
	mov	al, byte_47EDC[bx]
	cbw
	mov	cx, [bp+var_2]
	sub	cx, ax
	mov	[bp+var_11A], cx
	or	cx, cx
	jz	loc_219BD
	mov	ax, [bp+var_6]
	inc	[bp+var_6]
	cmp	ax, 1
	sbb	cx, cx
	neg	cx
	push	cx
	push	[bp+var_114]
	push	[bp+var_116]
	mov	ax, offset s_andAre
	push	ds
	push	ax
	call	str_pluralize
	add	sp, 0Ah
	mov	[bp+var_116], ax
	mov	[bp+var_114], dx
	cmp	[bp+var_11A], 0
	jl	short loc_21945
	mov	ax, [bp+var_11A]
	jmp	short loc_2194B
loc_21945:
	mov	ax, [bp+var_11A]
	neg	ax
loc_2194B:
	mov	[bp+var_112], ax
	sub	ax, ax
	push	ax
	mov	ax, [bp+var_112]
	cwd
	push	dx
	push	ax
	push	[bp+var_114]
	push	[bp+var_116]
	call	itoa
	add	sp, 0Ah
	mov	[bp+var_116], ax
	mov	[bp+var_114], dx
	mov	ax, [bp+var_112]
	dec	ax
	push	ax
	push	dx
	push	[bp+var_116]
	mov	ax, offset s_paces
	push	ds
	push	ax
	call	str_pluralize
	add	sp, 0Ah
	mov	[bp+var_116], ax
	mov	[bp+var_114], dx
	cmp	[bp+var_11A], 0
	jge	short loc_2199D
	mov	ax, 1
	jmp	short loc_2199F
loc_2199D:
	sub	ax, ax
loc_2199F:
	push	ax
	push	[bp+var_114]
	push	[bp+var_116]
	mov	ax, offset s_northSouth
	push	ds
	push	ax
	call	str_pluralize
	add	sp, 0Ah
	mov	[bp+var_116], ax
	mov	[bp+var_114], dx
loc_219BD:
	lfs	bx, [bp+var_110]
	mov	al, fs:[bx+dun_t.deltaSqE]
	cbw
	add	ax, sq_east
	mov	[bp+var_8], ax
	mov	si, [bp+var_118]
	mov	bl, fs:[bx+si+12h]
	sub	bh, bh
	mov	al, byte_47F1A[bx]
	cbw
	mov	cx, [bp+var_8]
	sub	cx, ax
	mov	[bp+var_4], cx
	or	cx, cx
	jnz	short loc_219F4
	jmp	loc_21AA0
loc_219F4:
	mov	ax, [bp+var_6]
	inc	[bp+var_6]
	cmp	ax, 1
	sbb	cx, cx
	neg	cx
	push	cx
	push	[bp+var_114]
	push	[bp+var_116]
	mov	ax, offset s_andAre
	push	ds
	push	ax
	call	str_pluralize
	add	sp, 0Ah
	mov	[bp+var_116], ax
	mov	[bp+var_114], dx
	cmp	[bp+var_4], 0
	jl	short loc_21A2A
	mov	ax, [bp+var_4]
	jmp	short loc_21A2F
loc_21A2A:
	mov	ax, [bp+var_4]
	neg	ax
loc_21A2F:
	mov	[bp+var_112], ax
	sub	ax, ax
	push	ax
	mov	ax, [bp+var_112]
	cwd
	push	dx
	push	ax
	push	[bp+var_114]
	push	[bp+var_116]
	call	itoa
	add	sp, 0Ah
	mov	[bp+var_116], ax
	mov	[bp+var_114], dx
	mov	ax, [bp+var_112]
	dec	ax
	push	ax
	push	dx
	push	[bp+var_116]
	mov	ax, offset s_paces
	push	ds
	push	ax
	call	str_pluralize
	add	sp, 0Ah
	mov	[bp+var_116], ax
	mov	[bp+var_114], dx
	cmp	[bp+var_4], 0
	jge	short loc_21A80
	mov	ax, 1
	jmp	short loc_21A82
loc_21A80:
	sub	ax, ax
loc_21A82:
	push	ax
	push	[bp+var_114]
	push	[bp+var_116]
	mov	ax, offset s_eastWest
	push	ds
	push	ax
	call	str_pluralize
	add	sp, 0Ah
	mov	[bp+var_116], ax
	mov	[bp+var_114], dx
loc_21AA0:
	cmp	[bp+var_6], 0
	jz	short loc_21AAB
	mov	ax, offset s_of
	jmp	short loc_21AAE
loc_21AAB:
	mov	ax, offset s_andAreAt
loc_21AAE:
	mov	[bp+var_C], ax
	mov	[bp+var_A], ds
	push	ds
	push	ax
	push	[bp+var_114]
	push	[bp+var_116]
	call	strcat
	add	sp, 8
	mov	[bp+var_116], ax
	mov	[bp+var_114], dx
	mov	si, [bp+var_118]
	lfs	bx, [bp+var_110]
	mov	al, fs:[bx+si+12h]
	sub	ah, ah
	mov	[bp+var_112], ax
	mov	bx, ax
	mov	al, byte_47F58[bx]
	cbw
	mov	bx, ax
	shl	bx, 1
	shl	bx, 1
	push	word ptr (scryBaseStringList+2)[bx]
	push	word ptr scryBaseStringList[bx]
	push	dx
	push	[bp+var_116]
	call	strcat
	add	sp, 8
	mov	[bp+var_116], ax
	mov	[bp+var_114], dx
	lea	ax, [bp+var_10C]
	push	ss
	push	ax
	call	printStringWClear
	add	sp, 4
	mov	ax, 4000h
	push	ax
	call	getKey
	add	sp, 2

	pop	si
	mov	sp, bp
	pop	bp
	retf
sp_scrySight endp

; Attributes: bp-based frame

sp_antiMagic proc far

	spellIndexNumber= word ptr	 8

	push	bp
	mov	bp, sp

	mov	bx, [bp+spellIndexNumber]
	mov	al, spellEffectFlags[bx]
	add	gs:antiMagicFlag, al
	mov	sp, bp
	pop	bp
	retf
sp_antiMagic endp

; Attributes: bp-based frame

sp_wordOfFear proc far

	spellCaster= word ptr	 6
	spellIndexNumber= word ptr	 8

	push	bp
	mov	bp, sp
	push	si

	push	[bp+spellCaster]
	push	cs
	call	near ptr spellSavingThrowHelper
	add	sp, 2
	or	ax, ax
	jz	short l_return

	cmp	[bp+spellCaster], 80h
	jge	short l_monCaster

	mov	al, gs:bat_curTarget
	sub	ah, ah
	mov	si, ax
	and	si, 3
	mov	bx, [bp+spellIndexNumber]
	mov	al, spellEffectFlags[bx]
	add	gs:monSpellToHitPenalty[si], al
	mov	bx, [bp+spellIndexNumber]

	; byte_41E50 isn't used anywhere else
	mov	al, spellEffectFlags[bx]
	add	gs:byte_41E50[si], al
	jmp	short l_return

l_monCaster:
	mov	bx, [bp+spellIndexNumber]
	mov	al, spellEffectFlags[bx]
	add	gs:g_monsterWOFBonus, al

l_return:
	pop	si
	mov	sp, bp
	pop	bp
	retf
sp_wordOfFear endp


; Attributes: bp-based frame

sp_spellbind proc far

	partySlotNumber= word ptr	-2
	spellCaster= word ptr	 6
	spellIndexNumber= word ptr	 8

	push	bp
	mov	bp, sp
	mov	ax, 2
	call	someStackOperation
	push	si

	sub	ax, ax
	push	ax
	push	[bp+spellCaster]
	or	ax, ax
	jz	l_printNoEffect

	cmp	gs:bat_curTarget, 80h
	jnb	short l_monTarget

	cmp	[bp+spellCaster], 80h
	jge	short l_monCaster

	; Set hostile flag to 0 when cast by party
	sub	al, al
	jmp	short l_setHostileFlag
l_monCaster:
	; Set hostfile flag to 1 when cast by enemy
	mov	al, 1
l_setHostileFlag:
	mov	cx, ax
	mov	ax, charSize
	imul	[bp+spellCaster]
	mov	bx, ax
	mov	gs:party.hostileFlag[bx], cl
	jmp	short l_return
l_monTarget:
	call	party_findEmptySlot
	mov	[bp+partySlotNumber], ax
	cmp	ax, 7
	jge	short l_printNoEffect
	mov	al, gs:bat_curTarget
	sub	ah, ah
	and	ax, 3
	mov	cx, 30h	
	mul	cx
	mov	si, ax
	test	gs:monGroups.groupSize[si], 1Fh
	jz	short l_printNoEffect

	test	gs:monGroups.flags[si],	10h
	jz	short l_printNoEffect

	dec	gs:monGroups.groupSize[si]
	lea	ax, monGroups._name[si]
	mov	dx, seg	seg027
	push	dx
	push	ax
	push	[bp+partySlotNumber]
	push	cs
	call	near ptr _sp_convertMonToSummon
	add	sp, 6
	mov	byte ptr g_printPartyFlag,	0
	jmp	short l_return
l_printNoEffect:
	push	[bp+spellIndexNumber]
	push	[bp+spellCaster]
	push	cs
	call	near ptr printNoEffect
	add	sp, 4
l_return:
	pop	si
	mov	sp, bp
	pop	bp
	retf
sp_spellbind endp

; This function	takes the data from the	mon_t data
; type and converts it to the summonStat_t data	type.
; Attributes: bp-based frame

_sp_convertMonToSummon proc far

	partySlotP=	dword ptr -1Ah
	counter= word ptr -16h
	var_14=	word ptr -14h
	singularName= dword ptr -4
	partySlotNumber= word ptr	 6
	monBufferP= dword ptr  8

	push	bp
	mov	bp, sp
	mov	ax, 1Ah
	call	someStackOperation
	push	si

	mov	ax, charSize
	imul	[bp+partySlotNumber]
	add	ax, offset party
	mov	word ptr [bp+partySlotP], ax
	mov	word ptr [bp+partySlotP+2],	seg seg027
	mov	ax, charSize
	push	ax
	sub	ax, ax
	push	ax
	push	word ptr [bp+partySlotP+2]
	push	word ptr [bp+partySlotP]
	call	memset
	add	sp, 8
	lea	ax, [bp+var_14]
	push	ss
	push	ax
	push	word ptr [bp+monBufferP+2]
	push	word ptr [bp+monBufferP]
	call	unmaskString
	add	sp, 8
	sub	ax, ax
	push	ax
	mov	ax, charSize
	imul	[bp+partySlotNumber]
	mov	bx, ax
	lea	ax, party._name[bx]
	mov	dx, seg	seg027
	push	dx
	push	ax
	lea	ax, [bp+var_14]
	push	ss
	push	ax
	call	str_pluralize
	add	sp, 0Ah
	mov	word ptr [bp+singularName], ax
	mov	word ptr [bp+singularName+2], dx
	lfs	bx, [bp+singularName]
	mov	byte ptr fs:[bx], 0
	lfs	bx, [bp+monBufferP]
	mov	al, fs:[bx+mon_t.breathSaveLo]
	lfs	bx, [bp+partySlotP]
	mov	fs:[bx+summonStat_t.breathSaveLo], al
	lfs	bx, [bp+monBufferP]
	mov	al, fs:[bx+mon_t.breathSaveHi]
	lfs	bx, [bp+partySlotP]
	mov	fs:[bx+summonStat_t.breathSaveHi], al
	lfs	bx, [bp+monBufferP]
	mov	al, fs:[bx+mon_t.oppPriorityLo]
	lfs	bx, [bp+partySlotP]
	mov	fs:[bx+summonStat_t.priorityLo], al
	lfs	bx, [bp+monBufferP]
	mov	al, fs:[bx+mon_t.oppPriorityHi]
	lfs	bx, [bp+partySlotP]
	mov	fs:[bx+summonStat_t.priorityHi], al
	lfs	bx, [bp+monBufferP]
	mov	al, fs:[bx+mon_t.picIndex]
	lfs	bx, [bp+partySlotP]
	mov	fs:[bx+summonStat_t.picIndex], al
	lfs	bx, [bp+monBufferP]
	mov	al, fs:[bx+mon_t.breathFlag]
	lfs	bx, [bp+partySlotP]
	mov	fs:[bx+summonStat_t.breathFlag], al
	lfs	bx, [bp+monBufferP]
	mov	al, fs:[bx+mon_t.breathRange]
	lfs	bx, [bp+partySlotP]
	mov	fs:[bx+summonStat_t.breathRange], al
	lfs	bx, [bp+monBufferP]
	mov	al, fs:[bx+mon_t.toHitLo]
	lfs	bx, [bp+partySlotP]
	mov	fs:[bx+summonStat_t.toHitLo], al
	lfs	bx, [bp+monBufferP]
	mov	al, fs:[bx+mon_t.toHitHi]
	lfs	bx, [bp+partySlotP]
	mov	fs:[bx+summonStat_t.toHitHi], al
	lfs	bx, [bp+monBufferP]
	mov	al, fs:[bx+mon_t.spellSaveLo]
	lfs	bx, [bp+partySlotP]
	mov	fs:[bx+summonStat_t.spellSaveLo], al
	lfs	bx, [bp+monBufferP]
	mov	al, fs:[bx+mon_t.spellSaveHi]
	lfs	bx, [bp+partySlotP]
	mov	fs:[bx+summonStat_t.spellSaveHi], al
	lfs	bx, [bp+monBufferP]
	mov	al, fs:[bx+mon_t.strongElement]
	lfs	bx, [bp+partySlotP]
	mov	fs:[bx+summonStat_t.strongElement], al
	lfs	bx, [bp+monBufferP]
	mov	al, fs:[bx+mon_t.weakElement]
	lfs	bx, [bp+partySlotP]
	mov	fs:[bx+summonStat_t.weakElement], al
	lfs	bx, [bp+monBufferP]
	mov	al, fs:[bx+mon_t.repelFlags]
	lfs	bx, [bp+partySlotP]
	mov	fs:[bx+summonStat_t.repelFlags], al
	mov	[bp+counter], 0
l_attackLoopEnter:
	mov	si, [bp+counter]
	lfs	bx, [bp+monBufferP]
	mov	al, fs:[bx+si+mon_t.attackType._type]
	lfs	bx, [bp+partySlotP]
	mov	fs:[bx+si+summonStat_t.attacks._type], al
	inc	[bp+counter]
	cmp	[bp+counter], 8
	jl	short l_attackLoopExit
	jmp	short l_attackLoopEnter
l_attackLoopExit:
	lfs	bx, [bp+monBufferP]
	mov	al, fs:[bx+mon_t.packedGenAc]
	and	al, 3Fh
	lfs	bx, [bp+partySlotP]
	mov	fs:[bx+summonStat_t.acBase], al
	lfs	bx, [bp+monBufferP]
	mov	al, fs:[bx+mon_t.packedGenAc]
	sub	ah, ah
	mov	cl, 6
	shr	ax, cl
	and	al, 3
	lfs	bx, [bp+partySlotP]
	mov	fs:[bx+summonStat_t.pronoun], al
	lfs	bx, [bp+monBufferP]
	mov	al, fs:[bx+mon_t.groupSize]
	sub	ah, ah
	mov	cl, 5
	shr	ax, cl
	and	al, 7
	lfs	bx, [bp+partySlotP]
	mov	fs:[bx+summonStat_t.numAttacks], al
	lfs	bx, [bp+monBufferP]
	mov	al, fs:[bx+mon_t.flags]
	and	al, 0Fh
	lfs	bx, [bp+partySlotP]
	mov	fs:[bx+summonStat_t.field_5E], al
	lfs	bx, [bp+monBufferP]
	mov	al, fs:[bx+mon_t.flags]
	sub	ah, ah
	mov	cl, 6
	shr	ax, cl
	and	al, 3
	lfs	bx, [bp+partySlotP]
	mov	fs:[bx+summonStat_t.field_5F], al
	lfs	bx, [bp+monBufferP]
	mov	al, fs:[bx+mon_t.flags]
	and	al, 10h
	cmp	al, 1
	sbb	cx, cx
	inc	cx
	add	cl, 0Dh
	lfs	bx, [bp+partySlotP]
	mov	fs:[bx+summonStat_t.class], cl
	lfs	bx, [bp+monBufferP]
	mov	al, fs:[bx+mon_t.hpDice]
	sub	ah, ah
	push	ax
	call	randomYdX
	add	sp, 2
	lfs	bx, [bp+monBufferP]
	mov	cx, fs:[bx+mon_t.hpBase]
	add	cx, ax
	lfs	bx, [bp+partySlotP]
	mov	fs:[bx+summonStat_t.curHP], cx
	lfs	bx, [bp+partySlotP]
	mov	ax, fs:[bx+summonStat_t.curHP]
	mov	fs:[bx+summonStat_t.maxHP], ax
	mov	[bp+counter], 0
l_questFlagLoopEnter:
	mov	si, [bp+counter]
	lfs	bx, [bp+partySlotP]
	mov	fs:[bx+si+summonStat_t.chronoQuest], 0FFh
	inc	[bp+counter]
	cmp	[bp+counter], 6
	jl	short l_questFlagLoopEnter

	pop	si
	mov	sp, bp
	pop	bp
	retf
_sp_convertMonToSummon endp


; Attributes: bp-based frame
sp_haltFoe proc	far

	spellCaster= word ptr	 6

	push	bp
	mov	bp, sp

	push	[bp+spellCaster]
	push	cs
	call	near ptr spellSavingThrowHelper
	add	sp, 2
	or	ax, ax
	jz	short l_return
	cmp	[bp+spellCaster], 80h
	jge	short l_monCaster
	inc	gs:monFrozenFlag
	jmp	short l_return
l_monCaster:
	inc	gs:partyFrozenFlag
	mov	ax, offset s_partyFreezes
	push	ds
	push	ax
	call	printString
	add	sp, 4
l_return:
	mov	sp, bp
	pop	bp
	retf
sp_haltFoe endp

; Attributes: bp-based frame

; DWORD - var_2 & var_4

sp_meleeMen proc far

	stringBuffer=	word ptr -56h
	var_4= word ptr	-4
	var_2= word ptr	-2
	spellCaster= word ptr	 6

	push	bp
	mov	bp, sp
	mov	ax, 56h
	call	someStackOperation

	push	[bp+spellCaster]
	push	cs
	call	near ptr spellSavingThrowHelper
	add	sp, 2
	or	ax, ax
	jz	short l_return

	test	byte ptr [bp+spellCaster], 80h
	jz	short l_partyCaster
	mov	ax, 1
	push	ax
	mov	ax, [bp+spellCaster]
	and	ax, 3
	push	ax
	push	cs
	call	near ptr _sp_setMonDistance
	add	sp, 4
	jmp	short l_printMessage
l_partyCaster:
	mov	ax, 1
	push	ax
	mov	al, gs:bat_curTarget
	sub	ah, ah
	and	ax, 3
	push	ax
	push	cs
	call	near ptr _sp_setMonDistance
	add	sp, 4
l_printMessage:
	mov	ax, offset s_andTheFoesAre
	push	ds
	push	ax
	lea	ax, [bp+stringBuffer]
	push	ss
	push	ax
	call	strcat
	add	sp, 8
	mov	[bp+var_4], ax
	mov	[bp+var_2], dx
	mov	ax, offset s_closer
	push	ds
	push	ax
	push	ax
	push	dx
	push	[bp+var_4]
	call	strcat
	add	sp, 8
	mov	[bp+var_4], ax
	mov	[bp+var_2], dx
	lea	ax, [bp+stringBuffer]
	push	ss
	push	ax
	call	printString
	add	sp, 4
l_return:
	mov	sp, bp
	pop	bp
	retf
sp_meleeMen endp

; Attributes: bp-based frame

sp_batchspell proc far

	batchListIndex= word ptr	-4
	var_2= word ptr	-2
	spellCaster= word ptr	 6
	spellIndexNumber= word ptr	 8

	push	bp
	mov	bp, sp
	mov	ax, 4
	call	someStackOperation

	mov	bx, [bp+spellIndexNumber]
	mov	al, spellEffectFlags[bx]
	sub	ah, ah
	mov	[bp+batchListIndex], ax
l_loopEnter:
	mov	bx, [bp+batchListIndex]
	inc	[bp+batchListIndex]
	mov	al, batchSpellList[bx]
	sub	ah, ah
	mov	[bp+var_2], ax
	or	ax, ax
	jz	short l_return
	push	ax
	push	[bp+spellCaster]
	push	cs
	call	near ptr _batchSpellCast
	add	sp, 4
	jmp	short l_loopEnter
l_return:
	mov	sp, bp
	pop	bp
	retf
sp_batchspell endp

; Attributes: bp-based frame

sp_camaraderie proc far

	loopCounter= word ptr	-2
	spellCaster= word ptr	 6

	push	bp
	mov	bp, sp
	mov	ax, 2
	call	someStackOperation

	mov	[bp+loopCounter], 0
l_loopEnter:
	mov	ax, charSize
	imul	[bp+spellCaster]
	mov	bx, ax
	cmp	gs:party.hostileFlag[bx], 0
	jz	short l_loopNext
	call	random
	and	al, 1
	mov	cx, ax
	mov	ax, charSize
	imul	[bp+spellCaster]
	mov	bx, ax
	mov	gs:party.hostileFlag[bx], cl
l_loopNext:
	inc	[bp+loopCounter]
	cmp	[bp+loopCounter], 7
	jl	l_loopEnter
	mov	sp, bp
	pop	bp
	retf
sp_camaraderie endp

printSpellFizzled proc far
	push	bp
	mov	bp, sp

	mov	ax, offset s_butItFizzled
	push	ds
	push	ax
	call	printString
	add	sp, 4
	mov	sp, bp
	pop	bp
	retf
printSpellFizzled endp

; Attributes: bp-based frame

sp_luckSpell proc far

	spellCaster= word ptr	 6
	spelIndexNumber= word ptr	 8

	push	bp
	mov	bp, sp

	mov	bx, [bp+spelIndexNumber]
	mov	al, spellEffectFlags[bx]
	add	gs:g_charFreezeToHitBonus, al
	push	bx
	push	[bp+spellCaster]
	push	cs
	call	near ptr sp_antiMagic
	add	sp, 4
	mov	sp, bp
	pop	bp
	retf
sp_luckSpell endp

; Attributes: bp-based frame

sp_identifySpell proc far

	var_F4=	word ptr -0F4h
	var_34=	word ptr -34h
	var_32=	word ptr -32h
	var_2= word ptr	-2
	spellCaster= word ptr	 6

	push	bp
	mov	bp, sp
	mov	ax, 0F4h
	call	someStackOperation

	call	text_clear
	and	[bp+spellCaster], 7Fh
	lea	ax, [bp+var_32]
	push	ss
	push	ax
	lea	ax, [bp+var_F4]
	push	ss
	push	ax
	push	[bp+spellCaster]
	call	inventory_getItemList
	add	sp, 0Ah
	mov	[bp+var_34], ax
	or	ax, ax
	jnz	short loc_22080
	mov	ax, offset s_pocketsAreEmpty
	push	ds
	push	ax
	call	printString
	add	sp, 4
	mov	[bp+var_2], 0FFFFh
	jmp	short loc_22098
loc_22080:
	push	[bp+var_34]
	lea	ax, [bp+var_32]
	push	ss
	push	ax
	mov	ax, offset s_whichItem
	push	ds
	push	ax
	call	text_scrollingWindow
	add	sp, 0Ah
	mov	[bp+var_2], ax
loc_22098:
	cmp	[bp+var_2], 0
	jge	short loc_220AD
	mov	ax, offset s_spellAborted
	push	ds
	push	ax
	call	printStringWClear
	add	sp, 4
	jmp	short l_return
loc_220AD:
	mov	ax, charSize
	imul	[bp+spellCaster]
	mov	bx, [bp+var_2]
	mov	cx, bx
	shl	bx, 1
	add	bx, cx
	add	bx, ax
	and	byte ptr gs:[bx+62h], 3Fh
	mov	ax, offset s_itemIdentified
	push	ds
	push	ax
	call	printStringWClear
	add	sp, 4
l_return:
	mov	sp, bp
	pop	bp
	retf
sp_identifySpell endp


; Attributes: bp-based frame

; DWORD var_104 & var_106

sp_earthMaw proc far

	loopCounter= word ptr -108h
	var_106= word ptr -106h
	var_104= word ptr -104h
	var_102= word ptr -102h
	var_100= word ptr -100h

	push	bp
	mov	bp, sp
	mov	ax, 108h
	call	someStackOperation
	push	si

	mov	ax, offset s_earthSwallows
	push	ds
	push	ax
	lea	ax, [bp+var_100]
	push	ss
	push	ax
	call	strcat
	add	sp, 8
	mov	[bp+var_106], ax
	mov	[bp+var_104], dx

	cmp	gs:bat_curTarget, 80h
	jnb	short l_monTarget

	; Kill all party members
	mov	[bp+loopCounter], 0
l_partyLoopEnter:
	mov	ax, charSize
	imul	[bp+loopCounter]
	mov	si, ax
	or	gs:party.status[si], stat_dead
	mov	gs:party.currentHP[si], 0
	inc	[bp+loopCounter]
	cmp	[bp+loopCounter], 7
	jl	short l_partyLoopEnter

	call	endNoncombatSong
	mov	ax, offset s_theParty
	push	ds
	push	ax
	lea	ax, [bp+var_100]
	push	ss
	push	ax
	call	strcat
	add	sp, 8
	mov	[bp+var_106], ax
	mov	[bp+var_104], dx
	jmp	l_return

l_monTarget:
	mov	al, gs:bat_curTarget
	sub	ah, ah
	mov	si, ax
	and	ax, 3
	mov	cx, monStruSize
	imul	cx
	mov	bx, ax
	mov	al, gs:monGroups.groupSize[bx]
	sub	ah, ah
	and	ax, 1Eh
	dec	ax
	push	ax
	push	si
	push	[bp+var_104]
	push	[bp+var_106]
	push	cs
	call	near ptr strcatTargetName
	add	sp, 8
	mov	[bp+var_106], ax
	mov	[bp+var_104], dx
	mov	al, gs:bat_curTarget
	sub	ah, ah
	and	ax, 3
	mov	[bp+var_102], ax
	mov	ax, monStruSize
	imul	[bp+var_102]
	mov	bx, ax
	and	gs:monGroups.groupSize[bx], 0E0h
	mov	[bp+loopCounter], 0
l_monLoopEnter:
	jge	short l_return
	mov	bx, [bp+var_102]
	mov	cl, 6
	shl	bx, cl
	mov	ax, [bp+loopCounter]
	shl	ax, 1
	add	bx, ax
	mov	gs:bat_monPriorityList[bx], 0
	inc	[bp+loopCounter]
	cmp	[bp+loopCounter], 32
	jl	short l_monLoopEnter
l_return:
	lea	ax, [bp+var_100]
	push	ss
	push	ax
	call	printString
	add	sp, 4
	pop	si
	mov	sp, bp
	pop	bp
	retf
sp_earthMaw endp

; Attributes: bp-based frame

printNoEffect proc far
	push	bp
	mov	bp, sp

	mov	ax, offset s_butItHadNoEffect
	push	ds
	push	ax
	call	printString
	add	sp, 4

	mov	sp, bp
	pop	bp
	retf
printNoEffect endp

; Attributes: bp-based frame

sp_divineIntervention proc far

	loopCounter= word ptr	-2
	spellCaster= word ptr	 6

	push	bp
	mov	bp, sp
	mov	ax, 2
	call	someStackOperation

	mov	[bp+loopCounter], 0
l_loopEnter:
	mov	ax, charSize
	imul	[bp+loopCounter]
	mov	bx, ax
	cmp	gs:party.class[bx], class_illusion
	jnz	short l_notIllusion

	mov	ax, charSize
	imul	[bp+loopCounter]
	mov	bx, ax
	mov	gs:party.class[bx], class_monster
l_notIllusion:
	mov	ax, charSize
	imul	[bp+loopCounter]
	mov	bx, ax
	and	gs:party.status[bx], stat_old or stat_unknown
	mov	ax, gs:party.maxHP[bx]
	mov	gs:party.currentHP[bx], ax
	inc	[bp+loopCounter]
	cmp	[bp+loopCounter], 7
	jl	short l_loopEnter
	cmp	gs:byte_422A4, 0
	jz	short l_return
	mov	al, 14h
	mov	gs:g_divineDamageBonus, al
	mov	gs:g_charFreezeToHitBonus, al
	mov	gs:antiMagicFlag, al
	mov	gs:partySpellAcBonus, al
	mov	gs:songExtraAttack, 8
	mov	gs:bat_curTarget, 80h
	mov	ax, 0CEh 
	push	ax
	push	[bp+spellCaster]
	push	cs
	call	near ptr _batchSpellCast
	add	sp, 4
l_return:
	mov	sp, bp
	pop	bp
	retf
sp_divineIntervention endp

; Attributes: bp-based frame

spGeo_removeTrap proc far

	squareP= dword ptr -4
	row= word ptr  6
	column=	word ptr  8

	push	bp
	mov	bp, sp
	mov	ax, 4
	call	someStackOperation

	mov	bx, [bp+row]
	shl	bx, 1
	shl	bx, 1
	mov	ax, word ptr gs:rowOffset[bx]
	mov	dx, word ptr gs:(rowOffset+2)[bx]
	mov	cx, [bp+column]
	mov	bx, cx
	shl	cx, 1
	shl	cx, 1
	add	cx, bx
	add	ax, cx
	add	ax, 2
	mov	word ptr [bp+squareP], ax
	mov	word ptr [bp+squareP+2], dx
	lfs	bx, [bp+squareP]
	and	byte ptr fs:[bx], 0EFh

	mov	sp, bp
	pop	bp
	retf
spGeo_removeTrap endp

dun_maskSquare proc far

	squareP=	dword ptr -4
	row=	word ptr 6
	column=	word ptr 8
	_byte=	word ptr 0Ah
	_mask=  byte ptr 0Ch

	push	bp
	mov	bp, sp
	mov	ax, 4
	call	someStackOperation

	mov	bx, [bp+row]
	shl	bx, 1
	shl	bx, 1
	mov	ax, word ptr gs:rowOffset[bx]
	mov	dx, word ptr gs:(rowOffset+2)[bx]
	mov	cx, [bp+column]
	mov	bx, cx
	shl	cx, 1
	shl	cx, 1
	add	cx, bx
	add	ax, cx
	add	ax, [bp+_byte]
	mov	word ptr [bp+squareP], ax
	mov	word ptr [bp+squareP+2], dx
	mov	al, [bp+_mask]
	lfs	bx, [bp+squareP]
	and	byte ptr fs:[bx], al

	mov	sp, bp
	pop	bp
	retf
dun_maskSquare endp

; Attributes: bp-based frame

spGeo_revealSquare proc far

	squareP= dword ptr -4
	row= word ptr  6
	column=	word ptr  8

	push	bp
	mov	bp, sp
	mov	ax, 4
	call	someStackOperation

	mov	bx, [bp+row]
	shl	bx, 1
	shl	bx, 1
	mov	ax, word ptr gs:rowOffset[bx]
	mov	dx, word ptr gs:(rowOffset+2)[bx]
	mov	cx, [bp+column]
	mov	bx, cx
	shl	cx, 1
	shl	cx, 1
	add	cx, bx
	add	ax, cx
	add	ax, 4
	mov	word ptr [bp+squareP], ax
	mov	word ptr [bp+squareP+2], dx
	lfs	bx, [bp+squareP]
	or	byte ptr fs:[bx], 1

	mov	sp, bp
	pop	bp
	retf
spGeo_revealSquare endp

; Attributes: bp-based frame
dun_revealSpSquare proc	far

	sqP= dword ptr -4
	row= word ptr  6
	column=	word ptr  8
	geoSpMaskIndex= word ptr	 0Ah

	push	bp
	mov	bp, sp
	mov	ax, 4
	call	someStackOperation

	push	si
	mov	bx, [bp+row]
	shl	bx, 1
	shl	bx, 1
	mov	ax, word ptr gs:rowOffset[bx]
	mov	dx, word ptr gs:(rowOffset+2)[bx]
	mov	cx, [bp+column]
	mov	bx, cx
	shl	cx, 1
	shl	cx, 1
	add	cx, bx
	add	ax, cx
	mov	word ptr [bp+sqP], ax
	mov	word ptr [bp+sqP+2], dx
	mov	bx, [bp+geoSpMaskIndex]
	mov	bl, geoSpMasks[bx-2]._byte
	sub	bh, bh
	lfs	si, [bp+sqP]
	mov	al, fs:[bx+si]
	sub	ah, ah
	mov	bx, [bp+geoSpMaskIndex]
	mov	cl, geoSpMasks[bx-2].bitmask
	sub	ch, ch
	test	ax, cx
	jz	short l_nextSquare
	mov	bx, si
	or	byte ptr fs:[bx+4], 4
	jmp	short l_return
l_nextSquare:
	lfs	bx, [bp+sqP]
	and	byte ptr fs:[bx+4], 0FBh
l_return:
	pop	si

	mov	sp, bp
	pop	bp
	retf
dun_revealSpSquare endp

; Attributes: bp-based frame

sp_geomancerSpell proc far

	row= word ptr -8
	var_6= word ptr	-6
	geoSpellNumber= word ptr	-4
	column=	word ptr -2
	spellIndexNumber= word ptr	 8

	push	bp
	mov	bp, sp
	mov	ax, 8
	call	someStackOperation

	cmp	inDungeonMaybe, 0
	jz	short l_return
	mov	bx, [bp+spellIndexNumber]
	mov	al, spellEffectFlags[bx]
	sub	ah, ah
	mov	[bp+var_6], ax
	sar	ax, 1
	mov	[bp+geoSpellNumber], ax
	mov	[bp+row], 0
	jmp	short loc_223DB
loc_223D8:
	inc	[bp+row]
loc_223DB:
	mov	al, g_dunHeight
	sub	ah, ah
	cmp	ax, [bp+row]
	jbe	short l_return
	mov	[bp+column], 0
	jmp	short loc_223F4
loc_223F1:
	inc	[bp+column]
loc_223F4:
	mov	al, g_dunWidth
	sub	ah, ah
	cmp	ax, [bp+column]
	jbe	short loc_2241C
	push	[bp+var_6]
	push	[bp+column]
	push	[bp+row]
	mov	bx, [bp+geoSpellNumber]
	shl	bx, 1
	shl	bx, 1
	call	geoSpList[bx]
	add	sp, 6
	jmp	short loc_223F1
loc_2241C:
	jmp	short loc_223D8

l_return:
	mov	sp, bp
	pop	bp
	retf
sp_geomancerSpell endp


; Attributes: bp-based frame

_sp_useLightObj	proc far

	spellCaster= word ptr	 6
	spellIndexNumber= word ptr	 8

	push	bp
	mov	bp, sp

	mov	ax, offset s_makesLight
	push	ds
	push	ax
	call	printString
	add	sp, 4
	push	[bp+spellIndexNumber]
	push	[bp+spellCaster]
	call	sp_lightSpell
	add	sp, 4

	mov	sp, bp
	pop	bp
	retf
_sp_useLightObj	endp

; Attributes: bp-based frame

_sp_useAcorn proc far

	spellCaster= byte ptr	 6

	push	bp
	mov	bp, sp

	mov	ax, offset s_ateIt
	push	ds
	push	ax
	call	printString
	add	sp, 4
	mov	al, [bp+spellCaster]
	mov	gs:bat_curTarget, al
	mov	ax, 94h	
	push	ax
	push	word ptr [bp+spellCaster]
	call	_batchSpellCast
	add	sp, 4
	mov	sp, bp
	pop	bp
	retf
_sp_useAcorn endp


; Attributes: bp-based frame

; DWORD - var_102 & var_104

_sp_useWineskin	proc far

	var_106= word ptr -106h
	var_104= word ptr -104h
	var_102= word ptr -102h
	var_100= word ptr -100h
	spellCaster= word ptr	 6

	push	bp
	mov	bp, sp
	mov	ax, 106h
	call	someStackOperation
	push	si

	mov	ax, charSize
	imul	[bp+spellCaster]
	mov	bx, ax
	mov	al, gs:g_usedItemSlotNumber
	sub	ah, ah
	add	bx, ax
	mov	al, gs:party.inventory.itemFlags[bx]
	shr	ax, 1
	shr	ax, 1
	and	ax, 7
	mov	[bp+var_106], ax
	mov	ax, offset s_drinksAndFeels
	push	ds
	push	ax
	lea	ax, [bp+var_100]
	push	ss
	push	ax
	call	strcat
	add	sp, 8
	mov	[bp+var_104], ax
	mov	[bp+var_102], dx
	mov	bx, [bp+var_106]
	shl	bx, 1
	shl	bx, 1
	push	word ptr (drinkStringList+2)[bx]
	push	word ptr drinkStringList[bx]
	push	dx
	push	ax
	call	strcat
	add	sp, 8
	mov	[bp+var_104], ax
	mov	[bp+var_102], dx
	lea	ax, [bp+var_100]
	push	ss
	push	ax
	call	printString
	add	sp, 4
	cmp	[bp+var_106], 1
	jnz	short loc_2252F

	mov	ax, charSize
	imul	[bp+spellCaster]
	mov	si, ax
	cmp	gs:party.class[si], class_bard
	jnz	short loc_2252F
	push	gs:party.level[si]
	push	cs
	call	near ptr lib_maxFF
	add	sp, 2
	mov	gs:party.specAbil[si],	al
	jmp	short l_return
loc_2252F:
	mov	al, byte ptr [bp+spellCaster]
	mov	gs:bat_curTarget, al
	mov	ax, 94h	
	push	ax
	push	[bp+spellCaster]
	push	cs
	call	near ptr _batchSpellCast
	add	sp, 4
l_return:
	pop	si
	mov	sp, bp
	pop	bp
	retf
_sp_useWineskin	endp

; Attributes: bp-based frame

printCantFindUse proc far
	push	bp
	mov	bp, sp

	mov	ax, offset s_cantFindUse
	push	ds
	push	ax
	call	printString
	add	sp, 4

	mov	sp, bp
	pop	bp
	retf
printCantFindUse endp


; Attributes: bp-based frame

; UNUSED - var_2 & var_4

_sp_useWeapon proc far

	var_10=	word ptr -10h
	var_E= byte ptr	-0Eh
	var_D= byte ptr	-0Dh
	var_C= byte ptr	-0Ch
	var_B= byte ptr	-0Bh
	var_A= byte ptr	-0Ah
	var_9= byte ptr	-9
	var_8= byte ptr	-8
	var_6= word ptr	-6
	var_4= word ptr	-4
	var_2= word ptr	-2
	spellCaster=	word ptr  6

	push	bp
	mov	bp, sp
	mov	ax, 10h
	call	someStackOperation
	push	di
	push	si

	mov	ax, charSize
	imul	[bp+spellCaster]
	mov	bx, ax
	mov	al, gs:g_usedItemSlotNumber
	sub	ah, ah
	add	bx, ax
	mov	al, gs:party.inventory.itemNo[bx]
	mov	[bp+var_6], ax
	mov	[bp+var_10], 31
	jmp	short loc_2259F
loc_2259C:
	dec	[bp+var_10]
loc_2259F:
	cmp	[bp+var_10], 0
	jge	short loc_225A8
	jmp	loc_22632
loc_225A8:
	mov	bx, [bp+var_10]
	mov	al, byte_48382[bx]
	sub	ah, ah
	cmp	ax, [bp+var_6]
	jnz	short loc_2262F
	cmp	bx, 17h
	jge	short loc_225C0
	mov	ax, offset s_castsWeapon
	jmp	short loc_225C3
loc_225C0:
	mov	ax, offset s_breathes
loc_225C3:
	mov	[bp+var_4], ax
	mov	[bp+var_2], ds
	push	ds
	push	ax
	call	printString
	add	sp, 4
	mov	ax, [bp+var_10]
	mov	cx, ax
	shl	ax, 1
	add	ax, cx
	shl	ax, 1
	mov	si, ax
	mov	al, byte ptr weaponDamageList.effectStrIndex[si]
	mov	[bp+var_E], al
	mov	al, weaponDamageList.elements[si]
	mov	[bp+var_D], al
	mov	[bp+var_C], 10h
	mov	[bp+var_B], 0
	mov	al, weaponDamageList.repelFlags[si]
	mov	[bp+var_A], al
	mov	al, weaponDamageList.damage[si]
	mov	[bp+var_9], al
	mov	al, weaponDamageList.targetFlags[si]
	mov	[bp+var_8], al
	mov	al, weaponDamageList.levelMult[si]
	sub	ah, ah
	push	ax
	sub	sp, 8
	push	si
	lea	si, [bp+var_E]
	mov	di, sp
	add	di, 2
	push	ss
	pop	es
	assume es:nothing
	movsw
	movsw
	movsw
	movsb
	pop	si
	push	[bp+spellCaster]
	push	cs
	call	near ptr bat_doBreathAttack
	add	sp, 0Ch
loc_2262F:
	jmp	loc_2259C
loc_22632:
	pop	si
	pop	di
	mov	sp, bp
	pop	bp
	retf
_sp_useWeapon endp

; Attributes: bp-based frame
_sp_reenergizeMage proc	far

	spellCaster= word ptr	 6

	push	bp
	mov	bp, sp
	push	si

	mov	ax, charSize
	imul	[bp+spellCaster]
	mov	si, ax
	mov	ax, gs:party.maxSppt[si]
	mov	gs:party.currentSppt[si], ax
	mov	ax, offset s_isReenergized
	push	ds
	push	ax
	call	printString
	add	sp, 4

	pop	si
	mov	sp, bp
	pop	bp
	retf
_sp_reenergizeMage endp

; Attributes: bp-based frame

_sp_useFigurine	proc far

	loopCounter= word ptr -4
	itemNo=	word ptr -2
	spellCaster=	word ptr  6

	push	bp
	mov	bp, sp
	mov	ax, 4
	call	someStackOperation

	mov	ax, offset s_invokesFigurine
	push	ds
	push	ax
	call	printString
	add	sp, 4
	mov	ax, charSize
	imul	[bp+spellCaster]
	mov	bx, ax
	mov	al, gs:g_usedItemSlotNumber
	sub	ah, ah
	add	bx, ax
	mov	al, gs:party.inventory.itemNo[bx]
	mov	[bp+itemNo], ax

	mov	[bp+loopCounter], 8
l_loopEnter:
	mov	bx, [bp+loopCounter]
	mov	al, figurineItemNo[bx]
	sub	ah, ah
	cmp	ax, [bp+itemNo]
	jnz	short l_loopNext
	mov	al, byte_483AC[bx]
	push	ax
	push	[bp+spellCaster]
	call	summon_execute
	add	sp, 4

l_loopNext:
	dec	[bp+loopCounter]
	cmp	[bp+loopCounter], 0
	jge	l_loopEnter

	mov	sp, bp
	pop	bp
	retf
_sp_useFigurine	endp

; Attributes: bp-based frame

rnd_Xd4	proc far

	rval= word ptr -2
	numOfDice= word	ptr  6

	push	bp
	mov	bp, sp
	mov	ax, 2
	call	someStackOperation

	mov	[bp+rval], 0
l_loopEnter:
	call	random
	and	ax, 3
	inc	ax
	add	[bp+rval], ax
	dec	[bp+numOfDice]
	cmp	[bp+numOfDice],	0
	jg	short l_loopEnter
	mov	ax, [bp+rval]

	mov	sp, bp
	pop	bp
	retf
rnd_Xd4	endp

; Attributes: bp-based frame
bat_isPartyInRange proc	far

	var_8= word ptr	-8
	var_6= word ptr	-6
	var_4= word ptr	-4
	var_2= word ptr	-2
	source=	word ptr  6
	range= word ptr  8

	push	bp
	mov	bp, sp
	mov	ax, 8
	call	someStackOperation

	; Return success if party attack
	cmp	gs:bat_curTarget, 80h
	jnb	short l_notPartyAttack
	cmp	[bp+source], 80h
	jl	l_returnOne

l_notPartyAttack:
	test	byte ptr [bp+range], 80h
	jz	short loc_22744
	mov	ax, [bp+range]
	and	ax, 7Fh
	mov	[bp+var_8], ax
	shl	ax, 1
	mov	[bp+var_2], ax
	jmp	short loc_2274F
loc_22744:
	mov	ax, [bp+range]
	mov	[bp+var_8], ax
	mov	[bp+var_2], 0

loc_2274F:
	cmp	gs:bat_curTarget, 80h
	jb	short l_monSource
	mov	al, gs:bat_curTarget
	sub	ah, ah
	jmp	short l_checkDistance
l_monSource:
	mov	ax, [bp+source]
l_checkDistance:
	mov	[bp+var_6], ax
	and	ax, 3
	mov	cx, monStruSize
	imul	cx
	mov	bx, ax
	mov	al, gs:monGroups.distance[bx]
	sub	ah, ah
	and	ax, 0Fh
	mov	[bp+var_4], ax
	mov	ax, [bp+var_8]
	cmp	[bp+var_4], ax
	jle	l_returnOne

	mov	ax, [bp+var_2]
	cmp	[bp+var_4], ax
	jg	short loc_returnZero
	mov	ax, 2
	jmp	short l_return 
loc_returnZero:
	sub	ax, ax
	jmp	l_return
l_returnOne:
	mov	ax, 1
l_return:
	mov	sp, bp
	pop	bp
	retf
bat_isPartyInRange endp

; Attributes: bp-based frame
spell_cast proc	far

	partySlotNumber=	word ptr  6
	spellNo= word ptr  8
	itemUsedFlag= word ptr	 0Ah

	push	bp
	mov	bp, sp

	cmp	[bp+itemUsedFlag], 0
	jnz	short l_notMapSpell

	; Spell is from an item. Pass the spell through vm_execute to
	; see if it triggers a map function.
	mov	ax, [bp+spellNo]
	mov	g_curSpellNumber, ax
	mov	ax, 1
	push	ax
	push	gs:mapDataSeg
	push	gs:mapDataOff
	call	vm_execute
	add	sp, 6
	or	ax, ax
	jnz	l_return

l_notMapSpell:
	cmp	[bp+itemUsedFlag], 0
	jz	short l_combatCheck

	; I think this checks for spells that shouldn't be able
	; to be cast from items
	mov	bx, [bp+spellNo]
	test	spellCastFlags[bx], spellcast_spellOnly
	jz	l_returnZero
	jmp	short l_callSpellFunction

l_combatCheck:
	mov	bx, [bp+spellNo]
	test	spellCastFlags[bx], spellcast_combatOnly
	jz	l_returnZero

l_callSpellFunction:
	push	[bp+spellNo]
	push	[bp+partySlotNumber]
	mov	bx, [bp+spellNo]
	shl	bx, 1
	shl	bx, 1
	call	spellFuncList[bx]
	add	sp, 4
	jmp	l_return

l_returnZero:
	sub	ax, ax

l_return:
	mov	sp, bp
	pop	bp
	retf
spell_cast endp

; Attributes: bp-based frame

; byte_4EEC3 and byte_4EEC4 don't seem to be
; used for anything.

_batchSpellCast proc far

	spellCaster= word ptr	 6
	spellIndexNumber= word ptr	 8

	push	bp
	mov	bp, sp

	and	[bp+spellIndexNumber], 7Fh
	push	[bp+spellIndexNumber]
	push	[bp+spellCaster]
	mov	bx, [bp+spellIndexNumber]
	shl	bx, 1
	shl	bx, 1
	call	spellFuncList[bx]
	add	sp, 4
	mov	sp, bp
	pop	bp
	retf
_batchSpellCast endp


; Attributes: bp-based frame

_sp_checkSPPT proc far

	requiredSppt= word ptr	-2
	spellCaster= word ptr	 6
	spellIndexNumber= word ptr	 8

	push	bp
	mov	bp, sp
	mov	ax, 2
	call	someStackOperation

	cmp	[bp+spellCaster], 80h
	jge	short l_returnOne

	push	[bp+spellIndexNumber]
	push	[bp+spellCaster]
	push	cs
	call	near ptr getSpptRequired
	add	sp, 4
	mov	[bp+requiredSppt], ax
	mov	cx, ax
	mov	ax, charSize
	imul	[bp+spellCaster]
	mov	bx, ax
	cmp	gs:party.currentSppt[bx], cx
	jb	short l_returnZero

	mov	ax, [bp+requiredSppt]
	mov	cx, ax
	mov	ax, charSize
	imul	[bp+spellCaster]
	mov	bx, ax
	sub	gs:party.currentSppt[bx], cx
l_returnOne:
	mov	ax, 1
	jmp	short l_return
l_returnZero:
	sub	ax, ax
l_return:
	mov	sp, bp
	pop	bp
	retf
_sp_checkSPPT endp

; Attributes: bp-based frame

strcatTargetName proc far

	monName=	word ptr -10h
	destString= dword ptr  6
	targetIndexNumber= word ptr	 0Ah
	targetCount= word ptr	 0Ch

	push	bp
	mov	bp, sp
	mov	ax, 10h
	call	someStackOperation

	cmp	[bp+targetIndexNumber], 80h
	jge	short l_monTarget
	mov	ax, charSize
	imul	[bp+targetIndexNumber]
	mov	bx, ax
	lea	ax, party._name[bx]
	mov	dx, seg	seg027
	push	dx
	push	ax
	push	word ptr [bp+destString+2]
	push	word ptr [bp+destString]
	call	strcat
	add	sp, 8
	mov	word ptr [bp+destString], ax
	mov	word ptr [bp+destString+2], dx
	jmp	l_return

l_monTarget:
	and	[bp+targetIndexNumber], 3
	lea	ax, [bp+monName]
	push	ss
	push	ax
	mov	ax, monStruSize
	imul	[bp+targetIndexNumber]
	mov	bx, ax
	lea	ax, monGroups._name[bx]
	mov	dx, seg	seg027
	push	dx
	push	ax
	call	unmaskString
	add	sp, 8

	cmp	[bp+targetCount], 0
	jz	short l_monSingular
	mov	ax, offset s_some
	push	ds
	push	ax
	call	strcat
	add	sp, 8
	mov	word ptr [bp+destString], ax
	mov	word ptr [bp+destString+2], dx
	jmp	short l_pluralize

l_monSingular:
	lfs	bx, dword ptr [bp+destString]
	inc	word ptr [bp+destString]
	mov	byte ptr fs:[bx], 'a'
	mov	al, byte ptr [bp+monName]
	cbw
	push	ax
	call	str_startsWithVowel
	add	sp, 2
	or	ax, ax
	jz	short l_appendSpace
	lfs	bx, dword ptr [bp+destString]
	inc	word ptr [bp+destString]
	mov	byte ptr fs:[bx], 'n'

l_appendSpace:
	lfs	bx, dword ptr [bp+destString]
	inc	word ptr [bp+destString]
	mov	byte ptr fs:[bx], ' '

l_pluralize:
	push	[bp+targetCount]
	push	word ptr [bp+destString+2]
	push	word ptr [bp+destString]
	lea	ax, [bp+monName]
	push	ss
	push	ax
	call	str_pluralize
	add	sp, 0Ah
	mov	word ptr [bp+destString], ax
	mov	word ptr [bp+destString+2], dx
l_return:
	mov	ax, word ptr [bp+destString]
	mov	dx, word ptr [bp+destString+2]

	mov	sp, bp
	pop	bp
	retf
strcatTargetName endp


seg010 ends

; Segment type: Pure code
seg011 segment word public 'CODE' use16
        assume cs:seg011
;org 1
        assume es:nothing, ss:nothing, ds:dseg, fs:nothing, gs:seg027
algn_229C1:
align 2

; Attributes: bp-based frame

song_singNonCombat	proc far

	partySlotNumber= word ptr	-6
	subtractor= word ptr	-4
	songNumber= word ptr	-2

	push	bp
	mov	bp, sp
	mov	ax, 6
	call	someStackOperation

	call	text_clear
	mov	ax, offset s_whoWillPlay
	push	ds
	push	ax
	call	printString
	add	sp, 4

	call	readSlotNumber
	mov	[bp+partySlotNumber], ax
	or	ax, ax
	jl	short l_return

	push	ax
	push	cs
	call	near ptr sing_getSongSubtractor
	add	sp, 2
	mov	[bp+subtractor], ax

	push	[bp+partySlotNumber]
	push	cs
	call	near ptr _canSingSong
	add	sp, 2
	or	ax, ax
	jz	short l_waitAndReturn

	cmp	[bp+subtractor], 0
	jl	short l_waitAndReturn

	call	text_clear
	sub	ax, ax
	push	ax
	push	[bp+partySlotNumber]
	push	cs
	call	near ptr song_getSong
	add	sp, 4
	mov	[bp+songNumber], ax
	or	ax, ax
	jl	short l_waitAndReturn

	; End currently playing song
	push	cs
	call	near ptr endNoncombatSong

	push	[bp+songNumber]
	push	[bp+partySlotNumber]
	push	cs
	call	near ptr song_playSong
	add	sp, 4

	push	cs
	call	near ptr song_doNoncombatEffect
	mov	al, byte ptr [bp+subtractor]
	mov	cx, ax
	mov	ax, charSize
	imul	[bp+partySlotNumber]
	mov	bx, ax
	sub	gs:party.specAbil[bx],	cl
l_waitAndReturn:
	mov	ax, 4000h
	push	ax
	call	getKey
	add	sp, 2
l_return:
	call	text_clear
	mov	sp, bp
	pop	bp
	retf
song_singNonCombat	endp

; Attributes: bp-based frame

_canSingSong proc far

	partySlotNumber=	word ptr  6

	push	bp
	mov	bp, sp

	mov	ax, charSize
	imul	[bp+partySlotNumber]
	mov	bx, ax
	test	gs:party.status[bx], stat_dead	or stat_stoned or stat_paralyzed
	jnz	short l_returnZero

	mov	ax, charSize
	imul	[bp+partySlotNumber]
	mov	bx, ax
	cmp	gs:party.class[bx], class_bard
	jz	short l_checkInstrument
	mov	ax, offset s_notBard
	push	ds
	push	ax
	call	printStringWClear
	add	sp, 4
	jmp	short l_returnZero

l_checkInstrument:
	mov	ax, itType_instrument
	push	ax
	push	[bp+partySlotNumber]
	call	character_hasTypeEquipped
	add	sp, 4
	or	ax, ax
	jz	short l_noInstrument

	mov	ax, charSize
	imul	[bp+partySlotNumber]
	mov	bx, ax
	cmp	gs:party.specAbil[bx],	0
	jnz	l_returnOne
	mov	ax, offset s_dryThroat
	push	ds
	push	ax
	call	printStringWClear
	add	sp, 4
	jmp	short l_returnZero

l_noInstrument:
	mov	ax, offset s_notUsingInstrument
	push	ds
	push	ax
	call	printStringWClear
	add	sp, 4

l_returnZero:
	sub	ax, ax
	jmp	l_return

l_returnOne:
	mov	ax, 1

l_return:
	mov	sp, bp
	pop	bp
	retf
_canSingSong endp


; This function	returns	1 if the character is active,
; a bard and has an instrument equipped. 0 otherwise.
; Attributes: bp-based frame

_charCanPlaySong proc far

	partySlotNumber=	word ptr  6

	push	bp
	mov	bp, sp
	push	si

	mov	ax, charSize
	imul	[bp+partySlotNumber]
	mov	si, ax

	test	gs:party.status[si], stat_dead	or stat_stoned or stat_paralyzed
	jnz	short l_returnZero

	cmp	gs:party.class[si], class_bard
	jnz	short l_returnZero

	mov	ax, itType_instrument
	push	ax
	push	[bp+partySlotNumber]
	call	character_hasTypeEquipped
	add	sp, 4
	jmp	short l_return
l_returnZero:
	sub	ax, ax
l_return:
	pop	si
	mov	sp, bp
	pop	bp
	retf
_charCanPlaySong endp


; This function	returns	the amount of songs that
; should be subtracted from the	bards songsLeft
; field. If an item with itemEff_freeSinging is
; equipped, return 0. If the bard has songs left,
; return 1. Otherwise return -1.
; Attributes: bp-based frame

sing_getSongSubtractor proc far

	partySlotNumber= word ptr	 6

	push	bp
	mov	bp, sp

	mov	ax, itemEff_freeSinging
	push	ax
	push	[bp+partySlotNumber]
	call	character_isEffectEquipped
	add	sp, 4
	or	ax, ax
	jz	short l_returnZero

	mov	ax, charSize
	imul	[bp+partySlotNumber]
	mov	bx, ax
	cmp	gs:party.specAbil[bx],	0
	jz	short l_returnMinusOne
	mov	ax, 1
	jmp	short l_return

l_returnMinusOne:
	mov	ax, 0FFFFh
	jmp	short l_return

l_returnZero:
	sub	ax, ax

l_return:
	mov	sp, bp
	pop	bp
	retf
sing_getSongSubtractor endp

; Attributes: bp-based frame

song_getSong proc far

	var_22C= word ptr -22Ch
	var_72=	word ptr -72h
	songListString=	word ptr -34h
	counter= word ptr -1Ch
	songListStringP= dword ptr -1Ah
	var_16=	word ptr -16h
	var_14=	word ptr -14h
	var_12=	word ptr -12h
	optionLetters=	word ptr -10h
	partySlotNumber=	word ptr  6
	songPlayingFlag= word ptr	 8

	push	bp
	mov	bp, sp
	mov	ax, 34h
	call	someStackOperation
	push	si

	sub	ax, ax
	mov	[bp+var_12], ax
	mov	[bp+var_16], ax
	mov	[bp+counter], ax
l_loopEnter:
	mov	ax, charSize
	imul	[bp+partySlotNumber]
	mov	bx, ax
	mov	al, gs:(party.specAbil+1)[bx]
	sub	ah, ah
	mov	bx, [bp+counter]
	mov	cl, byteMaskList[bx]
	sub	ch, ch
	test	ax, cx
	jz	short l_next
	lea	ax, [bp+songListString]
	mov	word ptr [bp+songListStringP], ax
	mov	word ptr [bp+songListStringP+2], ss

	mov	si, [bp+var_16]
	shl	si, 1
	mov	ax, bx
	mov	[bp+si+optionLetters],	ax
	lfs	bx, [bp+songListStringP]
	inc	word ptr [bp+songListStringP]
	mov	ax, [bp+var_16]
	inc	[bp+var_16]
	add	al, '1'
	mov	fs:[bx], al

	lfs	bx, [bp+songListStringP]
	inc	word ptr [bp+songListStringP]
	mov	byte ptr fs:[bx], ')'
	mov	bx, [bp+counter]
	shl	bx, 1
	shl	bx, 1
	push	word ptr (songNames+2)[bx]
	push	word ptr songNames[bx]
	push	word ptr [bp+songListStringP+2]
	push	word ptr [bp+songListStringP]
	call	strcat
	add	sp, 8
	mov	word ptr [bp+songListStringP], ax
	mov	word ptr [bp+songListStringP+2], dx
	lea	ax, [bp+songListString]
	push	ss
	push	ax
	mov	bl, gs:txt_numLines
	sub	bh, bh
	shl	bx, 1
	mov	ax, bitMask16bit[bx]
	or	[bp+var_12], ax
l_next:
	inc	[bp+counter]
	cmp	[bp+counter], 8
	jge	l_loopEnter

	mov	ax, bitMask16bit+16h
	or	[bp+var_12], ax
	cmp	[bp+songPlayingFlag], 0
	jz	short l_getUserInput
	mov	ax, offset s_stopPlayingSong
	push	ds
	push	ax
	call	printString
	add	sp, 4
l_getUserInput:
	push	[bp+var_12]
	call	getKey
	add	sp, 2
	mov	[bp+var_14], ax
	cmp	ax, 1Bh
	jz	short loc_22C76
	cmp	ax, 119h
	jnz	short loc_22C7B
loc_22C76:
	mov	ax, 0FFFFh
	jmp	short l_return
loc_22C7B:
	cmp	[bp+songPlayingFlag], 0
	jz	short loc_22C96
	cmp	[bp+var_14], 'S'
	jnz	short loc_22C96
	push	[bp+partySlotNumber]
	push	cs
	call	near ptr song_stopPlaying
	add	sp, 2
	mov	ax, 0FFFFh
	jmp	short l_return
loc_22C96:
	cmp	[bp+var_14], 10Eh
	jl	short loc_22CB3
	mov	ax, [bp+var_16]
	add	ax, 10Eh
	cmp	ax, [bp+var_14]
	jl	short loc_22CB3
	mov	si, [bp+var_14]
	shl	si, 1
	mov	ax, [bp+si+var_22C]
	jmp	short l_return
loc_22CB3:
	cmp	[bp+var_14], '0'
	jle	short l_badInput
	mov	ax, [bp+var_16]
	add	ax, '0'
	cmp	ax, [bp+var_14]
	jl	short l_badInput
	mov	si, [bp+var_14]
	shl	si, 1
	mov	ax, [bp+si+var_72]
	jmp	short l_return
l_badInput:
	jmp	short l_getUserInput
l_return:
	pop	si
	mov	sp, bp
	pop	bp
	retf
song_getSong endp


; Attributes: bp-based frame

song_playSong proc far

	var_4= word ptr	-4
	var_2= word ptr	-2
	partySlotNumber= word ptr	 6
	songNumber= byte ptr	 8

	push	bp
	mov	bp, sp
	mov	ax, 4
	call	someStackOperation

	mov	al, byte ptr [bp+partySlotNumber]
	mov	gs:g_currentSinger, al
	mov	g_songDuration, 5
	mov	al, [bp+songNumber]
	inc	al
	mov	gs:g_currentSongPlusOne, al
	mov	al, [bp+songNumber]
	mov	gs:g_currentSong, al
	call	sound_stop

	mov	ax, offset byte_40420
	mov	dx, seg	seg026
	push	dx
	push	ax
	mov	bx, word ptr [bp+songNumber]
	shl	bx, 1
	shl	bx, 1
	push	gs:musicBufs._segment[bx]
	push	word ptr gs:musicBufs._offset[bx]
	call	d3cmp_flate
	add	sp, 8

	mov	ax, itType_instrument
	push	ax
	push	[bp+partySlotNumber]
	call	character_getTypeEquippedSlot
	add	sp, 4
	mov	[bp+var_4], ax
	inc	ax
	jz	short loc_22D59
	mov	bx, [bp+var_4]
	mov	al, g_instrumentType[bx]
	cbw
	mov	[bp+var_2], ax
	jmp	short loc_22D5E
loc_22D59:
	mov	[bp+var_2], 0
loc_22D5E:
	push	[bp+var_2]
	mov	ax, offset byte_40420
	mov	dx, seg	seg026
	push	dx
	push	ax
	call	sound_start
	add	sp, 6
	mov	sp, bp
	pop	bp
	retf
song_playSong endp


; Attributes: bp-based frame

song_stopPlaying proc far

	partySlotNumber= word ptr	 6

	push	bp
	mov	bp, sp

	mov	al, gs:g_currentSinger
	sub	ah, ah
	cmp	ax, [bp+partySlotNumber]
	jnz	short l_return			; Not the current singer
	cmp	gs:g_currentSongPlusOne, ah
	jz	short l_return			; No song playing
	push	cs
	call	near ptr endNoncombatSong
l_return:
	mov	sp, bp
	pop	bp
	retf
song_stopPlaying endp


; Attributes: bp-based frame

endNoncombatSong proc far
	push	bp
	mov	bp, sp

	push	cs
	call	near ptr song_endNoncombatEffect
	call	sound_stop
	mov	sp, bp
	pop	bp
	retf
endNoncombatSong endp


; Attributes: bp-based frame

song_doNoncombatEffect proc far
	push	bp
	mov	bp, sp

	mov	al, gs:g_currentSong
	sub	ah, ah
	jmp	l_songSwitch
l_safety:
	mov	gs:songAntiMonster, 1
	jmp	l_return
l_sanctuary:
	mov	al, charSize
	mul	gs:g_currentSinger
	mov	bx, ax
	cmp	gs:party.level[bx], 60
	jnb	short l_maxFifteen
	mov	al, charSize
	mul	gs:g_currentSinger
	mov	bx, ax
	mov	ax, gs:party.level[bx]
	shr	ax, 1
	shr	ax, 1
	jmp	short l_setBonus
l_maxFifteen:
	mov	al, 15
l_setBonus:
	mov	gs:g_songAcBonus,	al
	or	al, al
	jnz	short l_setBonusIfZero
	inc	gs:g_songAcBonus
l_setBonusIfZero:
	mov	byte ptr g_printPartyFlag,	0
	jmp	l_return
l_duotime:
	mov	gs:songRegenSppt, 1
	jmp	l_return
l_watchwood:
	mov	lightDistance, 5
	mov	lightDuration, 0FFh
	mov	gs:gl_detectSecretDoorFlag, 0FFh
	sub	ax, ax
	push	ax
	call	icon_activate
	add	sp, 2
	jmp	short l_return
l_overture:
	mov	compassDuration, 0FFh
	mov	ax, 1
	push	ax
	call	icon_activate
	add	sp, 2
	jmp	short l_return
l_shield:
	mov	gs:songHalfDamage, 1
	mov	shieldDuration, 0FFh
	mov	ax, 3
	push	ax
	call	icon_activate
	add	sp, 2
	jmp	short l_return
l_songSwitch:
	cmp	ax, song_safety
	jz	l_safety
	cmp	ax, song_sanctuary
	jz	l_sanctuary
	cmp	ax, song_duotime
	jz	l_duotime
	cmp	ax, song_watchwood
	jz	l_watchwood
	cmp	ax, song_overture
	jz	short l_overture
	cmp	ax, song_shield
	jz	short l_shield
l_return:
	mov	sp, bp
	pop	bp
	retf
song_doNoncombatEffect endp


; Attributes: bp-based frame

song_endNoncombatEffect	proc far
	push	bp
	mov	bp, sp

	cmp	gs:g_currentSongPlusOne, 0
	jz	l_return

	mov	gs:g_currentSongPlusOne, 0
	cmp	gs:g_currentSinger, 7
	jnb	l_return
loc_22F03:
	mov	al, gs:g_currentSong
	sub	ah, ah
	jmp	short l_songSwitch
l_safety:
	mov	gs:songAntiMonster, 0
	jmp	short l_return
l_sanctuary:
	mov	gs:g_songAcBonus,	0
	mov	byte ptr g_printPartyFlag,	0
	jmp	short l_return
l_duotime:
	mov	gs:songRegenSppt, 0
	jmp	short l_return
l_watchwood:
	mov	lightDistance, 0
	sub	ax, ax
	push	ax
	call	icon_deactivate
	add	sp, 2
	mov	gs:gl_detectSecretDoorFlag, 0
	jmp	short l_return
l_overture:
	mov	ax, 1
	push	ax
	call	icon_deactivate
	add	sp, 2
	jmp	short l_return
l_shield:
	mov	gs:songHalfDamage, 0
	jmp	short l_return
l_songSwitch:
	cmp	ax, song_safety
	jz	short l_safety
	cmp	ax, song_sanctuary
	jz	short l_sanctuary
	cmp	ax, song_duotime
	jz	short l_duotime
	cmp	ax, song_watchwood
	jz	short l_watchwood
	cmp	ax, song_overture
	jz	short l_overture
	cmp	ax, song_shield
	jz	short l_shield
l_return:
	mov	sp, bp
	pop	bp
	retf
song_endNoncombatEffect	endp



seg011 ends

; Segment type: Pure code
seg012 segment byte public 'CODE' use16
        assume cs:seg012
;org 0Eh
        assume es:nothing, ss:nothing, ds:dseg, fs:nothing, gs:seg027

; Attributes: bp-based frame
;
; This function sets the maximum value of the dword
; to 0xFFFF. The function is always called with the high
; word as 0 so this doesn't really have any use.

lib_maxFFFF proc	far

	value= dword ptr	 6

	push	bp
	mov	bp, sp
	cmp	word ptr [bp+value+2], 0
	jnz	short l_setToMax
	cmp	word ptr [bp+value], 0FFFFh
	jbe	short l_return
l_setToMax:
	mov	word ptr [bp+value], 0FFFFh
	mov	word ptr [bp+value+2], 0
l_return:
	mov	ax, word ptr [bp+value]
	mov	sp, bp
	pop	bp
	retf
lib_maxFFFF endp

; Attributes: bp-based frame

review_enter proc far

	loopCounter= word ptr	-6
	inKey= word ptr	-4
	getKeyMouseMask= word ptr	-2

	push	bp
	mov	bp, sp
	mov	ax, 6
	call	someStackOperation

loc_23001:
	and	byte_4EE71, 0FDh
	push	cs
	call	near ptr review_setTitle
	test	byte_4EE71, 2
	jnz	l_return

	push	cs
	call	near ptr review_quest
	test	byte_4EE71, 2
	jnz	short loc_23001

l_ioLoop:
	mov	ax, offset s_lastOfTheGuildElders
	push	ds
	push	ax
	call	printStringWClear
	add	sp, 4
	mov	[bp+getKeyMouseMask], 0

	mov	[bp+loopCounter], 0
l_loop:
	mov	bl, gs:txt_numLines
	sub	bh, bh
	sub	bx, [bp+loopCounter]
	shl	bx, 1
	mov	ax, bitMask16bit[bx]
	or	[bp+getKeyMouseMask], ax
	inc	[bp+loopCounter]
	cmp	[bp+loopCounter], 5
	jl	short l_loop

	push	[bp+getKeyMouseMask]
	call	getKey
	add	sp, 2
	mov	[bp+inKey], ax
	cmp	ax, 10Eh
	jl	short l_processKey
	cmp	ax, 119h
	jg	short l_processKey
	mov	al, gs:txt_numLines
	sub	ah, ah
	sub	ax, 4
	sub	[bp+inKey], ax

l_processKey:
	mov	ax, [bp+inKey]
	cmp	ax, 'T'
	jz	short l_speakToElder
	jg	short l_processMouseKey
	cmp	ax, 'A'
	jz	short l_checkXp
	cmp	ax, 'C'
	jz	short l_changeClass
	cmp	ax, 'S'
	jz	short l_learnSpells
	jmp	short l_checkExit

l_processMouseKey:
	cmp	ax, 10Eh
	jz	short l_checkXp
	cmp	ax, 10Fh
	jz	short l_learnSpells
	cmp	ax, 110h
	jz	short l_changeClass
	cmp	ax, 111h
	jz	short l_speakToElder

l_checkExit:
	cmp	[bp+inKey], 'E'
	jz	short l_return
	cmp	[bp+inKey], 112h
	jz	short l_return
	jmp	l_ioLoop

l_checkXp:
	sub	ax, ax
	push	ax
	push	cs
	call	near ptr review_checkXp
	add	sp, 2
	jmp	l_ioLoop

l_learnSpells:
	sub	ax, ax
	push	ax
	push	cs
	call	near ptr review_learnSpells
	add	sp, 2
	mov	byte ptr g_printPartyFlag,	0
	jmp	l_ioLoop

l_changeClass:
	push	cs
	call	near ptr review_changeMageClass
	jmp	l_ioLoop

l_speakToElder:
	push	cs
	call	near ptr review_speakToElder
	mov	byte ptr g_printPartyFlag,	0
	jmp	l_ioLoop

l_return:
	sub	ax, ax
	mov	sp, bp
	pop	bp
	retf
review_enter endp

; Attributes: bp-based frame
;
; DWORD var_2 & var_4, var_8 & var_A

review_checkXp proc far

	stringBuffer= word ptr -10Ah
	var_A= word ptr	-0Ah
	var_8= word ptr	-8
	slotNumber= word ptr	-6
	var_4= word ptr	-4
	var_2= word ptr	-2

	push	bp
	mov	bp, sp
	mov	ax, 10Ah
	call	someStackOperation

l_loop:
	mov	ax, offset s_elderWeighsMerits
	push	ds
	push	ax
	call	printStringWClear
	add	sp, 4
	call	readSlotNumber
	mov	[bp+slotNumber], ax
	or	ax, ax
	jl	l_return

	mov	ax, charSize
	imul	[bp+slotNumber]
	mov	bx, ax
	test	gs:party.status[bx], 0Ch
	jz	short l_ableMember
	mov	ax, offset s_elderDeadCharacter
	push	ds
	push	ax
	lea	ax, [bp+stringBuffer]
	push	ss
	push	ax
	call	strcat
	add	sp, 8
	mov	[bp+var_4], ax
	mov	[bp+var_2], dx
	jmp	l_printBuffer

l_ableMember:
	mov	ax, offset s_guildElderDeems
	push	ds
	push	ax
	lea	ax, [bp+stringBuffer]
	push	ss
	push	ax
	call	strcat
	add	sp, 8
	mov	[bp+var_4], ax
	mov	[bp+var_2], dx
	mov	ax, charSize
	imul	[bp+slotNumber]
	mov	bx, ax
	lea	ax, party._name[bx]
	mov	dx, seg	seg027
	push	dx
	push	ax
	push	[bp+var_2]
	push	[bp+var_4]
	call	strcat
	add	sp, 8
	mov	[bp+var_4], ax
	mov	[bp+var_2], dx
	mov	ax, charSize
	imul	[bp+slotNumber]
	mov	bx, ax
	cmp	gs:party.class[bx], class_monster
	jnz	short l_notMonster

	mov	ax, offset s_cannotBeRaised
	push	ds
	push	ax
	push	[bp+var_2]
	push	[bp+var_4]
	call	strcat
	add	sp, 8
	mov	[bp+var_4], ax
	mov	[bp+var_2], dx
	jmp	l_printBuffer

l_notMonster:
	push	[bp+slotNumber]
	push	cs
	call	near ptr review_getXpDelta
	add	sp, 2
	mov	[bp+var_A], ax
	mov	[bp+var_8], dx
	or	dx, dx
	jg	short l_notYet
	jl	short l_earnedLevel
	or	ax, ax
	jnz	short l_notYet

l_earnedLevel:
	mov	ax, offset s_hathEarnedLevel
	push	ds
	push	ax
	push	[bp+var_2]
	push	[bp+var_4]
	call	strcat
	add	sp, 8
	mov	[bp+var_4], ax
	mov	[bp+var_2], dx
	push	dx
	push	ax
	push	[bp+slotNumber]
	push	cs
	call	near ptr review_advance
	add	sp, 6
	mov	[bp+var_4], ax
	mov	[bp+var_2], dx
	jmp	short l_printBuffer

l_notYet:
	mov	ax, offset s_stillNeedeth
	push	ds
	push	ax
	push	[bp+var_2]
	push	[bp+var_4]
	call	strcat
	add	sp, 8
	mov	[bp+var_4], ax
	mov	[bp+var_2], dx
	sub	ax, ax
	push	ax
	push	[bp+var_8]
	push	[bp+var_A]
	push	dx
	push	[bp+var_4]
	call	itoa
	add	sp, 0Ah
	mov	[bp+var_4], ax
	mov	[bp+var_2], dx
	mov	ax, offset s_experiencePoints
	push	ds
	push	ax
	push	dx
	push	[bp+var_4]
	call	strcat
	add	sp, 8
	mov	[bp+var_4], ax
	mov	[bp+var_2], dx

l_printBuffer:
	lea	ax, [bp+stringBuffer]
	push	ss
	push	ax
	call	printString
	add	sp, 4
	mov	byte ptr g_printPartyFlag,	0
	mov	ax, 4000h
	push	ax
	call	getKey
	add	sp, 2
	jmp	l_loop

l_return:
	mov	sp, bp
	pop	bp
	retf
review_checkXp endp

; Attributes: bp-based frame

review_advance proc far

	var_C= dword ptr -0Ch
	ageStatusFlag= word ptr	-8
	attributeIndex= word ptr	-6
	hpBonus= word ptr	-4
	bonusVar= word ptr	-2
	charNo=	word ptr  6
	arg_2= word ptr	 8
	arg_4= word ptr	 0Ah

	push	bp
	mov	bp, sp
	mov	ax, 0Ch
	call	someStackOperation
	push	si

	mov	ax, charSize
	imul	[bp+charNo]
	mov	si, ax
	inc	gs:party.maxLevel[si]
	mov	ax, gs:party.maxLevel[si]
	mov	gs:party.level[si], ax
	push	[bp+charNo]
	push	cs
	call	near ptr review_removeAgeStatus
	add	sp, 2
	mov	[bp+ageStatusFlag], ax
	mov	ax, charSize
	imul	[bp+charNo]
	mov	si, ax
	call	random
	mov	cx, ax
	mov	ax, charSize
	imul	[bp+charNo]
	mov	bx, ax
	mov	bl, gs:party.class[bx]
	sub	bh, bh
	mov	al, hpLevelBonusMask[bx]
	sub	ah, ah
	and	ax, cx
	mov	cl, gs:party.constitution[si]
	sub	ch, ch
	shr	cx, 1
	shr	cx, 1
	add	ax, cx
	mov	[bp+hpBonus], ax
	mov	ax, gs:party.currentHP[si]
	add	ax, [bp+hpBonus]
	sub	cx, cx
	push	cx
	push	ax
	push	cs
	call	near ptr lib_maxFFFF
	add	sp, 4
	mov	gs:party.currentHP[si], ax
	mov	ax, charSize
	imul	[bp+charNo]
	mov	bx, ax
	mov	ax, gs:party.maxHP[bx]
	add	ax, [bp+hpBonus]
	sub	cx, cx
	push	cx
	push	ax
	push	cs
	call	near ptr lib_maxFFFF
	add	sp, 4
	mov	cx, ax
	mov	ax, charSize
	imul	[bp+charNo]
	mov	bx, ax
	mov	gs:party.maxHP[bx], cx
	mov	ax, charSize
	imul	[bp+charNo]
	mov	bx, ax
	mov	al, gs:party.class[bx]
	sub	ah, ah

	or	ax, ax
	jz	fighterLevelUp
	cmp	ax, class_rogue
	jz	rogueLevelUp
	cmp	ax, class_bard
	jz	bardLevelUp
	cmp	ax, class_paladin
	jz	fighterLevelUp
	cmp	ax, class_hunter
	jz	hunterLevelUp
	cmp	ax, class_monk
	jz	fighterLevelUp
	jmp	mageLevelUp

fighterLevelUp:
	mov	ax, charSize
	imul	[bp+charNo]
	mov	si, ax
	mov	ax, gs:party.level[si]
	dec	ax
	shr	ax, 1
	shr	ax, 1
	mov	[bp+bonusVar], ax
	cmp	ax, 8
	jge	short l_setMaxAttacks
	mov	al, byte ptr [bp+bonusVar]
	jmp	short l_setAttackCount
l_setMaxAttacks:
	mov	al, 7
l_setAttackCount:
	mov	gs:party.numAttacks[si], al
	jmp	l_increaseRandomAttribute

rogueLevelUp:
	call	random_1d8
	mov	cx, ax
	mov	ax, charSize
	imul	[bp+charNo]
	mov	bx, ax
	mov	al, gs:party.dexterity[bx]
	sub	ah, ah
	mov	dx, cx
	mov	cl, 3
	shr	ax, cl
	add	ax, dx
	mov	[bp+bonusVar], ax
	mov	ax, charSize
	imul	[bp+charNo]
	mov	bx, ax
	mov	al, gs:party.specAbil[bx]
	sub	ah, ah
	add	ax, [bp+bonusVar]
	push	ax
	call	lib_maxFF
	add	sp, 2
	mov	cx, ax
	mov	ax, charSize
	imul	[bp+charNo]
	mov	bx, ax
	mov	gs:party.specAbil[bx],	cl

	; Adding random_1d8 to bonusVar looks wrong. Doing it this way,
	; specAbil+1 gets bonusVar+1d8 and specAbil+2 gets bonusVar+1d8+1d8.
	call	random_1d8
	add	[bp+bonusVar], ax
	mov	ax, charSize
	imul	[bp+charNo]
	mov	bx, ax
	mov	al, gs:(party.specAbil+1)[bx]
	sub	ah, ah
	add	ax, [bp+bonusVar]
	push	ax
	call	lib_maxFF
	add	sp, 2
	mov	cx, ax
	mov	ax, charSize
	imul	[bp+charNo]
	mov	bx, ax
	mov	gs:(party.specAbil+1)[bx], cl

	call	random_1d8
	add	[bp+bonusVar], ax
	mov	ax, charSize
	imul	[bp+charNo]
	mov	bx, ax
	mov	al, gs:(party.specAbil+2)[bx]
	sub	ah, ah
	add	ax, [bp+bonusVar]
	push	ax
	call	lib_maxFF
	add	sp, 2
	mov	cx, ax
	mov	ax, charSize
	imul	[bp+charNo]
	mov	bx, ax
	mov	gs:(party.specAbil+2)[bx], cl

	jmp	l_increaseRandomAttribute

bardLevelUp:
	mov	ax, charSize
	imul	[bp+charNo]
	mov	si, ax
	push	gs:party.level[si]
	call	lib_maxFF
	add	sp, 2
	mov	gs:party.specAbil[si],	al
	jmp	l_increaseRandomAttribute

hunterLevelUp:
	call	random_1d8
	mov	cx, ax
	mov	ax, charSize
	imul	[bp+charNo]
	mov	bx, ax
	mov	al, gs:party.dexterity[bx]
	sub	ah, ah
	mov	dx, cx
	mov	cl, 3
	shr	ax, cl
	add	ax, dx
	mov	[bp+bonusVar], ax
	mov	ax, charSize
	imul	[bp+charNo]
	mov	bx, ax
	mov	al, gs:party.specAbil[bx]
	sub	ah, ah
	add	ax, [bp+bonusVar]
	push	ax
	call	lib_maxFF
	add	sp, 2
	mov	cx, ax
	mov	ax, charSize
	imul	[bp+charNo]
	mov	bx, ax
	mov	gs:party.specAbil[bx],	cl
	jmp	l_increaseRandomAttribute

mageLevelUp:
	call	random
	and	ax, 3
	mov	cx, ax
	mov	ax, charSize
	imul	[bp+charNo]
	mov	bx, ax
	mov	al, gs:party.intelligence[bx]
	sub	ah, ah
	shr	ax, 1
	shr	ax, 1
	add	ax, cx
	inc	ax
	mov	[bp+bonusVar], ax
	mov	ax, charSize
	imul	[bp+charNo]
	mov	bx, ax
	mov	ax, gs:party.currentSppt[bx]
	add	ax, [bp+bonusVar]
	sub	cx, cx
	push	cx
	push	ax
	push	cs
	call	near ptr lib_maxFFFF
	add	sp, 4
	mov	cx, ax
	mov	ax, charSize
	imul	[bp+charNo]
	mov	bx, ax
	mov	gs:party.currentSppt[bx], cx
	mov	ax, charSize
	imul	[bp+charNo]
	mov	bx, ax
	mov	ax, gs:party.maxSppt[bx]
	add	ax, [bp+bonusVar]
	sub	cx, cx
	push	cx
	push	ax
	push	cs
	call	near ptr lib_maxFFFF
	add	sp, 4
	mov	cx, ax
	mov	ax, charSize
	imul	[bp+charNo]
	mov	bx, ax
	mov	gs:party.maxSppt[bx], cx
	jmp	short l_increaseRandomAttribute

l_increaseRandomAttribute:
	mov	ax, 4
	push	ax
	sub	ax, ax
	push	ax
	call	randomBetweenXandY
	add	sp, 4
	mov	[bp+attributeIndex], ax
	mov	ax, charSize
	imul	[bp+charNo]
	mov	bx, ax
	add	ax, offset party.strength
	mov	word ptr [bp+var_C], ax
	mov	word ptr [bp+var_C+2], seg seg027

; This section looks for an attribute under 30 to increase. It is possible
; to not increase an attribute when levelling up since the attribute search
; starts at a random attribute and doesn't wrap. 
;
l_findAttributeToIncrease:
	cmp	[bp+attributeIndex], 5
	jge	short l_restoreAgeStatus
	mov	bx, [bp+attributeIndex]
	lfs	si, [bp+var_C]
	cmp	byte ptr fs:[bx+si], 30
	jl	short l_printIncreasedAttribute
	mov	byte ptr fs:[bx+si], 30
	inc	[bp+attributeIndex]
	jmp	short l_findAttributeToIncrease

l_printIncreasedAttribute:
	mov	bx, [bp+attributeIndex]
	lfs	si, [bp+var_C]
	inc	byte ptr fs:[bx+si]
	mov	ax, offset s_plusOneTo
	push	ds
	push	ax
	push	[bp+arg_4]
	push	[bp+arg_2]
	call	strcat
	add	sp, 8
	mov	[bp+arg_2], ax
	mov	[bp+arg_4], dx
	mov	bx, [bp+attributeIndex]
	shl	bx, 1
	shl	bx, 1
	push	word ptr (fullAttributeString+2)[bx]
	push	word ptr fullAttributeString[bx]
	push	dx
	push	ax
	call	strcat
	add	sp, 8
	mov	[bp+arg_2], ax
	mov	[bp+arg_4], dx
	jmp	short l_restoreAgeStatus

l_restoreAgeStatus:
	cmp	[bp+ageStatusFlag], 0
	jz	short l_return
	push	[bp+charNo]
	call	review_resetAgeStatus
	add	sp, 2

l_return:
	mov	ax, [bp+arg_2]
	mov	dx, [bp+arg_4]
	pop	si
	mov	sp, bp
	pop	bp
	retf
review_advance endp

; This function	returns	the difference between the
; players experience points and the requirements
; for the next level.
; Attributes: bp-based frame

review_getXpDelta proc far

	slotNumber= word ptr  6

	push	bp
	mov	bp, sp
	push	si

	mov	ax, charSize
	imul	[bp+slotNumber]
	mov	bx, ax
	mov	ax, gs:party.maxLevel[bx]
	or	ax, ax
	jz	short l_levelZero
	dec	ax
	push	ax
	push	[bp+slotNumber]
	call	getLevelXp
	add	sp, 4
	mov	cx, ax
	mov	bx, dx
	mov	ax, charSize
	imul	[bp+slotNumber]
	mov	si, ax
	mov	ax, cx
	mov	dx, bx
	sub	ax, word ptr gs:party.experience[si]
	sbb	dx, word ptr gs:(party.experience+2)[si]
	jmp	short l_return

l_levelZero:
	mov	ax, charSize
	imul	[bp+slotNumber]
	mov	bx, ax
	mov	ax, word ptr gs:party.experience[bx]
	mov	dx, word ptr gs:(party.experience+2)[bx]
	neg	ax
	adc	dx, 0
	neg	dx

l_return:
	pop	si
	mov	sp, bp
	pop	bp
	retf
review_getXpDelta endp

; Attributes: bp-based frame

review_learnSpells	proc far

	stringBuffer= word ptr -10Eh
	payeeSlotNumber= word ptr	-0Eh
	spellBase= word	ptr -0Ch
	loopCounter= word ptr -0Ah
	levelCost= word ptr	-8
	stringBufferP= dword ptr -6
	slotNumber=	word ptr -2

	push	bp
	mov	bp, sp
	mov	ax, 10Eh
	call	someStackOperation
	push	si

	mov	ax, offset s_whoSeeksKnowledge
	push	ds
	push	ax
	call	printStringWClear
	add	sp, 4
	call	readSlotNumber
	mov	[bp+slotNumber], ax
	or	ax, ax
	jl	l_return

	mov	ax, charSize
	imul	[bp+slotNumber]
	mov	bx, ax
	mov	bl, gs:party.class[bx]
	sub	bh, bh
	mov	al, mageSpellIndex[bx]
	sub	ah, ah
	mov	[bp+spellBase],	ax
	cmp	ax, 0FFh
	jnz	short l_isSpellcaster
	mov	ax, offset s_thouArtNotASpellcaster
	push	ds
	push	ax
	call	printStringWithWait
	add	sp, 4
	jmp	l_return

l_isSpellcaster:
	mov	[bp+loopCounter], 0

l_searchSpellLevelsLoop:
	push	[bp+spellBase]
	push	[bp+loopCounter]
	push	[bp+slotNumber]
	push	cs
	call	near ptr character_learnedSpellLevel
	add	sp, 6
	or	ax, ax
	jz	short l_learnedAllLevelsCheck
	inc	[bp+loopCounter]
	cmp	[bp+loopCounter], 7
	jl	short l_searchSpellLevelsLoop

l_learnedAllLevelsCheck:
	cmp	[bp+loopCounter], 6
	jle	short l_levelCheckForSpells
	mov	ax, offset s_learnedAllSpells
	push	ds
	push	ax
	call	printStringWithWait
	add	sp, 4
	jmp	l_return

l_levelCheckForSpells:
	mov	ax, charSize
	imul	[bp+slotNumber]
	mov	bx, ax
	mov	ax, gs:party.level[bx]
	inc	ax
	shr	ax, 1
	mov	cx, [bp+loopCounter]
	inc	cx
	cmp	ax, cx
	jnb	short l_ioLoop
	mov	ax, offset s_cannotAcquireNewSpells
	push	ds
	push	ax
	call	printStringWithWait
	add	sp, 4
	jmp	l_return

l_ioLoop:
	mov	ax, charSize
	imul	[bp+slotNumber]
	mov	bx, ax
	mov	bl, gs:party.class[bx]
	sub	bh, bh
	shl	bx, 1
	shl	bx, 1
	push	word ptr (g_classString+2)[bx]
	push	word ptr g_classString[bx]
	lea	ax, [bp+stringBuffer]
	push	ss
	push	ax
	call	strcat
	add	sp, 8
	mov	word ptr [bp+stringBufferP], ax
	mov	word ptr [bp+stringBufferP+2], dx
	mov	ax, offset s_spellLevel
	push	ds
	push	ax
	push	dx
	push	word ptr [bp+stringBufferP]
	call	strcat
	add	sp, 8
	mov	word ptr [bp+stringBufferP], ax
	mov	word ptr [bp+stringBufferP+2], dx
	lfs	bx, [bp+stringBufferP]
	inc	word ptr [bp+stringBufferP]
	mov	al, byte ptr [bp+loopCounter]
	add	al, '1'
	mov	fs:[bx], al
	mov	ax, offset s_willCost
	push	ds
	push	ax
	push	word ptr [bp+stringBufferP+2]
	push	word ptr [bp+stringBufferP]
	call	strcat
	add	sp, 8
	mov	word ptr [bp+stringBufferP], ax
	mov	word ptr [bp+stringBufferP+2], dx
	mov	bx, [bp+loopCounter]
	shl	bx, 1
	mov	ax, levelCost[bx]
	mov	[bp+levelCost], ax
	sub	ax, ax
	push	ax
	mov	ax, [bp+levelCost]
	cwd
	push	dx
	push	ax
	push	word ptr [bp+stringBufferP+2]
	push	word ptr [bp+stringBufferP]
	call	itoa
	add	sp, 0Ah
	mov	word ptr [bp+stringBufferP], ax
	mov	word ptr [bp+stringBufferP+2], dx
	mov	ax, offset s_inGoldWhoWillPay
	push	ds
	push	ax
	push	dx
	push	word ptr [bp+stringBufferP]
	call	strcat
	add	sp, 8
	mov	word ptr [bp+stringBufferP], ax
	mov	word ptr [bp+stringBufferP+2], dx
	lea	ax, [bp+stringBuffer]
	push	ss
	push	ax
	call	printStringWClear
	add	sp, 4
	call	readSlotNumber
	mov	[bp+payeeSlotNumber], ax
	or	ax, ax
	jl	short l_return

	mov	ax, [bp+levelCost]
	cwd
	mov	cx, ax
	mov	bx, dx
	mov	ax, charSize
	imul	[bp+payeeSlotNumber]
	mov	si, ax
	cmp	word ptr gs:(party.gold+2)[si], bx
	ja	short l_removeGold
	jb	short l_notEnoughGold
	cmp	word ptr gs:party.gold[si], cx
	jnb	short l_removeGold

l_notEnoughGold:
	mov	ax, offset s_notEnoughGoldNl
	push	ds
	push	ax
	call	printStringWithWait
	add	sp, 4
	jmp	l_ioLoop

l_removeGold:
	mov	ax, [bp+levelCost]
	cwd
	mov	cx, ax
	mov	bx, dx
	mov	ax, charSize
	imul	[bp+payeeSlotNumber]
	mov	si, ax
	sub	word ptr gs:party.gold[si], cx
	sbb	word ptr gs:(party.gold+2)[si], bx
	mov	ax, offset s_elderTeachersLore
	push	ds
	push	ax
	call	printStringWithWait
	add	sp, 4
	push	[bp+spellBase]
	push	[bp+loopCounter]
	push	[bp+slotNumber]
	push	cs
	call	near ptr character_learnSpellLevel
	add	sp, 6
	jmp	short l_return

l_return:
	pop	si
	mov	sp, bp
	pop	bp
	retf
review_learnSpells	endp

; Attributes: bp-based frame

mage_convertConjurorCheck proc far

	slotNumber= word ptr	 6

	push	bp
	mov	bp, sp
	sub	ax, ax
	push	ax
	push	[bp+slotNumber]
	push	cs
	call	near ptr mage_hasBeenClass
	add	sp, 4
	mov	cx, ax
	cmp	cx, 1
	sbb	ax, ax
	neg	ax
	mov	sp, bp
	pop	bp
	retf
mage_convertConjurorCheck endp

; Attributes: bp-based frame

mage_convertMagicianCheck proc far

	slotNumber= word ptr	 6

	push	bp
	mov	bp, sp
	mov	ax, 0Eh
	push	ax
	push	[bp+slotNumber]
	push	cs
	call	near ptr mage_hasBeenClass
	add	sp, 4
	mov	cx, ax
	cmp	cx, 1
	sbb	ax, ax
	neg	ax
	mov	sp, bp
	pop	bp
	retf
mage_convertMagicianCheck endp

; Attributes: bp-based frame

mage_convertSorcererCheck proc far

	slotNumber= word ptr	 6

	push	bp
	mov	bp, sp
	mov	ax, 1Ch
	push	ax
	push	[bp+slotNumber]
	push	cs
	call	near ptr mage_hasBeenClass
	add	sp, 4
	or	ax, ax
	jnz	short l_returnZero

	push	[bp+slotNumber]
	push	cs
	call	near ptr mage_countClassesGained
	add	sp, 2
	cmp	ax, 1
	jl	short l_returnZero

	mov	ax, 1
	jmp	short l_return

l_returnZero:
	sub	ax, ax

l_return:
	mov	sp, bp
	pop	bp
	retf
mage_convertSorcererCheck endp

; Attributes: bp-based frame

mage_convertWizardCheck proc far

	slotNumber= word ptr	 6

	push	bp
	mov	bp, sp
	mov	ax, 2Ah
	push	ax
	push	[bp+slotNumber]
	push	cs
	call	near ptr mage_hasBeenClass
	add	sp, 4
	or	ax, ax
	jnz	short l_returnZero

	push	[bp+slotNumber]
	push	cs
	call	near ptr mage_countClassesGained
	add	sp, 2
	cmp	ax, 2
	jl	short l_returnZero

	mov	ax, 1
	jmp	short l_return

l_returnZero:
	sub	ax, ax

l_return:
	mov	sp, bp
	pop	bp
	retf
mage_convertWizardCheck endp

; Attributes: bp-based frame

mage_convertArchmageCheck proc far

	slotNumber= word ptr	 6

	push	bp
	mov	bp, sp
	mov	ax, 38h	
	push	ax
	push	[bp+slotNumber]
	push	cs
	call	near ptr mage_hasBeenClass
	add	sp, 4
	or	ax, ax
	jnz	short l_returnZero

	push	[bp+slotNumber]
	push	cs
	call	near ptr mage_countClassesGained
	add	sp, 2
	cmp	ax, 3
	jl	short l_returnZero

	mov	ax, 1
	jmp	short l_return

l_returnZero:
	sub	ax, ax
l_return:
	mov	sp, bp
	pop	bp
	retf
mage_convertArchmageCheck endp

; Attributes: bp-based frame

mage_convertChronomancerCheck proc far

	slotNumber= word ptr	 6

	push	bp
	mov	bp, sp
	mov	ax, 46h	
	push	ax
	push	[bp+slotNumber]
	call	mage_hasBeenClass
	add	sp, 4
	or	ax, ax
	jnz	short l_returnZero

	push	[bp+slotNumber]
	push	cs
	call	near ptr mage_countClassesGained
	add	sp, 2
	cmp	ax, 2
	jl	short l_returnZero

	mov	ax, 1
	jmp	short l_return

l_returnZero:
	sub	ax, ax

l_return:
	mov	sp, bp
	pop	bp
	retf
mage_convertChronomancerCheck endp

; Attributes: bp-based frame

review_changeMageClass proc far

	var_78=	word ptr -76h
	convertList=	word ptr -22h
	currentClassSpellIndex=	word ptr -20h
	loopCounter= word ptr -1Eh
	slotNumber=	word ptr -1Ch
	inKey=	word ptr -1Ah
	newClass=	word ptr -18h
	var_16=	word ptr -16h
	convertListMouseMask= word ptr	-2

	push	bp
	mov	bp, sp
	mov	ax, 76h
	call	someStackOperation
	push	si

	mov	ax, offset s_whichMageSeeksChange
	push	ds
	push	ax
	call	printStringWClear
	add	sp, 4
	call	readSlotNumber
	mov	[bp+slotNumber], ax
	or	ax, ax
	jl	l_return

	mov	ax, charSize
	imul	[bp+slotNumber]
	mov	bx, ax
	mov	al, gs:party.class[bx]
	cmp	al, class_chronomancer
	jz	short l_unableToChangeClass
	cmp	al, class_geomancer
	jnz	short l_spellcasterCheck

l_unableToChangeClass:
	mov	ax, offset s_cannotChangeClass
	push	ds
	push	ax
	call	printStringWithWait
	add	sp, 4
	jmp	l_return

l_spellcasterCheck:
	mov	ax, charSize
	imul	[bp+slotNumber]
	mov	bx, ax
	mov	bl, gs:party.class[bx]
	sub	bh, bh
	mov	al, mageSpellIndex[bx]
	sub	ah, ah
	mov	[bp+currentClassSpellIndex], ax
	cmp	ax, 0FFh
	jnz	short l_checkSpellLevels

	mov	ax, offset s_thouArtNotASpellcaster
	push	ds
	push	ax
	call	printStringWithWait
	add	sp, 4
	jmp	l_return

l_checkSpellLevels:
	mov	[bp+loopCounter], 0

l_spellLevelLoop:
	push	[bp+currentClassSpellIndex]
	push	[bp+loopCounter]
	push	[bp+slotNumber]
	push	cs
	call	near ptr character_learnedSpellLevel
	add	sp, 6
	or	ax, ax
	jnz	short l_spellLevelNext

	mov	ax, offset s_mustKnowThreeSpellLevels
	push	ds
	push	ax
	call	printStringWithWait
	add	sp, 4
	jmp	l_return

l_spellLevelNext:
	inc	[bp+loopCounter]
	cmp	[bp+loopCounter], 3
	jl	short l_spellLevelLoop

	mov	[bp+convertList], 0
	mov	[bp+convertListMouseMask], 0
	mov	[bp+loopCounter], 0

l_convertLoop:
	push	[bp+slotNumber]
	mov	bx, [bp+loopCounter]
	shl	bx, 1
	shl	bx, 1
	call	g_mageConversionCheckFunctions[bx]
	add	sp, 2
	or	ax, ax
	jz	short l_convertNext
	mov	bx, [bp+loopCounter]
	shl	bx, 1
	shl	bx, 1
	push	word ptr (magicUserString+2)[bx]
	push	word ptr magicUserString[bx]
	push	[bp+convertList]
	call	printListItem
	add	sp, 6
	mov	si, [bp+convertList]
	inc	[bp+convertList]
	shl	si, 1
	mov	ax, [bp+loopCounter]
	mov	[bp+si+var_16],	ax
	mov	bl, gs:txt_numLines
	sub	bh, bh
	shl	bx, 1
	mov	ax, bitMask16bit[bx]
	or	[bp+convertListMouseMask], ax

l_convertNext:
	inc	[bp+loopCounter]
	cmp	[bp+loopCounter], 6
	jl	short l_convertLoop

l_emptyListCheck:
	cmp	[bp+convertList], 0
	jnz	short l_promptForNewClass
	mov	ax, offset s_doesntQualifyForNewClass
	push	ds
	push	ax
	call	printStringWithWait
	add	sp, 4
	jmp	l_return

l_promptForNewClass:
	mov	ax, offset s_newClassPrompt
	push	ds
	push	ax
	call	printString
	add	sp, 4

l_ioLoop:
	push	[bp+convertListMouseMask]
	call	getKey
	add	sp, 2
	mov	[bp+inKey], ax
	cmp	ax, dosKeys_ESC
	jz	l_return
	cmp	[bp+inKey], 10Eh
	jl	short l_checkKey
	cmp	[bp+inKey], 119h
	jg	short l_checkKey
	sub	[bp+inKey], 0DEh 

l_checkKey:
	cmp	[bp+inKey], 31h 
	jl	short l_ioLoop
	mov	ax, [bp+convertList]
	add	ax, 31h	
	cmp	ax, [bp+inKey]
	jl	short l_ioLoop
	mov	si, [bp+inKey]
	shl	si, 1
	mov	ax, [bp+si+var_78]
	mov	[bp+loopCounter], ax
	cmp	ax, 5
	jnz	short l_changeClass

	mov	ax, offset s_convertChronomancerPrompt
	push	ds
	push	ax
	call	printStringWithWait
	add	sp, 4
	mov	ax, offset s_dostThouAccept
	push	ds
	push	ax
	call	printStringWClear
	add	sp, 4
	call	getYesNo
	or	ax, ax
	jz	l_return

	mov	ax, offset s_arboriaSpellText
	push	ds
	push	ax
	call	printStringWithWait
	add	sp, 4
	mov	ax, offset s_arboriaSpellLocation
	push	ds
	push	ax
	call	printStringWithWait
	add	sp, 4
	push	[bp+slotNumber]
	push	cs
	call	near ptr mage_removeAllSpells
	add	sp, 2

l_changeClass:
	getCharP	[bp+slotNumber], si
	mov	bx, [bp+loopCounter]
	mov	al, g_convertListToMageClass[bx]
	sub	ah, ah
	mov	[bp+newClass], ax
	mov	cl, gs:party.class[si]
	sub	ch, ch
	cmp	ax, cx
	jz	short l_return
	sub	ax, ax
	mov	word ptr gs:(party.experience+2)[si], ax
	mov	word ptr gs:party.experience[si], ax
	mov	gs:party.maxLevel[si],	1
	mov	gs:party.level[si], 1
	mov	al, byte ptr [bp+newClass]
	mov	gs:party.class[si], al
	mov	bx, [bp+newClass]
	mov	al, mageSpellIndex[bx]
	sub	ah, ah
	push	ax
	sub	ax, ax
	push	ax
	push	[bp+slotNumber]
	push	cs
	call	near ptr character_learnSpellLevel
	add	sp, 6
	mov	byte ptr g_printPartyFlag,	0
	mov	ax, offset s_beginsNewProfession
	push	ds
	push	ax
	call	printStringWithWait
	add	sp, 4

l_return:
	pop	si
	mov	sp, bp
	pop	bp
	retf
review_changeMageClass endp

; Attributes: bp-based frame

character_learnSpellLevel proc far

	spellCount= word ptr	-4
	spellNumber= word ptr	-2
	slotNumber=	word ptr  6
	spellLevelOffset= word ptr	 8
	spellLevelBase= word ptr	 0Ah

	push	bp
	mov	bp, sp
	mov	ax, 4
	call	someStackOperation
	mov	ax, [bp+spellLevelOffset]
	shl	ax, 1
	add	ax, [bp+spellLevelBase]
	mov	bx, ax
	mov	al, byte ptr g_spellLevelData.levelBase[bx]
	sub	ah, ah
	mov	[bp+spellNumber], ax
	mov	al, g_spellLevelData.numSpells[bx]
	mov	[bp+spellCount], ax

l_loop:
	mov	ax, [bp+spellCount]
	dec	[bp+spellCount]
	or	ax, ax
	jz	short l_return
	push	[bp+spellNumber]
	inc	[bp+spellNumber]
	push	[bp+slotNumber]
	call	character_learnSpell
	add	sp, 4
	jmp	short l_loop

l_return:
	mov	sp, bp
	pop	bp
	retf
character_learnSpellLevel endp

; Attributes: bp-spellLevelBased frame

character_learnedSpellLevel proc far

	spellCount= word ptr	-4
	baseSpellNumber= word ptr	-2
	slotNumber=	word ptr  6
	spellLevelOffset= word ptr  8
	spellLevelBase= word ptr	0Ah

	push	bp
	mov	bp, sp
	mov	ax, 4
	call	someStackOperation
	mov	ax, [bp+spellLevelOffset]
	shl	ax, 1
	add	ax, [bp+spellLevelBase]
	mov	bx, ax
	mov	al, byte ptr g_spellLevelData.levelBase[bx]
	sub	ah, ah
	mov	[bp+baseSpellNumber], ax
	mov	al, g_spellLevelData.numSpells[bx]
	mov	[bp+spellCount], ax

l_loop:
	mov	ax, [bp+spellCount]
	dec	[bp+spellCount]
	or	ax, ax
	jz	short l_returnOne
	push	[bp+baseSpellNumber]
	inc	[bp+baseSpellNumber]
	push	[bp+slotNumber]
	call	character_learnedSpell
	add	sp, 4
	or	ax, ax
	jnz	short l_loop
	sub	ax, ax
	jmp	short l_return

l_returnOne:
	mov	ax, 1

l_return:
	mov	sp, bp
	pop	bp
	retf
character_learnedSpellLevel endp

; This function	returns	1 if the mage has learned
; at least one level of	a certain mage class
; Attributes: bp-based frame

mage_hasBeenClass proc far

	loopCounter= word ptr -2
	slotNumber=	word ptr  6
	spellBase= word	ptr  8

	push	bp
	mov	bp, sp
	mov	ax, 2
	call	someStackOperation
	mov	[bp+loopCounter], 6
l_loop:
	push	[bp+spellBase]
	push	[bp+loopCounter]
	push	[bp+slotNumber]
	push	cs
	call	near ptr character_learnedSpellLevel
	add	sp, 6
	or	ax, ax
	jz	short l_returnZero
	dec	[bp+loopCounter]
	cmp	[bp+loopCounter], 0
	jge	short l_loop

l_returnOne:
	mov	ax, 1
	jmp	short l_return

l_returnZero:
	sub	ax, ax

l_return:
	mov	sp, bp
	pop	bp
	retf
mage_hasBeenClass endp

; This function	returns	the number of classes that
; a mage has learned a spell level as. This is used,
; for example, to ensure that a	mage has learned two
; classes before changing to a wizard.
; Attributes: bp-based frame

mage_countClassesGained	proc far

	classCount= word ptr -4
	loopCounter= word ptr -2
	slotNumber= word ptr	 6

	push	bp
	mov	bp, sp
	mov	ax, 4
	call	someStackOperation

	mov	[bp+classCount], 0
	mov	[bp+loopCounter], 0
l_loop:
	mov	ax, [bp+loopCounter]
	mov	cx, ax
	shl	ax, 1
	add	ax, cx
	shl	ax, 1
	add	ax, cx
	shl	ax, 1
	push	ax
	push	[bp+slotNumber]
	push	cs
	call	near ptr mage_hasBeenClass
	add	sp, 4
	or	ax, ax
	jz	short l_next
	inc	[bp+classCount]
	jmp	short l_loop

l_next:
	inc	[bp+loopCounter]
	cmp	[bp+loopCounter], 6
	jl	short l_loop

	mov	ax, [bp+classCount]
	mov	sp, bp
	pop	bp
	retf
mage_countClassesGained	endp

; Attributes: bp-based frame

mage_removeAllSpells proc far

	loopCounter= word ptr	-2
	slotNumber= word ptr	 6

	push	bp
	mov	bp, sp
	mov	ax, 2
	call	someStackOperation
	mov	[bp+loopCounter], 0

l_loop:
	mov	ax, charSize
	imul	[bp+slotNumber]
	mov	bx, ax
	add	bx, [bp+loopCounter]
	mov	gs:party.spells[bx], 0
	inc	[bp+loopCounter]
	cmp	[bp+loopCounter], 0Eh
	jl	short l_loop

	mov	sp, bp
	pop	bp
	retf
mage_removeAllSpells endp

; Attributes: bp-based frame

review_speakToElder proc far

	slotNumber=	word ptr -2

	push	bp
	mov	bp, sp
	mov	ax, 2
	call	someStackOperation

l_mainLoop:
	mov	ax, offset s_whoSpeaksToElder
	push	ds
	push	ax
	call	printStringWClear
	add	sp, 4
	call	readSlotNumber
	mov	[bp+slotNumber], ax
	or	ax, ax
	jl	l_return

	sub	ax, ax
	push	ax
	push	[bp+slotNumber]
	call	review_isQuestComplete
	add	sp, 4
	or	ax, ax
	jnz	short l_checkForChronomancer
	mov	ax, offset s_seekOutBrilhasti
	push	ds
	push	ax
	call	printStringWithWait
	add	sp, 4
	jmp	l_mainLoop

l_checkForChronomancer:
	mov	ax, charSize
	imul	[bp+slotNumber]
	mov	bx, ax
	cmp	gs:party.class[bx], class_chronomancer
	jz	short l_checkQuests
	mov	ax, offset s_teachOnlyChronomancer
	push	ds
	push	ax
	call	printStringWithWait
	add	sp, 4
	jmp	short l_mainLoop

l_checkQuests:
	push	[bp+slotNumber]
	push	cs
	call	near ptr review_elderGelidia
	add	sp, 2
	or	ax, ax
	jnz	short l_waitAndLoop

	push	[bp+slotNumber]
	push	cs
	call	near ptr review_elderLucencia
	add	sp, 2
	or	ax, ax
	jnz	short l_waitAndLoop

	push	[bp+slotNumber]
	push	cs
	call	near ptr review_elderKinestia
	add	sp, 2
	or	ax, ax
	jnz	short l_waitAndLoop

	push	[bp+slotNumber]
	push	cs
	call	near ptr review_elderTenebrosia
	add	sp, 2
	or	ax, ax
	jnz	short l_waitAndLoop

	push	[bp+slotNumber]
	push	cs
	call	near ptr review_elderTarmitia
	add	sp, 2
	or	ax, ax
	jnz	short l_waitAndLoop
	mov	ax, offset s_timeIsRunningOut
	push	ds
	push	ax
	call	printStringWClear
	add	sp, 4

l_waitAndLoop:
	mov	ax, 4000h
	push	ax
	call	getKey
	add	sp, 2
	jmp	l_mainLoop

l_return:
	mov	sp, bp
	pop	bp
	retf
review_speakToElder endp

; Attributes: bp-based frame

review_elderGelidia proc far

	slotNumber= word ptr	 6

	push	bp
	mov	bp, sp
	mov	ax, 2
	push	ax
	push	[bp+slotNumber]
	push	cs
	call	near ptr review_isQuestComplete
	add	sp, 4
	or	ax, ax
	jz	short l_returnZero

	mov	ax, 54h	
	push	ax
	push	[bp+slotNumber]
	call	character_learnedSpell
	add	sp, 4
	or	ax, ax
	jnz	short l_returnZero

	mov	ax, offset s_gelidiaSpellText
	push	ds
	push	ax
	call	printStringWithWait
	add	sp, 4
	mov	ax, offset s_gelidiaSpellLocation
	push	ds
	push	ax
	call	printStringWithWait
	add	sp, 4
	mov	ax, 54h	
	push	ax
	push	[bp+slotNumber]
	call	character_learnSpell
	add	sp, 4
	mov	ax, 55h	
	push	ax
	push	[bp+slotNumber]
	call	character_learnSpell
	add	sp, 4
	mov	ax, 1
	jmp	short l_return

l_returnZero:
	sub	ax, ax

l_return:
	mov	sp, bp
	pop	bp
	retf
review_elderGelidia endp

; Attributes: bp-based frame

review_elderLucencia proc far

	slotNumber= word ptr	 6

	push	bp
	mov	bp, sp
	mov	ax, 4
	push	ax
	push	[bp+slotNumber]
	push	cs
	call	near ptr review_isQuestComplete
	add	sp, 4
	or	ax, ax
	jz	short l_returnZero

	mov	ax, 58h	
	push	ax
	push	[bp+slotNumber]
	call	character_learnedSpell
	add	sp, 4
	or	ax, ax
	jnz	l_returnZero

	mov	ax, offset s_lucenciaSpellText
	push	ds
	push	ax
	call	printStringWithWait
	add	sp, 4
	mov	ax, offset s_lucenciaSpellLocation
	push	ds
	push	ax
	call	printStringWithWait
	add	sp, 4

	mov	ax, 58h	
	push	ax
	push	[bp+slotNumber]
	call	character_learnSpell
	add	sp, 4

	mov	ax, 59h	
	push	ax
	push	[bp+slotNumber]
	call	character_learnSpell
	add	sp, 4

	mov	ax, 1
	jmp	short l_return

l_returnZero:
	sub	ax, ax

l_return:
	mov	sp, bp
	pop	bp
	retf
review_elderLucencia endp

; Attributes: bp-based frame

review_elderKinestia proc far

	slotNumber= word ptr	 6

	push	bp
	mov	bp, sp
	mov	ax, 6
	push	ax
	push	[bp+slotNumber]
	push	cs
	call	near ptr review_isQuestComplete
	add	sp, 4
	or	ax, ax
	jz	short l_returnZero

	mov	ax, 5Ch	
	push	ax
	push	[bp+slotNumber]
	call	character_learnedSpell
	add	sp, 4
	or	ax, ax
	jnz	l_returnZero

	mov	ax, offset s_kinestiaSpellText
	push	ds
	push	ax
	call	printStringWithWait
	add	sp, 4
	mov	ax, offset s_kinestiaSpellLocation
	push	ds
	push	ax
	call	printStringWithWait
	add	sp, 4

	mov	ax, 5Ch	
	push	ax
	push	[bp+slotNumber]
	call	character_learnSpell
	add	sp, 4

	mov	ax, 5Dh	
	push	ax
	push	[bp+slotNumber]
	call	character_learnSpell
	add	sp, 4

	mov	ax, 1
	jmp	short l_return

l_returnZero:
	sub	ax, ax

l_return:
	mov	sp, bp
	pop	bp
	retf
review_elderKinestia endp

; Attributes: bp-based frame

review_elderTenebrosia proc far

	slotNumber= word ptr	 6

	push	bp
	mov	bp, sp
	mov	ax, 8
	push	ax
	push	[bp+slotNumber]
	push	cs
	call	near ptr review_isQuestComplete
	add	sp, 4
	or	ax, ax
	jz	short l_returnZero

	mov	ax, 60h	
	push	ax
	push	[bp+slotNumber]
	call	character_learnedSpell
	add	sp, 4
	or	ax, ax
	jnz	short l_returnZero

	mov	ax, offset s_tenebrosiaSpellText
	push	ds
	push	ax
	call	printStringWithWait
	add	sp, 4
	mov	ax, offset s_tenebrosiaSpellLocation
	push	ds
	push	ax
	call	printStringWithWait
	add	sp, 4

	mov	ax, 60h	
	push	ax
	push	[bp+slotNumber]
	call	character_learnSpell
	add	sp, 4

	mov	ax, 61h	
	push	ax
	push	[bp+slotNumber]
	call	character_learnSpell
	add	sp, 4

	mov	ax, 1
	jmp	short l_return

l_returnZero:
	mov	ax, ax

l_return:
	mov	sp, bp
	pop	bp
	retf
review_elderTenebrosia endp

; Attributes: bp-based frame

review_elderTarmitia proc far

	slotNumber= word ptr	 6

	push	bp
	mov	bp, sp
	mov	ax, 0Ah
	push	ax
	push	[bp+slotNumber]
	push	cs
	call	near ptr review_isQuestComplete
	add	sp, 4
	or	ax, ax
	jz	short l_returnZero

	mov	ax, 64h	
	push	ax
	push	[bp+slotNumber]
	call	character_learnedSpell
	add	sp, 4
	or	ax, ax
	jnz	short l_returnZero

	mov	ax, offset s_tarmitiaSpellText
	push	ds
	push	ax
	call	printStringWithWait
	add	sp, 4
	mov	ax, offset s_tarmitiaSpellLocation
	push	ds
	push	ax
	call	printStringWithWait
	add	sp, 4

	mov	ax, 64h	
	push	ax
	push	[bp+slotNumber]
	call	character_learnSpell
	add	sp, 4

	mov	ax, 65h	
	push	ax
	push	[bp+slotNumber]
	call	character_learnSpell
	add	sp, 4

	mov	ax, 1
	jmp	short l_return

l_returnZero:
	sub	ax, ax

l_return:
	mov	sp, bp
	pop	bp
	retf
review_elderTarmitia endp

; This function	returns	non-zero if the	chronomancer
; quest	flag has been set in slotNumber
; Attributes: bp-based frame

review_isQuestComplete proc far

	slotNumber=	word ptr  6
	questByte= word ptr	 8

	push	bp
	mov	bp, sp
	mov	ax, charSize
	imul	[bp+slotNumber]
	mov	bx, ax
	mov	ax, [bp+questByte]
	mov	cl, 3
	sar	ax, cl
	add	bx, ax
	mov	al, gs:party.chronoQuest[bx]
	sub	ah, ah
	mov	bx, [bp+questByte]
	and	bx, 7
	mov	cl, byteMaskList[bx]
	sub	ch, ch
	and	ax, cx
	mov	sp, bp
	pop	bp
	retf
review_isQuestComplete endp

; Attributes: bp-based frame
;
; DWORD var_2 & var_4

review_setTitle proc far

	bigpicNumber= word ptr	-8
	var_6= word ptr	-6
	var_4= word ptr	-4
	var_2= word ptr	-2

	push	bp
	mov	bp, sp
	mov	ax, 8
	call	someStackOperation
	mov	ax, 0Ch
	push	ax
	call	quest_partyNotHasFlagSet
	add	sp, 2
	cmp	ax, 1
	sbb	cx, cx
	neg	cx
	mov	[bp+var_6], cx
	or	cx, cx
	jz	short loc_24150
	mov	ax, 32h	
	jmp	short loc_24153
loc_24150:
	mov	ax, 2Fh	
loc_24153:
	mov	[bp+bigpicNumber], ax
	cmp	[bp+var_6], 0
	jz	short loc_24161
	mov	ax, offset s_building
	jmp	short loc_24164

loc_24161:
	mov	ax, offset s_reviewBoard

loc_24164:
	mov	[bp+var_4], ax
	mov	[bp+var_2], ds
	push	[bp+bigpicNumber]
	call	bigpic_drawPictureNumber
	add	sp, 2

	push	[bp+var_2]
	push	[bp+var_4]
	call	setTitle
	add	sp, 4

	cmp	[bp+var_6], 0
	jz	short l_return
	call	text_clear
	mov	ax, offset s_desertedReviewBoard
	push	ds
	push	ax
	call	printString
	add	sp, 4
	add	sp, 4
	mov	ax, 0FFh
	push	ax
	mov	ax, 3Eh	
	push	ax
	call	_updateFlags
	add	sp, 4
	mov	ax, 4000h
	push	ax
	call	getKey
	add	sp, 2

l_return:
	mov	sp, bp
	pop	bp
	retf
review_setTitle endp

; Attributes: bp-based frame

review_questBrilhasti proc far
	push	bp
	mov	bp, sp

	mov	ax, 35
	push	ax
	call	vm_partyUnderLevel
	add	sp, 2
	or	ax, ax
	jnz	short loc_24250

	mov	ax, quest_brilhastDone
	push	ax
	call	quest_partyHasFlagSet
	add	sp, 2
	or	ax, ax
	jnz	short loc_24250

	mov	ax, quest_brilhastActive
	push	ax
	call	quest_partyNotHasFlagSet
	add	sp, 2
	or	ax, ax
	jz	short l_returnZero

	mov	ax, offset s_questBrilhasti_1
	push	ds
	push	ax
	call	printStringWithWait
	add	sp, 4
	mov	ax, offset s_questBrilhasti_2
	push	ds
	push	ax
	call	printStringWithWait
	add	sp, 4
	mov	ax, offset s_questBrilhasti_3
	push	ds
	push	ax
	call	printStringWithWait
	add	sp, 4
	mov	ax, offset s_questBrilhasti_4
	push	ds
	push	ax
	call	printStringWithWait
	add	sp, 4

	mov	ax, 0FFh
	push	ax
	mov	ax, 3Fh	
	push	ax
	call	_updateFlags
	add	sp, 4

	mov	ax, quest_brilhastActive
	push	ax
	call	quest_setFlag
	add	sp, 2
	mov	ax, 1
	jmp	short l_return

loc_24250:
	mov	ax, quest_brilhastActive
	push	ax
	call	quest_setFlag
	add	sp, 2

	mov	ax, quest_brilhastDone
	push	ax
	call	quest_setFlag
	add	sp, 2

l_returnZero:
	sub	ax, ax

l_return:
	mov	sp, bp
	pop	bp
	retf
review_questBrilhasti endp

; Attributes: bp-based frame

review_questValarian proc far
	push	bp
	mov	bp, sp
	sub	ax, ax
	push	ax
	call	quest_partyNotHasFlagSet
	add	sp, 2
	or	ax, ax
	jz	l_returnZero

	mov	ax, quest_valarianDone
	push	ax
	call	quest_partyNotHasFlagSet
	add	sp, 2
	or	ax, ax
	jz	l_returnZero

	mov	ax, quest_brilhastDone
	push	ax
	call	quest_partyHasFlagSet
	add	sp, 2
	or	ax, ax
	jz	l_returnZero

	mov	ax, offset s_questValarian_1
	push	ds
	push	ax
	call	printStringWithWait
	add	sp, 4
	mov	ax, offset s_questValarian_2
	push	ds
	push	ax
	call	printStringWithWait
	add	sp, 4
	mov	ax, offset s_questValarian_3
	push	ds
	push	ax
	call	printStringWithWait
	add	sp, 4
	mov	ax, offset s_questValarian_4
	push	ds
	push	ax
	call	printStringWithWait
	add	sp, 4
	mov	ax, offset s_questValarian_5
	push	ds
	push	ax
	call	printStringWithWait
	add	sp, 4
	mov	ax, offset s_questValarian_6
	push	ds
	push	ax
	call	printStringWithWait
	add	sp, 4
	mov	ax, offset s_questValarian_7
	push	ds
	push	ax
	call	printStringWithWait
	add	sp, 4

	mov	ax, 0FFh
	push	ax
	mov	ax, 3Fh	
	push	ax
	call	_updateFlags
	add	sp, 4

	mov	ax, quest_brilhastActive
	push	ax
	call	quest_setFlag
	add	sp, 2

	mov	ax, quest_brilhastDone
	push	ax
	call	quest_setFlag
	add	sp, 2

	sub	ax, ax
	push	ax
	call	quest_setFlag
	add	sp, 2
	mov	ax, 1
	jmp	short l_return

l_returnZero:
	sub	ax, ax

l_return:
	mov	sp, bp
	pop	bp
	retf
review_questValarian endp

; Attributes: bp-based frame
review_questLanatir proc	far
	push	bp
	mov	bp, sp

	mov	ax, 2
	push	ax
	call	quest_partyNotHasFlagSet
	add	sp, 2
	or	ax, ax
	jz	l_returnZero

	mov	ax, quest_lanatirDone
	push	ax
	call	quest_partyNotHasFlagSet
	add	sp, 2
	or	ax, ax
	jz	l_returnZero

	mov	ax, 7Bh	
	push	ax
	call	vm_findItem
	add	sp, 2
	or	ax, ax
	jz	l_returnZero

	mov	ax, 7Ch	
	push	ax
	call	vm_findItem
	add	sp, 2
	or	ax, ax
	jz	short l_returnZero

	mov	ax, 7Bh	
	push	ax
	call	vm_removeItem
	add	sp, 2

	mov	ax, 7Ch	
	push	ax
	call	vm_removeItem
	add	sp, 2

	mov	ax, offset s_questLanatir_1
	push	ds
	push	ax
	call	printStringWithWait
	add	sp, 4
	mov	ax, offset s_questLanatir_2
	push	ds
	push	ax
	call	printStringWithWait
	add	sp, 4
	mov	ax, offset s_questLanatir_3
	push	ds
	push	ax
	call	printStringWithWait
	add	sp, 4
	mov	ax, offset s_questLanatir_4
	push	ds
	push	ax
	call	printStringWithWait
	add	sp, 4

	mov	ax, 0FFh
	push	ax
	mov	ax, 3Fh	
	push	ax
	call	_updateFlags
	add	sp, 4

	mov	ax, quest_lanatirActive
	push	ax
	call	quest_setFlag
	add	sp, 2

	sub	ax, ax
	push	ax
	call	quest_setFlag
	add	sp, 2
	mov	ax, 1
	jmp	short l_return

l_returnZero:
	sub	ax, ax

l_return:
	mov	sp, bp
	pop	bp
	retf
review_questLanatir endp

; Attributes: bp-based frame
review_questAlliria proc	far
	push	bp
	mov	bp, sp

	mov	ax, quest_alliriaDone
	push	ax
	call	quest_partyNotHasFlagSet
	add	sp, 2
	or	ax, ax
	jz	l_returnZero

	mov	ax, quest_alliriaActive
	push	ax
	call	quest_partyNotHasFlagSet
	add	sp, 2
	or	ax, ax
	jz	l_returnZero

	mov	ax, 73h	
	push	ax
	call	vm_findItem
	add	sp, 2
	or	ax, ax
	jz	short l_returnZero

	mov	ax, 74h	
	push	ax
	call	vm_findItem
	add	sp, 2
	or	ax, ax
	jz	short l_returnZero

	mov	ax, 73h	
	push	ax
	call	vm_removeItem
	add	sp, 2

	mov	ax, 74h	
	push	ax
	call	vm_removeItem
	add	sp, 2

	mov	ax, offset s_questAlliria_1
	push	ds
	push	ax
	call	printStringWithWait
	add	sp, 4
	mov	ax, offset s_questAlliria_2
	push	ds
	push	ax
	call	printStringWithWait
	add	sp, 4
	mov	ax, offset s_questAlliria_3
	push	ds
	push	ax
	call	printStringWithWait
	add	sp, 4

	mov	ax, 0FFh
	push	ax
	mov	ax, 3Fh	
	push	ax
	call	_updateFlags
	add	sp, 4

	mov	ax, quest_lanatirActive
	push	ax
	call	quest_setFlag
	add	sp, 2

	mov	ax, quest_alliriaActive
	push	ax
	call	quest_setFlag
	add	sp, 2
	mov	ax, 1
	jmp	short l_return

l_returnZero:
	sub	ax, ax

l_return:
	mov	sp, bp
	pop	bp
	retf
review_questAlliria endp

; Attributes: bp-based frame

review_questFerofist proc far
	push	bp
	mov	bp, sp

	mov	ax, quest_ferofistDone
	push	ax
	call	quest_partyNotHasFlagSet
	add	sp, 2
	or	ax, ax
	jz	l_returnZero

	mov	ax, quest_ferofistActive
	push	ax
	call	quest_partyNotHasFlagSet
	add	sp, 2
	or	ax, ax
	jz	l_returnZero

	mov	ax, 87h	
	push	ax
	call	vm_findItem
	add	sp, 2
	or	ax, ax
	jz	l_returnZero

	mov	ax, 88h	
	push	ax
	call	vm_findItem
	add	sp, 2
	or	ax, ax
	jz	short l_returnZero

	mov	ax, 87h	
	push	ax
	call	vm_removeItem
	add	sp, 2

	mov	ax, 88h	
	push	ax
	call	vm_removeItem
	add	sp, 2

	mov	ax, offset s_questFerofist_1
	push	ds
	push	ax
	call	printStringWithWait
	add	sp, 4
	mov	ax, offset s_questFerofist_2
	push	ds
	push	ax
	call	printStringWithWait
	add	sp, 4
	mov	ax, offset s_questFerofist_3
	push	ds
	push	ax
	call	printStringWithWait
	add	sp, 4
	mov	ax, offset s_questFerofist_4
	push	ds
	push	ax
	call	printStringWithWait
	add	sp, 4

	mov	ax, 0FFh
	push	ax
	mov	ax, 3Fh	
	push	ax
	call	_updateFlags
	add	sp, 4

	mov	ax, quest_ferofistActive
	push	ax
	call	quest_setFlag
	add	sp, 2

	mov	ax, quest_alliriaActive
	push	ax
	call	quest_setFlag
	add	sp, 2
	mov	ax, 1
	jmp	short l_return

l_returnZero:
	sub	ax, ax

l_return:
	mov	sp, bp
	pop	bp
	retf
review_questFerofist endp

; Attributes: bp-based frame

review_questSceadu proc far
	push	bp
	mov	bp, sp

	mov	ax, quest_sceaduActive
	push	ax
	call	quest_partyNotHasFlagSet
	add	sp, 2
	or	ax, ax
	jz	l_returnZero

	mov	ax, quest_sceaduDone
	push	ax
	call	quest_partyNotHasFlagSet
	add	sp, 2
	or	ax, ax
	jz	l_returnZero

	mov	ax, 98h	
	push	ax
	call	vm_findItem
	add	sp, 2
	or	ax, ax
	jz	l_returnZero

	mov	ax, 99h	
	push	ax
	call	vm_findItem
	add	sp, 2
	or	ax, ax
	jz	short l_returnZero

	mov	ax, 98h	
	push	ax
	call	vm_removeItem
	add	sp, 2

	mov	ax, 99h	
	push	ax
	call	vm_removeItem
	add	sp, 2

	mov	ax, offset s_questSceadu_1
	push	ds
	push	ax
	call	printStringWithWait
	add	sp, 4
	mov	ax, offset s_questSceadu_2
	push	ds
	push	ax
	call	printStringWithWait
	add	sp, 4
	mov	ax, offset s_questSceadu_3
	push	ds
	push	ax
	call	printStringWithWait
	add	sp, 4
	mov	ax, offset s_questSceadu_4
	push	ds
	push	ax
	call	printStringWithWait
	add	sp, 4

	mov	ax, 0FFh
	push	ax
	mov	ax, 3Fh	
	push	ax
	call	_updateFlags
	add	sp, 4

	mov	ax, quest_ferofistActive
	push	ax
	call	quest_setFlag
	add	sp, 2

	mov	ax, quest_sceaduActive
	push	ax
	call	quest_setFlag
	add	sp, 2

	mov	ax, 1
	jmp	short l_return

l_returnZero:
	sub	ax, ax

l_return:
	mov	sp, bp
	pop	bp
	retf
review_questSceadu endp

; Attributes: bp-based frame

review_questWerra proc far
	push	bp
	mov	bp, sp

	mov	ax, quest_werraDone
	push	ax
	call	quest_partyNotHasFlagSet
	add	sp, 2
	or	ax, ax
	jz	l_returnZero

	mov	ax, quest_werraActive
	push	ax
	call	quest_partyNotHasFlagSet
	add	sp, 2
	or	ax, ax
	jz	l_returnZero

	mov	ax, 9Ch	
	push	ax
	call	vm_findItem
	add	sp, 2
	or	ax, ax
	jz	l_returnZero

	mov	ax, 9Dh	
	push	ax
	call	vm_findItem
	add	sp, 2
	or	ax, ax
	jz	short l_returnZero

	mov	ax, 9Ch	
	push	ax
	call	vm_removeItem
	add	sp, 2

	mov	ax, 9Dh	
	push	ax
	call	vm_removeItem
	add	sp, 2

	mov	ax, offset s_questWerra_1
	push	ds
	push	ax
	call	printStringWithWait
	add	sp, 4
	mov	ax, offset s_questWerra_2
	push	ds
	push	ax
	call	printStringWithWait
	add	sp, 4
	mov	ax, offset s_questWerra_3
	push	ds
	push	ax
	call	printStringWithWait
	add	sp, 4
	mov	ax, offset s_questWerra_4
	push	ds
	push	ax
	call	printStringWithWait
	add	sp, 4

	mov	ax, 0FFh
	push	ax
	mov	ax, 3Fh	
	push	ax
	call	_updateFlags
	add	sp, 4

	mov	ax, quest_werraActive
	push	ax
	call	quest_setFlag
	add	sp, 2

	mov	ax, quest_sceaduActive
	push	ax
	call	quest_setFlag
	add	sp, 2

	mov	ax, 1
	jmp	short l_return

l_returnZero:
	sub	ax, ax

l_return:
	mov	sp, bp
	pop	bp
	retf
review_questWerra endp

; Attributes: bp-based frame

review_questTarjan proc far

	loopCounter= word ptr	-2

	push	bp
	mov	bp, sp
	mov	ax, 2
	call	someStackOperation
	push	si

	mov	ax, 0FFh
	push	ax
	mov	ax, 3Eh	
	push	ax
	call	_updateFlags
	add	sp, 4

	mov	ax, quest_tarjanDone
	push	ax
	call	quest_partyNotHasFlagSet
	add	sp, 2
	or	ax, ax
	jz	l_returnZero

	mov	ax, quest_tarjanActive
	push	ax
	call	quest_partyNotHasFlagSet
	add	sp, 2
	or	ax, ax
	jz	l_returnZero

	sub	ax, ax
	push	ax
	mov	ax, 3Eh	
	push	ax
	call	_updateFlags
	add	sp, 4

	mov	ax, 0A0h 
	push	ax
	call	vm_findItem
	add	sp, 2
	or	ax, ax
	jz	l_returnZero

	mov	ax, 0FFh
	push	ax
	mov	ax, 3Eh	
	push	ax
	call	_updateFlags
	add	sp, 4

	mov	ax, offset s_questTarjan_1
	push	ds
	push	ax
	call	printStringWithWait
	add	sp, 4
	mov	ax, offset s_questTarjan_2
	push	ds
	push	ax
	call	printStringWithWait
	add	sp, 4
	mov	ax, offset s_questTarjan_3
	push	ds
	push	ax
	call	printStringWithWait
	add	sp, 4
	mov	ax, offset s_questTarjan_4
	push	ds
	push	ax
	call	printStringWithWait
	add	sp, 4

	mov	ax, 4Ah	
	push	ax
	call	bigpic_drawPictureNumber
	add	sp, 2

	mov	ax, offset s_questTarjan_5
	push	ds
	push	ax
	call	printStringWithWait
	add	sp, 4

	mov	ax, quest_werraActive
	push	ax
	call	quest_setFlag
	add	sp, 2

	mov	ax, quest_tarjanActive
	push	ax
	call	quest_setFlag
	add	sp, 2

	mov	ax, 0FFh
	push	ax
	mov	ax, 46h	
	push	ax
	call	_updateFlags
	add	sp, 4

	mov	[bp+loopCounter], 0
l_loop:
	mov	ax, charSize
	imul	[bp+loopCounter]
	mov	si, ax
	cmp	byte ptr gs:party._name[si], 0
	jz	short l_next
	cmp	gs:party.class[si], class_chronomancer
	jnz	short l_next
	mov	ax, 68h	
	push	ax
	push	[bp+loopCounter]
	call	character_learnSpell
	add	sp, 4

	mov	ax, 69h	
	push	ax
	push	[bp+loopCounter]
	call	character_learnSpell
	add	sp, 4

l_next:
	inc	[bp+loopCounter]
	cmp	[bp+loopCounter], 7
	jge	short l_returnOne

l_returnOne:
	mov	ax, 1
	jmp	short l_return

l_returnZero:
	sub	ax, ax

l_return:
	pop	si
	mov	sp, bp
	pop	bp
	retf
review_questTarjan endp

; Attributes: bp-based frame

review_quest proc far

	loopCounter= word ptr -2

	push	bp
	mov	bp, sp
	mov	ax, 2
	call	someStackOperation

	mov	[bp+loopCounter], 0

l_loop:
	mov	bx, [bp+loopCounter]
	shl	bx, 1
	shl	bx, 1
	call	questFuncs[bx]
	or	ax, ax
	jz	short l_next

	push	[bp+loopCounter]
	push	cs
	call	near ptr review_questPartySetFlag
	add	sp, 2

	cmp	[bp+loopCounter], 2
	jl	short l_next
	cmp	[bp+loopCounter], 7
	jge	short l_next
	call	review_questAwardXp
l_next:
	inc	[bp+loopCounter]
	cmp	[bp+loopCounter], 8
	jl	short l_loop

l_return:
	mov	sp, bp
	pop	bp
	retf
review_quest endp

; Attributes: bp-based frame

review_questAwardXp proc far

	slotNumber= word ptr	-2

	push	bp
	mov	bp, sp
	mov	ax, 2
	call	someStackOperation
	push	si

	mov	ax, offset s_questAwardXp_1
	push	ds
	push	ax
	call	printStringWithWait
	add	sp, 4
	mov	ax, offset s_questAwardXp_2
	push	ds
	push	ax
	call	printStringWithWait
	add	sp, 4

	mov	[bp+slotNumber], 0
l_loop:
	mov	ax, charSize
	imul	[bp+slotNumber]
	mov	si, ax
	cmp	gs:party.class[si], class_monster
	jnb	short l_next
	test	gs:party.status[si], 4
	jnz	short l_next
	mov	ax, word ptr gs:party.experience[si]
	mov	dx, word ptr gs:(party.experience+2)[si]
	add	ax, 27C0h
	adc	dx, 9

	; Comment out the maximum check for Xp. It sets Xp
	; to 16 million which is too low for a maximum.
;	push	dx
;	push	ax
;	push	cs
;	call	near ptr lib_maxFFFFFF
;	add	sp, 4

	mov	word ptr gs:party.experience[si], ax
	mov	word ptr gs:(party.experience+2)[si], dx
	mov	ax, charSize
	imul	[bp+slotNumber]
	mov	si, ax
	mov	ax, gs:party.maxSppt[si]
	mov	gs:party.currentSppt[si], ax

l_next:
	inc	[bp+slotNumber]
	cmp	[bp+slotNumber], 7
	jl	short l_loop

l_return:
	mov	byte ptr g_printPartyFlag,	0
	pop	si
	mov	sp, bp
	pop	bp
	retf
review_questAwardXp endp

; Attributes: bp-based frame

review_questPartySetFlag proc far

	questDataP= dword ptr -6
	slotNumber= word ptr	-2
	questIndex= word ptr	 6

	push	bp
	mov	bp, sp
	mov	ax, 6
	call	someStackOperation
	push	di
	push	si

	mov	[bp+slotNumber], 0
l_loop:
	mov	ax, charSize
	imul	[bp+slotNumber]
	mov	si, ax
	cmp	gs:party.class[si], class_monster
	jz	short l_next

	mov	bx, [bp+questIndex]
	mov	al, g_questByteList[bx]
	sub	ah, ah
	add	ax, si
	add	ax, offset party.chronoQuest
	mov	word ptr [bp+questDataP], ax
	mov	word ptr [bp+questDataP+2], seg seg027
	mov	al, g_questMaskList[bx]
	sub	ah, ah
	lfs	bx, [bp+questDataP]
	mov	cl, fs:[bx]
	sub	ch, ch
	test	ax, cx
	jnz	short l_next
	mov	di, [bp+questIndex]
	mov	al, g_questMaskList[di]
	or	fs:[bx], al
l_next:
	inc	[bp+slotNumber]
	cmp	[bp+slotNumber], 7
	jl	short l_loop

l_return:
	pop	si
	pop	di
	mov	sp, bp
	pop	bp
	retf
review_questPartySetFlag endp

; Attributes: bp-based frame

review_removeAgeStatus proc far

	savedStatus= word ptr	-2
	slotNumber= word ptr	 6

	push	bp
	mov	bp, sp
	mov	ax, 2
	call	someStackOperation
	push	si

	mov	ax, charSize
	imul	[bp+slotNumber]
	mov	si, ax
	mov	al, gs:party.status[si]
	sub	ah, ah
	and	ax, 2
	mov	[bp+savedStatus], ax
	or	ax, ax
	jz	short l_return
	mov	ax, 5
	push	ax
	lea	ax, party.strength[si]
	mov	dx, seg	seg027
	push	dx
	push	ax
	lea	ax, party.savedST[si]
	push	dx
	push	ax
	call	character_applyAgeStatus
	add	sp, 0Ah
	mov	ax, charSize
	imul	[bp+slotNumber]
	mov	bx, ax
	and	gs:party.status[bx], 0FDh

l_return:
	mov	ax, [bp+savedStatus]
	pop	si
	mov	sp, bp
	pop	bp
	retf
review_removeAgeStatus endp

; Attributes: bp-based frame

review_resetAgeStatus proc far

	slotNumber=	word ptr  6

	push	bp
	mov	bp, sp
	push	si

	mov	ax, charSize
	imul	[bp+slotNumber]
	mov	si, ax
	mov	ax, 5
	push	ax
	lea	ax, party.savedST[si]
	mov	dx, seg	seg027
	push	dx
	push	ax
	lea	ax, party.strength[si]
	push	dx
	push	ax
	call	character_applyAgeStatus
	add	sp, 0Ah
	mov	ax, charSize
	imul	[bp+slotNumber]
	mov	bx, ax
	or	gs:party.status[bx], stat_old
	pop	si
	mov	sp, bp
	pop	bp
	retf
review_resetAgeStatus endp

; Attributes: bp-based frame
wizardHall_enter proc	far

	loopCounter= word ptr	-6
	inKey= word ptr	-4
	mouseMask= word ptr	-2

	push	bp
	mov	bp, sp
	mov	ax, 6
	call	someStackOperation

	mov	ax, offset s_guild
	push	ds
	push	ax
	call	setTitle
	add	sp, 4

	mov	ax, 36h	
	push	ax
	call	bigpic_drawPictureNumber
	add	sp, 2

l_hallLoop:
	mov	ax, offset s_hallOfWizards
	push	ds
	push	ax
	call	printStringWClear
	add	sp, 4

	mov	[bp+mouseMask], 0
	mov	[bp+loopCounter], 0
l_mouseLoop:
	mov	bl, gs:txt_numLines
	sub	bh, bh
	sub	bx, [bp+loopCounter]
	shl	bx, 1
	mov	ax, bitMask16bit[bx]
	or	[bp+mouseMask], ax
	inc	[bp+loopCounter]
	cmp	[bp+loopCounter], 4
	jl	short l_mouseLoop

	push	[bp+mouseMask]
	call	getKey
	add	sp, 2
	add	sp, 2
	mov	[bp+inKey], ax
	cmp	ax, 10Eh
	jl	short l_keySwitch
	cmp	ax, 119h
	jg	short l_keySwitch
	mov	al, gs:txt_numLines
	sub	ah, ah
	sub	ax, 3
	sub	[bp+inKey], ax

l_keySwitch:
	mov	ax, [bp+inKey]
	cmp	ax, 'A'	
	jz	short l_advance
	cmp	ax, 'B'	
	jz	short l_buySpell
	cmp	ax, 'S'	
	jz	short l_acquireSpell
	cmp	ax, 10Eh
	jz	short l_advance
	cmp	ax, 10Fh
	jz	short l_acquireSpell
	cmp	ax, 110h
	jz	short l_buySpell
	cmp	[bp+inKey], 'E'	
	jz	short l_return
	cmp	[bp+inKey], 111h
	jz	short l_return
	jmp	l_hallLoop

l_advance:
	mov	ax, 1
	push	ax
	push	cs
	call	near ptr review_checkXp
	add	sp, 2
	mov	byte ptr g_printPartyFlag,	0
	jmp	l_hallLoop

l_acquireSpell:
	mov	ax, 1
	push	ax
	push	cs
	call	near ptr review_learnSpells
	add	sp, 2
	mov	byte ptr g_printPartyFlag,	0
	jmp	l_hallLoop

l_buySpell:
	push	cs
	call	near ptr wizardHall_buySpell
	mov	byte ptr g_printPartyFlag,	0
	jmp	l_hallLoop

l_return:
	sub	ax, ax
	mov	sp, bp
	pop	bp
	retf
wizardHall_enter endp

; Attributes: bp-based frame
;
; DWORD var_104 & var_106

wizardHall_buySpell proc far

	var_10A= word ptr -10Ah
	payeeSlotNumber= word ptr -108h
	var_106= word ptr -106h
	var_104= word ptr -104h
	slotNumber= word ptr -102h
	stringBuffer= word ptr -100h

	push	bp
	mov	bp, sp
	mov	ax, 10Ah
	call	someStackOperation
	push	si

	mov	ax, offset s_buySpellPrompt
	push	ds
	push	ax
	call	printStringWClear
	add	sp, 4
	call	readSlotNumber
	mov	[bp+slotNumber], ax
	or	ax, ax
	jl	l_return

	mov	ax, charSize
	imul	[bp+slotNumber]
	mov	bx, ax
	mov	bl, gs:party.class[bx]
	sub	bh, bh
	cmp	mageSpellIndex[bx], 0FFh
	jnz	short l_isSpellcaster
	mov	ax, offset s_thouArtNotASpellcaster
	push	ds
	push	ax
	call	printStringWClear
	add	sp, 4
	mov	ax, 4000h
	push	ax
	call	getKey
	add	sp, 2
	jmp	l_return

l_isSpellcaster:
	mov	ax, g_locationNumber
	cmp	ax, 3
	jz	short loc_24C1A
	cmp	ax, 6
	jz	short loc_24C22
	jmp	short loc_24C2A

loc_24C1A:
	mov	[bp+var_10A], 0
	jmp	short loc_24C3E

loc_24C22:
	mov	[bp+var_10A], 1
	jmp	short loc_24C3E

loc_24C2A:
	mov	[bp+var_10A], 2
	jmp	short loc_24C3E

loc_24C3E:
	mov	ax, offset s_thouMayLearn
	push	ds
	push	ax
	lea	ax, [bp+stringBuffer]
	push	ss
	push	ax
	call	strcat
	add	sp, 8
	mov	[bp+var_106], ax
	mov	[bp+var_104], dx
	mov	bx, [bp+var_10A]
	shl	bx, 1
	shl	bx, 1
	push	word ptr (g_spellsForSaleList+2)[bx]
	push	word ptr g_spellsForSaleList[bx]
	push	dx
	push	ax
	call	strcat
	add	sp, 8
	mov	[bp+var_106], ax
	mov	[bp+var_104], dx
	sub	ax, ax
	push	ax
	mov	bx, [bp+var_10A]
	shl	bx, 1
	shl	bx, 1
	push	word ptr (g_spellsForSalePrice+2)[bx]
	push	word ptr g_spellsForSalePrice[bx]
	push	dx
	push	[bp+var_106]
	call	itoa
	add	sp, 0Ah
	mov	[bp+var_106], ax
	mov	[bp+var_104], dx
	mov	ax, offset s_inGoldWhoWillPay
	push	ds
	push	ax
	push	dx
	push	[bp+var_106]
	call	strcat
	add	sp, 8
	mov	[bp+var_106], ax
	mov	[bp+var_104], dx
	lea	ax, [bp+stringBuffer]
	push	ss
	push	ax
	call	printStringWClear
	add	sp, 4
	call	readSlotNumber
	mov	[bp+payeeSlotNumber], ax
	or	ax, ax
	jl	l_return

	mov	bx, [bp+var_10A]
	shl	bx, 1
	shl	bx, 1
	mov	ax, word ptr g_spellsForSalePrice[bx]
	mov	dx, word ptr (g_spellsForSalePrice+2)[bx]
	mov	cx, ax
	mov	bx, dx
	mov	ax, charSize
	imul	[bp+payeeSlotNumber]
	mov	si, ax
	cmp	word ptr gs:(party.gold+2)[si], bx
	ja	short l_pay
	jb	short l_notEnoughGold
	cmp	word ptr gs:party.gold[si], cx
	jnb	short l_pay

l_notEnoughGold:
	mov	ax, offset s_notEnoughGoldNl
	push	ds
	push	ax
	call	printStringWClear
	add	sp, 4
	mov	ax, 4000h
	push	ax
	call	getKey
	add	sp, 2
	jmp	short l_return

l_pay:
	mov	bx, [bp+var_10A]
	shl	bx, 1
	shl	bx, 1
	mov	ax, word ptr g_spellsForSalePrice[bx]
	mov	dx, word ptr (g_spellsForSalePrice+2)[bx]
	mov	cx, ax
	mov	bx, dx
	mov	ax, charSize
	imul	[bp+payeeSlotNumber]
	mov	si, ax
	sub	word ptr gs:party.gold[si], cx
	sbb	word ptr gs:(party.gold+2)[si], bx
	mov	ax, [bp+var_10A]
	add	ax, 7Ah	
	push	ax
	push	[bp+slotNumber]
	call	character_learnSpell
	add	sp, 4
	mov	ax, offset s_eldersTeachLore
	push	ds
	push	ax
	call	printStringWClear
	add	sp, 4
	mov	ax, 5
	push	ax
	call	text_delayNoTable
	add	sp, 2

l_return:
	pop	si
	mov	sp, bp
	pop	bp
	retf
wizardHall_buySpell endp


seg012 ends

; Segment type: Pure code
seg013 segment byte public 'CODE' use16
        assume cs:seg013
;org 4
        assume es:nothing, ss:nothing, ds:dseg, fs:nothing, gs:seg027

; Attributes: bp-based frame

dunsq_battleCheck proc far

	var_2= word ptr	-2

	push	bp
	mov	bp, sp
	mov	ax, 2
	call	someStackOperation

	call	random
	and	ax, 80h
	mov	[bp+var_2], ax
	or	ax, ax
	jz	short loc_24DA7
	inc	byte_4EECC

	; Add code to mask the encounter out
	mov	ax, 7Fh
	push	ax
	mov	ax, 2
	push	ax
	push	sq_east
	push	sq_north
	call	dun_maskSquare
	add	sp, 8

loc_24DA7:
	mov	ax, [bp+var_2]
	mov	sp, bp
	pop	bp
	retf
dunsq_battleCheck endp


; Attributes: bp-based frame

dunsq_doTrap proc far

	var_10C= word ptr -10Ch
	var_10A= word ptr -10Ah
	var_108= word ptr -108h
	var_106= word ptr -106h
	var_104= word ptr -104h
	var_102= word ptr -102h
	stringBuffer= word ptr -100h

	push	bp
	mov	bp, sp
	mov	ax, 10Ch
	call	someStackOperation
	push	si

	push	cs
	call	near ptr trap_levitationCheck
	mov	[bp+var_102], ax
	or	ax, ax
	jz	l_return

loc_24DCB:
	call	random
	and	ax, 3
	mov	[bp+var_10A], ax
	cmp	ax, 3
	jz	short loc_24DCB

	mov	al, g_levelNumber
	sub	ah, ah
	and	ax, 7
	shl	ax, 1
	shl	ax, 1
	or	ax, [bp+var_10A]
	mov	gs:trapIndex, ax
	mov	ax, offset s_hitTrap
	push	ds
	push	ax
	lea	ax, [bp+stringBuffer]
	push	ss
	push	ax
	call	strcat
	add	sp, 8
	mov	[bp+var_106], ax
	mov	[bp+var_104], dx
	mov	bx, gs:trapIndex
	mov	al, g_trapIndexByLevel[bx]
	cbw
	mov	bx, ax
	shl	bx, 1
	shl	bx, 1
	push	word ptr (trapTypeString+2)[bx]
	push	word ptr trapTypeString[bx]
	push	dx
	push	[bp+var_106]
	call	strcat
	add	sp, 8
	mov	[bp+var_106], ax
	mov	[bp+var_104], dx
	lea	ax, [bp+stringBuffer]
	push	ss
	push	ax
	call	printStringWClear
	add	sp, 4
	mov	bx, gs:trapIndex
	mov	al, byte_4B258[bx]
	cbw
	push	ax
	call	randomYdX
	add	sp, 2
	mov	[bp+var_10C], ax

	mov	si, gs:trapIndex
	shl	si, 1
	mov	al, trapSaveList._low[si]
	mov	gs:monGroups.breathSaveLo, al
	mov	al, trapSaveList._high[si]
	mov	gs:monGroups.breathSaveHi, al

	mov	[bp+var_108], 0
loc_24E97:
	push	[bp+var_10C]
	push	[bp+var_108]
	call	trap_doDamage
	add	sp, 4
	inc	[bp+var_108]
	cmp	[bp+var_108], 7
	jl	short loc_24E97

l_return:
	mov	byte ptr g_printPartyFlag, 0
	sub	ax, ax
	push	ax
	push	sq_east
	push	sq_north
	call	spGeo_removeTrap
	add	sp, 6
	mov	ax, [bp+var_102]

	pop	si
	mov	sp, bp
	pop	bp
	retf
dunsq_doTrap endp

; Attributes: bp-based frame

trap_doDamage proc far

	var_2= word ptr	-2
	arg_0= word ptr	 6
	arg_2= word ptr	 8

	push	bp
	mov	bp, sp
	mov	ax, 2
	call	someStackOperation
	push	si

	mov	ax, charSize
	imul	[bp+arg_0]
	mov	si, ax
	cmp	byte ptr gs:party._name[si], 0
	jz	short l_return
	test	gs:party.status[si], stat_dead
	jnz	short l_return
	mov	al, byte ptr [bp+arg_0]
	mov	gs:bat_curTarget, al
	mov	bx, gs:trapIndex
	mov	al, trapSpecialAttackValue[bx]
	and	ax, 7Fh
	mov	gs:specialAttackVal, ax
	mov	ax, [bp+arg_2]
	mov	gs:damageAmount, ax
	sub	ax, ax
	push	ax
	mov	ax, 80h
	push	ax
	call	savingThrowCheck
	add	sp, 4
	mov	[bp+var_2], ax
	or	ax, ax
	jz	short l_return
	mov	ax, 1
	mov	[bp+var_2], ax
	sar	gs:damageAmount, 1
	push	[bp+arg_0]
	call	bat_damageHp
	add	sp, 2
l_return:
	pop	si
	mov	sp, bp
	pop	bp
	retf
trap_doDamage endp


; Attributes: bp-based frame

trap_levitationCheck proc far
	push	bp
	mov	bp, sp

	cmp	levitationDuration, 0
	jz	short l_returnOne

	call	random
	and	al, 3
	mov	cx, ax
	cmp	cl, 1
	sbb	ax, ax
	neg	ax
	jmp	short l_return
l_returnOne:
	mov	ax, 1
l_return:
	mov	sp, bp
	pop	bp
	retf
trap_levitationCheck endp

; Attributes: bp-based frame

dunsq_doDarkness proc far
	push	bp
	mov	bp, sp

	cmp	lightDuration, 0
	jz	short l_checkLightSong
	sub	ax, ax
	push	ax
	call	icon_deactivate
	add	sp, 2
l_checkLightSong:
	mov	lightDistance, 0
	cmp	gs:g_currentSongPlusOne, 0
	jz	short l_return
	cmp	gs:g_currentSong, 5
	jnz	short l_return
	call	endNoncombatSong

l_return:
	mov	ax, offset s_darkness
	push	ds
	push	ax
	call	printStringWClear
	add	sp, 4
	sub	ax, ax

	mov	sp, bp
	pop	bp
	retf
dunsq_doDarkness endp

; Attributes: bp-based frame

dunsq_doSpinner	proc far

	slotNumber= word ptr	-2

	push	bp
	mov	bp, sp
	mov	ax, 2
	call	someStackOperation

	mov	[bp+slotNumber], 0
l_loop:
	mov	ax, itemEff_noSpin
	push	ax
	push	[bp+slotNumber]
	call	character_isEffectEquipped
	add	sp, 4
	or	ax, ax
	jz	short l_returnOne
	inc	[bp+slotNumber]
	cmp	[bp+slotNumber], 7
	jl	l_loop

	call	random
	and	ax, 3
	mov	g_direction, ax
	sub	ax, ax
	jmp	short l_return

l_returnOne:
	mov	ax, 1

l_return:
	mov	sp, bp
	pop	bp
	retf
dunsq_doSpinner	endp

; Attributes: bp-based frame

dunsq_antiMagic	proc far

	l_effectIndex= word ptr	-2

	push	bp
	mov	bp, sp
	mov	ax, 2
	call	someStackOperation

	inc	gs:sq_antiMagicFlag

	; Change to 1 to skip over lightDuration
	mov	[bp+l_effectIndex], 1
l_loop:
	mov	bx, [bp+l_effectIndex]
	cmp	lightDuration[bx], 0
	jz	short l_next
	push	[bp+l_effectIndex]
	call	icon_deactivate
	add	sp, 2

l_next:
	inc	[bp+l_effectIndex]
	cmp	[bp+l_effectIndex], 5
	jl	short l_loop


	mov	byte ptr g_printPartyFlag, 0
	sub	ax, ax
	mov	sp, bp
	pop	bp
	retf
dunsq_antiMagic	endp

; Attributes: bp-based frame

dunsq_drainHp proc far

	slotNumber= word ptr	-2

	push	bp
	mov	bp, sp
	mov	ax, 2
	call	someStackOperation
	push	di
	push	si

	mov	[bp+slotNumber], 0
l_loop:
	mov	ax, charSize
	imul	[bp+slotNumber]
	mov	si, ax
	test	gs:party.status[si], stat_dead	or stat_stoned
	jnz	short l_next
	mov	al, g_levelNumber
	sub	ah, ah
	mov	di, ax
	cmp	gs:party.currentHP[si], di
	jbe	short l_killCharacter
	sub	gs:party.currentHP[si], di
	jmp	short l_next
l_killCharacter:
	mov	ax, charSize
	imul	[bp+slotNumber]
	mov	si, ax
	mov	gs:party.currentHP[si], 0
	or	gs:party.status[si], stat_dead
l_next:
	inc	[bp+slotNumber]
	cmp	[bp+slotNumber], 7
	jl	short l_loop

	call	party_getLastSlot
	cmp	ax, 7
	jle	short l_return
	mov	g_mapRval, 5
l_return:
	mov	byte ptr g_printPartyFlag, 0
	sub	ax, ax

	pop	si
	pop	di
	mov	sp, bp
	pop	bp
	retf
dunsq_drainHp endp

party_regenHp	proc far
	push		cx
	xor		cx, cx

l_loop:
	mov	ax, charSize
	imul	cx
	mov	bx, ax
	test		gs:party.status[si], stat_dead or stat_stoned
	jnz		l_next
	mov		al, g_levelNumber
	sub		ah, ah
	add		gs:party.currentHP[bx], ax
	mov		ax, gs:party.maxHP[bx]
	cmp		party.currentHP[bx], ax
	jbe		l_next
	mov		gs:party.currentHP[bx], ax

l_next:
	inc		cx
	cmp		cx, 7
	jl		l_loop

	pop		cx
	retf
party_regenHp	endp

; Attributes: bp-based frame
dunsq_somethingOdd proc	far
	push	bp
	mov	bp, sp
	sub	al, al
	mov	g_detectType, al
	mov	gs:gl_detectSecretDoorFlag, al
	sub	ax, ax
	mov	sp, bp
	pop	bp
	retf
dunsq_somethingOdd endp

; Attributes: bp-based frame

dunsq_doSilence	proc far
	push	bp
	mov	bp, sp

	cmp	gs:g_currentSongPlusOne, 0
	jz	short l_return
	mov	ax, offset s_soundOfSilence
	push	ds
	push	ax
	call	printStringWClear
	add	sp, 4
	call	endNoncombatSong
l_return:
	sub	ax, ax
	mov	sp, bp
	pop	bp
	retf
dunsq_doSilence	endp


; Attributes: bp-based frame

dunsq_regenSppt	proc far
	push	bp
	mov	bp, sp
	inc	gs:regenSpptSq
	sub	ax, ax
	mov	sp, bp
	pop	bp
	retf
dunsq_regenSppt	endp

; Attributes: bp-based frame

dunsq_drainSppt	proc far

	slotNumber= word ptr	-2

	push	bp
	mov	bp, sp
	mov	ax, 2
	call	someStackOperation

	mov	[bp+slotNumber], 0
l_loop:
	call	random
	and	ax, 3
	mov	cl, g_levelNumber
	sub	ch, ch
	add	ax, cx
	mov	cx, ax

	mov	ax, charSize
	imul	[bp+slotNumber]
	mov	bx, ax
	cmp	gs:party.currentSppt[bx], cx
	jbe	short l_zeroSppt

	mov	ax, charSize
	imul	[bp+slotNumber]
	mov	bx, ax
	sub	gs:party.currentSppt[bx], cx
	jmp	short l_next

l_zeroSppt:
	mov	ax, charSize
	imul	[bp+slotNumber]
	mov	bx, ax
	mov	gs:party.currentSppt[bx], 0

l_next:
	inc	[bp+slotNumber]
	cmp	[bp+slotNumber], 7
	jl	short l_loop

	mov	byte ptr g_printPartyFlag,	0
	sub	ax, ax
	mov	sp, bp
	pop	bp
	retf
dunsq_drainSppt	endp

; Attributes: bp-based frame

dunsq_monHostile proc far

	var_2= word ptr	-2

	push	bp
	mov	bp, sp
	mov	ax, 2
	call	someStackOperation

	mov	[bp+var_2], 0
l_checkEffectLoop:
	mov	ax, itemEff_calmMonster
	push	ax
	push	[bp+var_2]
	call	character_isEffectEquipped
	add	sp, 4
	or	ax, ax
	jz	short l_returnOne
	inc	[bp+var_2]
	cmp	[bp+var_2], 7
	jl	short l_checkEffectLoop

	mov	[bp+var_2], 0
l_makeHostileLoop:
	mov	ax, charSize
	imul	[bp+var_2]
	mov	bx, ax
	cmp	gs:party.class[bx], class_monster

	; FIXED - Was jz. This activated the square when there were no monsters
	; in the party.
	jnz	short l_makeHostileNext

	call	random
	test	al, 3
	jnz	short l_makeHostileNext
	mov	ax, charSize
	imul	[bp+var_2]
	mov	bx, ax
	mov	gs:party.hostileFlag[bx], 1
	mov	byte_4EECC, 1

l_makeHostileNext:
	inc	[bp+var_2]
	cmp	[bp+var_2], 7
	jl	short l_makeHostileLoop

l_returnOne:
	mov	ax, 1
l_return:
	mov	ax, 7Fh
	push	ax
	mov	ax, 3
	push	ax
	push	sq_east
	push	sq_north
	call	dun_maskSquare
	add	sp, 8

	mov	sp, bp
	pop	bp
	retf
dunsq_monHostile endp

; Attributes: bp-based frame

dunsq_doStuck proc far
	push	bp
	mov	bp, sp
	call	random
	and	al, 3
	mov	gs:stuckFlag, al
	sub	ax, ax
	mov	sp, bp
	pop	bp
	retf
dunsq_doStuck endp

; Attributes: bp-based frame

dunsq_regenHP proc far
	push	bp
	mov	bp, sp
	inc	gs:sqRegenHPFlag
	mov	sp, bp
	pop	bp
	retf
dunsq_regenHP endp

; Attributes: bp-based frame

dunsq_explosion proc far
	push	bp
	mov	bp, sp
	cmp	lightDuration, 0
	jz	short l_return
	mov	ax, offset s_explosion
	push	ds
	push	ax
	call	printStringWClear
	add	sp, 4
	push	cs
	call	near ptr dunsq_drainHp
l_return:
	mov	ax, 1
	mov	sp, bp
	pop	bp
	retf
dunsq_explosion endp

; Attributes: bp-based frame

dunsq_portalAbove proc far
	push	bp
	mov	bp, sp
	mov	ax, offset s_portalAbove
	push	ds
	push	ax
	call	printStringWClear
	add	sp, 4
	mov	sp, bp
	pop	bp
	retf
dunsq_portalAbove endp

; Attributes: bp-based frame

dunsq_portalBelow proc far
	push	bp
	mov	bp, sp
	mov	ax, offset s_portalBelow
	push	ds
	push	ax
	call	printStringWClear
	add	sp, 4
	mov	sp, bp
	pop	bp
	retf
dunsq_portalBelow endp


; Attributes: bp-based frame

dun_doSpecialSquare proc far

	counter= word ptr -6
	squareDataP= dword ptr -4
	rowBuf=	dword ptr  6
	sqEast=	word ptr  0Ah
	sqNorth= word ptr  0Ch

	push	bp
	mov	bp, sp
	mov	ax, 6
	call	someStackOperation
	push	si

	sub	al, al
	mov	gs:sqRegenHPFlag, al
	mov	gs:stuckFlag, al
	mov	gs:sq_antiMagicFlag, al
	mov	gs:regenSpptSq,	al
	mov	byte_4EECC, al
	mov	bx, [bp+sqNorth]
	shl	bx, 1
	shl	bx, 1
	lfs	si, [bp+rowBuf]
	mov	ax, fs:[bx+si]
	mov	dx, fs:[bx+si+2]
	mov	cx, [bp+sqEast]
	mov	bx, cx
	shl	cx, 1
	shl	cx, 1
	add	cx, bx
	add	ax, cx
	add	ax, 2
	mov	word ptr [bp+squareDataP], ax
	mov	word ptr [bp+squareDataP+2], dx

	mov	[bp+counter], 0
l_loop:
	mov	bx, [bp+counter]
	mov	bl, specialSquareByteIndexList[bx]
	sub	bh, bh
	lfs	si, [bp+squareDataP]
	mov	al, fs:[bx+si]
	sub	ah, ah
	mov	bx, [bp+counter]
	mov	cl, specialSquareMaskList[bx]
	sub	ch, ch
	test	ax, cx
	jz	short l_next
	shl	bx, 1
	shl	bx, 1
	call	specialSquareFunctionList[bx]

l_next:
	inc	[bp+counter]
	cmp	[bp+counter], 10h
	jl	short l_loop

	pop	si
	mov	sp, bp
	pop	bp
	retf
dun_doSpecialSquare endp

; Attributes: bp-based frame

brilhasti_doBonus proc far

	slotNumber= word ptr	-2

	push	bp
	mov	bp, sp
	mov	ax, 2
	call	someStackOperation
	push	si

	mov	[bp+slotNumber], 0
l_loop:
	push	[bp+slotNumber]
	push	cs
	call	near ptr brilhasti_checkQuest
	add	sp, 2
	or	ax, ax
	jz	short l_next

	mov	ax, charSize
	imul	[bp+slotNumber]
	mov	bx, ax
	mov	al, gs:party.class[bx]

	or	al, al
	jz	short l_nonMagicUser

	cmp	al, 5
	jnb	short l_nonMagicUser

	push	[bp+slotNumber]
	call	brilhasti_levelMagicUser
	add	sp, 2
	jmp	short l_next

l_nonMagicUser:
	mov	ax, 34
	push	ax
	push	[bp+slotNumber]
	call	getLevelXp
	add	sp, 4
	mov	cx, ax
	mov	bx, dx
	mov	ax, charSize
	imul	[bp+slotNumber]
	mov	si, ax
	mov	word ptr gs:party.experience[si], cx
	mov	word ptr gs:(party.experience+2)[si], bx
l_next:
	inc	[bp+slotNumber]
	cmp	[bp+slotNumber], 7
	jl	short l_loop

	pop	si
	mov	sp, bp
	pop	bp
	retf
brilhasti_doBonus endp

; Attributes: bp-based frame

brilhasti_checkQuest proc far

	slotNumber= word ptr	 6

	push	bp
	mov	bp, sp

	mov	ax, charSize
	imul	[bp+slotNumber]
	mov	bx, ax
	test	gs:(party.chronoQuest+1)[bx], 1
	jnz	short l_returnZero

	mov	ax, charSize
	imul	[bp+slotNumber]
	mov	bx, ax
	cmp	gs:party.class[bx], class_monster
	jnb	short l_returnZero

	mov	ax, charSize
	imul	[bp+slotNumber]
	mov	bx, ax
	cmp	gs:party.level[bx], 35
	jnb	short l_returnZero

	mov	ax, 1
	jmp	short l_return

l_returnZero:
	sub	ax, ax

l_return:
	mov	sp, bp
	pop	bp
	retf
brilhasti_checkQuest endp

; Attributes: bp-based frame

brilhasti_levelMagicUser proc far

	spellIndex= word ptr	-2
	slotNumber= word ptr	 6

	push	bp
	mov	bp, sp
	mov	ax, 2
	call	someStackOperation
	push	si

	mov	[bp+spellIndex], 0
l_loop:
	push	[bp+spellIndex]
	push	[bp+slotNumber]
	call	character_learnSpell
	add	sp, 4
	inc	[bp+spellIndex]
	cmp	[bp+spellIndex], 74
	jl	short l_loop

loc_254C9:
	mov	ax, charSize
	imul	[bp+slotNumber]
	mov	si, ax
	mov	gs:party.class[si], class_archmage
	sub	ax, ax
	mov	word ptr gs:(party.experience+2)[si], ax
	mov	word ptr gs:party.experience[si], ax
	mov	ax, 14h
	push	ax
	lea	ax, party.strength[si]
	mov	dx, seg	seg027
	push	dx
	push	ax
	push	cs
	call	near ptr brilhasti_setAttributes
	add	sp, 6

	mov	ax, charSize
	imul	[bp+slotNumber]
	mov	bx, ax
	cmp	gs:party.maxHP[bx], 375
	jnb	short l_setSppt
	mov	ax, charSize
	imul	[bp+slotNumber]
	mov	bx, ax
	mov	gs:party.maxHP[bx], 375

l_setSppt:
	mov	ax, charSize
	imul	[bp+slotNumber]
	mov	bx, ax
	cmp	gs:party.maxSppt[bx], 350
	jnb	short l_return
	mov	ax, charSize
	imul	[bp+slotNumber]
	mov	bx, ax
	mov	gs:party.maxSppt[bx], 350

l_return:
	pop	si
	mov	sp, bp
	pop	bp
	retf
brilhasti_levelMagicUser endp

; Attributes: bp-based frame

brilhasti_setAttributes proc far

	attributeIndex= word ptr	-2
	attributeP= dword ptr  6
	attributeValue= word ptr	 0Ah

	push	bp
	mov	bp, sp
	mov	ax, 2
	call	someStackOperation
	push	si

	mov	[bp+attributeIndex], 0
l_loop:
	mov	bx, [bp+attributeIndex]
	lfs	si, [bp+attributeP]
	mov	al, fs:[bx+si]
	cbw
	cmp	ax, [bp+attributeValue]
	jge	short l_next
	mov	al, byte ptr [bp+attributeValue]
	mov	fs:[bx+si], al
l_next:
	inc	[bp+attributeIndex]
	cmp	[bp+attributeIndex], 5
	jl	short l_loop

	pop	si
	mov	sp, bp
	pop	bp
	retf
brilhasti_setAttributes endp

; Attributes: bp-based frame
geomancer_convert proc	far

	slotNumber=	word ptr  6

	push	bp
	mov	bp, sp
	push	si

	mov	ax, charSize
	imul	[bp+slotNumber]
	mov	si, ax
	mov	gs:party.class[si], class_geomancer
	sub	ax, ax
	mov	word ptr gs:(party.experience+2)[si], ax
	mov	word ptr gs:party.experience[si], ax
	mov	gs:party.level[si], 1
	mov	gs:party.maxLevel[si],	1
	mov	gs:party.currentSppt[si], 25
	mov	gs:party.maxSppt[si], 25
	mov	ax, 0Ch
	push	ax
	push	[bp+slotNumber]
	push	cs
	call	near ptr geomancer_convertEquipment
	add	sp, 4
	mov	ax, charSize
	imul	[bp+slotNumber]
	mov	bx, ax
	mov	gs:party.numAttacks[bx], 0
	mov	ax, 106
	push	ax
	push	[bp+slotNumber]
	call	character_learnSpell
	add	sp, 4
	mov	ax, 107
	push	ax
	push	[bp+slotNumber]
	call	character_learnSpell
	add	sp, 4
	mov	ax, 108
	push	ax
	push	[bp+slotNumber]
	call	character_learnSpell
	add	sp, 4
	mov	byte ptr g_printPartyFlag,	0

	pop	si
	mov	sp, bp
	pop	bp
	retf
geomancer_convert endp

; Attributes: bp-based frame

geomancer_convertEquipment proc far

	inventorySlotNumber= word ptr	-4
	newEquipableFlags= word ptr	-2
	slotNumber= word ptr	 6
	classNumber= word ptr	 8

	push	bp
	mov	bp, sp
	mov	ax, 4
	call	someStackOperation
	push	si

	mov	[bp+inventorySlotNumber], 0
l_loop:
	mov	ax, charSize
	imul	[bp+slotNumber]
	mov	si, ax
	add	si, [bp+inventorySlotNumber]
	mov	al, gs:party.inventory.itemNo[si]
	sub	ah, ah
	mov	bx, ax
	mov	al, itemEquipMask[bx]
	mov	bx, [bp+classNumber]
	mov	cl, classEquipMask[bx]
	sub	ch, ch
	test	ax, cx
	jz	short l_setUnequipable
	sub	ax, ax
	jmp	short l_setItemFlags
l_setUnequipable:
	mov	ax, 2
l_setItemFlags:
	mov	[bp+newEquipableFlags], ax
	mov	al, gs:party.inventory.itemFlags[si]
	and	al, 0FCh
	or	al, byte ptr [bp+newEquipableFlags]
	mov	gs:party.inventory.itemFlags[si], al
	add	[bp+inventorySlotNumber], 3
	cmp	[bp+inventorySlotNumber], 24h	
	jl	short l_loop

l_return:
	pop	si
	mov	sp, bp
	pop	bp
	retf
geomancer_convertEquipment endp

; Attributes: bp-based frame

dun_detectSquares proc far

	aheadFlags= word ptr -6
	detectIndex= word ptr	-2
	sqE= word ptr  6
	sqN= word ptr  8
	direction= word ptr  0Ah

	push	bp
	mov	bp, sp
	mov	ax, 6
	call	someStackOperation
	push	si

	; Return if detect spell not active
	cmp	detectDuration, 0
	jz	l_return

	; Return if current square and direction are the same as
	; the last time this function was run.
	;
	mov	al, gs:g_lastDetectSqE
	sub	ah, ah
	cmp	ax, [bp+sqE]
	jnz	short loc_256DB
	mov	al, gs:g_lastDetectSqN
	cmp	ax, [bp+sqN]
	jnz	short loc_256DB
	mov	al, gs:g_lastDetectDirection
	cmp	ax, [bp+direction]
	jz	l_return

loc_256DB:
	; Set the last detection variables
	mov	al, byte ptr [bp+sqE]
	mov	gs:g_lastDetectSqE, al
	mov	al, byte ptr [bp+sqN]
	mov	gs:g_lastDetectSqN, al
	mov	al, byte ptr [bp+direction]
	mov	gs:g_lastDetectDirection, al

	lea	ax, [bp+aheadFlags]
	push	ss
	push	ax
	push	[bp+sqN]
	push	[bp+sqE]
	push	cs
	call	near ptr detect_getSquares
	add	sp, 8
	mov	bl, g_detectType
	sub	bh, bh
	mov	al, detectByteStartList[bx]
	cbw
	mov	[bp+detectIndex], ax

l_loop:
	mov	bx, [bp+detectIndex]
	mov	al, detectByte[bx]
	sub	ah, ah
	cmp	ax, 0FFh
	jge	short l_return
	mov	si, ax
	mov	al, byte ptr [bp+si+aheadFlags]
	cbw
	mov	cl, detectMask[bx]
	sub	ch, ch
	test	ax, cx
	jz	short l_next

	mov	bx, [bp+detectIndex]
	mov	al, detectMsgIndex[bx]
	cbw
	mov	bx, ax
	shl	bx, 1
	shl	bx, 1
	push	word ptr (detectMessages+2)[bx]
	push	word ptr detectMessages[bx]
	call	printString
	add	sp, 4
l_next:
	inc	[bp+detectIndex]
	jmp	short l_loop

l_return:
	pop	si
	mov	sp, bp
	pop	bp
	retf
dun_detectSquares endp

; This function	returns	a list of the square flags
; for the three	squares	ahead.
; Attributes: bp-based frame

detect_getSquares proc far

	sqFlagP= dword ptr -8
	counter= word ptr -4
	deltaSq= word ptr -2
	sqE= word ptr  6
	sqN= word ptr  8
	rSqList= dword ptr  0Ah

	push	bp
	mov	bp, sp
	mov	ax, 8
	call	someStackOperation
	push	si

	mov	[bp+deltaSq], 0
l_zeroRvalLoop:
	mov	bx, [bp+deltaSq]
	lfs	si, [bp+rSqList]
	mov	byte ptr fs:[bx+si], 0
	inc	[bp+deltaSq]
	cmp	[bp+deltaSq], 3
	jl	short l_zeroRvalLoop

	mov	[bp+deltaSq], 0
l_outerLoop:
	mov	si, g_direction
	shl	si, 1
	mov	ax, dirDeltaE[si]
	add	[bp+sqE], ax
	mov	al, g_dunWidth
	sub	ah, ah
	push	ax
	push	[bp+sqE]
	call	wrapNumber
	add	sp, 4
	mov	[bp+sqE], ax
	mov	ax, dirDeltaN[si]
	sub	[bp+sqN], ax
	mov	al, g_dunHeight
	sub	ah, ah
	push	ax
	push	[bp+sqN]
	call	wrapNumber
	add	sp, 4
	mov	[bp+sqN], ax
	mov	bx, [bp+sqN]
	shl	bx, 1
	shl	bx, 1
	mov	ax, word ptr gs:rowOffset[bx]
	mov	dx, word ptr gs:(rowOffset+2)[bx]
	mov	cx, [bp+sqE]
	mov	bx, cx
	shl	cx, 1
	shl	cx, 1
	add	cx, bx
	add	ax, cx
	add	ax, 2
	mov	word ptr [bp+sqFlagP], ax
	mov	word ptr [bp+sqFlagP+2], dx

	mov	[bp+counter], 0
l_copyBytesLoop:
	mov	bx, [bp+counter]
	lfs	si, [bp+sqFlagP]
	mov	al, fs:[bx+si]
	lfs	si, [bp+rSqList]
	or	fs:[bx+si], al
	inc	[bp+counter]
	cmp	[bp+counter], 3
	jl	short l_copyBytesLoop

	inc	[bp+deltaSq]
	cmp	[bp+deltaSq], 3
	jl	l_outerLoop

	pop	si
	mov	sp, bp
	pop	bp
	retf
detect_getSquares endp

; Attributes: bp-based frame

dun_ascendPortal proc far

	var_4= dword ptr -4
	sqE= word ptr	 6
	sqN= word ptr	 8

	push	bp
	mov	bp, sp
	mov	ax, 4
	call	someStackOperation

	mov	bx, [bp+sqN]
	shl	bx, 1
	shl	bx, 1
	mov	ax, word ptr gs:rowOffset[bx]
	mov	dx, word ptr gs:(rowOffset+2)[bx]
	mov	cx, [bp+sqE]
	mov	bx, cx
	shl	cx, 1
	shl	cx, 1
	add	cx, bx
	add	ax, cx
	add	ax, 2
	mov	word ptr [bp+var_4], ax
	mov	word ptr [bp+var_4+2], dx
	lfs	bx, [bp+var_4]
	test	byte ptr fs:[bx], 40h		; 40h == portal above
	jz	short l_return
	cmp	levitationDuration, 0
	jz	short l_return
	test	g_levelFlags, 10h
	jz	short loc_25878
	push	cs
	call	near ptr portal_incrementLevel
	jmp	short l_return
loc_25878:
	push	cs
	call	near ptr portal_decrementLevel
l_return:
	mov	sp, bp
	pop	bp
	retf
dun_ascendPortal endp

; Attributes: bp-based frame

dun_descendPortal proc far

	var_4= dword ptr -4
	sqE= word ptr	 6
	sqN= word ptr	 8

	push	bp
	mov	bp, sp
	mov	ax, 4
	call	someStackOperation
	mov	bx, [bp+sqN]
	shl	bx, 1
	shl	bx, 1
	mov	ax, word ptr gs:rowOffset[bx]
	mov	dx, word ptr gs:(rowOffset+2)[bx]
	mov	cx, [bp+sqE]
	mov	bx, cx
	shl	cx, 1
	shl	cx, 1
	add	cx, bx
	add	ax, cx
	add	ax, 2
	mov	word ptr [bp+var_4], ax
	mov	word ptr [bp+var_4+2], dx
	lfs	bx, [bp+var_4]
	test	byte ptr fs:[bx], 20h			; 20h == portal below
	jz	short loc_258E5
	cmp	levitationDuration, 0
	jnz	short loc_258CF
	call	dunsq_drainHp
loc_258CF:
	test	g_levelFlags, 10h
	jz	short loc_258E1
	call	portal_decrementLevel
	jmp	short loc_258E5
loc_258E1:
	call	portal_incrementLevel
loc_258E5:
	mov	sp, bp
	pop	bp
	retf
dun_descendPortal endp

; Attributes: bp-based frame

portal_decrementLevel proc far
	push	bp
	mov	bp, sp
	dec	g_dunLevelNum
	jns	short l_changeLevel
	call	dun_setExitLocation
	jmp	short l_return
l_changeLevel:
	call	dun_changeLevels
l_return:
	mov	sp, bp
	pop	bp
	retf
portal_decrementLevel endp

; Attributes: bp-based frame

portal_incrementLevel proc far
	push	bp
	mov	bp, sp
	inc	g_dunLevelNum
	call	dun_changeLevels
	mov	sp, bp
	pop	bp
	retf
portal_incrementLevel endp

; Attributes: bp-based frame

wanderer_join proc far

	emptySlotNumber= word ptr	-2
	arg_0= word ptr	 6
	arg_2= word ptr	 8

	push	bp
	mov	bp, sp
	mov	ax, 2
	call	someStackOperation

	call	party_findEmptySlot
	mov	[bp+emptySlotNumber], ax

	cmp	ax, 7					; no empty slot number?
	jl	short loc_25963
	call	dropPartyMember
	or	ax, ax
	jz	short l_returnZero			; return if not dropping
	call	party_findEmptySlot
	mov	[bp+emptySlotNumber], ax
	mov	byte ptr g_printPartyFlag, 0

loc_25963:
	push	[bp+arg_2]
	push	[bp+arg_0]
	push	[bp+emptySlotNumber]
	call	_sp_convertMonToSummon
	add	sp, 6
	mov	byte ptr g_printPartyFlag, 0
	mov	ax, 1
	jmp	short l_return
l_returnZero:
	sub	ax, ax
l_return:
	mov	sp, bp
	pop	bp
	retf
wanderer_join endp

; Attributes: bp-based frame
wanderer_fight proc	far
	push	bp
	mov	bp, sp
	mov	g_monsterGroupCount, 1
	mov	gs:g_nonRandomBattleFlag, 1
	mov	byte_4EECC, 1
	mov	ax, 1
	mov	sp, bp
	pop	bp
	retf
wanderer_fight endp

; Attributes: bp-based frame
wanderer_leave proc	far
	push	bp
	mov	bp, sp
	mov	ax, 1
	mov	sp, bp
	pop	bp
	retf
wanderer_leave endp

; Attributes: bp-based frame

dun_wanderingCreature proc far

	pluralizedNameP=	dword ptr -46h
	loopCounter=	word ptr -42h
	pluralizedName=	word ptr -40h
	monsterBufferP=	dword ptr -30h
	unmaskedName=	word ptr -2Ch
	validOptionCharacters=	word ptr -1Ch
	inKey=	word ptr -16h
	validOptionMouse=	word ptr -14h
	optionList= word ptr	-8
	monsterIndex= word ptr	-2

	push	bp
	mov	bp, sp
	mov	ax, 46h
	call	someStackOperation
	push	si

l_selectMonsterRetry:
	mov	ax, 17h
	push	ax
	sub	ax, ax
	push	ax
	call	randomBetweenXandY
	add	sp, 4			; Pick a random monster to wander
	mov	[bp+monsterIndex], ax
	mov	ax, monStruSize
	imul	[bp+monsterIndex]
	add	ax, offset monsterBuf
	mov	word ptr [bp+monsterBufferP], ax
	mov	word ptr [bp+monsterBufferP+2],	seg seg023
	lfs	bx, [bp+monsterBufferP]			; Retry if
	test	fs:[bx+mon_t.flags], mon_noSummon	;	monster can't be summoned
	jnz	short l_selectMonsterRetry		; or
	cmp	byte ptr fs:[bx], 0			; 	no monster at that index
	jz	short l_selectMonsterRetry

	; Draw monster image
	mov	al, fs:[bx+mon_t.picIndex]
	sub	ah, ah
	push	ax
	call	bigpic_drawPictureNumber
	add	sp, 2

	; Set title with properly pluralized name
	lea	ax, [bp+unmaskedName]
	push	ss
	push	ax
	push	word ptr [bp+monsterBufferP+2]
	push	word ptr [bp+monsterBufferP]
	call	unmaskString
	add	sp, 8
	sub	ax, ax
	push	ax
	lea	ax, [bp+pluralizedName]
	push	ss
	push	ax
	lea	ax, [bp+unmaskedName]
	push	ss
	push	ax
	call	str_pluralize
	add	sp, 0Ah
	mov	word ptr [bp+pluralizedNameP], ax
	mov	word ptr [bp+pluralizedNameP+2], dx
	lfs	bx, [bp+pluralizedNameP]
	mov	byte ptr fs:[bx], 0
	lea	ax, [bp+pluralizedName]
	push	ss
	push	ax
	call	setTitle
	add	sp, 4

	mov	gs:monGroups.groupSize,	1
	mov	al, byte ptr [bp+monsterIndex]
	mov	byte ptr gs:monGroups._name, al

	mov	[bp+loopCounter], 0
l_setOptionListLoop:
	mov	si, [bp+loopCounter]
	mov	byte ptr [bp+si+optionList],	1
	inc	[bp+loopCounter]
	cmp	[bp+loopCounter], 5
	jl	short l_setOptionListLoop

l_ioLoop:
	call	text_clear
	lea	ax, [bp+validOptionMouse]
	push	ss
	push	ax
	lea	ax, [bp+validOptionCharacters]
	push	ss
	push	ax
	lea	ax, [bp+optionList]
	push	ss
	push	ax
	mov	ax, offset s_wandererText
	push	ds
	push	ax
	call	printVarString
	add	sp, 10h
	mov	[bp+loopCounter], 0
	push	ax
	call	getKey
	add	sp, 2
	mov	[bp+inKey], ax
	cmp	ax, dosKeys_ESC
	jz	short l_return

loc_25AC1:
	mov	si, [bp+loopCounter]
	cmp	byte ptr [bp+si+validOptionCharacters], 0
	jz	short l_ioLoop
	mov	al, byte ptr [bp+si+validOptionCharacters]
	cbw
	cmp	ax, [bp+inKey]
	jz	short l_callWandererFunction
	shl	si, 1
	mov	ax, [bp+inKey]
	cmp	[bp+si+validOptionMouse],	ax
	jnz	short l_optionCheckNext

l_callWandererFunction:
	push	word ptr [bp+monsterBufferP+2]
	push	word ptr [bp+monsterBufferP]
	mov	bx, [bp+loopCounter]
	shl	bx, 1
	shl	bx, 1
	call	g_wandererFunctionTable[bx]
	add	sp, 4
	or	ax, ax
	jz	short l_return
	call	text_clear
	jmp	short l_return

l_optionCheckNext:
	inc	[bp+loopCounter]
	jmp	short loc_25AC1

l_return:
	pop	si
	mov	sp, bp
	pop	bp
	retf
dun_wanderingCreature endp


seg013 ends

; Segment type: Pure code
seg014 segment byte public 'CODE' use16
        assume cs:seg014
;org 8
        assume es:nothing, ss:nothing, ds:dseg, fs:nothing, gs:seg027

; Attributes: bp-based frame

bards_enter proc far
	var_4= word ptr	-4
	var_2= word ptr	-2

	push	bp
	mov	bp, sp
	mov	ax, 4
	call	someStackOperation
	push	si

	mov	ax, offset s_bardsHall
	push	ds
	push	ax
	call	setTitle
	add	sp, 4
	mov	ax, 83
	push	ax
	call	bigpic_drawPictureNumber
	add	sp, 2
l_loop:
	mov	ax, offset s_bardHallGreeting
	call	printStringWClear
	add	sp, 4
	mov	al, gs:txt_numLines
	sub	ah, ah
	mov	si, ax
	shl	si, 1
	mov	ax, g_printPartyFlag[si]
	or	ax, bitMask16bit[si]
	mov	[bp+var_2], ax
	call	getKey
	add	sp, 2
	mov	[bp+var_4], ax
	cmp	ax, 10Eh
	jl	short loc_25B7D
	cmp	ax, 119h
	jg	short loc_25B7D
	mov	al, gs:txt_numLines
	sub	ah, ah
	dec	ax
	sub	[bp+var_4], ax
loc_25B7D:
	cmp	[bp+var_4], 'L'
	jz	short l_listen
	cmp	[bp+var_4], 10Eh
	jnz	short loc_25B8E
l_listen:
	push	cs
	call	near ptr bards_listen
loc_25B8E:
	cmp	[bp+var_4], dosKeys_ESC
	jz	short l_return
	cmp	[bp+var_4], 'E'
	jz	short l_return
	cmp	[bp+var_4], 10Fh
	jnz	short l_loop

l_return:
	sub	ax, ax
	pop	si
	mov	sp, bp
	pop	bp
	retf
bards_enter endp

; Attributes: bp-based frame

bards_listen proc far

	validMouseKeys=	word ptr -2Eh
	validKeys=	word ptr -1Ah
	loopCounter=	word ptr -10h
	var_E= word ptr	-0Eh
	var_C= word ptr	-0Ch
	inKey= word ptr	-2

	push	bp
	mov	bp, sp
	mov	ax, 2Eh
	call	someStackOperation
	push	si

	lea	ax, [bp+var_C]
	push	ss
	push	ax
	cmp	g_locationNumber, 9
	jnz	short loc_25BCC
	mov	ax, 1
	jmp	short loc_25BCE
loc_25BCC:
	sub	ax, ax
loc_25BCE:
	push	ax
	push	cs
	call	near ptr bards_configOptionList
	add	sp, 6
	call	text_clear
	lea	ax, [bp+validMouseKeys]
	push	ss
	push	ax
	lea	ax, [bp+validKeys]
	push	ss
	push	ax
	lea	ax, [bp+var_C]
	push	ss
	push	ax
	mov	ax, offset s_songTitleList
	push	ds
	push	ax
	call	printVarString
	add	sp, 10h
	mov	[bp+var_E], ax
l_readKey:
	push	[bp+var_E]
	call	getKey
	add	sp, 2
	mov	[bp+inKey], ax
	cmp	ax, dosKeys_ESC
	jz	short l_return

	mov	[bp+loopCounter], 0
l_checkKeysLoop:
	mov	si, [bp+loopCounter]
	mov	al, byte ptr [bp+si+validKeys]
	cbw
	cmp	ax, [bp+inKey]
	jz	short l_songSelected
	shl	si, 1
	mov	ax, [bp+inKey]
	cmp	[bp+si+validMouseKeys],	ax
	jz	short l_songSelected
	inc	[bp+loopCounter]
	cmp	[bp+loopCounter], 6
	jl	short l_checkKeysLoop
	jmp	short l_readKey

l_songSelected:
	mov	bx, [bp+loopCounter]
	shl	bx, 1
	shl	bx, 1
	mov	ax, word ptr bardSongLyrics[bx]
	or	ax, word ptr (bardSongLyrics+2)[bx]
	jnz	short loc_25C5D
	cmp	[bp+loopCounter], 2
	jnz	short loc_25C51
	mov	ax, 1
	jmp	short loc_25C53
loc_25C51:
	sub	ax, ax

loc_25C53:
	push	ax
	push	cs
	call	near ptr bards_learnSong
	add	sp, 2
	jmp	short l_return

loc_25C5D:
	push	[bp+loopCounter]
	push	cs
	call	near ptr bards_printLyrics
	add	sp, 2
l_return:
	pop	si
	mov	sp, bp
	pop	bp
	retf
bards_listen endp

; Attributes: bp-based frame

bards_printLyrics proc far

	loopCounter= word ptr	-2
	songNumber= word ptr	 6

	push	bp
	mov	bp, sp
	mov	ax, 2
	call	someStackOperation
	push	si

	call	text_clear
	mov	[bp+loopCounter], 0
l_loop:
	mov	si, [bp+loopCounter]
	shl	si, 1
	shl	si, 1
	mov	bx, [bp+songNumber]
	shl	bx, 1
	shl	bx, 1
	lfs	bx, bardSongLyrics[bx]
	push	word ptr fs:[bx+si+2]
	push	word ptr fs:[bx+si]
	call	printString
	add	sp, 4
	mov	ax, 4000h
	push	ax
	call	getKey
	add	sp, 2
	inc	[bp+loopCounter]
	mov	bx, [bp+songNumber]
	shl	bx, 1
	mov	ax, [bp+loopCounter]
	cmp	bardSongLineCount[bx],	ax
	jg	short l_loop

	pop	si
	mov	sp, bp
	pop	bp
	retf
bards_printLyrics endp

; DWORD - var_2 & var_4
; Attributes: bp-based frame

bards_learnSong	proc far

	stringBuffer= word ptr -108h
	partySlotNumber= word ptr	-8
	var_6= word ptr	-6
	var_4= word ptr	-4
	var_2= word ptr	-2
	songNumber= word ptr	 6

	push	bp
	mov	bp, sp
	mov	ax, 108h
	call	someStackOperation
	push	si

	mov	ax, offset s_bardSmiles
	push	ds
	push	ax
	call	printStringWClear
	add	sp, 4
	mov	ax, 4000h
	push	ax
	call	getKey
	add	sp, 2
	mov	ax, offset s_itWillCostYou
	push	ds
	push	ax
	lea	ax, [bp+stringBuffer]
	push	ss
	push	ax
	call	strcat
	add	sp, 8
	mov	[bp+var_4], ax
	mov	[bp+var_2], dx
	sub	ax, ax
	push	ax
	mov	bx, [bp+songNumber]
	shl	bx, 1
	shl	bx, 1
	push	word ptr (bardSongPrice+2)[bx]
	push	word ptr bardSongPrice[bx]
	push	dx
	push	[bp+var_4]
	call	itoa
	add	sp, 0Ah
	mov	[bp+var_4], ax
	mov	[bp+var_2], dx
	mov	ax, offset s_inGoldWhoWillPay
	push	ds
	push	ax
	push	dx
	push	[bp+var_4]
	call	strcat
	add	sp, 8
	mov	[bp+var_4], ax
	mov	[bp+var_2], dx
	lea	ax, [bp+stringBuffer]
	push	ss
	push	ax
	call	printString
	add	sp, 4
	call	readSlotNumber
	mov	[bp+partySlotNumber], ax
	or	ax, ax
	jl	l_return

	mov	bx, [bp+songNumber]
	shl	bx, 1
	shl	bx, 1
	mov	ax, word ptr bardSongPrice[bx]
	mov	dx, word ptr (bardSongPrice+2)[bx]
	mov	cx, ax
	mov	bx, dx
	mov	ax, charSize
	imul	[bp+partySlotNumber]
	mov	si, ax
	cmp	word ptr gs:(party.gold+2)[si], bx
	ja	short loc_25DA2
	jb	short loc_25D93
	cmp	word ptr gs:party.gold[si], cx
	jnb	short loc_25DA2
loc_25D93:
	mov	ax, offset s_notEnoughGoldNl
	push	ds
	push	ax
	call	printStringWClear
	add	sp, 4
	jmp	short l_waitAndReturn

loc_25DA2:
	mov	bx, [bp+songNumber]
	shl	bx, 1
	shl	bx, 1
	mov	ax, word ptr bardSongPrice[bx]
	mov	dx, word ptr (bardSongPrice+2)[bx]
	mov	cx, ax
	mov	bx, dx
	mov	ax, charSize
	imul	[bp+partySlotNumber]
	mov	si, ax
	sub	word ptr gs:party.gold[si], cx
	sbb	word ptr gs:(party.gold+2)[si], bx
	mov	[bp+var_6], 0
l_loop:
	mov	ax, charSize
	imul	[bp+var_6]
	mov	si, ax
	cmp	gs:party.class[si], class_bard
	jnz	short l_increment
	mov	bx, [bp+songNumber]
	mov	al, byte_4BDF0[bx]
	or	gs:(party.specAbil+1)[si], al
l_increment:
	inc	[bp+var_6]
	cmp	[bp+var_6], 7
	jl	short l_loop

l_playSong:
	mov	ax, offset s_bardPlaysSong
	push	ds
	push	ax
	call	printStringWClear
	add	sp, 4
l_waitAndReturn:
	mov	ax, 4000h
	push	ax
	call	getKey
	add	sp, 2
l_return:
	pop	si
	mov	sp, bp
	pop	bp
	retf
bards_learnSong	endp

; Set up the song list that you can learn from the Bard's Hall
;
; optionList[0] = !locationFlag
; optionList[1] = !locationFlag
; optionList[2] = !locationFlag
; optionList[3] = locationFlag
; optionList[4] = locationFlag
; optionList[5] = locationFlag
;

; Attributes: bp-based frame

bards_configOptionList proc far

	loopCounter= word ptr	-2
	locationFlag= word ptr	 6
	optionList= dword ptr  8

	push	bp
	mov	bp, sp
	mov	ax, 2
	call	someStackOperation
	push	si

	mov	[bp+loopCounter], 0
loc_25E2E:
	mov	bx, [bp+loopCounter]
	lfs	si, [bp+optionList]
	cmp	[bp+locationFlag], 1
	sbb	ax, ax
	neg	ax
	mov	fs:[bx+si], al
	inc	[bp+loopCounter]
	cmp	[bp+loopCounter], 3
	jl	short loc_25E2E

	mov	[bp+loopCounter], 3
loc_25E51:
	mov	bx, [bp+loopCounter]
	lfs	si, [bp+optionList]
	mov	al, byte ptr [bp+locationFlag]
	mov	fs:[bx+si], al
	inc	[bp+loopCounter]
	cmp	[bp+loopCounter], 6
	jl	short loc_25E51

	pop	si
	mov	sp, bp
	pop	bp
	retf
bards_configOptionList endp


seg014 ends

; Segment type: Pure code
seg015 segment word public 'CODE' use16
        assume cs:seg015
;org 0Dh
        assume es:nothing, ss:nothing, ds:dseg, fs:nothing, gs:seg027
align 2

; Attributes: bp-based frame

summon_execute proc far

	spellCaster= byte ptr	 6
	spellNumber= word ptr	 8

	push	bp
	mov	bp, sp

	test	gs:disbelieveFlags, disb_nosummon
	jz	short loc_25E96
	mov	ax, offset s_butItFizzledNl
	push	ds
	push	ax
	call	printString
	add	sp, 4
	jmp	short l_return

loc_25E96:
	test	[bp+spellCaster], 80h
	jz	short loc_25EA8
	push	[bp+spellNumber]
	push	cs
	call	near ptr summon_monSummon
	add	sp, 2
	jmp	short l_return

loc_25EA8:
	push	[bp+spellNumber]
	push	cs
	call	near ptr summon_partySummon
	add	sp, 2

l_return:
	mov	sp, bp
	pop	bp
	retf
summon_execute endp

; Attributes: bp-based frame

summon_partySummon proc far

	skipNoRoomFlag= word ptr	-4
	emptySlot= word ptr	-2
	summonIndex= word ptr	 6

	push	bp
	mov	bp, sp
	mov	ax, 4
	call	someStackOperation

	mov	[bp+skipNoRoomFlag], 0
l_loop:
	call	party_findEmptySlot
	mov	[bp+emptySlot], ax
	cmp	ax, 7
	jge	short l_noRoom
	mov	ax, [bp+summonIndex]
	and	ax, 1Fh
	mov	cx, monStruSize
	imul	cx
	add	ax, offset summonData
	push	ds
	push	ax
	push	[bp+emptySlot]
	call	_sp_convertMonToSummon
	add	sp, 6
	test	byte ptr [bp+summonIndex], 80h
	jz	short loc_25EF8
	mov	al, class_illusion
	jmp	short loc_25EFA
loc_25EF8:
	mov	al, class_monster
loc_25EFA:
	mov	cx, ax
	mov	ax, charSize
	imul	[bp+emptySlot]
	mov	bx, ax
	mov	gs:party.class[bx], cl
	mov	byte ptr g_printPartyFlag, 0
	mov	[bp+skipNoRoomFlag], 1
	cmp	g_curSpellNumber, 77			; Kringle Bros spell
	jz	short l_loop

l_noRoom:
	push	[bp+skipNoRoomFlag]
	push	cs
	call	near ptr summon_printNoRoom
	add	sp, 2

l_return:
	mov	sp, bp
	pop	bp
	retf
summon_partySummon endp


; Attributes: bp-based frame

summon_monSummon proc far

	groupNo= word ptr -6
	skipNoRoomFlag= word ptr	-4
	spellNumber= word ptr	 6

	push	bp
	mov	bp, sp
	mov	ax, 6
	call	someStackOperation

	mov	[bp+skipNoRoomFlag], 0

l_entry:
	mov	[bp+groupNo], 0

l_searchForEmptyGroup:
	mov	ax, monStruSize
	imul	[bp+groupNo]
	mov	bx, ax
	test	gs:monGroups.groupSize[bx], 1Fh
	jz	short l_makeNewMonsterGroup
	inc	[bp+groupNo]
	cmp	[bp+groupNo], 4
	jl	short l_searchForEmptyGroup

l_makeNewMonsterGroup:
	cmp	[bp+groupNo], 4				; If no empty groups,
	jge	short l_findMatchingGroup		;   Try to find a matching group
	push	[bp+groupNo]
	push	[bp+spellNumber]
	push	cs
	call	near ptr summon_newMonGroup
	add	sp, 4			; Create new group
	push	[bp+groupNo]
	push	[bp+spellNumber]
	push	cs
	call	near ptr summon_addMonToGroup
	add	sp, 4			; Add monster to group
	or	[bp+skipNoRoomFlag], ax
	jmp	short l_kringleBrosCheck

l_findMatchingGroup:
	cmp	g_curSpellNumber, 77			; Skip if kringle bros spell
	jz	l_printNoRoom

	push	[bp+spellNumber]
	push	cs
	call	near ptr summon_getMatchMonGroup
	add	sp, 2
	mov	[bp+groupNo], ax
	or	ax, ax
	jl	short l_kringleBrosCheck
	push	ax
	push	[bp+spellNumber]
	push	cs
	call	near ptr summon_addMonToGroup
	add	sp, 4
	or	[bp+skipNoRoomFlag], ax
	jmp	l_printNoRoom

l_kringleBrosCheck:
	cmp	g_curSpellNumber, 77			; Kringle Bros
	jnz	l_entry

l_printNoRoom:
	push	[bp+skipNoRoomFlag]
	call	summon_printNoRoom
	add	sp, 2
	
l_return:
	mov	sp, bp
	pop	bp
	retf
summon_monSummon endp

; This function	looks for a monster group that matches
; the summonData.name given by summonNo. It returns
; the matching group number. If	not found, it returns
; 0xffff
;
; Attributes: bp-based frame

summon_getMatchMonGroup proc far

	groupCounter= word ptr	-2
	summonNo= word ptr  6

	push	bp
	mov	bp, sp
	mov	ax, 2
	call	someStackOperation

	mov	[bp+groupCounter], 0
loc_2600B:
	mov	ax, monStruSize
	imul	[bp+summonNo]
	add	ax, offset summonData
	push	ds
	push	ax
	mov	ax, monStruSize
	imul	[bp+groupCounter]
	mov	bx, ax
	lea	ax, monGroups._name[bx]
	mov	dx, seg	seg027
	push	dx
	push	ax
	call	vm_strcmp
	add	sp, 8
	or	ax, ax
	jnz	l_returnValue
	inc	[bp+groupCounter]
	cmp	[bp+groupCounter], 4
	jl	short loc_2600B

l_returnValue:
	mov	ax, [bp+groupCounter]
	jmp	short l_return

l_returnFail:
	mov	ax, 0FFFFh

l_return:
	mov	sp, bp
	pop	bp
	retf
summon_getMatchMonGroup endp

; DWORD - stringBuffer & var_104
;
; Attributes: bp-based frame

summon_addMonToGroup proc far

	var_116= word ptr -116h
	var_106= word ptr -106h
	var_104= word ptr -104h
	stringBuffer= word ptr -102h
	groupSize= word	ptr -2
	arg_0= byte ptr	 6
	arg_2= word ptr	 8

	push	bp
	mov	bp, sp
	mov	ax, 116h
	call	someStackOperation
	push	si

	mov	ax, monStruSize
	imul	[bp+arg_2]
	mov	bx, ax
	mov	al, gs:monGroups.groupSize[bx]
	sub	ah, ah
	and	ax, 1Fh
	mov	[bp+groupSize],	ax
	cmp	ax, 1Fh
	jnz	short loc_2607B
	sub	ax, ax
	jmp	l_return
loc_2607B:
	mov	ax, monStruSize
	imul	[bp+arg_2]
	mov	si, ax
	inc	gs:monGroups.groupSize[si]
	mov	al, gs:monGroups.hpDice[si]
	sub	ah, ah
	push	ax
	call	randomYdX
	add	sp, 2
	mov	cx, gs:monGroups.hpBase[si]
	add	cx, ax
	mov	bx, [bp+arg_2]
	mov	ax, cx
	mov	cl, 6
	shl	bx, cl
	mov	cx, [bp+groupSize]
	shl	cx, 1
	add	bx, cx
	mov	gs:monHpList[bx], ax
	mov	bx, [bp+arg_2]
	mov	cl, 6
	shl	bx, cl
	mov	ax, [bp+groupSize]
	shl	ax, 1
	add	bx, ax
	mov	gs:bat_monPriorityList[bx], 0
	test	[bp+arg_0], 80h
	jz	short loc_260EF
	mov	ax, monStruSize
	imul	[bp+arg_2]
	mov	bx, ax
	or	gs:monGroups.flags[bx],	10h
	jmp	short loc_26101
loc_260EF:
	mov	ax, monStruSize
	imul	[bp+arg_2]
	mov	bx, ax
	and	gs:monGroups.flags[bx],	0EFh
loc_26101:
	lea	ax, [bp+var_116]
	push	ss
	push	ax
	mov	ax, monStruSize
	imul	[bp+arg_2]
	mov	bx, ax
	lea	ax, monGroups._name[bx]
	mov	dx, seg	seg027
	push	dx
	push	ax
	call	unmaskString
	add	sp, 8
	mov	ax, offset s_andA
	push	ds
	push	ax
	lea	ax, [bp+stringBuffer]
	push	ss
	push	ax
	call	strcat
	add	sp, 8
	mov	[bp+var_106], ax
	mov	[bp+var_104], dx
	sub	ax, ax
	push	ax
	push	dx
	push	[bp+var_106]
	lea	ax, [bp+var_116]
	push	ss
	push	ax
	call	str_pluralize
	add	sp, 0Ah
	mov	[bp+var_106], ax
	mov	[bp+var_104], dx
	mov	ax, offset s_appears
	push	ds
	push	ax
	push	dx
	push	[bp+var_106]
	call	strcat
	add	sp, 8
	mov	[bp+var_106], ax
	mov	[bp+var_104], dx
	lea	ax, [bp+stringBuffer]
	push	ss
	push	ax
	call	printString
	add	sp, 4
	mov	ax, 1
l_return:
	pop	si
	mov	sp, bp
	pop	bp
	retf
summon_addMonToGroup endp

; Attributes: bp-based frame

summon_newMonGroup proc far

	arg_0= word ptr	 6
	arg_2= word ptr	 8

	push	bp
	mov	bp, sp

	and	[bp+arg_0], 1Fh
	mov	ax, monStruSize
	imul	[bp+arg_0]
	add	ax, offset summonData
	push	ds
	push	ax
	mov	ax, monStruSize
	imul	[bp+arg_2]
	mov	bx, ax
	lea	ax, monGroups._name[bx]
	mov	dx, seg	seg027
	push	dx
	push	ax
	push	cs
	call	near ptr summon_maskSummonName
	add	sp, 8
	mov	ax, 20h
	push	ax
	mov	ax, monStruSize
	imul	[bp+arg_0]
	add	ax, offset summonHpDice
	push	ds
	push	ax
	mov	ax, monStruSize
	imul	[bp+arg_2]
	mov	bx, ax
	lea	ax, monGroups.hpDice[bx]
	mov	dx, seg	seg027
	push	dx
	push	ax
	call	memcpy
	add	sp, 0Ah

	; FIXED: Set the group size to 0. 
	mov	ax, monStruSize
	imul	[bp+arg_2]
	mov	bx, ax
	mov	monGroups.groupSize[bx], 0

	mov	sp, bp
	pop	bp
	retf
summon_newMonGroup endp

; Attributes: bp-based frame

summon_maskSummonName proc far

	loopCounter= word ptr	-2
	destAddress= dword ptr  6
	srcAddress= dword ptr  0Ah

	push	bp
	mov	bp, sp
	mov	ax, 2
	call	someStackOperation
	push	si

	mov	[bp+loopCounter], 0
l_zeroLoop:
	mov	bx, [bp+loopCounter]
	lfs	si, [bp+destAddress]
	mov	byte ptr fs:[bx+si], 0FFh
	inc	[bp+loopCounter]
	cmp	[bp+loopCounter], 10h
	jl	short l_zeroLoop

l_copyLoop:
	lfs	bx, [bp+srcAddress]
	cmp	byte ptr fs:[bx], 0
	jz	short l_return
	inc	word ptr [bp+srcAddress]
	mov	al, fs:[bx]
	or	al, 80h
	lfs	bx, [bp+destAddress]
	inc	word ptr [bp+destAddress]
	mov	fs:[bx], al
	jmp	short l_copyLoop

l_return:
	pop	si
	mov	sp, bp
	pop	bp
	retf
summon_maskSummonName endp

; Attributes: bp-based frame

summon_printNoRoom	proc far

	noRoomFlag= word ptr	 6

	push	bp
	mov	bp, sp

	cmp	[bp+noRoomFlag], 0
	jnz	short l_return
	mov	ax, offset s_noRoomForSummon
	push	ds
	push	ax
	call	printString
	add	sp, 4
	call	text_delayWithTable

l_return:
	mov	sp, bp
	pop	bp
	retf
summon_printNoRoom	endp



seg015 ends

; Segment type: Pure code
seg016 segment byte public 'CODE' use16
        assume cs:seg016
;org 0Eh
        assume es:nothing, ss:nothing, ds:dseg, fs:nothing, gs:seg027

; Attributes: bp-based frame

configureBT3 proc far

	var_8= word ptr	-8
	var_6= word ptr	-6
	var_4= word ptr	-4
	var_2= word ptr	-2
	arg_0= word ptr	 6
	arg_2= dword ptr  8

	push	bp
	mov	bp, sp
	mov	ax, 8
	call	someStackOperation

	cmp	[bp+arg_0], 1
	jle	short loc_2627C
	lfs	bx, [bp+arg_2]
	lfs	bx, fs:[bx+4]
	mov	al, fs:[bx]
	cbw
	jmp	short loc_2627F
loc_2627C:
	mov	ax, 0FFh
loc_2627F:
	mov	[bp+var_4], ax
	cmp	ax, '1'
	jl	short loc_2628C
	cmp	ax, '4'
	jle	short loc_2630B
loc_2628C:

	mov	[bp+var_8], 0
l_clearScreenLoop:
	mov	ax, offset s_nl
	push	ds
	push	ax
	call	printf
	add	sp, 4
	inc	[bp+var_8]
	cmp	[bp+var_8], 25
	jl	short l_clearScreenLoop

loc_262AB:
	mov	ax, offset s_displayQuestion
	push	ds
	push	ax
	call	printf
	add	sp, 4
	mov	ax, offset s_videoOption1
	push	ds
	push	ax
	call	printf
	add	sp, 4
	mov	ax, offset s_videoOption2
	push	ds
	push	ax
	call	printf
	add	sp, 4
	mov	ax, offset s_videoOption3
	push	ds
	push	ax
	call	printf
	add	sp, 4
	mov	ax, offset s_videoOption4
	push	ds
	push	ax
	call	printf
	add	sp, 4
	mov	ax, offset s_videoQuestion
	push	ds
	push	ax
	call	printf
	add	sp, 4
	call	sub_2A9D4
	mov	[bp+var_4], ax
	cmp	ax, '1'	
	jl	short loc_2628C
	cmp	ax, '4'	
	jg	short loc_2628C
loc_2630B:
	mov	ax, [bp+var_4]
	sub	ax, '1'	
	mov	[bp+var_6], ax
	cmp	[bp+arg_0], 2
	jle	short loc_26327
	lfs	bx, [bp+arg_2]
	lfs	bx, fs:[bx+8]
	mov	al, fs:[bx]
	cbw
	jmp	short loc_2632A
loc_26327:
	mov	ax, 0FFh
loc_2632A:
	mov	[bp+var_4], ax
	cmp	ax, '1'	
	jl	short loc_2633A
	cmp	ax, '4'	
	jle	l_return

loc_2633A:
	mov	[bp+var_8], 0
loc_26341:
	mov	ax, offset s_nl
	push	ds
	push	ax
	call	printf
	add	sp, 4
	inc	[bp+var_8]
	cmp	[bp+var_8], 25
	jl	short loc_26341

loc_26359:
	mov	ax, offset s_soundQuestion
	push	ds
	push	ax
	call	printf
	add	sp, 4
	mov	ax, offset s_soundOption1
	push	ds
	push	ax
	call	printf
	add	sp, 4
	mov	ax, offset s_soundOption2
	push	ds
	push	ax
	call	printf
	add	sp, 4
	mov	ax, offset s_soundOption3
	push	ds
	push	ax
	call	printf
	add	sp, 4
	mov	ax, offset s_soundOption4
	push	ds
	push	ax
	call	printf
	add	sp, 4
	mov	ax, offset s_soundOption5
	push	ds
	push	ax
	call	printf
	add	sp, 4
	mov	ax, offset s_soundPrompt
	push	ds
	push	ax
	call	printf
	add	sp, 4
	call	sub_2A9D4
	mov	[bp+var_4], ax
	cmp	ax, '1'	
	jl	loc_2633A
	cmp	ax, '5'	
	jg	loc_2633A
l_return:
	mov	ax, [bp+var_4]
	sub	ax, '1'	
	mov	[bp+var_2], ax
	mov	ah, byte ptr [bp+var_2]
	sub	al, al
	or	ax, [bp+var_6]
	jmp	short $+2

	mov	sp, bp
	pop	bp
	retf
configureBT3 endp


seg016 ends



; Segment type: Pure code
seg017 segment word public 'CODE' use16
        assume cs:seg017
;org 3
        assume es:nothing, ss:nothing, ds:dseg, fs:nothing, gs:seg027
align 2

; Attributes: bp-based frame

transferCharacter proc far

	inKey= word ptr	-2

	push	bp
	mov	bp, sp
	mov	ax, 2
	call	someStackOperation

l_entry:
	mov	ax, offset s_transferVersionPrompt
	push	ds
	push	ax
	call	printStringWClear
	add	sp, 4
	mov	ax, 3Ch	
	push	ax
	call	getKey
	add	sp, 2
	mov	[bp+inKey], ax
	cmp	ax, 110h
	jl	short loc_2641A
	cmp	ax, 112h
	jg	short loc_2641A
	sub	[bp+inKey], 0DFh 
loc_2641A:
	mov	ax, [bp+inKey]
	cmp	ax, dosKeys_ESC
	jz	short l_return
	cmp	ax, '1'	
	jz	short l_bt1
	cmp	ax, '2'	
	jz	short l_bt2
	cmp	ax, '3'	
	jz	short l_bt3
	cmp	ax, 'E'	
	jz	short l_return
	cmp	ax, 113h
	jz	short l_return
	jmp	short l_entry

l_bt3:
	push	cs
	call	near ptr getTransferCharacters
	add	sp, 4
	jmp	short l_entry

l_bt2:
	mov	ax, 1
	push	ax
	push	cs
	call	near ptr importCharacter
	jmp	short l_entry

l_bt1:
	sub	ax, ax
	push	ax
	push	cs
	call	near ptr importCharacter
	jmp	short l_entry

l_return:
	mov	sp, bp
	pop	bp
	retf
transferCharacter endp

; DWORD - 1C4 & 1C6, 17E & 180, 24 & 26
; Attributes: bp-based frame

getTransferCharacters proc far

	var_1CA= dword ptr -1CAh
	var_1C6= word ptr -1C6h
	var_1C4= word ptr -1C4h
	var_1C2= word ptr -1C2h
	var_1C0= word ptr -1C0h
	var_1BC= word ptr -1BCh
	var_1BA= dword ptr -1BAh
	var_1B6= word ptr -1B6h
	var_1B4= word ptr -1B4h
	fd= word ptr -182h
	var_180= word ptr -180h
	var_17E= word ptr -17Eh
	var_17C= word ptr -17Ch
	var_17A= dword ptr -17Ah
	var_26=	word ptr -26h
	var_24=	word ptr -24h
	var_22=	word ptr -22h
	var_20=	word ptr -20h
	var_1E=	word ptr -1Eh

	push	bp
	mov	bp, sp
	mov	ax, 1CAh
	call	someStackOperation
	push	si

	mov	ax, 9000
	push	ax
	call	_mallocMaybe
	add	sp, 2
	mov	[bp+var_1C6], ax
	mov	[bp+var_1C4], dx

	mov	ax, 500h
	push	ax
	call	_mallocMaybe
	add	sp, 2
	mov	[bp+var_180], ax
	mov	[bp+var_17E], dx

loc_2649C:
	mov	ax, offset s_diskToTransferFrom
	push	ds
	push	ax
	call	printStringWClear
	add	sp, 4
	lea	ax, [bp+var_1B4]
	mov	[bp+var_26], ax
	mov	[bp+var_24], ss
	mov	ax, 18h
	push	ax
	lea	ax, [bp+var_1E]
	push	ss
	push	ax
	call	readString
	add	sp, 6
	or	ax, ax
	jz	short loc_264E1
	lea	ax, [bp+var_1E]
	push	ss
	push	ax
	push	[bp+var_24]
	push	[bp+var_26]
	call	strcat
	add	sp, 8
	mov	[bp+var_26], ax
	mov	[bp+var_24], dx

loc_264E1:
	mov	ax, offset s_thievesInf
	push	ds
	push	ax
	push	[bp+var_24]
	push	[bp+var_26]
	call	strcat
	add	sp, 8
	mov	[bp+var_26], ax
	mov	[bp+var_24], dx

	sub	ax, ax
	push	ax
	lea	ax, [bp+var_1B4]
	push	ss
	push	ax
	call	open
	add	sp, 6
	mov	[bp+fd], ax
	inc	ax
	jnz	short loc_2653C
	mov	ax, offset s_noCharactersFoundOn
	push	ds
	push	ax
	call	printStringWClear
	add	sp, 4

	lea	ax, [bp+var_1B4]
	push	ss
	push	ax
	call	printString
	add	sp, 4
	mov	ax, 4000h
	push	ax
	call	getKey
	add	sp, 2
	jmp	loc_2649C

loc_2653C:
	mov	ax, [bp+var_1C6]
	mov	dx, [bp+var_1C4]
	mov	word ptr [bp+var_1BA], ax
	mov	word ptr [bp+var_1BA+2], dx

	mov	[bp+var_1C2], 0
loc_26554:
	mov	ax, charSize
	imul	[bp+var_1C2]
	mov	bx, ax
	lfs	si, [bp+var_1BA]
	mov	byte ptr fs:[bx+si], 0
	inc	[bp+var_1C2]
	cmp	[bp+var_1C2], 75
	jl	short loc_26554

	mov	ax, 9000
	push	ax
	push	[bp+var_1C4]
	push	[bp+var_1C6]
	push	[bp+fd]
	call	read
	add	sp, 8

	push	[bp+fd]
	call	close
	add	sp, 2

	lea	ax, [bp+var_1E]
	push	ss
	push	ax
	lea	ax, [bp+var_1B4]
	push	ss
	push	ax
	call	strcat
	add	sp, 8
	mov	[bp+var_26], ax
	mov	[bp+var_24], dx

	mov	ax, offset s_partiesInf
	push	ds
	push	ax
	push	dx
	push	[bp+var_26]
	call	strcat
	add	sp, 8
	mov	[bp+var_26], ax
	mov	[bp+var_24], dx

	mov	ax, [bp+var_180]
	mov	dx, [bp+var_17E]
	mov	word ptr [bp+var_1BA], ax
	mov	word ptr [bp+var_1BA+2], dx

	mov	[bp+var_1C2], 0
loc_265DE:
	mov	bx, [bp+var_1C2]
	mov	cl, 7
	shl	bx, cl
	lfs	si, [bp+var_1BA]
	mov	byte ptr fs:[bx+si], 0
	inc	[bp+var_1C2]
	cmp	[bp+var_1C2], 0Ah
	jl	short loc_265DE

	sub	ax, ax
	push	ax
	lea	ax, [bp+var_1B4]
	push	ss
	push	ax
	call	open
	add	sp, 6
	mov	[bp+fd], ax
	inc	ax
	jnz	short loc_2663C
	mov	ax, offset s_noPartiesFoundOn
	push	ds
	push	ax
	call	printStringWClear
	add	sp, 4
	lea	ax, [bp+var_1B4]
	push	ss
	push	ax
	call	printString
	add	sp, 4
	mov	ax, 4000h
	push	ax
	call	getKey
	add	sp, 2
	jmp	short loc_26654

loc_2663C:
	mov	ax, 500h
	push	ax
	push	[bp+var_17E]
	push	[bp+var_180]
	push	[bp+fd]
	call	read
	add	sp, 8

loc_26654:
	mov	[bp+var_1C2], 0
	mov	[bp+var_1C0], 0
loc_2665A:
	cmp	[bp+var_1C0], 10
	jge	l_partyLimitReached
	mov	si, [bp+var_1C2]
	shl	si, 1
	shl	si, 1
	mov	ax, [bp+var_1C2]
	mov	cl, 7
	shl	ax, cl
	add	ax, [bp+var_180]
	mov	dx, [bp+var_17E]
	mov	word ptr [bp+si+var_17A], ax
	mov	word ptr [bp+si+var_17A+2], dx
	mov	si, [bp+var_1C2]
	inc	[bp+var_1C2]
	inc	[bp+var_1C0]
	shl	si, 1
	shl	si, 1
	lfs	bx, [bp+si+var_17A]
	cmp	byte ptr fs:[bx], 0
	jnz	short loc_2665A

l_partyLimitReached:
	dec	[bp+var_1C2]
	mov	ax, [bp+var_1C2]
	mov	[bp+var_1BC], ax
	mov	[bp+var_1C0], 0
loc_2669C:
	cmp	[bp+var_1C0], 75
	jge	l_charLimitReached

	mov	ax, [bp+var_1C2]
	sub	ax, [bp+var_1BC]
	mov	cx, charSize
	imul	cx
	add	ax, [bp+var_1C6]
	mov	dx, [bp+var_1C4]
	mov	si, [bp+var_1C2]
	shl	si, 1
	shl	si, 1
	mov	word ptr [bp+si+var_17A], ax
	mov	word ptr [bp+si+var_17A+2], dx
	mov	si, [bp+var_1C2]
	inc	[bp+var_1C2]
	inc	[bp+var_1C0]
	shl	si, 1
	shl	si, 1
	lfs	bx, [bp+si+var_17A]
	cmp	byte ptr fs:[bx], 0
	jnz	short loc_2669C
l_charLimitReached:
	dec	[bp+var_1C2]

l_askWhoTransfers:
	push	[bp+var_1C2]
	lea	ax, [bp+var_17A]
	push	ss
	push	ax
	mov	ax, offset s_whoShallTransfer
	push	ds
	push	ax
	call	text_scrollingWindow
	add	sp, 0Ah
	mov	[bp+var_1C0], ax
	or	ax, ax
	jge	short loc_2671D
	push	[bp+var_1C4]
	push	[bp+var_1C6]
	call	_freeMaybe
	add	sp, 4
	push	[bp+var_17E]
	push	[bp+var_180]
	call	_freeMaybe
	add	sp, 4
	jmp	l_return
loc_2671D:
	mov	ax, [bp+var_1BC]
	cmp	[bp+var_1C0], ax
	jge	l_transferCharacter

l_transferParty:
	mov	si, [bp+var_1C0]
	shl	si, 1
	shl	si, 1
	mov	ax, word ptr [bp+si+var_17A]
	mov	dx, word ptr [bp+si+var_17A+2]
	mov	[bp+var_22], ax
	mov	[bp+var_20], dx

	mov	[bp+var_17C], 0
loc_26748:
	mov	ax, [bp+var_17C]
	mov	cl, 4
	shl	ax, cl
	add	ax, [bp+var_22]
	mov	dx, [bp+var_20]
	add	ax, 10h
	mov	word ptr [bp+var_1CA], ax
	mov	word ptr [bp+var_1CA+2], dx
	lfs	bx, [bp+var_1CA]
	cmp	byte ptr fs:[bx], 0
	jz	l_askWhoTransfers
	push	[bp+var_1C4]
	push	[bp+var_1C6]
	push	dx
	push	ax
	push	cs
	call	near ptr transfer_findName
	add	sp, 8
	mov	[bp+var_1B6], ax
	cmp	[bp+var_1B6], 0
	jl	short loc_267AE

	mov	ax, charSize
	imul	[bp+var_1B6]
	add	ax, [bp+var_1C6]
	mov	dx, [bp+var_1C4]
	push	dx
	push	ax
	push	cs
	call	near ptr transfer_bt3Character
	add	sp, 4

loc_267AE:
	inc	[bp+var_17C]
	cmp	[bp+var_17C], 7
	jl	short loc_26748
	jmp	l_askWhoTransfers

l_transferCharacter:
	mov	si, [bp+var_1C0]
	shl	si, 1
	shl	si, 1
	push	word ptr [bp+si+var_17A+2]
	push	word ptr [bp+si+var_17A]
	push	cs
	call	near ptr transfer_bt3Character
	add	sp, 4
	jmp	l_askWhoTransfers

l_return:
	pop	si
	mov	sp, bp
	pop	bp
	retf
getTransferCharacters endp

; DWORD - arg_0 & arg_2, arg_4 & arg_6
;
; Only used when attempting to transfer a party. Since a party
; definition can have names that don't exist in the thieves.inf
; file, this function searches the thieves.inf for the given
; name.
;
; Attributes: bp-based frame

transfer_findName proc far

	var_2= word ptr	-2
	arg_0= word ptr	 6
	arg_2= word ptr	 8
	arg_4= word ptr	 0Ah
	arg_6= word ptr	 0Ch

	push	bp
	mov	bp, sp
	mov	ax, 2
	call	someStackOperation
	mov	[bp+var_2], 0

l_loop:
	mov	ax, charSize
	imul	[bp+var_2]
	add	ax, [bp+arg_4]
	mov	dx, [bp+arg_6]
	push	dx
	push	ax
	push	[bp+arg_2]
	push	[bp+arg_0]
	call	strcmp
	add	sp, 8
	or	ax, ax
	jz	short l_returnValue
	inc	[bp+var_2]
	cmp	[bp+var_2], 75
	jge	short l_returnFailed
	jmp	short l_loop

l_returnValue:
	mov	ax, [bp+var_2]
	jmp	short l_return

l_returnFailed:
	mov	ax, 0FFFFh

l_return:
	mov	sp, bp
	pop	bp
	retf
transfer_findName endp

; Attributes: bp-based frame

transfer_bt3Character proc far

	var_4= word ptr	-4
	var_2= word ptr	-2
	arg_0= word ptr	 6
	arg_2= word ptr	 8

	push	bp
	mov	bp, sp
	mov	ax, 4
	call	someStackOperation

	push	[bp+arg_2]
	push	[bp+arg_0]
	call	roster_nameExists
	add	sp, 4
	mov	[bp+var_4], ax
	or	ax, ax
	jge	short loc_26868
	call	roster_countCharacters
	mov	[bp+var_2], ax
	mov	ax, charSize
	imul	[bp+var_2]
	mov	bx, ax
	lea	ax, g_rosterCharacterBuffer[bx]
	mov	dx, seg	seg022
	push	dx
	push	ax
	push	[bp+arg_2]
	push	[bp+arg_0]
	call	copyCharacterBuf
	add	sp, 8
	jmp	short loc_26881
loc_26868:
	mov	ax, offset s_characterAlreadyExists
	push	ds
	push	ax
	call	printStringWClear
	add	sp, 4
	mov	ax, 4000h
	push	ax
	call	getKey
	add	sp, 2
loc_26881:
	mov	sp, bp
	pop	bp
	retf
transfer_bt3Character endp

; Attributes: bp-based frame

importCharacter	proc far

	var_1F0= dword ptr -1F0h
	var_1EC= word ptr -1ECh
	var_1EA= word ptr -1EAh
	var_1E8= word ptr -1E8h
	var_1E6= word ptr -1E6h
	var_1E0= word ptr -1E0h
	var_1C2= word ptr -1C2h
	var_1AE= word ptr -1AEh
	var_17C= word ptr -17Ch
	var_178= word ptr -178h
	var_176= word ptr -176h
	var_24=	word ptr -24h
	var_22=	word ptr -22h
	var_20=	word ptr -20h
	var_1E=	word ptr -1Eh
	arg_0= word ptr	 6

	push	bp
	mov	bp, sp
	mov	ax, 1F0h
	call	someStackOperation
	push	si

	mov	ax, 2BF2h
	push	ax
	call	_mallocMaybe
	add	sp, 2
	mov	[bp+var_1EC], ax
	mov	[bp+var_1EA], dx
	mov	word ptr [bp+var_1F0], ax
	mov	word ptr [bp+var_1F0+2], dx
loc_268AD:
	mov	ax, offset s_diskToTransferFrom
	push	ds
	push	ax
	call	printStringWClear
	add	sp, 4
	lea	ax, [bp+var_1AE]
	mov	[bp+var_24], ax
	mov	[bp+var_22], ss
	mov	ax, 18h
	push	ax
	lea	ax, [bp+var_1E]
	push	ss
	push	ax
	call	readString
	add	sp, 6
	or	ax, ax
	jz	short loc_268F2
	lea	ax, [bp+var_1E]
	push	ss
	push	ax
	push	[bp+var_22]
	push	[bp+var_24]
	call	strcat
	add	sp, 8
	mov	[bp+var_24], ax
	mov	[bp+var_22], dx
loc_268F2:
	mov	bx, [bp+arg_0]
	shl	bx, 1
	shl	bx, 1
	push	word ptr (oldCharFilters+2)[bx]
	push	word ptr oldCharFilters[bx]
	push	[bp+var_22]
	push	[bp+var_24]
	call	strcat
	add	sp, 8
	mov	[bp+var_24], ax
	mov	[bp+var_22], dx
	lea	ax, [bp+var_1E0]
	push	ss
	push	ax
	lea	ax, [bp+var_1AE]
	push	ss
	push	ax
	call	findFirstFile
	add	sp, 8
	or	ax, ax
	jnz	short loc_26965

	mov	ax, offset s_noCharactersFoundOn
	push	ds
	push	ax
	call	printStringWClear
	add	sp, 4
	lea	ax, [bp+var_1AE]
	push	ss
	push	ax
	call	printString
	add	sp, 4
	sub	ax, ax
	push	ax
	call	getKey
	add	sp, 2
	mov	[bp+var_20], ax
	cmp	ax, dosKeys_ESC
	jz	l_return
	jmp	loc_268AD

loc_26965:
	mov	[bp+var_1E8], 0
loc_2696B:
	lea	ax, [bp+var_1E]
	push	ss
	push	ax
	lea	ax, [bp+var_1AE]
	push	ss
	push	ax
	call	strcat
	add	sp, 8
	mov	[bp+var_24], ax
	mov	[bp+var_22], dx
	lea	ax, [bp+var_1C2]
	push	ss
	push	ax
	push	dx
	push	[bp+var_24]
	call	strcat
	add	sp, 8
	mov	[bp+var_24], ax
	mov	[bp+var_22], dx
	sub	ax, ax
	push	ax
	lea	ax, [bp+var_1AE]
	push	ss
	push	ax
	call	open
	add	sp, 6
	mov	[bp+var_17C], ax
	inc	ax
	jz	short loc_26A01
	mov	ax, 81h	
	push	ax
	push	word ptr [bp+var_1F0+2]
	push	word ptr [bp+var_1F0]
	push	[bp+var_17C]
	call	read
	add	sp, 8
	lfs	bx, [bp+var_1F0]
	cmp	byte ptr fs:[bx+10h], 1
	jnz	short loc_269F5
	mov	si, [bp+var_1E8]
	inc	[bp+var_1E8]
	shl	si, 1
	shl	si, 1
	mov	ax, bx
	mov	dx, fs
	mov	[bp+si+var_178], ax
	mov	[bp+si+var_176], dx
	add	word ptr [bp+var_1F0], 96h 
loc_269F5:
	push	[bp+var_17C]
	call	close
	add	sp, 2
loc_26A01:
	call	findNextFile
	or	ax, ax
	jnz	loc_2696B

loc_26A0D:
	push	[bp+var_1E8]
	lea	ax, [bp+var_178]
	push	ss
	push	ax
	mov	ax, offset s_whoShallTransfer
	push	ds
	push	ax
	call	text_scrollingWindow
	add	sp, 0Ah
	mov	[bp+var_1E6], ax
	or	ax, ax
	jge	short loc_26A3E
	push	[bp+var_1EA]
	push	[bp+var_1EC]
	call	_freeMaybe
	add	sp, 4
	jmp	short l_return
loc_26A3E:
	cmp	[bp+arg_0], 0
	jz	short loc_26A5D
	mov	si, [bp+var_1E6]
	shl	si, 1
	shl	si, 1
	push	[bp+si+var_176]
	push	[bp+si+var_178]
	push	cs
	push	cs
	call	near ptr transfer_bt2Character
	add	sp, 4
	add	sp, 4
	jmp	short loc_26A74
loc_26A5D:
	mov	si, [bp+var_1E6]
	shl	si, 1
	shl	si, 1
	push	[bp+si+var_176]
	push	[bp+si+var_178]
	push	cs
	call	near ptr transfer_bt1Character
	add	sp, 4
loc_26A74:
	mov	ax, offset newCharBuffer
	mov	dx, seg	seg027
	push	dx
	push	ax
	push	cs
	call	near ptr transfer_bt3Character
	add	sp, 4
	jmp	short loc_26A0D
l_return:
	pop	si
	mov	sp, bp
	pop	bp
	retf
importCharacter	endp

; Attributes: bp-based frame

convertSpellLevel proc far

	var_4= word ptr	-4
	var_2= word ptr	-2
	arg_0= word ptr	 6
	spLevel= word ptr  8

	push	bp
	mov	bp, sp
	mov	ax, 4
	call	someStackOperation

	cmp	[bp+spLevel], 0
	jz	short l_return
	mov	bx, [bp+arg_0]
	mov	al, mageSpellIndex[bx]
	sub	ah, ah
	mov	[bp+var_2], ax
	cmp	ax, 0FFh
	jz	short l_return
	mov	[bp+var_4], 0
loc_26AB8:
	mov	ax, [bp+spLevel]
	cmp	[bp+var_4], ax
	jge	short l_return
	push	[bp+var_2]
	push	[bp+var_4]
	mov	ax, 7
	push	ax
	call	character_learnSpellLevel
	add	sp, 6
	inc	[bp+var_4]
	jmp	short loc_26AB8
l_return:
	mov	sp, bp
	pop	bp
	retf
convertSpellLevel endp

; Attributes: bp-based frame

transfer_bt2Character proc far

	var_8= byte ptr	-8
	var_6= word ptr	-6
	var_4= word ptr	-4
	var_2= word ptr	-2
	arg_0= dword ptr  6

	push	bp
	mov	bp, sp
	mov	ax, 8
	call	someStackOperation
	push	si

	mov	ax, 78h	
	push	ax
	sub	ax, ax
	push	ax
	mov	ax, offset newCharBuffer
	mov	dx, seg seg027
	push	dx
	push	ax
	call	memset
	add	sp, 8

	mov	[bp+var_4], 0
l_copyName:
	mov	bx, [bp+var_4]
	lfs	si, [bp+arg_0]
	mov	al, fs:[bx+si]
	mov	[bp+var_8], al
	or	al, al
	jz	short l_copyStats
	mov	byte ptr gs:newCharBuffer._name[bx], al
	inc	[bp+var_4]
	jmp	short l_copyName

l_copyStats:
	lfs	bx, [bp+arg_0]
	mov	al, fs:[bx+bii_char_t.strength]
	mov	gs:newCharBuffer.strength, al
	mov	al, fs:[bx+bii_char_t.intelligence]
	mov	gs:newCharBuffer.intelligence, al
	mov	al, fs:[bx+bii_char_t.dexterity]
	mov	gs:newCharBuffer.dexterity, al
	mov	al, fs:[bx+bii_char_t.constitution]
	mov	gs:newCharBuffer.constitution, al
	mov	al, fs:[bx+bii_char_t.luck]
	mov	gs:newCharBuffer.luck, al
	mov	ax, word ptr fs:[bx+bii_char_t.experience]
	mov	dx, fs:[bx+45h]
	mov	word ptr gs:newCharBuffer.experience, ax
	mov	word ptr gs:newCharBuffer.experience+2,	dx
	mov	ax, word ptr fs:[bx+bii_char_t.gold]
	mov	dx, fs:[bx+49h]
	mov	word ptr gs:newCharBuffer.gold,	ax
	mov	word ptr gs:newCharBuffer.gold+2, dx
	mov	al, fs:[bx+bii_char_t.level]
	sub	al, 35
	sbb	cl, cl
	and	al, cl
	add	al, 35
	sub	ah, ah
	mov	gs:newCharBuffer.level,	ax
	mov	gs:newCharBuffer.maxLevel, ax
	mov	ax, fs:[bx+bii_char_t.maxHp]
	mov	gs:newCharBuffer.currentHP, ax
	mov	ax, fs:[bx+bii_char_t.maxHp]
	mov	gs:newCharBuffer.maxHP,	ax
	mov	ax, fs:[bx+bii_char_t.maxSppt]
	mov	gs:newCharBuffer.currentSppt, ax
	mov	ax, fs:[bx+bii_char_t.currentSppt]
	mov	gs:newCharBuffer.maxSppt, ax
	mov	bl, fs:[bx+bii_char_t.class]
	sub	bh, bh
	mov	al, bii_classMap[bx]
	mov	gs:newCharBuffer.class,	al
	lfs	bx, [bp+arg_0]
	mov	al, fs:[bx+bii_char_t.race]
	mov	gs:newCharBuffer.race, al
	call	getCharacterGender
	and	al, 1
	mov	gs:newCharBuffer.gender, al
	mov	bl, gs:newCharBuffer.class
	sub	bh, bh
	shl	bx, 1
	sub	ah, ah
	add	bx, ax
	mov	al, g_classPictureNumber[bx]
	mov	gs:newCharBuffer.picIndex, al
	mov	gs:newCharBuffer.status, ah

	mov	[bp+var_6], 0
	mov	[bp+var_4], 0
l_copyInventory:
	mov	si, [bp+var_4]
	shl	si, 1
	lfs	bx, [bp+arg_0]
	mov	bl, byte ptr fs:[bx+si+bii_char_t.inventory]
	sub	bh, bh
	mov	al, bii_inventoryMap[bx]
	cbw
	mov	[bp+var_2], ax
	or	ax, ax
	jz	short loc_26CE6
	mov	al, byte ptr [bp+var_2]
	mov	bx, [bp+var_6]
	mov	gs:newCharBuffer.inventory.itemNo[bx], al
	mov	bx, [bp+var_2]
	mov	al, g_itemBaseCount[bx]
	mov	bx, [bp+var_6]
	mov	gs:newCharBuffer.inventory.itemCount[bx], al
	mov	bl, gs:newCharBuffer.class
	sub	bh, bh
	mov	al, classEquipMask[bx]
	sub	ah, ah
	mov	bx, [bp+var_2]
	mov	cl, itemEquipMask[bx]
	sub	ch, ch
	test	ax, cx
	jnz	short loc_26CE2
	mov	bx, [bp+var_6]
	mov	gs:newCharBuffer.inventory.itemFlags[bx], 2
loc_26CE2:
	add	[bp+var_6], 3
loc_26CE6:
	inc	[bp+var_4]
	cmp	[bp+var_4], 8
	jl	l_copyInventory

loc_26CE9:
	mov	al, gs:newCharBuffer.class
	sub	ah, ah
	or	ax, ax
	jz	short loc_26D25
	cmp	ax, class_rogue
	jz	short loc_26CF5
	cmp	ax, class_bard
	jz	short loc_26D0E
	cmp	ax, class_paladin
	jz	short loc_26D25
	cmp	ax, class_hunter
	jz	short loc_26D36
	cmp	ax, class_monk
	jz	short loc_26D25
	jmp	short loc_26D68

loc_26CF5:
	lfs	bx, [bp+arg_0]
	mov	al, fs:[bx+bii_char_t.field_52]
	mov	gs:newCharBuffer.specAbil, al
	mov	gs:newCharBuffer.specAbil+1, al
	mov	gs:newCharBuffer.specAbil+2, al
	jmp	short loc_26D68

loc_26D0E:
	lfs	bx, [bp+arg_0]
	mov	al, fs:[bx+bii_char_t.songsLeft]
	mov	gs:newCharBuffer.specAbil, al
	mov	gs:newCharBuffer.specAbil+1, 0FCh 
	jmp	short loc_26D68

loc_26D25:
	lfs	bx, [bp+arg_0]
	mov	al, fs:[bx+bii_char_t.numAttacks]
	mov	gs:newCharBuffer.numAttacks, al
	jmp	short loc_26D68

loc_26D36:
	lfs	bx, [bp+arg_0]
	mov	al, fs:[bx+bii_char_t.field_55]
	mov	gs:newCharBuffer.specAbil, al

loc_26D68:
	lfs	bx, [bp+arg_0]
	mov	al, fs:[bx+bii_char_t.wizdLevel]
	sub	ah, ah
	push	ax
	mov	ax, 1
	push	ax
	push	cs
	call	near ptr convertSpellLevel
	add	sp, 4
	lfs	bx, [bp+arg_0]
	mov	al, fs:[bx+bii_char_t.sorcLevel]
	sub	ah, ah
	push	ax
	mov	ax, 2
	push	ax
	push	cs
	call	near ptr convertSpellLevel
	add	sp, 4
	lfs	bx, [bp+arg_0]
	mov	al, fs:[bx+bii_char_t.conjLevel]
	sub	ah, ah
	push	ax
	mov	ax, 3
	push	ax
	push	cs
	call	near ptr convertSpellLevel
	add	sp, 4
	lfs	bx, [bp+arg_0]
	mov	al, fs:[bx+bii_char_t.magiLevel]
	sub	ah, ah
	push	ax
	mov	ax, 4
	push	ax
	push	cs
	call	near ptr convertSpellLevel
	add	sp, 4
	lfs	bx, [bp+arg_0]
	mov	al, fs:[bx+bii_char_t.archLevel]
	sub	ah, ah
	push	ax
	mov	ax, 0Ah
	push	ax
	push	cs
	call	near ptr convertSpellLevel
	add	sp, 4

	pop	si
	mov	sp, bp
	pop	bp
	retf
transfer_bt2Character endp


; Attributes: bp-based frame

transfer_bt1Character proc far

	var_8= byte ptr	-8
	var_6= word ptr	-6
	var_4= word ptr	-4
	var_2= word ptr	-2
	arg_0= dword ptr  6

	push	bp
	mov	bp, sp
	mov	ax, 8
	call	someStackOperation
	push	si

	mov	ax, 78h	
	push	ax
	sub	ax, ax
	push	ax
	mov	ax, offset newCharBuffer
	mov	dx, seg seg027
	push	dx
	push	ax
	call	memset
	add	sp, 8
	mov	[bp+var_4], 0

l_copyName:
	mov	bx, [bp+var_4]
	lfs	si, [bp+arg_0]
	mov	al, fs:[bx+si]
	mov	[bp+var_8], al
	or	al, al
	jz	short l_copyStats
	mov	byte ptr gs:newCharBuffer._name[bx], al
	inc	[bp+var_4]
	jmp	short l_copyName

l_copyStats:
	lfs	bx, [bp+arg_0]
	mov	al, byte ptr fs:[bx+bi_char_t.strength]
	mov	gs:newCharBuffer.strength, al
	mov	al, byte ptr fs:[bx+bi_char_t.intelligence]
	mov	gs:newCharBuffer.intelligence, al
	mov	al, byte ptr fs:[bx+bi_char_t.dexterity]
	mov	gs:newCharBuffer.dexterity, al
	mov	al, byte ptr fs:[bx+bi_char_t.constitution]
	mov	gs:newCharBuffer.constitution, al
	mov	al, byte ptr fs:[bx+bi_char_t.luck]
	mov	gs:newCharBuffer.luck, al
	mov	ax, word ptr fs:[bx+bi_char_t.experience]
	mov	dx, fs:[bx+47h]
	mov	word ptr gs:newCharBuffer.experience, ax
	mov	word ptr gs:newCharBuffer.experience+2,	dx
	mov	ax, word ptr fs:[bx+bi_char_t.gold]
	mov	dx, fs:[bx+4Bh]
	mov	word ptr gs:newCharBuffer.gold,	ax
	mov	word ptr gs:newCharBuffer.gold+2, dx
	mov	ax, fs:[bx+bi_char_t.level]
	sub	al, 35
	sbb	cl, cl
	and	al, cl
	add	al, 35
	mov	gs:newCharBuffer.level,	ax
	mov	gs:newCharBuffer.maxLevel, ax
	mov	ax, fs:[bx+bi_char_t.maxHP]
	mov	gs:newCharBuffer.currentHP, ax
	mov	ax, fs:[bx+bi_char_t.maxHP]
	mov	gs:newCharBuffer.maxHP,	ax
	mov	ax, fs:[bx+bi_char_t.currentSppt]
	mov	gs:newCharBuffer.currentSppt, ax
	mov	ax, fs:[bx+bi_char_t.maxSppt]
	mov	gs:newCharBuffer.maxSppt, ax
	mov	bx, fs:[bx+bi_char_t.class]
	mov	al, bii_classMap[bx]
	mov	gs:newCharBuffer.class,	al
	lfs	bx, [bp+arg_0]
	mov	al, byte ptr fs:[bx+bi_char_t.race]
	mov	gs:newCharBuffer.race, al
	call	getCharacterGender
	and	al, 1
	mov	gs:newCharBuffer.gender, al
	mov	bl, gs:newCharBuffer.class
	sub	bh, bh
	shl	bx, 1
	sub	ah, ah
	add	bx, ax
	mov	al, g_classPictureNumber[bx]
	mov	gs:newCharBuffer.picIndex, al
	mov	gs:newCharBuffer.status, ah
	mov	[bp+var_6], 0
	mov	[bp+var_4], 0
	jmp	short loc_26F55
loc_26F52:
loc_26F55:
	mov	si, [bp+var_4]
	shl	si, 1
	lfs	bx, [bp+arg_0]
	mov	bl, byte ptr fs:[bx+si+bi_char_t.inventory]
	sub	bh, bh
	mov	al, bi_inventoryMap[bx]
	cbw
	mov	[bp+var_2], ax
	or	ax, ax
	jz	short loc_26FD1
	mov	al, byte ptr [bp+var_2]
	mov	bx, [bp+var_6]
	mov	gs:newCharBuffer.inventory.itemNo[bx], al
	mov	bx, [bp+var_2]
	mov	al, g_itemBaseCount[bx]
	mov	bx, [bp+var_6]
	mov	gs:newCharBuffer.inventory.itemCount[bx], al
	mov	bl, gs:newCharBuffer.class
	sub	bh, bh
	mov	al, classEquipMask[bx]
	sub	ah, ah
	mov	bx, [bp+var_2]
	mov	cl, itemEquipMask[bx]
	sub	ch, ch
	test	ax, cx
	jnz	short loc_26FCD
	mov	bx, [bp+var_6]
	mov	gs:newCharBuffer.inventory.itemFlags[bx], 2
loc_26FCD:
	add	[bp+var_6], 3
loc_26FD1:
	inc	[bp+var_4]
	cmp	[bp+var_4], 8
	jl	loc_26F52

	mov	al, gs:newCharBuffer.class
	sub	ah, ah
	or	ax, ax
	jz	short loc_27010
	cmp	ax, class_rogue
	jz	short loc_26FE0
	cmp	ax, class_bard
	jz	short loc_26FF9
	cmp	ax, class_paladin
	jz	short loc_27010
	cmp	ax, class_hunter
	jz	short loc_27021
	cmp	ax, class_monk
	jz	short loc_27010
	jmp	short loc_27053

loc_26FE0:
	lfs	bx, [bp+arg_0]
	mov	al, byte ptr fs:[bx+bi_char_t.field_55]
	mov	gs:newCharBuffer.specAbil, al
	mov	gs:newCharBuffer.specAbil+1, al
	mov	gs:newCharBuffer.specAbil+2, al
	jmp	short loc_27053

loc_26FF9:
	lfs	bx, [bp+arg_0]
	mov	al, byte ptr fs:[bx+bi_char_t.songsLeft]
	mov	gs:newCharBuffer.specAbil, al
	mov	gs:newCharBuffer.specAbil+1, 0FCh
	jmp	short loc_27053

loc_27010:
	lfs	bx, [bp+arg_0]
	mov	al, byte ptr fs:[bx+bi_char_t.numAttacks]
	mov	gs:newCharBuffer.numAttacks, al
	jmp	short loc_27053

loc_27021:
	lfs	bx, [bp+arg_0]
	mov	al, byte ptr fs:[bx+bi_char_t.field_5B]
	mov	gs:newCharBuffer.specAbil, al

loc_27053:
	lfs	bx, [bp+arg_0]
	mov	al, fs:[bx+bi_char_t.wizdLevel]
	sub	ah, ah
	push	ax
	mov	ax, 1
	push	ax
	push	cs
	call	near ptr convertSpellLevel
	add	sp, 4
	lfs	bx, [bp+arg_0]
	mov	al, fs:[bx+bi_char_t.sorcLevel]
	sub	ah, ah
	push	ax
	mov	ax, 2
	push	ax
	push	cs
	call	near ptr convertSpellLevel
	add	sp, 4
	lfs	bx, [bp+arg_0]
	mov	al, fs:[bx+bi_char_t.conjLevel]
	sub	ah, ah
	push	ax
	mov	ax, 3
	push	ax
	push	cs
	call	near ptr convertSpellLevel
	add	sp, 4
	lfs	bx, [bp+arg_0]
	mov	al, fs:[bx+bi_char_t.magiLevel]
	sub	ah, ah
	push	ax
	mov	ax, 4
	push	ax
	push	cs
	call	near ptr convertSpellLevel
	add	sp, 4

	pop	si
	mov	sp, bp
	pop	bp
	retf
transfer_bt1Character endp


seg017 ends

; Segment type: Pure code
seg018 segment byte public 'CODE' use16
        assume cs:seg018
;org 0Ch
        assume es:nothing, ss:nothing, ds:dseg, fs:nothing, gs:seg027

; DWORD - var_130 & var_132
;
; Attributes: bp-based frame

copyProtection proc	far

	var_14C= word ptr -14Ch
	var_14A= word ptr -14Ah
	var_136= word ptr -136h
	random16_3= word ptr -134h
	var_132= word ptr -132h
	var_130= word ptr -130h
	var_12E= word ptr -12Eh
	var_12C= word ptr -12Ch
	var_12A= word ptr -12Ah
	random16_1= word ptr -2Ah
	var_28=	word ptr -28h
	var_26=	word ptr -26h
	var_24=	word ptr -24h
	random16_2= word ptr -22h
	var_20=	word ptr -20h
	var_1E=	word ptr -1Eh
	var_A= word ptr	-0Ah
	random16_4= word ptr -6
	var_4= word ptr	-4
	var_2= word ptr	-2

	push	bp
	mov	bp, sp
	mov	ax, 14Ch
	call	someStackOperation
	push	si

	call	random
	and	ax, 0Fh
	mov	[bp+random16_1], ax
	call	random
	and	ax, 0Fh
	mov	[bp+random16_2], ax
	call	random
	and	ax, 0Fh
	mov	[bp+random16_3], ax

	call	random
	and	ax, 0Fh
	mov	[bp+random16_4], ax
	mov	bx, ax
	mov	al, byte_4CA18[bx]
	sub	ah, ah
	mov	[bp+var_A], ax			; var_A = byte_4CA18[random16_4]
	mov	cl, 4
	shr	ax, cl
	mov	[bp+var_136], ax		; var_136 = var_A >> 4

	mov	al, byte ptr [bp+random16_4]
	xor	al, byte ptr [bp+random16_1]
	test	al, 1				; if ((random16_1 ^ random16_4) & 1)
	jz	short loc_2712B
	mov	ax, [bp+var_A]
	and	ax, 7
	shl	ax, 1
	mov	cx, [bp+random16_2]
	and	cx, 1
	or	ax, cx				
	mov	[bp+var_12E], ax		;   var_12E = ((var_A & 7) << 1) | (random16_2 & 1))

	mov	bx, ax
	mov	al, byte_4CA28[bx]
	sub	ah, ah
	add	ax, [bp+random16_1]
	sub	ax, [bp+var_136]
	and	ax, 0Fh
	mov	[bp+random16_2], ax		;   random16_2 = (byte_4CA28[var_12E] + random16_1 - var_136) & 0Fh
						; endif
loc_2712B:
	mov	ax, [bp+var_A]
	and	ax, 7
	shl	ax, 1
	mov	[bp+var_12E], ax		; var_12E = ((var_A & 7) << 1)

	mov	ax, [bp+random16_2]
	sub	ax, [bp+random16_1]
	add	ax, [bp+var_136]
	and	ax, 0Fh
	mov	[bp+var_12C], ax		; var_12C = (random16_2 - random16_1 + var_136) & 0Fh

	mov	bx, [bp+var_12E]
	mov	al, byte_4CA28[bx]
	sub	ah, ah
	cmp	ax, [bp+var_12C]
	jz	short loc_27162			; if (byte_4CA28[var_12E] == var_12C) var_26 = 1
	mov	al, byte_4CA28[bx + 1]
	cmp	ax, [bp+var_12C]		; if (byte_4CA28[var_12E+1] == var_12C) var_26 = 1
	jnz	short loc_27167			; else var_26 = 0
loc_27162:
	mov	ax, 1
	jmp	short loc_27169
loc_27167:
	sub	ax, ax
loc_27169:
	mov	[bp+var_26], ax
	or	ax, ax
	jz	short loc_2717F			; if var_26 != 0
	mov	ax, [bp+random16_3]
	sub	ax, [bp+random16_1]
	mov	cl, 4
	shl	ax, cl
	or	al, 8
	jmp	short loc_27189			;   var_4 = ((random16_3 - random16_1) << 4) | 8

loc_2717F:					; else
	mov	ax, [bp+random16_2]
	sub	ax, [bp+random16_1]
	mov	cl, 4
	shl	ax, cl				;   var_4 = (random16_2 - random16_1) << 4

loc_27189:
	mov	[bp+var_4], ax
	mov	al, byte ptr [bp+var_4]
	add	al, byte ptr [bp+var_A]
	sub	ah, ah
	mov	[bp+var_2], ax			; var_2 = var_4 + var_A

	mov	ah, byte ptr [bp+var_2]
	sub	al, al
	add	ax, [bp+var_2]
	mov	[bp+var_24], ax			; var_24 = (var_2 & 0F0h) + var_2

	mov	[bp+var_28], 0Fh		; var_28 = 0Fh
loc_271A9:					; do {
	mov	ax, [bp+var_24]
	and	ax, 1
	mov	[bp+var_4], ax			;   var_4 = var_24 & 1
	shr	[bp+var_24], 1			;   var_24 >> 1
	or	ax, ax				;   if var_4 != 0
	jz	short loc_271C6			;     var_24 += 0B400
	add	byte ptr [bp+var_24+1],	0B4h
loc_271C6:
	dec	[bp+var_28]			; } while (--var_28 > 0)
	cmp	[bp+var_28], 0
	jg	short loc_271A9

loc_271C8:
	mov	al, byte ptr [bp+var_24+1]
	sub	ah, ah
	mov	[bp+var_14C], ax
	mov	ax, [bp+var_2]
	and	ax, 7
	mov	si, ax
	shr	si, 1
	mov	al, byte_4CA38[si]
	sub	ah, ah
	and	[bp+var_14C], ax
	mov	ax, si
	xor	al, 3
	mov	[bp+var_20], ax


	; Zero 20 bytes of var_1E
	mov	[bp+var_28], 0
loc_271F3:
	mov	si, [bp+var_28]
	mov	byte ptr [bp+si+var_1E], 0
	inc	[bp+var_28]
	cmp	[bp+var_28], 20
	jl	short loc_271F3

	mov	[bp+var_28], 0

	mov	ax, [bp+var_14C]
	mov	cl, 7
	shr	ax, cl
	push	ax
	push	cs
	call	near ptr cp_toDigit
	add	sp, 2
	mov	si, [bp+var_28]
	inc	[bp+var_28]
	mov	byte ptr [bp+si+var_1E], al			; var_1E[0] = ((var_14C >> 7) & 7) | 0x30

	mov	ax, [bp+var_14C]
	mov	cl, 4
	shr	ax, cl
	push	ax
	push	cs
	call	near ptr cp_toDigit
	add	sp, 2
	mov	si, [bp+var_28]
	inc	[bp+var_28]
	mov	byte ptr [bp+si+var_1E], al			; var_1E[1] = ((var_14C >> 4) & 7) | 0x30

	mov	ax, [bp+var_14C]
	shr	ax, 1
	push	ax
	push	cs
	call	near ptr cp_toDigit
	add	sp, 2
	mov	si, [bp+var_28]
	inc	[bp+var_28]
	mov	byte ptr [bp+si+var_1E], al			; var_1E[2] = ((var_14C >> 1) & 7) | 0x30

	mov	ax, [bp+var_24]
	mov	cl, 6
	shr	ax, cl
	push	ax
	push	cs
	call	near ptr cp_toDigit
	add	sp, 2
	mov	si, [bp+var_28]
	inc	[bp+var_28]
	mov	byte ptr [bp+si+var_1E], al			; var_1E[3] = ((var_24 >> 6) & 7) | 0x30

	mov	ax, [bp+var_24]
	mov	cl, 3
	shr	ax, cl
	push	ax
	push	cs
	call	near ptr cp_toDigit
	add	sp, 2
	mov	si, [bp+var_28]
	inc	[bp+var_28]
	mov	byte ptr [bp+si+var_1E], al			; var_1E[4] = ((var_24 >> 3) & 7 | 0x30

	push	[bp+var_24]
	push	cs
	call	near ptr cp_toDigit
	add	sp, 2
	mov	si, [bp+var_28]
	inc	[bp+var_28]
	mov	byte ptr [bp+si+var_1E], al			; var_1E[5] = (var_24 & 7) | 0x30

	mov	ax, offset s_copyProtectIntro
	push	ds
	push	ax
	lea	ax, [bp+var_12A]
	push	ss
	push	ax
	call	strcat
	add	sp, 8
	mov	[bp+var_132], ax
	mov	[bp+var_130], dx

	mov	bx, [bp+random16_1]
	shl	bx, 1
	shl	bx, 1
	push	word ptr (g_cpLocationOne+2)[bx]
	push	word ptr g_cpLocationOne[bx]
	push	dx
	push	ax
	call	strcat
	add	sp, 8
	mov	[bp+var_132], ax
	mov	[bp+var_130], dx

	mov	ax, offset s_commaSpace
	push	ds
	push	ax
	push	dx
	push	[bp+var_132]
	call	strcat
	add	sp, 8
	mov	[bp+var_132], ax
	mov	[bp+var_130], dx

	mov	bx, [bp+random16_2]
	shl	bx, 1
	shl	bx, 1
	push	word ptr (g_cpLocationTwo+2)[bx]
	push	word ptr g_cpLocationTwo[bx]
	push	dx
	push	ax
	call	strcat
	add	sp, 8
	mov	[bp+var_132], ax
	mov	[bp+var_130], dx

	mov	ax, offset s_commaSpace
	push	ds
	push	ax
	push	dx
	push	[bp+var_132]
	call	strcat
	add	sp, 8
	mov	[bp+var_132], ax
	mov	[bp+var_130], dx

	mov	bx, [bp+random16_3]
	shl	bx, 1
	shl	bx, 1
	push	word ptr (g_cpLocationThree+2)[bx]
	push	word ptr g_cpLocationThree[bx]
	push	dx
	push	ax
	call	strcat
	add	sp, 8
	mov	[bp+var_132], ax
	mov	[bp+var_130], dx

	mov	ax, offset s_commaAnd
	push	ds
	push	ax
	push	dx
	push	[bp+var_132]
	call	strcat
	add	sp, 8
	mov	[bp+var_132], ax
	mov	[bp+var_130], dx

	mov	bx, [bp+random16_4]
	shl	bx, 1
	shl	bx, 1
	push	word ptr (g_cpLocationFour+2)[bx]
	push	word ptr g_cpLocationFour[bx]
	push	dx
	push	ax
	call	strcat
	add	sp, 8
	mov	[bp+var_132], ax
	mov	[bp+var_130], dx
	mov	ax, offset s_period
	push	ds
	push	ax
	push	dx
	push	[bp+var_132]
	call	strcat
	add	sp, 8
	mov	[bp+var_132], ax
	mov	[bp+var_130], dx

	lea	ax, [bp+var_12A]
	push	ss
	push	ax
	call	printString
	add	sp, 4
	mov	ax, 10h
	push	ax
	lea	ax, [bp+var_14A]
	push	ss
	push	ax
	call	readString
	add	sp, 6

	push	[bp+var_20]
	lea	ax, [bp+var_1E]
	push	ss
	push	ax
	lea	ax, [bp+var_14A]
	push	ss
	push	ax
	push	cs
	call	near ptr cp_compareStrings
	add	sp, 0Ah

	pop	si
	mov	sp, bp
	pop	bp
	retf
copyProtection endp

; Attributes: bp-based frame

cp_toDigit proc far

	inValue= word ptr	 6

	push	bp
	mov	bp, sp

	mov	ax, [bp+inValue]
	and	ax, 7
	or	al, 30h
	mov	sp, bp
	pop	bp
	retf
cp_toDigit endp

; Attributes: bp-based frame

cp_compareStrings proc far

	var_2= word ptr	-2
	arg_0= dword ptr  6
	arg_4= dword ptr  0Ah
	arg_8= word ptr	 0Eh

	push	bp
	mov	bp, sp
	mov	ax, 2
	call	someStackOperation
	push	si

	mov	ax, [bp+arg_8]
	mov	[bp+var_2], ax
l_loop:
	lfs	bx, [bp+arg_0]
	inc	word ptr [bp+arg_0]
	mov	al, fs:[bx]
	mov	bx, [bp+var_2]
	lfs	si, [bp+arg_4]
	cmp	fs:[bx+si], al
;	jnz	short l_returnFail		; Uncomment to enable copy protection
	inc	[bp+var_2]
	cmp	[bp+var_2], 7
	jl	short l_loop
	jmp	short l_returnSuccess

l_returnFail:
	sub	ax, ax
	jmp	short l_return

l_returnSuccess:
	mov	ax, 1

l_return:
	pop	si
	mov	sp, bp
	pop	bp
	retf
cp_compareStrings endp



seg018 ends

; Segment type: Pure code
seg019 segment word public 'CODE' use16
        assume cs:seg019
;org 3
        assume es:nothing, ss:nothing, ds:dseg, fs:nothing, gs:nothing

byte_27433 db 90h, 10h dup(0)

huf_init proc far

	fileHandle= word ptr	 6

	push	bp
	mov	bp, sp
	push	ds
	push	si
	push	di
	push	es
	mov	ax, seg	seg020
	mov	ds, ax
	assume ds:seg020
	mov	bx, [bp+fileHandle]
	mov	huf_fileHandle, bx
	mov	ah, 3Fh	
	mov	dx, offset huf_fileBuffer
	mov	cx, 200h
	int	21h		; BX = file handle, CX = number	of bytes to read
				; DS:DX	-> buffer
	mov	si, offset huf_fileBuffer
	lodsw
	mov	dx, ax
	lodsw
	xchg	al, ah
	xchg	dl, dh
	mov	word ptr huf_dataSize, ax
	mov	word ptr huf_dataSize+2, dx
	mov	huf_nodeListTail, 0
	add	si, 4
	lodsb
	mov	huf_fileBufferIndex, si
	mov	huf_bitMask, 80h
	mov	huf_currentByte, al
	mov	ax, offset huf_treeData
	push	ax
	call	huf_expandTree
	add	sp, 2
	pop	es
	pop	di
	pop	si
	pop	ds
	assume ds:dseg
	pop	bp
	retf
huf_init endp

huf_flate	proc far

	bufferP= dword ptr  6
	maxSize= word ptr	 0Ah

	push	bp
	mov	bp, sp
	push	es
	push	ds
	mov	ax, seg	seg020
	mov	ds, ax
	assume ds:seg020
	push	si
	push	di

	les	di, [bp+bufferP]
	mov	huf_bufferP, di
	mov	bx, [bp+maxSize]
	mov	huf_flateSize, bx
	mov	ax, word ptr huf_dataSize
	mov	dx, word ptr huf_dataSize+2
	sub	cx, cx
	sub	bx, ax
	sbb	cx, dx
	jl	short l_skipFixSize
	mov	huf_flateSize, ax		; Set flateSize to huf_dataSize 
						; if huf_dataSize < huf_flateSize
l_skipFixSize:
	mov	huf_flateByteCount, 0

loc_274CA:
	mov	ax, huf_flateSize
	cmp	ax, huf_flateByteCount
	jz	short l_return

	mov	di, offset huf_treeData

loc_274D6:
	cmp	word ptr [di], 0
	jz	short loc_274F8

	mov	ax, word ptr huf_bitMask
	or	al, al
	jz	short l_getNextByte

loc_274E2:
	and	ah, al
	shr	al, 1
	mov	huf_bitMask, al
	mov	al, ah
	or	al, al
	jnz	short loc_274F3

	mov	di, [di]
	jmp	short loc_274D6

loc_274F3:
	mov	di, [di+2]
	jmp	short loc_274D6

loc_274F8:
	mov	al, [di+4]
	mov	di, huf_bufferP
	stosb
	mov	huf_bufferP, di
	inc	huf_flateByteCount
	jmp	short loc_274CA

l_return:
	sub	word ptr huf_dataSize, ax
	sbb	word ptr huf_dataSize+2, 0
	pop	di
	pop	si
	pop	ds
	assume ds:dseg
	pop	es
	pop	bp
	retf

l_getNextByte:
	mov	si, ds:huf_fileBufferIndex
	cmp	si, offset huf_fileBufferIndex
	jz	short l_nextFileBuffer
	lodsb
	mov	ds:huf_currentByte, al
	mov	ds:huf_fileBufferIndex, si
	mov	ah, 80h
	xchg	al, ah
	jmp	short loc_274E2

l_nextFileBuffer:
	mov	ah, 3Fh	
	mov	bx, ds:huf_fileHandle
	mov	cx, 200h
	mov	dx, offset huf_fileBuffer
	int	21h	; DOS -	2+ - call(read) FROM FILE WITH HANDLE
			; BX = file handle, CX = number	of bytes to read
			; DS:DX	-> buffer
	mov	si, dx
	lodsb
	mov	ah, 80h
	mov	ds:huf_fileBufferIndex, si
	mov	ds:huf_currentByte, al
	xchg	al, ah
	jmp	short loc_274E2
huf_flate	endp

; Attributes: bp-based frame
;
; Recursively reconstruct the Huffman tree
;
huf_expandTree	proc near

	arg_0= word ptr	 2

	call	huf_getNextBit
	jnz	short loc_27576

	call	huf_newNode
	mov	di, ax
	call	huf_newNode
	mov	bp, sp
	mov	si, [bp+arg_0]
	mov	[si], di
	mov	[si+2],	ax
	push	ax
	push	di
	call	huf_expandTree
	add	sp, 2
	call	huf_getNextBit
	call	huf_expandTree
	add	sp, 2
	retn

loc_27576:
	call	huf_extractByte
	mov	bp, sp
	mov	si, [bp+arg_0]
	mov	[si+4],	al
	retn
huf_expandTree	endp

huf_getNextBit	proc near
	mov	ax, word ptr ds:huf_bitMask
	or	al, al
	jz	short l_getNextByte

l_return:
	and	ah, al
	shr	al, 1
	mov	ds:huf_bitMask, al
	mov	al, ah
	or	al, al
	retn

l_getNextByte:
	mov	si, ds:huf_fileBufferIndex
	cmp	si, offset huf_fileBufferIndex
	jz	short l_readMoreData
	lodsb
	mov	byte ptr ds:huf_currentByte, al
	mov	ds:huf_fileBufferIndex, si
	mov	ah, 80h
	xchg	al, ah
	jmp	short l_return

l_readMoreData:
	mov	ah, 3Fh	
	mov	bx, ds:huf_fileHandle
	mov	cx, 200h
	mov	dx, offset huf_fileBuffer
	int	21h	; DOS -	2+ - call(read) FROM FILE WITH HANDLE
			; BX = file handle, CX = number	of bytes to read
			; DS:DX	-> buffer
	mov	si, dx
	lodsb
	mov	ah, 80h
	mov	ds:huf_fileBufferIndex, si
	mov	byte ptr ds:huf_currentByte, al
	xchg	al, ah
	jmp	short l_return
huf_getNextBit	endp

; Returns the address of the new node
;
; Returns 0 on failure
;
huf_newNode proc near
	mov	ax, ds:huf_nodeListTail
	cmp	ax, 300h
	jge	short l_returnFail

	mov	bx, ax
	inc	ax
	mov	ds:huf_nodeListTail, ax
	mov	ax, bx
	shl	ax, 1
	shl	ax, 1
	add	ax, bx
	add	ax, (offset huf_treeData+5)
	mov	bx, ax
	mov	word ptr [bx], 0
	retn

l_returnFail:
	sub	ax, ax
	retn
huf_newNode endp

huf_extractByte proc near
	mov	bp, 8

loc_275CE:
	shl	di, 1
	call	huf_getNextBit
	jz	short loc_275D8
	or	di, 1

loc_275D8:
	dec	bp

	jnz	short loc_275CE
	mov	ax, di
	retn
huf_extractByte endp

; Read 64 words from the source and write to the work buffer
;
; Resets d3cmp_workBufIndex
;
d3cmp_readData proc near
	push	es
	push	di
	push	cx
	push	si
	push	ax
	cld
	mov	ax, ds
	mov	es, ax
	assume es:dseg
	mov	di, offset d3cmp_workBuf
	mov	si, word ptr d3cmp_srcP
	add	word ptr d3cmp_srcP, 80h
	mov	ds, word ptr d3cmp_srcP+2
	mov	cx, 64
	rep movsw
	mov	ax, es
	mov	ds, ax
	mov	d3cmp_workBufIndex, 0
	pop	ax
	pop	si
	pop	cx
	pop	di
	pop	es
	assume es:nothing
	retn
d3cmp_readData endp

sub_27632 proc near
	mov	si, d3cmp_workBufIndex
	xor	ax, ax
	test	si, 80h
	jnz	short loc_27647
loc_2763E:
	mov	al, byte ptr d3cmp_workBuf[si]
	inc	d3cmp_workBufIndex
	retn
loc_27647:
	call	d3cmp_readData
	xor	si, si
	jmp	short loc_2763E
sub_27632 endp

; Copy a number of bytes from d3comp_outputBuffer to the 
; destination buffer at d3cmp_destP
;
; bp has the number of bytes to copy
;
d3cmp_outputToBuffer proc near
	push	es
	push	di
	push	si
	cld
	mov	ax, word ptr d3cmp_destP
	mov	es, ax
	mov	di, word ptr d3cmp_destP+2
	mov	si, offset d3comp_outputBuffer
	mov	cx, bp
	rep movsb
	add	word ptr d3cmp_destP+2, bp
	jb	short loc_2766C

loc_27668:
	pop	si
	pop	di
	pop	es
	retn

loc_2766C:
	add	word ptr d3cmp_destP, 1000h
	add	word_4EE46, 1
	jmp	short loc_27668
d3cmp_outputToBuffer endp

d3cmp_updateMemory proc	near
	push	bp
	push	ax
	push	di
	cmp	word_4D12F, 8000h
	jnz	short loc_27699
	push	ax
	push	bx
	push	cx
	push	dx
	push	si
	push	di
	push	ds
	push	es
	push	bp
	call	sub_27980
	pop	bp
	pop	es
	pop	ds
	pop	di
	pop	si
	pop	dx
	pop	cx
	pop	bx
	pop	ax
loc_27699:
	mov	si, ax
	shl	si, 1
	mov	bp, word_4D619[si]
loc_276A1:
	mov	cx, bp
	shl	bp, 1
	inc	ds:word_4CC4B[bp]
	mov	si, ds:word_4CC4B[bp]
	mov	bx, cx
	inc	bx
	shl	bx, 1
	cmp	word_4CC4B[bx],	si
	jb	short loc_276BE
	mov	bx, bp
	jmp	short loc_27716
loc_276BE:
	add	bx, 2
	cmp	si, word_4CC4B[bx]
	ja	short loc_276BE
	sub	bx, 2
	mov	ax, word_4CC4B[bx]
	mov	di, cx
	shl	di, 1
	mov	word_4CC4B[di],	ax
	mov	word_4CC4B[bx],	si
	mov	si, word_4D88D[di]
	shl	si, 1
	shr	bx, 1
	mov	word_4D133[si], bx
	cmp	si, 1254
	jge	short loc_276F0
	mov	word_4D133[si+2], bx
loc_276F0:
	shl	bx, 1
	mov	di, word_4D88D[bx]
	shl	di, 1
	shr	si, 1
	mov	word_4D88D[bx],	si
	mov	word_4D133[di], cx
	cmp	di, 4E6h
	jge	short loc_2770C
	mov	word_4D133[di+2], cx
loc_2770C:
	mov	si, cx
	shl	si, 1
	shr	di, 1
	mov	word_4D88D[si],	di
loc_27716:
	mov	bp, word_4D133[bx]
	or	bp, bp
	jz	short loc_27720
	jmp	short loc_276A1
loc_27720:
	pop	di
	pop	ax
	pop	bp
	retn
d3cmp_updateMemory endp



sub_27724 proc near
	cmp	dl, 8
	jbe	short loc_27733
loc_27729:
	xor	ax, ax
	shl	di, 1
	adc	ax, 0
	dec	dl
	retn
loc_27733:
	mov	si, d3cmp_workBufIndex
	xor	ax, ax
	test	si, 80h
	jnz	short loc_27759
loc_2773F:
	mov	al, byte ptr d3cmp_workBuf[si]
	inc	d3cmp_workBufIndex
	mov	cl, 8
	sub	cl, dl
	shl	ax, cl
	or	di, ax
	add	dl, 8
	test	cl, 8
	jz	short loc_27729
	jmp	short loc_27733
loc_27759:
	call	d3cmp_readData
	xor	si, si
	jmp	short loc_2773F
sub_27724 endp

; This function extracts the next data element from the source
; buffer.
;
d3cmp_getNextWord proc near
	mov	bx, word_4DD71

loc_27791:
	shl	bx, 1
	cmp	bx, 1254
	jnb	short loc_277B1

	cmp	dl, 8
	jbe	short l_updateDataWord

loc_2779E:
	xor	ax, ax
	shl	di, 1
	adc	ax, 0
	dec	dl
	shl	ax, 1
	add	bx, ax
	mov	bx, word_4D88D[bx]
	jmp	short loc_27791

; ==============================================
; updateDataWord()
; ==============================================
l_updateDataWord:
	mov	si, d3cmp_workBufIndex
	xor	ax, ax
	test	si, 80h
	jnz	short loc_27786

loc_2776C:
	mov	al, byte ptr d3cmp_workBuf[si]
	inc	d3cmp_workBufIndex
	mov	cl, 8
	sub	cl, dl
	shl	ax, cl
	or	di, ax
	add	dl, 8
	test	cl, 8
	jz	short loc_2779E
	jmp	short l_updateDataWord

loc_27786:
	CALL(d3cmp_readData)
	xor	si, si
	jmp	short loc_2776C
; ==============================================
; updateDataWord() end
; ==============================================

loc_277B1:
	mov	ax, bx
	shr	ax, 1
	sub	ax, 627
	CALL(d3cmp_updateMemory)
	retn
d3cmp_getNextWord endp

; This function uses the high byte of the current data
; word to determine the offset of the sequence that is
; to be repeated in d3cmp_outputBuffer
;
; A return value of 0 indicates that the previous
; byte is repeated
;

d3cmp_readCopyOffset proc near

; This section is common to several functions
; and updates the current data word stored in di
; ==============================================
; updateDataWord()
; ==============================================
	cmp	dl, 8
	ja	short loc_277EE
loc_277C1:
	mov	si, d3cmp_workBufIndex
	xor	ax, ax
	test	si, 80h
	jnz	short l_readData
loc_277CD:
	mov	al, byte ptr d3cmp_workBuf[si]
	inc	d3cmp_workBufIndex
	mov	cl, 8
	sub	cl, dl
	shl	ax, cl
	or	di, ax
	add	dl, 8
	test	cl, 8
	jz	short loc_277EE
	jmp	short loc_277C1
l_readData:
	CALL(d3cmp_readData)
	xor	si, si
	jmp	short loc_277CD
; ==============================================
; updateDataWord() end
; ==============================================

loc_277EE:
	; Extract 8 bits to index into byte_4CB3F
	sub	dl, 8			; subtract 8 from dataShift value
	mov	bx, di			; save original dataWord value
	xor	ax, ax			; clear ax
	xchg	bl, ah			; 
	mov	di, ax			; dataWord = (dataWord << 8)
	xchg	bh, bl			; bx = low 8 bits of original dataWord 
					; bx = index into byte_4CB3F & byte_4CA3F
					; arrays

	xor	cx, cx
	mov	ch, byte_4CB3F[bx]	; write byte_4CB3F value to high 8 bits
	shr	cx, 1
	shr	cx, 1
	push	cx			; Equivalent to cx = (byte_4CB3F[index] << 6)

	xor	cx, cx
	mov	cl, byte_4CA3F[bx]
	dec	cl
	dec	cl			; cx = (byte_4CA3F[index] - 2)
	jcxz	short l_return

loc_27812:
	shl	bx, 1
	xchg	dh, cl
	cmp	dl, 8
	jbe	short l_updateDataWord

loc_2781B:
	xor	ax, ax
	shl	di, 1
	adc	ax, 0
	dec	dl
	xchg	cl, dh
	add	bx, ax
	loop	loc_27812

l_return:
	pop	cx
	and	bx, 3Fh
	or	cx, bx
	mov	ax, cx
	retn

; ==============================================
; updateDataWord()
; ==============================================
l_updateDataWord:
	mov	si, d3cmp_workBufIndex
	xor	ax, ax
	test	si, 80h
	jnz	short loc_27859
loc_2783F:
	mov	al, byte ptr d3cmp_workBuf[si]
	inc	d3cmp_workBufIndex
	mov	cl, 8
	sub	cl, dl
	shl	ax, cl
	or	di, ax
	add	dl, 8
	test	cl, 8
	jz	short loc_2781B
	jmp	short l_updateDataWord

loc_27859:
	CALL(d3cmp_readData)
	xor	si, si
	jmp	short loc_2783F
; ==============================================
; updateDataWord() end
; ==============================================
d3cmp_readCopyOffset endp

d3cmp_init proc	near
	push	bp
	push	di
	push	si
	xor	si, si				
	mov	bp, 2

loc_27868:					 
	mov	cx, si				; for (i = 0; i < 314; i++) {
	shr	cx, 1				;
	mov	word_4CC4B[si],	1		;	word_4CC4B[i] = 1
	mov	di, cx
	add	di, 627				;
	mov	word_4D88D[si],	di		; 	word_4D88D[i] = i + 627
	shl	di, 1
	mov	word_4D133[di], cx		;	word_4D133[i+627] = i
	add	si, bp
	cmp	si, 628
	jl	short loc_27868

	xor	di, di
	mov	bx, 628
loc_2788F:
	mov	ax, word_4CC4B[di]
	add	ax, word_4CC4B[di+2]
	mov	word_4CC4B[bx],	ax
	shr	di, 1
	mov	word_4D88D[bx],	di
	shl	di, 1
	shr	bx, 1
	mov	word_4D133[di], bx
	mov	word_4D133[di+2], bx
	shl	bx, 1
	add	di, 4
	add	bx, bp
	cmp	bx, 1252
	jle	short loc_2788F
	mov	word_4D131, 0FFFFh
	mov	word_4D617, 0
	pop	si
	pop	di
	pop	bp
	retn
d3cmp_init endp


d3cmp_doDecomp proc near
	push	bp
	mov	ax, word ptr dataHeader		; Return if dataHeader == 0
	or	ax, word ptr dataHeader+2
	jz	l_return

	CALL(d3cmp_init)
	xor	bp, bp
	sub	ax, ax
	mov	word ptr countMaybe+2, ax
	mov	word ptr countMaybe, ax
	sub	dx, dx

loc_278E6:
	mov	ax, word ptr dataHeader
	mov	cx, word ptr dataHeader+2
	cmp	word ptr countMaybe+2, cx
	ja	l_output

loc_278F6:
	jb	short loc_27901
	cmp	word ptr countMaybe, ax
	jnb	short l_output

loc_27901:
	CALL(d3cmp_getNextWord)
	cmp	ax, 256				; Just output the value if less than 256
	jge	short l_repeatSequence
	mov	ds:d3comp_outputBuffer[bp], al
	inc	bp
	test	bp, 4096
	jz	short loc_2791B
	CALL(d3cmp_outputToBuffer)
	mov	bp, 0

loc_2791B:
	add	word ptr countMaybe, 1
	adc	word ptr countMaybe+2, 0
	jmp	short loc_27978

l_repeatSequence:				; A value greater than 256 indicates a repeat copy
	sub	ax, 253				; number of repeats is value - 3
	mov	d3cmp_repeatCount, ax
	CALL(d3cmp_readCopyOffset)
	mov	cx, bp				; bp is the work buffer index
	sub	cx, ax
	dec	cx
	mov	_d3cmp_baseAddr, cx		; Copy address is buffer - 1 - value from d3cmp_readCopyOffset
	mov	_d3cmp_offset, 0
	jmp	short loc_2796F

loc_27941:
	mov	bx, _d3cmp_baseAddr
	add	bx, _d3cmp_offset
	and	bh, 0Fh
	mov	al, d3comp_outputBuffer[bx]
	mov	ds:d3comp_outputBuffer[bp], al
	inc	bp
	test	bp, 1000h
	jz	short loc_27961
	CALL(d3cmp_outputToBuffer)
	xor	bp, bp

loc_27961:
	add	word ptr countMaybe, 1
	adc	word ptr countMaybe+2, 0
	inc	_d3cmp_offset

loc_2796F:
	mov	ax, d3cmp_repeatCount
	cmp	_d3cmp_offset, ax
	jl	short loc_27941

loc_27978:
	jmp	loc_278E6

l_output:
	CALL(d3cmp_outputToBuffer)

l_return:
	pop	bp
	retn
d3cmp_doDecomp endp

sub_27980 proc near
	push	ax
	push	bx
	push	cx
	push	dx
	push	si
	push	di
	push	ds
	push	es
	push	bp
	mov	word_4EE4A, 0
	mov	word_4EE48, 0
loc_27995:
	mov	si, word_4EE48
	shl	si, 1
	cmp	word_4D88D[si],	273h
	jl	short loc_279C0
	mov	di, word_4EE4A
	shl	di, 1
	mov	ax, word_4CC4B[si]
	inc	ax
	shr	ax, 1
	mov	word_4CC4B[di],	ax
	mov	ax, word_4D88D[si]
	mov	word_4D88D[di],	ax
	inc	word_4EE4A
loc_279C0:
	inc	word_4EE48
	cmp	word_4EE48, 273h
	jl	short loc_27995
	mov	word_4EE48, 0
	mov	word_4EE4A, 13Ah
	jmp	short loc_27A52
loc_279DA:
	dec	word_4EE4C
loc_279DE:
	mov	bx, word_4EE4C
	shl	bx, 1
	mov	ax, word_4EE4E
	cmp	word_4CC4B[bx],	ax
	ja	short loc_279DA
	inc	word_4EE4C
	mov	cx, word_4EE4A
	sub	cx, word_4EE4C
	shl	cx, 1
	mov	word_4EE50, cx
	std
	mov	di, word_4EE4C
	shl	di, 1
	add	di, offset word_4CC4B
	add	di, cx
	shr	cx, 1
	mov	si, di
	sub	si, 2
	rep movsw
	mov	si, word_4EE4C
	shl	si, 1
	mov	ax, word_4EE4E
	mov	word_4CC4B[si],	ax
	mov	cx, word_4EE50
	mov	di, word_4EE4C
	shl	di, 1
	add	di, word_4D88D
	add	di, cx
	shr	cx, 1
	mov	si, di
	sub	si, 2
	rep movsw
	cld
	mov	bx, word_4EE4C
	shl	bx, 1
	mov	ax, word_4EE48
	mov	word_4D88D[bx],	ax
	add	word_4EE48, 2
	inc	word_4EE4A
loc_27A52:
	cmp	word_4EE4A, 273h
	jge	short loc_27A8C
	mov	ax, word_4EE48
	inc	ax
	mov	word_4EE4C, ax
	mov	bx, word_4EE4A
	shl	bx, 1
	mov	si, word_4EE48
	shl	si, 1
	mov	ax, word_4CC4B[si]
	mov	si, word_4EE4C
	shl	si, 1
	add	ax, word_4CC4B[si]
	mov	word_4CC4B[bx],	ax
	mov	word_4EE4E, ax
	mov	ax, word_4EE4A
	dec	ax
	mov	word_4EE4C, ax
	jmp	loc_279DE
loc_27A8C:
	mov	word_4EE48, 0
	jmp	short loc_27AA9
loc_27A94:
	mov	si, word_4EE4C
	shl	si, 1
	mov	ax, word_4EE48
	mov	word_4D133[si+2], ax
	mov	word_4D133[si], ax
loc_27AA5:
	inc	word_4EE48
loc_27AA9:
	cmp	word_4EE48, 273h
	jge	short loc_27AD0
	mov	bx, word_4EE48
	shl	bx, 1
	mov	ax, word_4D88D[bx]
	mov	word_4EE4C, ax
	cmp	ax, 273h
	jl	short loc_27A94
	mov	bx, ax
	shl	bx, 1
	mov	ax, word_4EE48
	mov	word_4D133[bx], ax
	jmp	short loc_27AA5
loc_27AD0:
	pop	bp
	pop	es
	pop	ds
	pop	di
	pop	si
	pop	dx
	pop	cx
	pop	bx
	pop	ax
	retn
sub_27980 endp

; Attributes: bp-based frame

d3cmp_flate proc far

	srcP	= dword ptr 6
	destP	= dword ptr 0Ah

	push	bp
	mov	bp, sp
	push	di
	push	si
	push	ds
	push	es
	mov	ax, seg	dseg
	mov	ds, ax

	mov	ax, word ptr [bp+srcP]
	mov	word ptr d3cmp_srcP, ax

	mov	ax, word ptr [bp+srcP+2]
	mov	word ptr d3cmp_srcP+2,	ax

	mov	ax, word ptr [bp+destP]
	mov	word ptr d3cmp_destP+2, ax

	mov	ax, word ptr [bp+destP+2]
	mov	word ptr d3cmp_destP, ax

	mov	ax, word ptr d3cmp_srcP+2
	mov	es, ax
	mov	di, word ptr d3cmp_srcP
	mov	ax, es:[di]
	mov	word ptr dataHeader, ax
	mov	ax, es:[di+2]
	mov	word ptr dataHeader+2, ax
	add	word ptr d3cmp_srcP, 4

	; Initialize d3comp_outputBuffer array to ' '
	mov	ax, ds
	mov	es, ax
	assume es:dseg
	mov	di, offset d3comp_outputBuffer
	mov	cx, 4155
	mov	al, 20h	
	rep stosb

	xor	di, di
	CALL(d3cmp_readData)
	CALL(d3cmp_doDecomp)
	pop	es
	assume es:nothing
	pop	ds
	pop	si
	pop	di
	pop	bp
	retf
d3cmp_flate endp

_readChFromKeyboard proc far
	sub	ax, ax
	int	16h		; KEYBOARD - call(read) CHAR FROM BUFFER, WAIT IF EMPTY
				; Return: AH = scan code, AL = character
	retf
_readChFromKeyboard endp

random	proc far
	cli
	in	al, 40h		; Timer	8253-5 (AT: 8254.2).
	mov	ah, al
	in	al, 40h		; Timer	8253-5 (AT: 8254.2).
	add	al, ah
	sti
	add	ax, randomSeed
	mov	randomSeed, ax
	retf
random	endp

; Attributes: bp-based frame

open proc far

	fileName= dword ptr  6
	fileMode= byte ptr	 0Ah

	push	bp
	mov	bp, sp
	push	ds
	lds	dx, [bp+fileName]
	mov	al, [bp+fileMode]
	mov	ah, 3Dh
	int	21h		; DS:DX	-> ASCIZ filename
				; AL = access mode
				; 0 - read, 1 -	write, 2 - read	& write
	jnb	short l_return
	sub	ax, ax
	dec	ax

l_return:
	pop	ds
	pop	bp
	retf
open endp

; Attributes: bp-based frame

close proc far

	fileHandle= word ptr	 6

	push	bp
	mov	bp, sp
	mov	bx, [bp+fileHandle]
	mov	ah, 3Eh
	int	21h		; DOS -	2+ - call(close) A FILE WITH HANDLE
				; BX = file handle
	jnb	short l_return
	sub	ax, ax
	dec	ax

l_return:
	pop	bp
	retf
close endp




; Attributes: bp-based frame

read proc far

	fileHandle= word ptr  6
	destBuffer=	dword ptr  8
	numBytes= word ptr  0Ch

	push	bp
	mov	bp, sp
	push	ds
	mov	bx, [bp+fileHandle]
	lds	dx, [bp+destBuffer]
	mov	cx, [bp+numBytes]
	mov	ah, 3Fh
	int	21h		; DOS -	2+ - call(read) FROM FILE WITH HANDLE
				; BX = file handle, CX = number	of bytes to read
				; DS:DX	-> buffer
	jnb	short l_return
	sub	ax, ax
	dec	ax

l_return:
	pop	ds
	pop	bp
	retf
read endp

write proc far

	fileHandle= word ptr	 6
	sourceP= dword ptr  8
	writeLength= word ptr	 0Ch

	push	bp
	mov	bp, sp
	push	ds
	mov	bx, [bp+fileHandle]
	lds	dx, [bp+sourceP]
	mov	cx, [bp+writeLength]
	mov	ah, 40h
	int	21h		; DOS -	2+ - call(write) TO FILE WITH	HANDLE
				; BX = file handle, CX = number	of bytes to write, DS:DX -> buffer
	jnb	short l_return
	sub	ax, ax
	dec	ax

l_return:
	pop	ds
	pop	bp
	retf
write endp

lseek proc far

	fileHandle= word ptr	 6
	offsetLo= word ptr	 8
	offsetHi= word ptr	 0Ah

	push	bp
	mov	bp, sp
	push	ds
	mov	bx, [bp+fileHandle]
	mov	cx, [bp+offsetHi]
	mov	dx, [bp+offsetLo]
	mov	ax, 4200h
	int	21h		; DOS -	2+ - MOVE FILE call(read)/call(write) POINTER (LSEEK)
				; AL = method: offset from beginning of	file
	jnb	short l_return
	sub	ax, ax
	dec	ax

l_return:
	pop	ds
	pop	bp
	retf
lseek endp

; Attributes: bp-based frame

findFirstFile proc far

	pathGlob= dword ptr  6
	bufferP= dword ptr  0Ah

	push	bp
	mov	bp, sp
	push	ds
	lds	dx, [bp+bufferP]
	mov	ah, 1Ah
	int	21h		; DOS -	SET DISK TRANSFER AREA ADDRESS
				; DS:DX	-> disk	transfer buffer
	lds	dx, [bp+pathGlob]
	mov	cx, 7
	mov	ah, 4Eh
	int	21h		; DOS -	2+ - FIND FIRST	ASCIZ (FINDFIRST)
				; CX = search attributes
				; DS:DX	-> ASCIZ filespec
				; (drive, path,	and wildcards allowed)
	mov	ax, 0
	jb	short l_return
	inc	ax

l_return:
	pop	ds
	pop	bp
	retf
findFirstFile endp

findNextFile proc far
	push	bp
	mov	ah, 4Fh
	int	21h		; DOS -	2+ - FIND NEXT ASCIZ (FINDNEXT)
				; [DTA]	= data block from
				; last AH = 4Eh/4Fh call
	mov	ax, 0
	jb	short l_return
	inc	ax

l_return:
	pop	bp
	retf
findNextFile endp

checkKeyboard proc far
	mov	ah, 1
	int	16h		; KEYBOARD - CHECK BUFFER, DO NOT CLEAR
				; Return: ZF clear if character	in buffer
				; AH = scan code, AL = character
				; ZF set if no character in buffer
	jnz	short l_haveKey

	sub	ax, ax
	jmp	short l_return

l_haveKey:
	or	ax, ax
	jnz	short l_return
	inc	ax

l_return:
	retf
checkKeyboard endp

; Attributes: bp-based frame
bigpic_initBuffers proc	far

	backgroundValue= word ptr	 6

	push	bp
	mov	bp, sp
	push	ds
	mov	ax, seg	seg021
	mov	ds, ax
	assume ds:seg021
	mov	dx, [bp+backgroundValue]
	mov	dh, dl
	and	dx, 0F00Fh
	mov	cl, 4
	mov	bx, 0FFh

loc_27C7F:
	xor	ah, ah
	mov	al, bl
	and	al, 0Fh
	mov	g_tile_lowNibble[bx],	al
	cmp	dl, al
	jnz	short loc_27C8F
	mov	ah, 0Fh

loc_27C8F:
	shl	al, cl
	mov	g_tile_lowNibbleSwapped[bx],	al
	mov	al, bl
	and	al, 0F0h
	mov	g_tile_highNibble[bx],	al
	cmp	dh, al
	jnz	short loc_27CA4
	or	ah, 0F0h

loc_27CA4:
	shr	al, cl
	mov	g_tile_highNibbleSwapped[bx],	al
	mov	g_tile_backgroundMask[bx],	ah
	dec	bx
	jns	short loc_27C7F
	pop	ds
	assume ds:dseg
	pop	bp
	retf
bigpic_initBuffers endp

; Attributes: bp-based frame

_bigpic_copyTopoElem proc far

	graphicsBufferP= dword ptr	 6
	destBaseColumn=	word ptr  0Ah
	destBaseRow= word ptr  0Ch
	arg_8= word ptr	 0Eh
	srcSkip= word ptr	 10h
	height=	word ptr  12h
	scaleFactor= word ptr	 14h
	rightFlag= word	ptr  16h

	push	bp
	mov	bp, sp
	push	di
	push	si
	push	ds
	push	es

	mov	ax, seg	seg021
	mov	ds, ax
	assume ds:seg021
	mov	es, ax
	assume es:seg021
	mov	g_tile_currentScaleValue, 0
	mov	g_tile_currentCount, 0

loc_27CCE:
	mov	ax, g_tile_currentScaleValue
	sub	ax, [bp+scaleFactor]
	mov	g_tile_currentScaleValue, ax
	jge	short loc_27D1D

	add	ax, 64
	mov	g_tile_currentScaleValue, ax
	mov	dx, [bp+destBaseRow]
	mov	ax, 56
	mul	dx
	add	ax, [bp+destBaseColumn]
	add	ax, offset bigpicBuf
	mov	si, ax

	mov	cx, [bp+arg_8]
	or	cx, cx
	jz	short l_return
	les	di, [bp+graphicsBufferP]
	assume es:nothing
	add	di, g_tile_currentCount
	mov	dx, [bp+scaleFactor]
	mov	dh, dl
	xor	dl, dl
	xor	bx, bx
	mov	ax, [bp+rightFlag]
	or	ax, ax
	jz	short l_copyLeft
	add	di, [bp+srcSkip]
	dec	di
	CALL(_bigpic_copyRightTopo)
	jmp	short l_nextRow

l_copyLeft:
	CALL(_bigpic_copyLeftTopo)

l_nextRow:
	inc	[bp+destBaseRow]

loc_27D1D:
	mov	ax, [bp+srcSkip]
	add	g_tile_currentCount, ax
	dec	[bp+height]
	jnz	short loc_27CCE

l_return:
	pop	es
	pop	ds
	assume ds:dseg
	pop	si
	pop	di
	pop	bp
	retf
_bigpic_copyTopoElem endp

_bigpic_copyLeftTopo proc near
	assume ds:seg021
	mov	bl, es:[di]
	inc	di
	sub	dl, dh
	jge	short loc_27D5A
	add	dl, 64
	mov	al, g_tile_highNibble[bx]
loc_27D3E:
	sub	dl, dh
	jge	short loc_27D65
	add	dl, 64
	or	al, g_tile_lowNibble[bx]
	mov	bl, al
	xor	al, [si]
	and	al, g_tile_backgroundMask[bx]
	xor	al, bl
	mov	[si], al
	inc	si
	dec	cx
	jns	short _bigpic_copyLeftTopo
	retn
loc_27D5A:
	sub	dl, dh
	jge	short _bigpic_copyLeftTopo
	add	dl, 40h	
	mov	al, g_tile_lowNibbleSwapped[bx]
loc_27D65:
	mov	bl, es:[di]
	inc	di
	sub	dl, dh
	jge	short loc_27D3E
	add	dl, 40h	
	or	al, g_tile_highNibbleSwapped[bx]
	push	bx
	mov	bl, al
	xor	al, [si]
	and	al, g_tile_backgroundMask[bx]
	xor	al, bl
	pop	bx
	mov	[si], al
	inc	si
	dec	cx
	jns	short loc_27D5A
	retn
_bigpic_copyLeftTopo endp

_bigpic_copyRightTopo proc near
	assume ds:seg021
	mov	bl, es:[di]
	mov	bl, [bx+0]
	dec	di
	sub	dl, dh
	jge	short loc_27DB6
	add	dl, 64
	mov	al, g_tile_highNibble[bx]

loc_27D9A:
	sub	dl, dh
	jge	short loc_27DC3
	add	dl, 64
	or	al, g_tile_lowNibble[bx]
	mov	bl, al
	xor	al, [si]
	and	al, g_tile_backgroundMask[bx]
	xor	al, bl
	mov	[si], al
	inc	si
	dec	cx
	jns	short _bigpic_copyRightTopo
	retn

loc_27DB6:
	sub	dl, dh
	jge	short _bigpic_copyRightTopo
	add	dl, 64
	shl	ah, 1
	mov	al, g_tile_lowNibbleSwapped[bx]

loc_27DC3:
	mov	bl, es:[di]
	mov	bl, [bx+0]
	dec	di
	sub	dl, dh
	jge	short loc_27D9A
	add	dl, 64
	or	al, g_tile_highNibbleSwapped[bx]
	push	bx
	mov	bl, al
	xor	al, [si]
	and	al, g_tile_backgroundMask[bx]
	xor	al, bl
	pop	bx
	mov	[si], al
	inc	si
	dec	cx
	jns	short loc_27DB6
	retn
_bigpic_copyRightTopo endp

; Attributes: bp-based frame

sound_start proc far

	_segment= word ptr  8
	arg_4= word ptr	 0Ah

	push	bp
	mov	bp, sp
	mov	cx, [bp+_segment]
	mov	ax, [bp+arg_4]
	and	al, 3
	mov	ah, 1
	call	music_driver
	pop	bp
	retf
sound_start endp

sound_stop proc far
	mov	ah, 2
	call	music_driver
	retf
sound_stop endp

sub_27E05 proc far
	mov	ah, al
	and	ah, 1
	add	ah, 3
	call	music_driver
	retf
sub_27E05 endp

; Attributes: bp-based frame

dungeon_getWallInDirection proc far

	walls= word ptr	 6
	direction= word ptr  8

	push	bp
	mov	bp, sp
	mov	ax, [bp+direction]
	and	al, 3
	mov	cl, 2
	shl	ax, cl
	mov	cl, al
	mov	ax, [bp+walls]
	rol	ax, cl
	xor	dx, dx
	pop	bp
	retf
dungeon_getWallInDirection endp


; Attributes: bp-based frame

minimap_clearSquare proc far

	arg_0= dword ptr  6

	push	bp
	mov	bp, sp
	push	es
	push	di
	les	di, [bp+arg_0]
	xor	ax, ax
	mov	cx, 8
	rep stosb
	pop	di
	pop	es
	pop	bp
	retf
minimap_clearSquare endp

; Attributes: bp-based frame

minimap_setSquare proc far

	arg_0= dword ptr  6
	arg_4= word ptr	 0Ah

	push	bp
	mov	bp, sp
	push	di
	push	si
	push	ds
	push	es
	mov	si, offset minimapWallBitmasks
	les	di, [bp+arg_0]
	mov	ax, [bp+arg_4]
	shl	ax, 1
	shl	ax, 1
	shl	ax, 1
	add	si, ax
	mov	cx, 8
loc_27E58:
	lodsb
	or	al, es:[di]
	stosb
	dec	cx
	jnz	short loc_27E58
	pop	es
	pop	ds
	assume ds:dseg
	pop	si
	pop	di
	pop	bp
	retf
minimap_setSquare endp

; Attributes: bp-based frame

bigpic_memcpy proc far

	arg_0= dword ptr  6
	skyColor= word ptr  0Ah
	grndColor= word	ptr  0Ch

	push	bp
	mov	bp, sp
	push	di
	push	es
	les	di, [bp+arg_0]
	mov	cx, 1288
	mov	ax, [bp+skyColor]
	mov	ah, al
	rep stosw
	mov	cx, 498h
	mov	ax, [bp+grndColor]
	mov	ah, al
	rep stosw
	pop	es
	pop	di
	pop	bp
	retf
bigpic_memcpy endp

byte_27E86 db 0, 1, 2, 3, 4, 5,	6, 7; 0
db 8, 9, 0Ah, 0, 0Ch, 0Dh, 0Eh,	0Fh; 8
byte_27E96 db 0, 10h, 20h, 30h,	40h, 50h, 60h, 70h; 0
db 80h,	90h, 0A0h, 0, 0C0h, 0D0h, 0E0h,	0F0h; 8

; Attributes: bp-based frame

bigpic_makeNight proc far

	arg_0= dword ptr  6

	push	bp
	mov	bp, sp
	push	di
	push	ds
	push	es
	les	di, [bp+arg_0]
	mov	ax, cs
	mov	ds, ax
	assume ds:seg019
	sub	bx, bx
	mov	cx, 0F04h
	mov	dx, 1340h
	cld
loc_27EBC:
	mov	ah, es:[di]
	mov	bl, ah
	and	bl, ch
	mov	al, byte_27E86[bx]
	shr	ah, cl
	mov	bl, ah
	or	al, byte_27E96[bx]
	stosb
	dec	dx
	jnz	short loc_27EBC
	pop	es
	pop	ds
	assume ds:dseg
	pop	di
	pop	bp
	retf
bigpic_makeNight endp




sub_27ED8 proc far
	push	bp
	push	si
	push	di
	push	es
	int	11h		; EQUIPMENT DETERMINATION
			; Return: AX = equipment flag bits
	and	ax, 0C0h
	pop	es
	pop	di
	pop	si
	pop	bp
	cld
	retf
sub_27ED8 endp

; Attributes: bp-based frame

sub_27EE7 proc far

	arg_0= byte ptr	 6

	push	bp
	mov	bp, sp
	push	si
	push	di
	push	es
	mov	dl, [bp+arg_0]
	mov	ah, 0Eh
	int	21h		; DOS -	SELECT DISK
			; DL = new default drive number	(0 = A,	1 = B, etc.)
			; Return: AL = number of logical drives
	pop	es
	pop	di
	pop	si
	pop	bp
	cld
	retf
sub_27EE7 endp


sub_27EFA proc far
	push	bp
	mov	ah, 19h
	int	21h		; DOS -	GET DEFAULT DISK NUMBER
	sub	ah, ah
	pop	bp
	retf
sub_27EFA endp

db    0
db    0
word_27F05 dw 0
dword_27F07 dd 0
word_27F0B dw 0
word_27F0D dw 0
align 2

timerIntHandler proc far
	push	es
	push	ds
	push	ax
	mov	ds, cs:word_27F05
	xor	ax, ax
	call	music_driver
	mov	al, 20h	
	out	20h, al		; Interrupt controller,	8259A.
	mov	ds, cs:word_27F05
	inc	word_4EF49
	mov	ax, word_4EF49
	and	ax, 3
	jnz	short loc_27F40
	inc	_clockTicks
	pop	ax
	pop	ds
	pop	es
	jmp	cs:dword_27F07
loc_27F40:
	pop	ax
	pop	ds
	pop	es
	iret
timerIntHandler endp


errorHandler	proc far
                push    ds
                push    es
                push    bx
                push    cx
                push    dx
                push    si
                push    di
                push    bp
                mov     ds, cs:word_27F05
                pop     bp
                pop     di
                pop     si
                pop     dx
                pop     cx
                pop     bx
                pop     es
                pop     ds
                iret
errorHandler       endp

; Attributes: bp-based frame

sub_27F63 proc far
	push	bp
	mov	bp, sp
	push	es
	sub	ax, ax
	mov	es, ax
	assume es:nothing
	cli
	mov	ax, es:20h
	mov	word ptr cs:dword_27F07, ax
	mov	ax, es:22h
	mov	word ptr cs:dword_27F07+2, ax
	mov	word ptr es:20h, offset	timerIntHandler
	mov	word ptr es:22h, cs
	mov	cs:word_27F05, ds
	mov	al, 36h	
	out	43h, al		; Timer	8253-5 (AT: 8254.2).
	mov	ax, 4DA7h
	out	40h, al		; Timer	8253-5 (AT: 8254.2).
	xchg	al, ah
	out	40h, al		; Timer	8253-5 (AT: 8254.2).
	sti
	mov	di, 90h	
	cli
	mov	ax, es:[di]
	mov	cs:word_27F0B, ax
	mov	ax, es:[di+2]
	mov	cs:word_27F0D, ax
	mov	word ptr es:[di], offset errorHandler
	mov	word ptr es:[di+2], cs
	sti
	sub	ax, ax
	mov	es, ax
	cmp	word ptr es:0CCh, 0
	jz	short loc_27FD6
	int	33h		; - MS MOUSE - RESET DRIVER AND	CALL(read) STATUS
			; Return: AX = status
			; BX = number of buttons
	or	ax, ax
	jz	short loc_27FD6
	mov	byte_4EF4B, 1
	mov	byte_4EF5E, 1
	jmp	short loc_28008
loc_27FD6:
	mov	byte_4EF4C, 0
	cmp	byte_4EF4C, 0
	jz	short loc_28008
	cmp	ax, 0FFFFh
	jnz	short loc_27FEF
	mov	byte_4EF4C, 0
	jmp	short loc_28008
db 90h
loc_27FEF:
	mov	byte_4EF5E, 1
	mov	bl, ah
	sub	ah, ah
	inc	ax
	mov	word_4EF59, ax
	sub	bh, bh
	inc	bx
	mov	word_4EF5B, bx
loc_28008:
	pop	es
	assume es:nothing
	pop	bp
	retf
sub_27F63 endp


sub_2800B proc far
	push	es
	sub	ax, ax
	mov	es, ax
	assume es:nothing
	cli
	mov	ax, word ptr cs:dword_27F07
	mov	es:20h,	ax
	mov	ax, word ptr cs:dword_27F07+2
	mov	es:22h,	ax
	mov	al, 36h	
	out	43h, al		; Timer	8253-5 (AT: 8254.2).
	mov	ax, 0
	out	40h, al		; Timer	8253-5 (AT: 8254.2).
	xchg	al, ah
	out	40h, al		; Timer	8253-5 (AT: 8254.2).
	mov	di, 90h	
	mov	ax, cs:word_27F0B
	mov	es:[di], ax
	mov	ax, cs:word_27F0D
	mov	es:[di+2], ax
	sti
	pop	es
	assume es:nothing
	retf
sub_2800B endp

checkMouse proc	far
	push	bp
	push	si
	push	di
	push	ds
	push	es
	cmp	byte_4EF4B, 0
	jz	short loc_280C0
	mov	byte_4EF50, 0
	mov	ax, 5
	sub	bx, bx
	int	33h		; - MS MOUSE - RETURN BUTTON PRESS DATA
			; BX = button
			; Return: AX = button states
			; BX = number of times specified button	has been pressed
			; CX = column at time specified	button was last	pressed
			; DX = row at time specified button was	last pressed
	test	al, 3
	jz	short loc_28077
	mov	byte_4EF50, 1
	cmp	byte_4EF4D, 0
	jnz	short loc_2807C
	mov	byte_4EF52, 1
	mov	byte_4EF4D, 1
	jmp	short loc_2807C
loc_28077:
	mov	byte_4EF4D, 0
loc_2807C:
	mov	ax, 0Bh
	int	33h		; - MS MOUSE - CALL(read) MOTION COUNTERS
			; Return: CX = number of mickeys mouse moved horizontally since	last call
			; DX = number of mickeys mouse moved vertically
	or	cx, cx
	jnz	short loc_2808C
	or	dx, dx
	jnz	short loc_2808C
	jmp	loc_2810F
loc_2808C:
	add	cx, mouse_x
	test	ch, 80h
	jz	short loc_28098
	mov	cx, 1
loc_28098:
	cmp	cx, 130h
	jbe	short loc_280A1
	mov	cx, 130h
loc_280A1:
	mov	mouse_x, cx
	add	dx, mouse_y
	test	dh, 80h
	jz	short loc_280B1
	mov	dx, 1
loc_280B1:
	cmp	dx, 0C2h 
	jbe	short loc_280BA
	mov	dx, 0C2h 
loc_280BA:
	mov	mouse_y, dx
	jmp	short loc_2810A
loc_280C0:
	cmp	byte_4EF5E, 0
	jz	short loc_2810F
	cmp	byte_4EF4C, 0
	jz	short loc_2810F
	sti
	call	sub_28115
	or	ax, ax
	jz	short loc_2810F
	mov	ax, mouse_x
	cmp	ax, 130h
	jbe	short loc_280E6
	mov	ax, 130h
	jmp	short loc_280EE
align 2
loc_280E6:
	cmp	ax, 1
	jnb	short loc_280EE
	mov	ax, 1
loc_280EE:
	mov	mouse_x, ax
	mov	ax, mouse_y
	cmp	ax, 0C2h 
	jbe	short loc_280FF
	mov	ax, 0C2h 
	jmp	short loc_28107
db 90h
loc_280FF:
	cmp	ax, 1
	jnb	short loc_28107
	mov	ax, 1
loc_28107:
	mov	mouse_y, ax
loc_2810A:
	mov	mouse_moved, 1
loc_2810F:
	pop	es
	pop	ds
	pop	di
	pop	si
	pop	bp
	retf
checkMouse endp


sub_28115 proc far
	mov	byte_4EF5D, 0
	cmp	byte_4EF4C, 0
	jz	short loc_28183
	cmp	byte_4EF4B, 0
	jnz	short loc_28183
	call	sub_2821E
	mov	bl, ah
	sub	ah, ah
	sub	bh, bh
	mov	cx, word_4EF59
	sub	cx, ax
	mov	ax, cx
	sar	ax, 1
	sar	ax, 1
	or	ax, ax
	jz	short loc_2815A
	add	mouse_x, ax
	mov	byte_4EF5D, 1
	test	mouse_x, 8000h
	jz	short loc_2815A
	mov	mouse_x, 0
loc_2815A:
	mov	ax, bx
	mov	cx, word_4EF5B
	sub	cx, ax
	mov	ax, cx
	sar	ax, 1
	sar	ax, 1
	or	ax, ax
	jz	short loc_28183
	add	mouse_y, ax
	mov	byte_4EF5D, 1
	test	mouse_y, 8000h
	jz	short loc_28183
	mov	mouse_y, 0
loc_28183:
	mov	al, byte_4EF5D
	sub	ah, ah
	retf
sub_28115 endp

checkGamePort proc far
	xor	ax, ax
	cmp	byte_4EF52, al
	jz	short loc_281B1
	mov	byte_4EF52, al
	inc	ax
	jmp	short locret_281DE
db 90h
loc_281B1:
	cmp	byte_4EF4C, al
	jz	short loc_281CF
	mov	dx, 201h
	in	al, dx		; Game I/O port
			; bits 0-3: Coordinates	(resistive, time-dependent inputs)
			; bits 4-7: Buttons/Triggers (digital inputs)
	cmp	byte_4EF50, 0
	jz	short loc_281D2
	test	al, 10h
	mov	ax, 0
	jz	short locret_281DE
	mov	byte_4EF50, al
	jmp	short locret_281DE
db 90h
loc_281CF:
	jmp	short locret_281DE
align 2
loc_281D2:
	test	al, 10h
	mov	ax, 0
	jnz	short locret_281DE
	inc	al
	mov	byte_4EF50, al
locret_281DE:
	retf
checkGamePort endp

checkOtherGamePort proc	far
	xor	ax, ax
	cmp	byte_4EF53, 0
	jz	short loc_281EF
	mov	byte_4EF53, al
	inc	ax
	jmp	short locret_2821D
db 90h
loc_281EF:
	cmp	byte_4EF4C, 0
	jz	short loc_2820E
	mov	dx, 201h
	in	al, dx		; Game I/O port
			; bits 0-3: Coordinates	(resistive, time-dependent inputs)
			; bits 4-7: Buttons/Triggers (digital inputs)
	cmp	byte_4EF51, 0
	jz	short loc_28211
	test	al, 20h
	mov	ax, 0
	jz	short locret_2821D
	mov	byte_4EF51, al
	jmp	short locret_2821D
align 2
loc_2820E:
	jmp	short locret_2821D
db 90h
loc_28211:
	test	al, 20h
	mov	ax, 0
	jnz	short locret_2821D
	inc	al
	mov	byte_4EF51, al
locret_2821D:
	retf
checkOtherGamePort endp


sub_2821E proc far
	cli
	sub	cx, cx
	cmp	byte_4EF4C, 0
	jz	short loc_2824E
	dec	cx
	xor	bx, bx
	mov	dx, 201h
	out	dx, al		; Game I/O port
			; bits 0-3: Coordinates	(resistive, time-dependent inputs)
			; bits 4-7: Buttons/Triggers (digital inputs)
	sub	ax, ax
loc_28231:		; Game I/O port
	in	al, dx		; bits 0-3: Coordinates	(resistive, time-dependent inputs)
			; bits 4-7: Buttons/Triggers (digital inputs)
	mov	bl, al
	and	bl, 1
	sub	cl, bl
	mov	bl, al
	shr	bl, 1
	and	bl, 1
	sub	ch, bl
	test	al, 3
	jz	short loc_2824E
	inc	ah
	jnz	short loc_28231
	mov	byte_4EF4C, ah
loc_2824E:
	mov	ax, cx
	sti
	retf
sub_2821E endp

assume ss:seg029, ds:nothing
public start

start proc far
	mov	ah, 30h
	int	21h		; DOS -	GET DOS	VERSION
			; Return: AL = major version number (00h for DOS 1.x)
	cmp	al, 2
	jnb	short loc_2829C
	int	20h		; DOS -	PROGRAM	TERMINATION
			; returns to DOS--identical to INT 21/AH=00h
loc_2829C:
	mov	di, seg	dseg
	mov	si, ds:2
	sub	si, di
	cmp	si, 1000h
	jb	short loc_282AE
	mov	si, 1000h
loc_282AE:
	cli
	mov	ss, di
	assume ss:dseg
	add	sp, offset dseg_end
	sti
	jnb	short loc_282CC
	push	ss
	pop	ds
	assume ds:dseg
	call	sub_284C2
	xor	ax, ax
	push	ax
	call	sub_28785
	mov	ax, 4CFFh
	int	21h		; DOS -	2+ - QUIT WITH EXIT CODE (EXIT)
			; AL = exit code
loc_282CC:
	assume ds:nothing
	and	sp, 0FFFEh
	mov	ss:word_4EF82, sp
	mov	ss:word_4EF7E, sp
	mov	ax, si
	mov	cl, 4
	shl	ax, cl
	dec	ax
	mov	ss:word_4EF7C, ax
	add	si, di
	mov	ds:2, si
	mov	bx, es
	sub	bx, si
	neg	bx
	mov	ah, 4Ah
	int	21h		; DOS -	2+ - ADJUST MEMORY BLOCK SIZE (SETBLOCK)
			; ES = segment address of block	to change
			; BX = new size	in paragraphs
	mov	ss:word_4EFF3, ds
	push	ss
	pop	es
	assume es:dseg
	cld
	mov	di, offset g_tavernSayingBase
	mov	cx, offset dseg_end+2
	sub	cx, di
	xor	ax, ax
	rep stosb
	push	ss
	pop	ds
	call 	far ptr loc_28360
	push	ss
	pop	ds
	call	far ptr sub_286DE
	call	far ptr	sub_28536
	xor	bp, bp
	push	ds:word_4F018
	push	ds:word_4F016
	push	ds:word_4F014
	push	ds:word_4F012
	push	ds:word_4F010
	call	_main
	push	ax
	call	far ptr	sub_28424

loc_2833C:
	mov	ax, seg	dseg
	mov	ds, ax
	mov	ax, 3
	mov	ss:off_4EF80, offset sub_28424
loc_2834B::
	push	ax
	call	sub_284C2
	call	sub_28785
	mov	ax, 0FFh
	push	ax
	push	cs
	call	off_4EF80

	db 0

loc_28360:
	mov	ah, 30h
	int	21h
	mov	ds:word_4EFF5, ax
	mov	ax, 3500h
	int	21h		; DOS -	2+ - GET INTERRUPT VECTOR
			; AL = interrupt number
			; Return: ES:BX	= value	of interrupt vector
	mov	word ptr ds:dword_4EFE1, bx
	mov	word ptr ds:dword_4EFE1+2,	es
	push	cs
	pop	ds
	assume ds:seg019
	mov	ax, 2500h
	mov	dx, offset loc_2833C
	int	21h		; DOS -	SET INTERRUPT VECTOR
			; AL = interrupt number
			; DS:DX	= new vector to	be used	for specified interrupt
	push	ss
	pop	ds
	assume ds:dseg
	mov	cx, word_4F906
	jcxz	short loc_283B4
	mov	es, word_4EFF3
	assume es:nothing
	mov	si, es:2Ch
	lds	ax, dword_4F908
	mov	dx, ds
	xor	bx, bx
	call	dword ptr ss:unk_4F904
	jnb	short loc_283A3
	push	ss
	pop	ds
	jmp	sub_284E6
loc_283A3:
	lds	ax, ss:dword_4F90C
	mov	dx, ds
	mov	bx, 3
	call	dword ptr ss:unk_4F904
	push	ss
	pop	ds
loc_283B4:
	mov	es, word_4EFF3
	mov	cx, es:2Ch
	jcxz	short loc_283F5
	mov	es, cx
	xor	di, di
loc_283C3:
	cmp	byte ptr es:[di], 0
	jz	short loc_283F5
	mov	cx, 0Ch
	mov	si, offset aC_file_info
	repe cmpsb
	jz	short loc_283DE
	mov	cx, 7FFFh
	xor	ax, ax
	repne scasb
	jnz	short loc_283F5
	jmp	short loc_283C3
loc_283DE:
	push	es
	push	ds
	pop	es
	assume es:dseg
	pop	ds
	mov	si, di
	mov	di, offset byte_4EFFC
	lodsb
	cbw
	xchg	ax, cx
loc_283EA:
	lodsb
	inc	al
	jz	short loc_283F0
	dec	ax
loc_283F0:
	stosb
	loop	loc_283EA
	push	ss
	pop	ds
loc_283F5:
	mov	bx, 4
loc_283F8:
	and	byte_4EFFC[bx],	0BFh
	mov	ax, 4400h
	int	21h		; DOS -	2+ - IOCTL - GET DEVICE	INFORMATION
			; BX = file or device handle
	jb	short loc_2840E
	test	dl, 80h
	jz	short loc_2840E
	or	byte_4EFFC[bx],	40h
loc_2840E:
	dec	bx
	jns	short loc_283F8
	mov	si, offset off_4F910
	mov	di, offset off_4F910
	call	sub_284AF
	mov	si, offset off_4F910
	mov	di, offset off_4F910
	call	sub_284AF
	retf
start endp

; Attributes: bp-based frame
sub_28424 proc near
	push	bp
	mov	bp, sp
	mov	si, offset byte_5006A
	mov	di, offset byte_5006A
	call	sub_284AF
	mov	si, offset off_4F910
	mov	di, offset seg027_41
	call	sub_284AF
	jmp	short loc_2843E
sub_28424 endp

; Attributes: bp-based frame
sub_2843B proc near
arg_2= word ptr	 6
	push	bp
	mov	bp, sp
loc_2843E::
	mov	si, offset seg027_41
	mov	di, offset seg027_41
	call	sub_284AF
	mov	si, offset seg027_41
	mov	di, offset seg027_41
	call	sub_284AF
	call	sub_28510
	or	ax, ax
	jz	short loc_28464
	cmp	[bp+arg_2], 0
	jnz	short loc_28464
	mov	[bp+arg_2], 0FFh
loc_28464:
	mov	cx, 0Fh
	mov	bx, 5
loc_2846A:
	test	byte_4EFFC[bx],	1
	jz	short loc_28475
	mov	ah, 3Eh
	int	21h		; DOS -	2+ - CALL(close) A FILE WITH HANDLE
			; BX = file handle
loc_28475:
	inc	bx
	loop	loc_2846A
	call	sub_28482
	mov	ax, [bp+arg_2]
	mov	ah, 4Ch
	int	21h		; DOS -	2+ - QUIT WITH EXIT CODE (EXIT)
sub_2843B endp		; AL = exit code
sub_28482 proc near
	mov	cx, word_4F906
	jcxz	short loc_2848F
	mov	bx, 2
	call	dword ptr unk_4F904
loc_2848F:
	push	ds
	lds	dx, dword_4EFE1
	mov	ax, 2500h
	int	21h		; DOS -	SET INTERRUPT VECTOR
			; AL = interrupt number
			; DS:DX	= new vector to	be used	for specified interrupt
	pop	ds
	cmp	byte_4F022, 0
	jz	short locret_284AE
	push	ds
	mov	al, byte_4F023
	lds	dx, dword_4F024
	mov	ah, 25h
	int	21h		; DOS -	SET INTERRUPT VECTOR
			; AL = interrupt number
			; DS:DX	= new vector to	be used	for specified interrupt
	pop	ds
locret_284AE:
	retn
sub_28482 endp

sub_284AF proc near
	cmp	si, di
	jnb	short locret_284C1
	sub	di, 4
	mov	ax, [di]
	or	ax, [di+2]
	jz	short sub_284AF
	call	dword ptr [di]
	jmp	short sub_284AF
locret_284C1:
	retn
sub_284AF endp

; Attributes: bp-based frame

sub_284C2 proc far
	push	bp
	mov	bp, sp
	mov	ax, 0FCh 
	push	ax
	call	sub_28785
	cmp	word_4F02A, 0
	jz	short loc_284D9
	call	dword ptr unk_4F028
loc_284D9:
	mov	ax, 0FFh
	push	ax
	call	sub_28785
	mov	sp, bp
	pop	bp
	retf
sub_284C2 endp

sub_284E6 proc near
	mov	ax, 2
	jmp	loc_2834B
sub_284E6 endp

someStackOperation proc	far
	pop	cx
	pop	dx
	mov	bx, sp
	sub	bx, ax
	jb	short loc_284FF
	cmp	bx, word_4F030
	jb	short loc_284FF
	mov	sp, bx
	push	dx
	push	cx
	retf
loc_284FF:
	mov	ax, word ptr dword_4F02C
	inc	ax
	jnz	short loc_2850A
	xor	ax, ax
	jmp	loc_2834B
loc_2850A:
	push	dx
	push	cx
	jmp	dword_4F02C
someStackOperation endp


sub_28510 proc far
	push	si
	mov	si, offset word_42670
	mov	cx, 42h	
	xor	ah, ah
	cld
loc_28519:
	lodsb
	xor	ah, al
	loop	loc_28519
	xor	ah, 55h
	jz	short loc_28534
	call	sub_284C2
	mov	ax, 1
	push	ax
	call	sub_28785
	mov	ax, 1
loc_28534:
	pop	si
	retf
sub_28510 endp

sub_28536 proc near
	pop	word ptr dword_4F032
	pop	word ptr dword_4F032+2
	mov	dx, 2
	cmp	byte ptr word_4EFF5, dl
	jz	short loc_28570
	mov	es, word_4EFF3
	assume es:nothing
	mov	es, word ptr es:2Ch
	mov	word ptr off_4F01A+2, es
	xor	ax, ax
	cwd
	mov	cx, 8000h
	xor	di, di
loc_2855C:
	repne scasb
	scasb
	jnz	short loc_2855C
	inc	di
	inc	di
	mov	word ptr off_4F01A, di
	mov	cx, 0FFFFh
	repne scasb
	not	cx
	mov	dx, cx
loc_28570:
	mov	di, 1
	mov	si, 81h	
	mov	ds, word_4EFF3
loc_2857A:
	lodsb
	cmp	al, 20h	
	jz	short loc_2857A
	cmp	al, 9
	jz	short loc_2857A
	cmp	al, 0Dh
	jz	short loc_285F6
	or	al, al
	jz	short loc_285F6
	inc	di
loc_2858C:
	dec	si
loc_2858D:
	lodsb
	cmp	al, 20h	
	jz	short loc_2857A
	cmp	al, 9
	jz	short loc_2857A
	cmp	al, 0Dh
	jz	short loc_285F6
	or	al, al
	jz	short loc_285F6
	cmp	al, 22h	
	jz	short loc_285C6
	cmp	al, 5Ch	
	jz	short loc_285A9
	inc	dx
	jmp	short loc_2858D
loc_285A9:
	xor	cx, cx
loc_285AB:
	inc	cx
	lodsb
	cmp	al, 5Ch	
	jz	short loc_285AB
	cmp	al, 22h	
	jz	short loc_285B9
	add	dx, cx
	jmp	short loc_2858C
loc_285B9:
	mov	ax, cx
	shr	cx, 1
	adc	dx, cx
	test	al, 1
	jnz	short loc_2858D
	jmp	short loc_285C6
loc_285C5:
	dec	si
loc_285C6:
	lodsb
	cmp	al, 0Dh
	jz	short loc_285F6
	or	al, al
	jz	short loc_285F6
	cmp	al, 22h	
	jz	short loc_2858D
	cmp	al, 5Ch	
	jz	short loc_285DA
	inc	dx
	jmp	short loc_285C6
loc_285DA:
	xor	cx, cx
loc_285DC:
	inc	cx
	lodsb
	cmp	al, 5Ch	
	jz	short loc_285DC
	cmp	al, 22h	
	jz	short loc_285EA
	add	dx, cx
	jmp	short loc_285C5
loc_285EA:
	mov	ax, cx
	shr	cx, 1
	adc	dx, cx
	test	al, 1
	jnz	short loc_285C6
	jmp	short loc_2858D
loc_285F6:
	push	ss
	pop	ds
	mov	word_4F010, di
	add	dx, di
	inc	di
	shl	di, 1
	shl	di, 1
	add	dx, di
	and	dl, 0FEh
	sub	sp, dx
	mov	ax, sp
	mov	word_4F012, ax
	mov	word_4F014, ds
	mov	bx, ax
	add	di, bx
	push	ss
	pop	es
	assume es:dseg
	mov	ss:[bx], di
	mov	word ptr ss:[bx+2], ss
	add	bx, 4
	lds	si, off_4F01A
loc_28627:
	lodsb
	stosb
	or	al, al
	jnz	short loc_28627
	mov	si, 81h	
	mov	ds, ss:word_4EFF3
	jmp	short loc_2863A
loc_28637:
	xor	ax, ax
	stosb
loc_2863A:
	lodsb
	cmp	al, 20h	
	jz	short loc_2863A
	cmp	al, 9
	jz	short loc_2863A
	cmp	al, 0Dh
	jnz	short loc_2864A
	jmp	loc_286CE
loc_2864A:
	or	al, al
	jnz	short loc_28651
	jmp	short loc_286CE
db 90h
loc_28651:
	mov	ss:[bx], di
	mov	word ptr ss:[bx+2], ss
	add	bx, 4
loc_2865B:
	dec	si
loc_2865C:
	lodsb
	cmp	al, 20h	
	jz	short loc_28637
	cmp	al, 9
	jz	short loc_28637
	cmp	al, 0Dh
	jz	short loc_286CB
	or	al, al
	jz	short loc_286CB
	cmp	al, 22h	
	jz	short loc_28698
	cmp	al, 5Ch	
	jz	short loc_28678
	stosb
	jmp	short loc_2865C
loc_28678:
	xor	cx, cx
loc_2867A:
	inc	cx
	lodsb
	cmp	al, 5Ch	
	jz	short loc_2867A
	cmp	al, 22h	
	jz	short loc_2868A
	mov	al, 5Ch	
	rep stosb
	jmp	short loc_2865B
loc_2868A:
	mov	al, 5Ch	
	shr	cx, 1
	rep stosb
	jnb	short loc_28698
	mov	al, 22h	
	stosb
	jmp	short loc_2865C
loc_28697:
	dec	si
loc_28698:
	lodsb
	cmp	al, 0Dh
	jz	short loc_286CB
	or	al, al
	jz	short loc_286CB
	cmp	al, 22h	
	jz	short loc_2865C
	cmp	al, 5Ch	
	jz	short loc_286AC
	stosb
	jmp	short loc_28698
loc_286AC:
	xor	cx, cx
loc_286AE:
	inc	cx
	lodsb
	cmp	al, 5Ch	
	jz	short loc_286AE
	cmp	al, 22h	
	jz	short loc_286BE
	mov	al, 5Ch	
	rep stosb
	jmp	short loc_28697
loc_286BE:
	mov	al, 5Ch	
	shr	cx, 1
	rep stosb
	jnb	short loc_2865C
	mov	al, 22h	
	stosb
	jmp	short loc_28698
loc_286CB:
	xor	ax, ax
	stosb
loc_286CE:
	push	ss
	pop	ds
	mov	word ptr [bx], 0
	mov	word ptr [bx+2], 0
	jmp	dword_4F032
sub_28536 endp

align 2
; Attributes: bp-based frame

sub_286DE proc far
	push	bp
	mov	bp, sp
	push	bp
	mov	ds, word_4EFF3
	assume ds:nothing
	xor	cx, cx
	mov	ax, cx
	mov	bp, cx
	mov	di, cx
	dec	cx
	mov	si, ds:2Ch
	or	si, si
	jz	short loc_28707
	mov	es, si
	assume es:nothing
	cmp	byte ptr es:0, 0
	jz	short loc_28707
loc_28701:
	repne scasb
	inc	bp
	scasb
	jnz	short loc_28701
loc_28707:
	inc	bp
	xchg	ax, di
	inc	ax
	and	al, 0FEh
	mov	di, bp
	shl	bp, 1
	shl	bp, 1
	add	ax, bp
	push	ss
	pop	ds
	push	di
	mov	di, 9
	call	sub_287B0
	pop	di
	mov	cx, di
	mov	di, bp
	add	di, ax
	mov	ds:word_4F016, bp
	mov	ds:word_4F018, ds
	push	ds
	pop	es
	assume es:dseg
	mov	ds, si
	xor	si, si
	dec	cx
	jcxz	short loc_2874C
loc_28735:
	cmp	word ptr [si], 433Bh
	jz	short loc_28744
	mov	[bp+0],	di
	mov	word ptr [bp+2], es
	add	bp, 4
loc_28744:
	lodsb
	stosb
	or	al, al
	jnz	short loc_28744
	loop	loc_28735
loc_2874C:
	mov	[bp+0],	cx
	mov	[bp+2],	cx
	push	ss
	pop	ds
	pop	bp
	mov	sp, bp
	pop	bp
	retf
sub_286DE endp

align 2
; Attributes: bp-based frame

sub_2875A proc far

	arg_0= word ptr	 6

	push	bp
	mov	bp, sp
	push	si
	push	di
	push	ds
	pop	es
	mov	dx, [bp+arg_0]
	mov	si, (offset aNmsg+8)
loc_28767:
	lodsw
	cmp	ax, dx
	jz	short loc_2877C
	inc	ax
	xchg	ax, si
	jz	short loc_2877C
	xchg	ax, di
	xor	ax, ax
	mov	cx, 0FFFFh
	repne scasb
	mov	si, di
	jmp	short loc_28767
loc_2877C:
	xchg	ax, si
	pop	di
	pop	si
	mov	sp, bp
	pop	bp
	retf	2
sub_2875A endp

; Attributes: bp-based frame

sub_28785 proc far

	arg_0= word ptr	 6

	push	bp
	mov	bp, sp
	push	di
	push	[bp+arg_0]
	call	sub_2875A
	or	ax, ax
	jz	short loc_287A9
	xchg	ax, dx
	mov	di, dx
	xor	ax, ax
	mov	cx, 0FFFFh
	repne scasb
	not	cx
	dec	cx
	mov	bx, 2
	mov	ah, 40h
	int	21h		; DOS -	2+ - CALL(write) TO FILE WITH	HANDLE
			; BX = file handle, CX = number	of bytes to write, DS:DX -> buffer
loc_287A9:
	pop	di
	mov	sp, bp
	pop	bp
	retf	2
sub_28785 endp

sub_287B0 proc near
	mov	dx, ax
	add	ax, ds:word_4EF82
	jb	short loc_287ED
	cmp	ds:word_4EF7C, ax
	jnb	short loc_287E3
	add	ax, 0Fh
	push	ax
	rcr	ax, 1
	mov	cl, 3
	shr	ax, cl
	mov	cx, ds
	mov	bx, ds:word_4EFF3
	sub	cx, bx
	add	ax, cx
	mov	es, bx
	assume es:nothing
	mov	bx, ax
	mov	ah, 4Ah
	int	21h		; DOS -	2+ - ADJUST MEMORY BLOCK SIZE (SETBLOCK)
			; ES = segment address of block	to change
			; BX = new size	in paragraphs
	pop	ax
	jb	short loc_287ED
	and	al, 0F0h
	dec	ax
	mov	ds:word_4EF7C, ax
loc_287E3:
	xchg	ax, bp
	mov	bp, ds:word_4EF82
	add	ds:word_4EF82, dx
	retn
loc_287ED:
	mov	ax, di
	jmp	loc_2834B
sub_287B0 endp

	jb	short loc_28807
loc_287F4:
	xor	ax, ax
	mov	sp, bp
	pop	bp
	retf
	jnb	short loc_287F4
	push	ax
	call	sub_28818
	pop	ax
	mov	sp, bp
	pop	bp
	retf
; START	OF FUNCTION CHUNK FOR sub_2A2F6
loc_28805:
	jnb	short loc_2880E
loc_28807:
	call	sub_28818
	mov	ax, 0FFFFh
	cwd
loc_2880E:
	mov	sp, bp
	pop	bp
	retf
; END OF FUNCTION CHUNK	FOR sub_2A2F6
	xor	ah, ah
	call	sub_28818
	retf

sub_28818 proc near
	mov	ds:byte_4EFF8, al
	or	ah, ah
	jnz	short loc_28842
	cmp	ds:word_4EFF5, 3
	jb	short loc_28833
	cmp	al, 22h	
	jnb	short loc_28837
	cmp	al, 20h	
	jb	short loc_28833
	mov	al, 5
	jmp	short loc_28839
db 90h
loc_28833:
	cmp	al, 13h
	jbe	short loc_28839
loc_28837:
	mov	al, 13h
loc_28839:
	mov	bx, offset byte_4F036
	xlat
loc_2883D:
	cbw
	mov	ds:word_4EFED, ax
	retn
loc_28842:
	mov	al, ah
	jmp	short loc_2883D
sub_28818 endp

sub_28846	proc far

	var_6 = dword ptr -6

	push	bp
	mov	bp, sp
	sub	sp, 6
	push	si
	mov	ax, offset off_4F64C
	mov	[bp-6],	ax
	mov	word ptr [bp-4], ds
	sub	si, si
	jmp	short loc_28876
loc_2885A:
	les	bx, [bp-6]
	test	byte ptr es:[bx+0Ah], 83h
	jz	short loc_28872
	push	es
	push	bx
	call	sub_28DC2
	add	sp, 4
	inc	ax
	jz	short loc_28872
	inc	si
loc_28872:
	add	word ptr [bp-6], 0Ch
loc_28876:
	mov	ax, ds:word_4F7B4
	mov	dx, ds:seg_4F7B6
	cmp	[bp-6],	ax
	jbe	short loc_2885A
	mov	ax, si
	pop	si
	mov	sp, bp
	pop	bp
	retf
sub_28846	endp

align 2
; Attributes: bp-based frame

printf proc far

	var_C= word ptr	-0Ch
	var_A= word ptr	-0Ah
	var_8= word ptr	-8
	var_6= word ptr	-6
	var_4= word ptr	-4
	arg_0= word ptr	 6
	arg_2= word ptr	 8
	arg_4= word ptr	 0Ah

	push	bp
	mov	bp, sp
	sub	sp, 0Ch
	push	si
	mov	ax, offset byte_4F658
	mov	[bp+var_A], ax
	mov	[bp+var_8], ds
	lea	ax, [bp+arg_4]
	mov	[bp+var_6], ax
	mov	[bp+var_4], ss
	push	ds
	push	[bp+var_A]
	call	sub_28C28
	add	sp, 4
	mov	si, ax
	push	[bp+var_4]
	push	[bp+var_6]
	push	[bp+arg_2]
	push	[bp+arg_0]
	push	[bp+var_8]
	push	[bp+var_A]
	call	printf_doPrint
	add	sp, 0Ch
	mov	[bp+var_C], ax
	push	[bp+var_8]
	push	[bp+var_A]
	push	si
	call	sub_28CE2
	add	sp, 6
	mov	ax, [bp+var_C]
	pop	si
	mov	sp, bp
	pop	bp
	retf
printf endp

align 2
; Attributes: bp-based frame

sub_288E6 proc far

	var_2= word ptr	-2
	arg_0= word ptr	 6

	push	bp
	mov	bp, sp
	sub	sp, 2
	push	si
	mov	ax, [bp+arg_0]
	sub	ax, offset off_4F64C
	cwd
	mov	cx, 0Ch
	idiv	cx
	mov	cx, ax
	shl	ax, 1
	add	ax, cx
	shl	ax, 1
	add	ax, offset off_4F64C
	mov	[bp+var_2], ax
	les	bx, dword ptr [bp+arg_0]
	test	byte ptr es:[bx+0Ah], 83h
	jz	short loc_28918
	test	byte ptr es:[bx+0Ah], 40h
	jz	short loc_2891E
loc_28918:
	mov	ax, 0FFFFh
	jmp	loc_289DB
loc_2891E:
	les	bx, dword ptr [bp+arg_0]
	test	byte ptr es:[bx+0Ah], 2
	jz	short loc_28930
	or	byte ptr es:[bx+0Ah], 20h
	jmp	short loc_28918
align 2
loc_28930:
	or	byte ptr es:[bx+0Ah], 1
	mov	bx, [bp+var_2]
	and	byte ptr [bx], 0FBh
	mov	bx, [bp+arg_0]
	test	byte ptr es:[bx+0Ah], 0Ch
	jnz	short loc_2896C
	mov	ax, bx
	sub	ax, offset off_4F64C
	cwd
	mov	cx, 0Ch
	idiv	cx
	mov	bx, ax
	shl	bx, 1
	add	bx, ax
	shl	bx, 1
	test	ds:byte_4F73C[bx], 1
	jnz	short loc_2896C
	push	es
	push	[bp+arg_0]
	call	sub_28B9E
	add	sp, 4
	jmp	short loc_2897E
align 2
loc_2896C:
	les	bx, dword ptr [bp+arg_0]
	mov	ax, es:[bx+6]
	mov	dx, es:[bx+8]
	mov	es:[bx], ax
	mov	es:[bx+2], dx
loc_2897E:
	mov	bx, [bp+var_2]
	push	word ptr [bx+2]
	les	bx, dword ptr [bp+arg_0]
	push	word ptr es:[bx+8]
	push	word ptr es:[bx+6]
	mov	al, es:[bx+0Bh]
	cbw
	push	ax
	call	sub_2A370
	add	sp, 8
	les	bx, dword ptr [bp+arg_0]
	mov	es:[bx+4], ax
	or	ax, ax
	jz	short loc_289AD
	cmp	ax, 0FFFFh
	jnz	short loc_289C8
loc_289AD:
	cmp	word ptr es:[bx+4], 0
	jz	short loc_289B8
	mov	al, 20h	
	jmp	short loc_289BA
loc_289B8:
	mov	al, 10h
loc_289BA:
	or	es:[bx+0Ah], al
	mov	word ptr es:[bx+4], 0
	jmp	loc_28918
align 2
loc_289C8:
	dec	word ptr es:[bx+4]
	mov	si, es:[bx]
	inc	word ptr es:[bx]
	mov	es, word ptr es:[bx+2]
	mov	al, es:[si]
	sub	ah, ah
loc_289DB:
	pop	si
	mov	sp, bp
	pop	bp
	retf
sub_288E6 endp

; Attributes: bp-based frame

sub_289E0 proc far

	var_8= word ptr	-8
	var_6= word ptr	-6
	var_4= word ptr	-4
	arg_0= word ptr	 6
	arg_2= dword ptr  8

	push	bp
	mov	bp, sp
	sub	sp, 8
	push	di
	push	si
	les	bx, [bp+arg_2]
	mov	al, es:[bx+0Bh]
	cbw
	mov	[bp+var_6], ax
	mov	ax, bx
	sub	ax, offset off_4F64C
	cwd
	mov	cx, 0Ch
	idiv	cx
	mov	cx, ax
	shl	ax, 1
	add	ax, cx
	shl	ax, 1
	add	ax, offset off_4F64C
	mov	[bp+var_8], ax
	test	byte ptr es:[bx+0Ah], 83h
	jz	short loc_28A1A
	test	byte ptr es:[bx+0Ah], 40h
	jz	short loc_28A28
loc_28A1A:
	les	bx, [bp+arg_2]
	or	byte ptr es:[bx+0Ah], 20h
	mov	ax, 0FFFFh
	jmp	loc_28B98
loc_28A28:
	test	byte ptr es:[bx+0Ah], 1
	jnz	short loc_28A1A
	or	byte ptr es:[bx+0Ah], 2
	and	byte ptr es:[bx+0Ah], 0EFh
	sub	ax, ax
	mov	es:[bx+4], ax
	mov	si, ax
	mov	[bp+var_4], si
	test	byte ptr es:[bx+0Ah], 0Ch
	jz	short loc_28A4E
	jmp	loc_28AE4
loc_28A4E:
	mov	ax, bx
	sub	ax, offset off_4F64C
	cwd
	mov	cx, 0Ch
	idiv	cx
	mov	bx, ax
	shl	bx, 1
	add	bx, ax
	shl	bx, 1
	test	ds:byte_4F73C[bx], 1
	jnz	short loc_28AE4
	cmp	word ptr [bp+arg_2], offset byte_4F658
	jnz	short loc_28A76
	cmp	word ptr [bp+arg_2+2], seg dseg
	jz	short loc_28A84
loc_28A76:
	cmp	word ptr [bp+arg_2], offset byte_4F664
	jnz	short loc_28AD8
	cmp	word ptr [bp+arg_2+2], seg dseg
	jnz	short loc_28AD8
loc_28A84:
	push	[bp+var_6]
	call	sub_2A9AC
	add	sp, 2
	or	ax, ax
	jnz	short loc_28AE4
	inc	word_4F04A
	cmp	word ptr [bp+arg_2], offset byte_4F658
	jnz	short loc_28AB2
	cmp	word ptr [bp+arg_2+2], seg dseg
	jnz	short loc_28AB2
	les	bx, [bp+arg_2]
	mov	ax, offset byte_4F24C
	mov	dx, seg	dseg
	jmp	short loc_28ABB
db 2 dup(90h)
loc_28AB2:
	les	bx, [bp+arg_2]
	mov	ax, offset byte_4F44C
	mov	dx, seg	dseg
loc_28ABB:
	mov	es:[bx+6], ax
	mov	es:[bx+8], dx
	mov	es:[bx], ax
	mov	es:[bx+2], dx
	mov	bx, [bp+var_8]
	mov	word ptr [bx+2], 200h
	mov	byte ptr [bx], 1
	jmp	short loc_28AE4
align 2
loc_28AD8:
	push	word ptr [bp+arg_2+2]
	push	word ptr [bp+arg_2]
	call	sub_28B9E
	add	sp, 4
loc_28AE4:
	les	bx, [bp+arg_2]
	test	byte ptr es:[bx+0Ah], 8
	jnz	short loc_28B08
	mov	ax, bx
	sub	ax, offset off_4F64C
	cwd
	mov	cx, 0Ch
	idiv	cx
	mov	bx, ax
	shl	bx, 1
	add	bx, ax
	shl	bx, 1
	test	ds:byte_4F73C[bx], 1
	jz	short loc_28B72
loc_28B08:
	mov	bx, word ptr [bp+arg_2]
	mov	si, es:[bx]
	sub	si, es:[bx+6]
	mov	ax, es:[bx+6]
	mov	dx, es:[bx+8]
	inc	ax
	mov	es:[bx], ax
	mov	es:[bx+2], dx
	mov	di, [bp+var_8]
	mov	ax, [di+2]
	dec	ax
	mov	es:[bx+4], ax
	or	si, si
	jle	short loc_28B48
	push	si
	push	dx
	push	word ptr es:[bx+6]
	push	[bp+var_6]
	call	sub_2A45A
	add	sp, 8
	mov	[bp+var_4], ax
	jmp	short loc_28B63
align 2
loc_28B48:
	mov	bx, [bp+var_6]
	test	ds:byte_4EFFC[bx], 20h
	jz	short loc_28B63
	mov	ax, 2
	push	ax
	sub	ax, ax
	push	ax
	push	ax
	push	bx
	call	sub_2A2F6
	add	sp, 8
loc_28B63:
	les	bx, [bp+arg_2]
	les	bx, es:[bx+6]
	mov	al, byte ptr [bp+arg_0]
	mov	es:[bx], al
	jmp	short loc_28B8B
loc_28B72:
	mov	si, 1
	mov	ax, si
	push	ax
	lea	ax, [bp+arg_0]
	push	ss
	push	ax
	push	[bp+var_6]
	call	sub_2A45A
	add	sp, 8
	mov	[bp+var_4], ax
loc_28B8B:
	cmp	[bp+var_4], si
	jz	short loc_28B93
	jmp	loc_28A1A
loc_28B93:
	mov	al, byte ptr [bp+arg_0]
	sub	ah, ah
loc_28B98:
	pop	si
	pop	di
	mov	sp, bp
	pop	bp
	retf
sub_289E0 endp

; Attributes: bp-based frame
sub_28B9E proc near

	var_4= dword ptr -4
	arg_0= word ptr	 4

	push	bp
	mov	bp, sp
	sub	sp, 4
	mov	ax, [bp+arg_0]
	sub	ax, offset off_4F64C
	cwd
	mov	cx, 0Ch
	idiv	cx
	mov	cx, ax
	shl	ax, 1
	add	ax, cx
	shl	ax, 1
	add	ax, offset byte_4F73C
	mov	word ptr [bp+var_4], ax
	mov	word ptr [bp+var_4+2], ds
	mov	ax, 200h
	push	ax
	call	_mallocMaybe
	add	sp, 2
	les	bx, dword ptr [bp+arg_0]
	mov	es:[bx+6], ax
	mov	es:[bx+8], dx
	or	dx, ax
	jz	short loc_28BEC
	or	byte ptr es:[bx+0Ah], 8
	les	bx, [bp+var_4]
	mov	word ptr es:[bx+2], 200h
	jmp	short loc_28C0C
loc_28BEC:
	les	bx, dword ptr [bp+arg_0]
	or	byte ptr es:[bx+0Ah], 4
	mov	ax, word ptr [bp+var_4]
	mov	dx, word ptr [bp+var_4+2]
	inc	ax
	mov	es:[bx+6], ax
	mov	es:[bx+8], dx
	les	bx, [bp+var_4]
	mov	word ptr es:[bx+2], 1
loc_28C0C:
	les	bx, dword ptr [bp+arg_0]
	mov	ax, es:[bx+6]
	mov	dx, es:[bx+8]
	mov	es:[bx], ax
	mov	es:[bx+2], dx
	mov	word ptr es:[bx+4], 0
	mov	sp, bp
	pop	bp
	retn
sub_28B9E endp

; Attributes: bp-based frame

sub_28C28 proc far

	var_6= word ptr	-6
	var_4= word ptr	-4
	var_2= word ptr	-2
	arg_0= dword ptr  6

	push	bp
	mov	bp, sp
	sub	sp, 6
	push	si
	inc	word_4F04A
	cmp	word ptr [bp+arg_0], offset byte_4F658
	jnz	short loc_28C4E
	cmp	word ptr [bp+arg_0+2], seg dseg
	jnz	short loc_28C4E
	mov	[bp+var_4], offset byte_4F24C
	mov	[bp+var_2], seg	dseg
	jmp	short loc_28C66
align 2
loc_28C4E:
	cmp	word ptr [bp+arg_0], offset byte_4F664
	jnz	short loc_28C8A
	cmp	word ptr [bp+arg_0+2], seg dseg
	jnz	short loc_28C8A
	mov	[bp+var_4], offset byte_4F44C
	mov	[bp+var_2], seg	dseg
loc_28C66:
	les	bx, [bp+arg_0]
	test	byte ptr es:[bx+0Ah], 0Ch
	jnz	short loc_28C8A
	mov	ax, bx
	sub	ax, offset off_4F64C
	cwd
	mov	cx, 0Ch
	idiv	cx
	mov	bx, ax
	shl	bx, 1
	add	bx, ax
	shl	bx, 1
	test	ds:byte_4F73C[bx],	1
	jz	short loc_28C8E
loc_28C8A:
	sub	ax, ax
	jmp	short loc_28CDD
loc_28C8E:
	mov	ax, word ptr [bp+arg_0]
	sub	ax, offset off_4F64C
	cwd
	mov	cx, 0Ch
	idiv	cx
	mov	cx, ax
	shl	ax, 1
	add	ax, cx
	shl	ax, 1
	add	ax, offset byte_4F73C
	mov	[bp+var_6], ax
	les	bx, [bp+arg_0]
	mov	ax, [bp+var_4]
	mov	dx, [bp+var_2]
	mov	es:[bx+6], ax
	mov	es:[bx+8], dx
	mov	es:[bx], ax
	mov	es:[bx+2], dx
	mov	si, [bp+var_6]
	mov	ax, 200h
	mov	[si+2],	ax
	mov	es:[bx+4], ax
	mov	bx, si
	mov	byte ptr [bx], 1
	mov	bx, word ptr [bp+arg_0]
	or	byte ptr es:[bx+0Ah], 2
	mov	ax, 1
loc_28CDD:
	pop	si
	mov	sp, bp
	pop	bp
	retf
sub_28C28 endp

; Attributes: bp-based frame

sub_28CE2 proc far

	var_4= dword ptr -4
	arg_0= word ptr	 6
	arg_2= dword ptr  8

	push	bp
	mov	bp, sp
	sub	sp, 4
	cmp	[bp+arg_0], 0
	jnz	short loc_28CF1
	jmp	loc_28D7A
loc_28CF1:
	cmp	word ptr [bp+arg_2], offset byte_4F658
	jnz	short loc_28CFF
	cmp	word ptr [bp+arg_2+2], seg dseg
	jz	short loc_28D13
loc_28CFF:
	cmp	word ptr [bp+arg_2], offset byte_4F664
	jz	short loc_28D09
	jmp	loc_28DBD
loc_28D09:
	cmp	word ptr [bp+arg_2+2], seg dseg
	jz	short loc_28D13
	jmp	loc_28DBD
loc_28D13:
	les	bx, [bp+arg_2]
	mov	al, es:[bx+0Bh]
	cbw
	push	ax
	call	sub_2A9AC
	add	sp, 2
	or	ax, ax
	jnz	short loc_28D2B
	jmp	loc_28DBD
loc_28D2B:
	mov	ax, word ptr [bp+arg_2]
	sub	ax, offset off_4F64C
	cwd
	mov	cx, 0Ch
	idiv	cx
	mov	cx, ax
	shl	ax, 1
	add	ax, cx
	shl	ax, 1
	add	ax, offset byte_4F73C
	mov	word ptr [bp+var_4], ax
	mov	word ptr [bp+var_4+2], ds
	push	word ptr [bp+arg_2+2]
	push	word ptr [bp+arg_2]
	call	sub_28DC2
	add	sp, 4
	les	bx, [bp+var_4]
	mov	byte ptr es:[bx], 0
	mov	word ptr es:[bx+2], 0
	les	bx, [bp+arg_2]
	sub	ax, ax
	cwd
	mov	es:[bx], ax
	mov	es:[bx+2], dx
	mov	es:[bx+6], ax
	mov	es:[bx+8], dx
	jmp	short loc_28DBD
loc_28D7A:
	les	bx, [bp+arg_2]
	cmp	word ptr es:[bx+6], offset byte_4F24C
	jnz	short loc_28D8D
	cmp	word ptr es:[bx+8], seg	dseg
	jz	short loc_28D9D
loc_28D8D:
	cmp	word ptr es:[bx+6], offset byte_4F44C
	jnz	short loc_28DBD
	cmp	word ptr es:[bx+8], seg	dseg
	jnz	short loc_28DBD
loc_28D9D:
	mov	al, es:[bx+0Bh]
	cbw
	push	ax
	call	sub_2A9AC
	add	sp, 2
	or	ax, ax
	jz	short loc_28DBD
	push	word ptr [bp+arg_2+2]
	push	word ptr [bp+arg_2]
	call	sub_28DC2
	add	sp, 4
loc_28DBD:
	mov	sp, bp
	pop	bp
	retf
sub_28CE2 endp

align 2
; Attributes: bp-based frame

sub_28DC2 proc far
	var_4= word ptr	-4
	arg_0= dword ptr  6

	push	bp
	mov	bp, sp
	sub	sp, 4
	push	si
	sub	si, si
	les	bx, [bp+arg_0]
	mov	al, es:[bx+0Ah]
	and	al, 3
	cmp	al, 2
	jnz	short loc_28E31
	test	byte ptr es:[bx+0Ah], 8
	jnz	short loc_28DF9
	mov	ax, bx
	sub	ax, offset off_4F64C
	cwd
	mov	cx, 0Ch
	idiv	cx
	mov	bx, ax
	shl	bx, 1
	add	bx, ax
	shl	bx, 1
	test	ds:byte_4F73C[bx], 1
	jz	short loc_28E31
loc_28DF9:
	mov	bx, word ptr [bp+arg_0]
	mov	ax, es:[bx]
	sub	ax, es:[bx+6]
	mov	[bp+var_4], ax
	or	ax, ax
	jle	short loc_28E31
	push	ax
	push	word ptr es:[bx+8]
	push	word ptr es:[bx+6]
	mov	al, es:[bx+0Bh]
	cbw
	push	ax
	call	sub_2A45A
	add	sp, 8
	cmp	ax, [bp+var_4]
	jz	short loc_28E31
	les	bx, [bp+arg_0]
	or	byte ptr es:[bx+0Ah], 20h
	mov	si, 0FFFFh
loc_28E31:
	les	bx, [bp+arg_0]
	mov	ax, es:[bx+6]
	mov	dx, es:[bx+8]
	mov	es:[bx], ax
	mov	es:[bx+2], dx
	mov	word ptr es:[bx+4], 0
	mov	ax, si
	pop	si
	mov	sp, bp
	pop	bp
	retf
sub_28DC2 endp

; Attributes: bp-based frame

_sscanf proc far

	var_6= byte ptr	-6
	var_4= byte ptr	-4
	arg_0= word ptr	 6
	arg_2= word ptr	 8
	arg_4= dword ptr  0Ah
	arg_8= word ptr	 0Eh
	arg_A= word ptr	 10h

	push	bp
	mov	bp, sp
	mov	ax, 6
	call	someStackOperation
	push	di
	push	si
	mov	word_4FD7A, 0
	mov	ax, [bp+arg_0]
	mov	dx, [bp+arg_2]
	mov	word ptr sscanf_structP, ax
	mov	word ptr sscanf_structP+2,	dx
	mov	ax, offset sscanf_buf
	mov	word ptr sscanf_bufp, ax
	mov	word ptr sscanf_bufp+2,	ds
	mov	word_4FE8A, 0
	mov	word_4FE8C, 0
	mov	ax, [bp+arg_8]
	mov	dx, [bp+arg_A]
	mov	word ptr dword_4FD7C, ax
	mov	word ptr dword_4FD7C+2,	dx
loc_28E93:
	les	bx, [bp+arg_4]
	mov	al, es:[bx]
	mov	[bp+var_6], al
	or	al, al
	jnz	short loc_28EA3
	jmp	loc_2927E
loc_28EA3:
	cbw
	mov	bx, ax
	test	sscanf_charFlags[bx],	8
	jz	short loc_28EC4
	push	cs
	call	near ptr _sscanf_skipWhitespace
loc_28EB1:
	inc	word ptr [bp+arg_4]
	les	bx, [bp+arg_4]
	mov	al, es:[bx]
	cbw
	mov	bx, ax
	test	sscanf_charFlags[bx],	8
	jnz	short loc_28EB1
loc_28EC4:
	mov	bx, word ptr [bp+arg_4]
	cmp	byte ptr es:[bx], 25h ;	'%'
	jz	short loc_28ED0
	jmp	loc_29254
loc_28ED0:
	sub	ax, ax
	mov	sscanf_noAssign, ax
	mov	word_4FD84, ax
	mov	sscanf_charListFlag, ax
	mov	word_4FD72, ax
	mov	word_4FD74, ax
	mov	word_4FD6C, ax
	mov	sscanf_argSizeFlag, ax
	mov	sscanf_minWidth, ax
	mov	[bp+var_4], al
	inc	word ptr [bp+arg_4]
	mov	bx, word ptr [bp+arg_4]
	cmp	byte ptr es:[bx], 2Ah ;	'*'
	jnz	short loc_28F00
	inc	sscanf_noAssign
	inc	word ptr [bp+arg_4]
loc_28F00:
	mov	bx, word ptr [bp+arg_4]
	mov	al, es:[bx]
	cbw
	mov	bx, ax
	test	sscanf_charFlags[bx], 4
	jz	short loc_28F50
	mov	di, word ptr [bp+arg_4]
loc_28F13:
	mov	al, es:[di]
	cbw
	mov	cx, sscanf_minWidth
	shl	cx, 1
	shl	cx, 1
	add	cx, sscanf_minWidth
	shl	cx, 1
	add	cx, ax
	sub	cx, 30h	
	mov	sscanf_minWidth, cx
	inc	di
	mov	al, es:[di]
	cbw
	mov	bx, ax
	test	sscanf_charFlags[bx], 4
	jnz	short loc_28F13
	mov	word ptr [bp+arg_4], di
	mov	word ptr [bp+arg_4+2], es
	or	cx, cx
	jz	short loc_28F4C
	inc	word_4FD84
	jmp	short loc_28F50
loc_28F4C:
	inc	word_4FD74
loc_28F50:
	mov	bx, word ptr [bp+arg_4]
	mov	al, es:[bx]
	cbw
	cmp	ax, 46h	
	jz	short loc_28FD0
	cmp	ax, 4Eh	
	jz	short loc_28FC8
	cmp	ax, 68h	
	jz	short loc_28F72
	cmp	ax, 6Ch	
	jz	short loc_28FC0
	cmp	ax, 70h	
	jz	short loc_28FD0
	jmp	short loc_28F78
loc_28F72:
	mov	sscanf_argSizeFlag, 1
loc_28F78:
	cmp	sscanf_argSizeFlag, 0
	jz	short loc_28F88
	les	bx, [bp+arg_4]
	cmp	byte ptr es:[bx], 70h ;	'p'
	jnz	short loc_28F91
loc_28F88:
	les	bx, [bp+arg_4]
	cmp	byte ptr es:[bx], 4Ch ;	'L'
	jnz	short loc_28F94
loc_28F91:
	inc	word ptr [bp+arg_4]
loc_28F94:
	mov	bx, word ptr [bp+arg_4]
	mov	al, es:[bx]
	cbw
	mov	si, ax
	test	sscanf_charFlags[si], 1
	jz	short loc_28FD8
	cmp	si, 45h	
	jz	short loc_28FB9
	cmp	si, 47h	
	jz	short loc_28FB9
	cmp	si, 58h	
	jz	short loc_28FB9
	mov	sscanf_argSizeFlag, 2
loc_28FB9:
	add	si, 20h	
	jmp	loc_29040
align 2
loc_28FC0:
	mov	sscanf_argSizeFlag, 2
	jmp	short loc_28F78
loc_28FC8:
	mov	sscanf_argSizeFlag, 8
	jmp	short loc_28F78
loc_28FD0:
	mov	sscanf_argSizeFlag, 10h
	jmp	short loc_28F78
loc_28FD8:
	cmp	si, 5Bh	
	jnz	short loc_29040
	inc	sscanf_charListFlag
	inc	word ptr [bp+arg_4]
	les	bx, [bp+arg_4]
	cmp	byte ptr es:[bx], 5Eh ;	'^'
	jnz	short loc_28FF3
	inc	[bp+var_4]
	inc	word ptr [bp+arg_4]
loc_28FF3:
	mov	ax, 100h
	push	ax
	mov	al, [bp+var_4]
	cbw
	push	ax
	push	word ptr sscanf_bufp+2
	push	word ptr sscanf_bufp
	call	memset
	add	sp, 8
	jmp	short loc_29028
loc_2900E:
	les	bx, [bp+arg_4]
	cmp	byte ptr es:[bx], 5Dh ;	']'
	jz	short loc_29031
	mov	al, es:[bx]
	cbw
	mov	bx, ax
	les	di, sscanf_bufp
	xor	byte ptr es:[bx+di], 1
	inc	word ptr [bp+arg_4]
loc_29028:
	les	bx, [bp+arg_4]
	cmp	byte ptr es:[bx], 0
	jnz	short loc_2900E
loc_29031:
	cmp	byte ptr es:[bx], 0
	jz	short loc_2903C
	mov	ax, 73h	
	jmp	short loc_2903E
loc_2903C:
	sub	ax, ax
loc_2903E:
	mov	si, ax
loc_29040:
	cmp	si, 69h	
	jz	short loc_29048
	jmp	loc_290FA
loc_29048:
	mov	word_4F7B8, 1
	push	cs
	call	near ptr _sscanf_skipWhitespace
	inc	word_4FE8C
	les	bx, sscanf_structP
	dec	word ptr es:[bx+4]
	js	short loc_29072
	mov	di, es:[bx]
	inc	word ptr es:[bx]
	mov	es, word ptr es:[bx+2]
	mov	al, es:[di]
	sub	ah, ah
	jmp	short loc_2907F
align 2
loc_29072:
	push	word ptr sscanf_structP+2
	push	bx
	call	sub_288E6
	add	sp, 4
loc_2907F:
	mov	si, ax
	cmp	si, 30h	
	jnz	short loc_290E2
	inc	word_4FD72
	inc	word_4FE8C
	les	bx, sscanf_structP
	dec	word ptr es:[bx+4]
	js	short loc_290AA
	mov	di, es:[bx]
	inc	word ptr es:[bx]
	mov	es, word ptr es:[bx+2]
	mov	al, es:[di]
	sub	ah, ah
	jmp	short loc_290B7
align 2
loc_290AA:
	push	word ptr sscanf_structP+2
	push	bx
	call	sub_288E6
	add	sp, 4
loc_290B7:
	mov	si, ax
	cmp	si, 78h	
	jz	short loc_290C3
	cmp	si, 58h	
	jnz	short loc_290C8
loc_290C3:
	mov	si, 78h	
	jmp	short loc_290FA
loc_290C8:
	dec	word_4FE8C
	push	word ptr sscanf_structP+2
	push	word ptr sscanf_structP
	push	si
	call	sscanf_segAdjust
	add	sp, 6
	mov	si, 6Fh	
	jmp	short loc_290FA
loc_290E2:
	dec	word_4FE8C
	push	word ptr sscanf_structP+2
	push	word ptr sscanf_structP
	push	si
	call	sscanf_segAdjust
	add	sp, 6
	mov	si, 64h	
loc_290FA:
	or	si, si
	jnz	short loc_29101
	jmp	loc_2927E
loc_29101:
	mov	ax, si
	sub	ax, 63h	
	cmp	ax, 15h
	jbe	short loc_2910E
	jmp	_sscanf_parseLiteral
loc_2910E:
	add	ax, ax
	xchg	ax, bx
	jmp	cs:_sscanf_parsers[bx]
_sscanf_parseChar:
	cmp	word_4FD84, 0
	jnz	short loc_29126
	mov	ax, 1
	mov	sscanf_minWidth, ax
	mov	word_4FD84, ax
loc_29126:
	sub	ax, ax
loc_29128:
	push	ax
	push	cs
	call	near ptr sscanf_readString
loc_2912D:
	add	sp, 2
	jmp	loc_29240
align 2
_sscanf_parseString:
	mov	ax, 1
	jmp	short loc_29128
align 2
_sscanf_parseNchars:
	inc	word_4FD6C
_sscanf_parseSignedInt:
	mov	ax, 0Ah
loc_29141:
	push	ax
	push	cs
	call	near ptr sscanf_readNumber
	jmp	short loc_2912D
_sscanf_parseOctal:
	mov	ax, 8
	jmp	short loc_29141
align 2
_sscanf_parsePointer:
	cmp	sscanf_argSizeFlag, 1
	jnz	short loc_29158
	jmp	_sscanf_parseHex
loc_29158:
	cmp	sscanf_argSizeFlag, 8
	jnz	short loc_29162
	jmp	_sscanf_parseHex
loc_29162:
	cmp	sscanf_argSizeFlag, 0
	jnz	short loc_2916C
	jmp	_sscanf_parseHex
loc_2916C:
	mov	ax, 10h
	push	ax
	push	cs
	call	near ptr sscanf_readNumber
	add	sp, 2
	sub	word ptr dword_4FD7C, 4
	les	bx, dword_4FD7C
	les	bx, es:[bx]
	mov	ax, es:[bx]
	mov	dx, es:[bx+2]
	mov	word_4FED0, ax
	mov	word_4FED2, dx
	inc	word_4FE8C
	les	bx, sscanf_structP
	dec	word ptr es:[bx+4]
	js	short loc_291B0
	mov	di, es:[bx]
	inc	word ptr es:[bx]
	mov	es, word ptr es:[bx+2]
	mov	al, es:[di]
	sub	ah, ah
	jmp	short loc_291BD
loc_291B0:
	push	word ptr sscanf_structP+2
	push	bx
	call	sub_288E6
	add	sp, 4
loc_291BD:
	mov	si, ax
	cmp	si, 3Ah	
	jnz	short loc_291EC
	inc	word_4FE8A
	mov	ax, 10h
	push	ax
	push	cs
	call	near ptr sscanf_readNumber
	add	sp, 2
	sub	word ptr dword_4FD7C, 4
	les	bx, dword_4FD7C
	les	bx, es:[bx]
	mov	dx, word_4FED0
	sub	ax, ax
	or	es:[bx+2], dx
	jmp	short loc_29201
align 2
loc_291EC:
	dec	word_4FE8C
	push	word ptr sscanf_structP+2
	push	word ptr sscanf_structP
	push	si
	call	sscanf_segAdjust
	add	sp, 6
loc_29201:
	add	word ptr dword_4FD7C, 4
	jmp	short loc_29240
_sscanf_parseHex:
	mov	ax, 10h
	jmp	loc_29141
_sscanf_parseFloat:
	push	cs
	call	near ptr sscanf_readFloat
	jmp	short loc_29240
_sscanf_parsers dw offset _sscanf_parseChar
dw offset _sscanf_parseSignedInt
dw offset _sscanf_parseFloat
dw offset _sscanf_parseFloat
dw offset _sscanf_parseFloat
dw offset _sscanf_parseLiteral
dw offset _sscanf_parseLiteral
dw offset _sscanf_parseLiteral
dw offset _sscanf_parseLiteral
dw offset _sscanf_parseLiteral
dw offset _sscanf_parseLiteral
dw offset _sscanf_parseNchars
dw offset _sscanf_parseOctal
dw offset _sscanf_parsePointer
dw offset _sscanf_parseLiteral
dw offset _sscanf_parseLiteral
dw offset _sscanf_parseString
dw offset _sscanf_parseLiteral
dw offset _sscanf_parseSignedInt
dw offset _sscanf_parseLiteral
dw offset _sscanf_parseLiteral
dw offset _sscanf_parseHex
loc_29240:
	cmp	word_4FD7A, 0
	jz	short loc_29284
	cmp	word_4FE8A, 0
	jnz	short loc_2927E
loc_2924E:
	mov	ax, 0FFFFh
	jmp	short loc_2928A
align 2
loc_29254:
	les	bx, [bp+arg_4]
	cmp	byte ptr es:[bx], 0
	jz	short loc_2927E
_sscanf_parseLiteral:
	les	bx, [bp+arg_4]
	mov	al, es:[bx]
	cbw
	push	ax
	push	cs
	call	near ptr sscanf_readLiteral
	add	sp, 2
	mov	si, ax
	or	si, si
	jz	short loc_29284
	cmp	si, 1
	jz	short loc_2927E
	cmp	word_4FE8A, 0
	jz	short loc_2924E
loc_2927E:
	mov	ax, word_4FE8A
	jmp	short loc_2928A
align 2
loc_29284:
	inc	word ptr [bp+arg_4]
	jmp	loc_28E93
loc_2928A:
	pop	si
	pop	di
	mov	sp, bp
	pop	bp
	retf
_sscanf endp

; Attributes: bp-based frame

sscanf_readString proc far

	var_A= word ptr	-0Ah
	var_8= word ptr	-8
	var_4= dword ptr -4
	arg_0= word ptr	 6

	push	bp
	mov	bp, sp
	sub	sp, 0Ah
	push	di
	push	si
	les	bx, dword_4FD7C
	mov	ax, es:[bx]
	mov	dx, es:[bx+2]
	mov	word ptr [bp+var_4], ax
	mov	word ptr [bp+var_4+2], dx
	mov	[bp+var_A], ax
	mov	[bp+var_8], dx
	cmp	sscanf_noAssign, 0
	jnz	short loc_292BB
	add	word ptr dword_4FD7C, 4
loc_292BB:
	cmp	word_4FD74, 0
	jz	short loc_292C5
	jmp	loc_293A8
loc_292C5:
	cmp	[bp+arg_0], 0
	jz	short loc_292D6
	cmp	sscanf_charListFlag, 0
	jnz	short loc_292D6
	push	cs
	call	near ptr _sscanf_skipWhitespace
loc_292D6:
	mov	di, [bp+arg_0]
	jmp	short loc_29301
align 2
loc_292DC:
	mov	al, sscanf_charFlags[si]
	and	al, 8
	mov	cx, ax
	cmp	cl, 1
	sbb	ax, ax
	neg	ax
loc_292EB:
	or	ax, ax
	jz	short loc_29328
loc_292EF:
	cmp	sscanf_noAssign, 0
	jnz	short loc_29301
	les	bx, [bp+var_4]
	mov	ax, si
	mov	es:[bx], al
	inc	word ptr [bp+var_4]
loc_29301:
	push	cs
	call	near ptr sub_297F0
	or	ax, ax
	jz	short loc_29328
	push	cs
	call	near ptr sscanf_getc
	mov	si, ax
	inc	ax
	jz	short loc_29328
	or	di, di
	jz	short loc_292EF
	cmp	sscanf_charListFlag, 0
	jz	short loc_292DC
	les	bx, sscanf_bufp
	mov	al, es:[bx+si]
	cbw
	jmp	short loc_292EB
align 2
loc_29328:
	cmp	si, 0FFFFh
	jnz	short loc_29334
	inc	word_4FD7A
	jmp	short loc_29380
align 2
loc_29334:
	cmp	[bp+arg_0], 0
	jz	short loc_29380
	cmp	word_4FD84, 0
	jz	short loc_2936B
	cmp	sscanf_minWidth, 0
	jnz	short loc_2936B
	cmp	sscanf_charListFlag, 0
	jz	short loc_2935E
	les	bx, sscanf_bufp
	cmp	byte ptr es:[bx+si], 1
	sbb	ax, ax
	neg	ax
	jmp	short loc_29367
align 2
loc_2935E:
	mov	al, sscanf_charFlags[si]
	sub	ah, ah
	and	ax, 8
loc_29367:
	or	ax, ax
	jz	short loc_29380
loc_2936B:
	dec	word_4FE8C
	push	word ptr sscanf_structP+2
	push	word ptr sscanf_structP
	push	si
	call	sscanf_segAdjust
	add	sp, 6
loc_29380:
	cmp	sscanf_noAssign, 0
	jnz	short loc_293A8
	cmp	[bp+arg_0], 0
	jz	short loc_29394
	les	bx, [bp+var_4]
	mov	byte ptr es:[bx], 0
loc_29394:
	mov	ax, word ptr [bp+var_4]
	mov	dx, word ptr [bp+var_4+2]
	cmp	[bp+var_A], ax
	jnz	short loc_293A4
	cmp	[bp+var_8], dx
	jz	short loc_293A8
loc_293A4:
	inc	word_4FE8A
loc_293A8:
	pop	si
	pop	di
	mov	sp, bp
	pop	bp
	retf
sscanf_readString endp

; Attributes: bp-based frame

sscanf_readNumber proc far

	var_6= word ptr	-6
	var_4= word ptr	-4
	var_2= word ptr	-2
	arg_0= word ptr	 6

	push	bp
	mov	bp, sp
	sub	sp, 8
	push	di
	push	si
	mov	si, [bp+arg_0]
	sub	ax, ax
	mov	[bp+var_2], ax
	cwd
	mov	[bp+var_6], ax
	mov	[bp+var_4], dx
	cmp	word_4FD6C, ax
	jz	short loc_293CE
	jmp	loc_294EE
loc_293CE:
	cmp	word_4FD74, ax
	jz	short loc_293E0
	cmp	sscanf_noAssign, ax
	jz	short loc_293DD
	jmp	loc_2954F
loc_293DD:
	jmp	loc_2954A
loc_293E0:
	cmp	word_4F7B8, 0
	jnz	short loc_293EB
	push	cs
	call	near ptr _sscanf_skipWhitespace
loc_293EB:
	push	cs
	call	near ptr sscanf_getc
	mov	di, ax
	cmp	di, 2Dh	
	jz	short loc_293FE
	cmp	di, 2Bh	
	jz	short loc_293FE
	jmp	loc_294A5
loc_293FE:
	cmp	di, 2Dh	
	jnz	short loc_29406
	inc	[bp+var_2]
loc_29406:
	dec	sscanf_minWidth
	jmp	loc_2949F
align 2
loc_2940E:
	mov	ax, 30h	
loc_29411:
	sub	di, ax
	jmp	short loc_29492
align 2
loc_29416:
	cmp	si, 8
	jnz	short loc_29468
	cmp	di, 38h	
	jge	short loc_2942E
	mov	al, 3
	push	ax
	lea	ax, [bp+var_6]
	push	ax
	call	sub_2ACF6
	jmp	short loc_2948F
loc_2942E:
	cmp	di, 0FFFFh
	jz	short loc_29448
	dec	word_4FE8C
	push	word ptr ds:sscanf_structP+2
	push	word ptr ds:sscanf_structP
	push	di
	call	sscanf_segAdjust
	add	sp, 6
loc_29448:
	cmp	[bp+var_2], 0
	jnz	short loc_29451
	jmp	loc_294F9
loc_29451:
	mov	ax, [bp+var_6]
	mov	dx, [bp+var_4]
	neg	ax
	adc	dx, 0
	neg	dx
	mov	[bp+var_6], ax
	mov	[bp+var_4], dx
	jmp	loc_294F9
align 2
loc_29468:
	test	ds:sscanf_charFlags[di], 4
	jz	short loc_2942E
	mov	ax, [bp+var_6]
	mov	dx, [bp+var_4]
	mov	cl, 2
loc_29477:
	shl	ax, 1
	rcl	dx, 1
	dec	cl
	jnz	short loc_29477
	add	ax, [bp+var_6]
	adc	dx, [bp+var_4]
	shl	ax, 1
	rcl	dx, 1
	mov	[bp+var_6], ax
	mov	[bp+var_4], dx
loc_2948F:
	sub	di, 30h	
loc_29492:
	mov	ax, di
	cwd
	add	[bp+var_6], ax
	adc	[bp+var_4], dx
	inc	word_4FD72
loc_2949F:
	push	cs
	call	near ptr sscanf_getc
	mov	di, ax
loc_294A5:
	push	cs
	call	near ptr sub_297F0
	or	ax, ax
	jz	short loc_2942E
	cmp	di, 0FFFFh
	jnz	short loc_294B5
	jmp	loc_2942E
loc_294B5:
	test	ds:sscanf_charFlags[di], 80h
	jnz	short loc_294BF
	jmp	loc_2942E
loc_294BF:
	cmp	si, 10h
	jz	short loc_294C7
	jmp	loc_29416
loc_294C7:
	mov	al, 4
	push	ax
	lea	ax, [bp+var_6]
	push	ax
	call	sub_2ACF6
	test	sscanf_charFlags[di], 1
	jz	short loc_294DD
	add	di, 20h	
loc_294DD:
	test	sscanf_charFlags[di], 2
	jnz	short loc_294E7
	jmp	loc_2940E
loc_294E7:
	mov	ax, 57h	
	jmp	loc_29411
align 2
loc_294EE:
	mov	ax, word_4FE8C
	mov	[bp+var_6], ax
	mov	[bp+var_4], 0
loc_294F9:
	cmp	sscanf_noAssign, 0
	jnz	short loc_2954F
	cmp	word_4FD72, 0
	jnz	short loc_2950E
	cmp	word_4FD6C, 0
	jz	short loc_2954A
loc_2950E:
	cmp	sscanf_argSizeFlag, 2
	jz	short loc_2951C
	cmp	sscanf_argSizeFlag, 10h
	jnz	short loc_29532
loc_2951C:
	les	bx, dword_4FD7C
	les	bx, es:[bx]
	mov	ax, [bp+var_6]
	mov	dx, [bp+var_4]
	mov	es:[bx], ax
	mov	es:[bx+2], dx
	jmp	short loc_2953F
loc_29532:
	les	bx, dword_4FD7C
	les	bx, es:[bx]
	mov	ax, [bp+var_6]
	mov	es:[bx], ax
loc_2953F:
	cmp	word_4FD6C, 0
	jnz	short loc_2954A
	inc	word_4FE8A
loc_2954A:
	add	word ptr dword_4FD7C, 4
loc_2954F:
	pop	si
	pop	di
	mov	sp, bp
	pop	bp
	retf
sscanf_readNumber endp

align 2
; Attributes: bp-based frame

sscanf_readFloat proc far

	var_C= word ptr	-0Ch
	var_A= word ptr	-0Ah
	var_6= word ptr	-6
	var_4= dword ptr -4

	push	bp
	mov	bp, sp
	sub	sp, 0Ch
	push	di
	push	si
	mov	[bp+var_6], 0
	cmp	word_4FD74, 0
	jz	short loc_29578
	cmp	sscanf_noAssign, 0
	jz	short loc_29574
	jmp	loc_2971E
loc_29574:
	jmp	loc_29719
align 2
loc_29578:
	push	cs
	call	near ptr _sscanf_skipWhitespace
	mov	ax, offset _sscanf_floatBuf
	mov	word ptr [bp+var_4], ax
	mov	word ptr [bp+var_4+2], ds
	mov	dx, ds
	add	ax, 40h	
	mov	[bp+var_C], ax
	mov	[bp+var_A], dx
	push	cs
	call	near ptr sscanf_getc
	mov	si, ax
	cmp	si, 2Bh	
	jz	short loc_295A0
	cmp	si, 2Dh	
	jnz	short loc_295BA
loc_295A0:
	cmp	si, 2Dh	
	jnz	short loc_295B0
	les	bx, [bp+var_4]
	inc	word ptr [bp+var_4]
	mov	ax, si
	mov	es:[bx], al
loc_295B0:
	dec	sscanf_minWidth
	push	cs
	call	near ptr sscanf_getc
	mov	si, ax
loc_295BA:
	mov	di, [bp+var_6]
	jmp	short loc_295DD
align 2
loc_295C0:
	mov	ax, [bp+var_C]
	mov	dx, [bp+var_A]
	cmp	word ptr [bp+var_4], ax
	jnb	short loc_295E9
	inc	di
	les	bx, [bp+var_4]
	mov	ax, si
	mov	es:[bx], al
	inc	word ptr [bp+var_4]
	push	cs
	call	near ptr sscanf_getc
	mov	si, ax
loc_295DD:
	push	si
	push	cs
	call	near ptr sub_29724
	add	sp, 2
	or	ax, ax
	jnz	short loc_295C0
loc_295E9:
	mov	[bp+var_6], di
	cmp	si, 2Eh	
	jnz	short loc_2963E
	push	cs
	call	near ptr sub_297F0
	or	ax, ax
	jz	short loc_2963E
	mov	ax, [bp+var_C]
	mov	dx, [bp+var_A]
	cmp	word ptr [bp+var_4], ax
	jnb	short loc_2963E
	les	bx, [bp+var_4]
	inc	word ptr [bp+var_4]
	mov	ax, si
	mov	es:[bx], al
	jmp	short loc_29629
align 2
loc_29612:
	mov	ax, [bp+var_C]
	mov	dx, [bp+var_A]
	cmp	word ptr [bp+var_4], ax
	jnb	short loc_2963B
	inc	di
	les	bx, [bp+var_4]
	mov	ax, si
	mov	es:[bx], al
	inc	word ptr [bp+var_4]
loc_29629:
	push	cs
	call	near ptr sscanf_getc
	mov	si, ax
	push	si
	push	cs
	call	near ptr sub_29724
	add	sp, 2
	or	ax, ax
	jnz	short loc_29612
loc_2963B:
	mov	[bp+var_6], di
loc_2963E:
	cmp	[bp+var_6], 0
	jnz	short loc_29647
	jmp	loc_296CC
loc_29647:
	cmp	si, 65h	
	jz	short loc_29651
	cmp	si, 45h	
	jnz	short loc_296CC
loc_29651:
	push	cs
	call	near ptr sub_297F0
	or	ax, ax
	jz	short loc_296CC
	mov	ax, [bp+var_C]
	mov	dx, [bp+var_A]
	cmp	word ptr [bp+var_4], ax
	jnb	short loc_296CC
	les	bx, [bp+var_4]
	inc	word ptr [bp+var_4]
	mov	ax, si
	mov	es:[bx], al
	push	cs
	call	near ptr sscanf_getc
	mov	si, ax
	cmp	si, 2Dh	
	jz	short loc_2967F
	cmp	si, 2Bh	
	jnz	short loc_296C0
loc_2967F:
	push	cs
	call	near ptr sub_297F0
	or	ax, ax
	jz	short loc_296C0
	cmp	si, 2Dh	
	jnz	short loc_296BA
	mov	ax, [bp+var_C]
	mov	dx, [bp+var_A]
	cmp	word ptr [bp+var_4], ax
	jnb	short loc_296BA
	les	bx, [bp+var_4]
	inc	word ptr [bp+var_4]
	mov	ax, si
	mov	es:[bx], al
	jmp	short loc_296BA
loc_296A4:
	mov	ax, [bp+var_C]
	mov	dx, [bp+var_A]
	cmp	word ptr [bp+var_4], ax
	jnb	short loc_296CC
	les	bx, [bp+var_4]
	mov	ax, si
	mov	es:[bx], al
	inc	word ptr [bp+var_4]
loc_296BA:
	push	cs
	call	near ptr sscanf_getc
	mov	si, ax
loc_296C0:
	push	si
	push	cs
	call	near ptr sub_29724
	add	sp, 2
	or	ax, ax
	jnz	short loc_296A4
loc_296CC:
	dec	word_4FE8C
	push	word ptr sscanf_structP+2
	push	word ptr sscanf_structP
	push	si
	call	sscanf_segAdjust
	add	sp, 6
	cmp	sscanf_noAssign, 0
	jnz	short loc_2971E
	cmp	[bp+var_6], 0
	jz	short loc_29719
	les	bx, [bp+var_4]
	mov	byte ptr es:[bx], 0
	mov	ax, offset _sscanf_floatBuf
	push	ds
	push	ax
	push	word ptr dword_4FD7C+2
	push	word ptr dword_4FD7C
	mov	ax, sscanf_argSizeFlag
	and	ax, 2
	push	ax
	call	off_4F7EC
	add	sp, 0Ah
	inc	word_4FE8A
loc_29719:
	add	word ptr dword_4FD7C, 4
loc_2971E:
	pop	si
	pop	di
	mov	sp, bp
	pop	bp
	retf
sscanf_readFloat endp

; Attributes: bp-based frame

sub_29724 proc far

	arg_0= word ptr	 6

	push	bp
	mov	bp, sp
	cmp	[bp+arg_0], 0FFFFh
	jz	short loc_29744
	mov	bx, [bp+arg_0]
	test	sscanf_charFlags[bx], 4
	jz	short loc_29744
	push	cs
	call	near ptr sub_297F0
	or	ax, ax
	jz	short loc_29744
	mov	ax, 1
	jmp	short loc_29746
loc_29744:
	sub	ax, ax
loc_29746:
	pop	bp
	retf
sub_29724 endp

; Attributes: bp-based frame

sscanf_readLiteral proc far

	arg_0= word ptr	 6

	push	bp
	mov	bp, sp
	sub	sp, 2
	push	si
	push	cs
	call	near ptr sscanf_getc
	mov	si, ax
	cmp	si, [bp+arg_0]
	jnz	short loc_2975E
	sub	ax, ax
	jmp	short loc_29780
loc_2975E:
	cmp	si, 0FFFFh
	jnz	short loc_29768
	mov	ax, 0FFFFh
	jmp	short loc_29780
loc_29768:
	dec	word_4FE8C
	push	word ptr sscanf_structP+2
	push	word ptr sscanf_structP
	push	si
	call	sscanf_segAdjust
	add	sp, 6
	mov	ax, 1
loc_29780:
	pop	si
	mov	sp, bp
	pop	bp
	retf
sscanf_readLiteral endp

align 2

sscanf_getc proc far
	push	si
	inc	word_4FE8C
	les	bx, sscanf_structP
	assume es:nothing
	dec	word ptr es:[bx+4]
	js	short loc_297A6
	mov	si, es:[bx]
	inc	word ptr es:[bx]
	mov	es, word ptr es:[bx+2]
	mov	al, es:[si]
	sub	ah, ah
	jmp	short loc_297B3
loc_297A6:
	push	word ptr sscanf_structP+2
	push	bx
	call	sub_288E6
	add	sp, 4
loc_297B3:
	pop	si
	retf
sscanf_getc endp

align 2
; Attributes: bp-based frame

_sscanf_skipWhitespace proc far
	push	bp
	mov	bp, sp
	sub	sp, 2
	push	si
loc_297BD:
	push	cs
	call	near ptr sscanf_getc
	mov	si, ax
	test	sscanf_charFlags[si], 8
	jnz	short loc_297BD
	cmp	si, 0FFFFh
	jnz	short loc_297D6
	inc	word_4FD7A
	jmp	short loc_297EB
align 2
loc_297D6:
	dec	word_4FE8C
	push	word ptr sscanf_structP+2
	push	word ptr sscanf_structP
	push	si
	call	sscanf_segAdjust
	add	sp, 6
loc_297EB:
	pop	si
	mov	sp, bp
	pop	bp
	retf
_sscanf_skipWhitespace endp


sub_297F0 proc far
	cmp	word_4FD84, 0
	jnz	short loc_297FC
loc_297F7:
	mov	ax, 1
	jmp	short locret_2980C
loc_297FC:
	cmp	sscanf_minWidth, 0
	jle	short loc_2980A
	dec	sscanf_minWidth
	jmp	short loc_297F7
align 2
loc_2980A:
	sub	ax, ax
locret_2980C:
	retf
sub_297F0 endp

align 2
; Attributes: bp-based frame

printf_doPrint proc far

	var_A= byte ptr	-0Ah
	var_8= word ptr	-8
	var_6= word ptr	-6
	var_4= dword ptr -4
	arg_0= word ptr	 6
	arg_2= word ptr	 8
	arg_4= dword ptr  0Ah
	arg_8= word ptr	 0Eh
	arg_A= word ptr	 10h

	push	bp
	mov	bp, sp
	mov	ax, 0Ah
	call	someStackOperation
	mov	ax, offset byte_4FF08
	mov	word_4FF02, ax
	mov	word_4FF04, ds
	mov	ax, [bp+arg_8]
	mov	dx, [bp+arg_A]
	mov	word ptr dword_4FEF0, ax
	mov	word ptr dword_4FEF0+2,	dx
	mov	ax, [bp+arg_0]
	mov	dx, [bp+arg_2]
	mov	word ptr dword_4FED6, ax
	mov	word ptr dword_4FED6+2,	dx
	mov	word_4FEFC, 0
	mov	word_4FEFA, 0
	jmp	loc_29B8D
loc_2984C:
	cmp	[bp+var_A], 25h	
	jz	short loc_29855
	jmp	loc_29AFC
loc_29855:
	mov	word_4FEFE, 1
	sub	ax, ax
	mov	word_4FEE0, ax
	mov	word_4FEDC, ax
	mov	word_4FEF8, ax
	mov	word_4FEDE, ax
	mov	word_4FEF6, ax
	mov	word_4FEF4, ax
	mov	word_4FEDA, ax
	mov	word_4FED4, ax
	mov	word_4FEEE, ax
	mov	word_50068, 20h	
	les	bx, [bp+arg_4]
	cmp	byte ptr es:[bx+1], 30h	
	jnz	short loc_298D1
	inc	word ptr [bp+arg_4]
	mov	word_50068, 30h	
	jmp	short loc_298D1
align 2
loc_29894:
	mov	bx, word ptr [bp+arg_4]
	cmp	byte ptr es:[bx], 2Bh ;	'+'
	jnz	short loc_298AA
	inc	word_4FEE0
	mov	word_4FEF4, 0
	jmp	short loc_298D1
align 2
loc_298AA:
	cmp	byte ptr es:[bx], 20h ;	' '
	jnz	short loc_298BE
	cmp	word_4FEE0, 0
	jnz	short loc_298D1
	inc	word_4FEF4
	jmp	short loc_298D1
align 2
loc_298BE:
	inc	word_4FED4
	jmp	short loc_298D1
loc_298C4:
	les	bx, [bp+arg_4]
	cmp	byte ptr es:[bx], 2Dh ;	'-'
	jnz	short loc_29894
	inc	word_4FEEE
loc_298D1:
	inc	word ptr [bp+arg_4]
	mov	bx, word ptr [bp+arg_4]
	mov	al, es:[bx]
	cbw
	push	ax
	push	cs
	call	near ptr sub_2A22A
	add	sp, 2
	or	ax, ax
	jnz	short loc_298C4
	push	word ptr [bp+arg_4+2]
	push	word ptr [bp+arg_4]
	mov	ax, offset word_4FF06
	push	ds
	push	ax
	push	cs
	call	near ptr sub_2A188
	add	sp, 8
	mov	word ptr [bp+arg_4], ax
	mov	word ptr [bp+arg_4+2], dx
	cmp	word_4FF06, 0
	jge	short loc_29912
	inc	word_4FEEE
	mov	ax, word_4FF06
	neg	ax
	mov	word_4FF06, ax
loc_29912:
	les	bx, [bp+arg_4]
	cmp	byte ptr es:[bx], 2Eh ;	'.'
	jnz	short loc_29949
	inc	word_4FEF6
	inc	word ptr [bp+arg_4]
	push	es
	push	word ptr [bp+arg_4]
	mov	ax, word_4FEFE
	push	ds
	push	ax
	push	cs
	call	near ptr sub_2A188
	add	sp, 8
	mov	word ptr [bp+arg_4], ax
	mov	word ptr [bp+arg_4+2], dx
	cmp	word_4FEFE, 0
	jge	short loc_29949
	mov	word_4FEFE, 1
	dec	word_4FEF6
loc_29949:
	les	bx, [bp+arg_4]
	mov	al, es:[bx]
	cbw
	cmp	ax, 46h	
	jz	short loc_29992
	cmp	ax, 4Eh	
	jz	short loc_2999A
	cmp	ax, 68h	
	jz	short loc_2998A
	cmp	ax, 6Ch	
	jnz	short loc_2996A
	mov	word_4FEDE, 2
loc_2996A:
	cmp	word_4FEDE, 0
	jnz	short loc_2997A
	les	bx, [bp+arg_4]
	cmp	byte ptr es:[bx], 4Ch ;	'L'
	jnz	short loc_2997D
loc_2997A:
	inc	word ptr [bp+arg_4]
loc_2997D:
	les	bx, [bp+arg_4]
	cmp	byte ptr es:[bx], 0
	jnz	short loc_299A2
	jmp	loc_29B9D
align 2
loc_2998A:
	mov	word_4FEDE, 1
	jmp	short loc_2996A
loc_29992:
	mov	word_4FEDE, 10h
	jmp	short loc_2996A
loc_2999A:
	mov	word_4FEDE, 8
	jmp	short loc_2996A
loc_299A2:
	mov	al, es:[bx]
	cbw
	mov	[bp+var_8], ax
	cmp	ax, 45h	
	jz	short loc_299B8
	cmp	ax, 47h	
	jz	short loc_299B8
	cmp	ax, 58h	
	jnz	short loc_299C0
loc_299B8:
	inc	word_4FEDC
	add	[bp+var_8], 20h	
loc_299C0:
	mov	ax, [bp+var_8]
	sub	ax, 63h	
	cmp	ax, 15h
	jbe	short loc_299CE
	jmp	loc_29AEC
loc_299CE:
	add	ax, ax
	xchg	ax, bx
	jmp	cs:off_29B0C[bx]
loc_299D6:
	les	bx, dword_4FEF0
	les	bx, es:[bx]
	mov	ax, word_4FEFA
	mov	es:[bx], ax
	add	word ptr dword_4FEF0, 4
	jmp	loc_29B38
align 2
loc_299EC:
	inc	word_4FEF8
loc_299F0:
	mov	word_4FED4, 0
	mov	ax, 0Ah
loc_299F9:
	push	ax
	push	cs
	call	near ptr sub_29BBC
loc_299FE:
	add	sp, 2
	jmp	loc_29B38
loc_29A04:
	mov	ax, 8
	jmp	short loc_299F9
align 2
loc_29A0A:
	inc	word_4FEDA
	inc	word_4FEDC
	cmp	word_4FEF6, 0
	jnz	short loc_29A22
	mov	word_4FF00, 1
	jmp	short loc_29A28
align 2
loc_29A22:
	mov	word_4FF00, 0
loc_29A28:
	inc	word_4FEF6
	mov	word_4FEFE, 4
	cmp	word_4FEDE, 8
	jnz	short loc_29A3C
	jmp	loc_29ACC
loc_29A3C:
	sub	ax, ax
	mov	word_4FEDE, ax
	mov	[bp+var_6], ax
	cmp	word_4FF06, ax
	jz	short loc_29A71
	mov	ax, word_4FF06
	mov	[bp+var_6], ax
	cmp	word_4FEEE, 0
	jz	short loc_29A60
	mov	word_4FF06, 0
	jmp	short loc_29A71
align 2
loc_29A60:
	sub	word_4FF06, 5
	mov	ax, word_4FF06
	or	ax, ax
	jge	short loc_29A6E
	sub	ax, ax
loc_29A6E:
	mov	word_4FF06, ax
loc_29A71:
	add	word ptr dword_4FEF0, 2
	mov	ax, 10h
	push	ax
	push	cs
	call	near ptr sub_29BBC
	add	sp, 2
	mov	ax, 3Ah	
	push	ax
	push	cs
	call	near ptr sub_29F12
	add	sp, 2
	cmp	[bp+var_6], 0
	jz	short loc_29AB4
	cmp	word_4FEEE, 0
	jz	short loc_29AAE
	mov	ax, [bp+var_6]
	sub	ax, 5
	mov	word_4FF06, ax
	or	ax, ax
	jge	short loc_29AA8
	sub	ax, ax
loc_29AA8:
	mov	word_4FF06, ax
	jmp	short loc_29AB4
align 2
loc_29AAE:
	mov	word_4FF06, 0
loc_29AB4:
	sub	word ptr dword_4FEF0, 4
	mov	ax, 10h
	push	ax
	push	cs
	call	near ptr sub_29BBC
	add	sp, 2
	add	word ptr dword_4FEF0, 2
	jmp	short loc_29B38
align 2
loc_29ACC:
	mov	ax, 10h
	jmp	loc_299F9
loc_29AD2:
	sub	ax, ax
loc_29AD4:
	push	ax
	push	cs
	call	near ptr sub_29D32
	jmp	loc_299FE
loc_29ADC:
	mov	ax, 1
	jmp	short loc_29AD4
align 2
loc_29AE2:
	push	[bp+var_8]
	push	cs
	call	near ptr sub_29E26
	jmp	loc_299FE
loc_29AEC:
	cmp	word_4FEDE, 0
	jz	short loc_29AFC
	mov	ax, word ptr [bp+arg_4]
	mov	dx, word ptr [bp+arg_4+2]
	dec	word ptr [bp+arg_4]
loc_29AFC:
	mov	ax, word ptr [bp+arg_4]
	mov	dx, word ptr [bp+arg_4+2]
	inc	ax
	mov	word ptr [bp+var_4], ax
	mov	word ptr [bp+var_4+2], dx
	jmp	short loc_29B5D
align 2
off_29B0C dw offset loc_29ADC
dw offset loc_299F0
dw offset loc_29AE2
dw offset loc_29AE2
dw offset loc_29AE2
dw offset loc_29AEC
dw offset loc_299F0
dw offset loc_29AEC
dw offset loc_29AEC
dw offset loc_29AEC
dw offset loc_29AEC
dw offset loc_299D6
dw offset loc_29A04
dw offset loc_29A0A
dw offset loc_29AEC
dw offset loc_29AEC
dw offset loc_29AD2
dw offset loc_29AEC
dw offset loc_299EC
dw offset loc_29AEC
dw offset loc_29AEC
dw offset loc_29ACC
loc_29B38:
	cmp	word_4FEFC, 0
	jz	short loc_29B54
	cmp	word_4FEFA, 0
	jnz	short loc_29BB4
	les	bx, dword_4FED6
	test	byte ptr es:[bx+0Ah], 20h
	jnz	short loc_29BAF
	jmp	short loc_29BB4
align 2
loc_29B54:
	inc	word ptr [bp+arg_4]
	jmp	short loc_29B8D
align 2
loc_29B5A:
	inc	word ptr [bp+var_4]
loc_29B5D:
	les	bx, [bp+var_4]
	mov	al, es:[bx]
	mov	[bp+var_A], al
	or	al, al
	jz	short loc_29B6E
	cmp	al, 25h	
	jnz	short loc_29B5A
loc_29B6E:
	mov	ax, bx
	sub	ax, word ptr [bp+arg_4]
	push	ax
	push	word ptr [bp+arg_4+2]
	push	word ptr [bp+arg_4]
	push	cs
	call	near ptr sub_29FCA
	add	sp, 6
	mov	ax, word ptr [bp+var_4]
	mov	dx, word ptr [bp+var_4+2]
	mov	word ptr [bp+arg_4], ax
	mov	word ptr [bp+arg_4+2], dx
loc_29B8D:
	les	bx, [bp+arg_4]
	mov	al, es:[bx]
	mov	[bp+var_A], al
	or	al, al
	jz	short loc_29B9D
	jmp	loc_2984C
loc_29B9D:
	cmp	word_4FEFA, 0
	jnz	short loc_29BB4
	les	bx, dword_4FED6
	test	byte ptr es:[bx+0Ah], 20h
	jz	short loc_29BB4
loc_29BAF:
	mov	ax, 0FFFFh
	jmp	short loc_29BB7
loc_29BB4:
	mov	ax, word_4FEFA
loc_29BB7:
	mov	sp, bp
	pop	bp
	retf
printf_doPrint endp

align 2
; Attributes: bp-based frame

sub_29BBC proc far

	var_12=	word ptr -12h
	var_10=	word ptr -10h
	var_E= dword ptr -0Eh
	var_A= word ptr	-0Ah
	var_8= dword ptr -8
	var_4= word ptr	-4
	var_2= word ptr	-2
	arg_0= word ptr	 6

	push	bp
	mov	bp, sp
	sub	sp, 12h
	push	di
	push	si
	cmp	[bp+arg_0], 0Ah
	jz	short loc_29BCE
	inc	word_4FEF8
loc_29BCE:
	cmp	word_4FEDE, 2
	jz	short loc_29BDC
	cmp	word_4FEDE, 10h
	jnz	short loc_29BF4
loc_29BDC:
	les	bx, dword_4FEF0
	mov	ax, es:[bx]
	mov	dx, es:[bx+2]
	mov	[bp+var_4], ax
	mov	[bp+var_2], dx
	add	word ptr dword_4FEF0, 4
	jmp	short loc_29C1F
loc_29BF4:
	cmp	word_4FEF8, 0
	jz	short loc_29C0C
	les	bx, dword_4FEF0
	mov	ax, es:[bx]
	mov	[bp+var_4], ax
	mov	[bp+var_2], 0
	jmp	short loc_29C1A
loc_29C0C:
	les	bx, dword_4FEF0
	mov	ax, es:[bx]
	cwd
	mov	[bp+var_4], ax
	mov	[bp+var_2], dx
loc_29C1A:
	add	word ptr dword_4FEF0, 2
loc_29C1F:
	cmp	word_4FED4, 0
	jz	short loc_29C34
	mov	ax, [bp+var_4]
	or	ax, [bp+var_2]
	jz	short loc_29C34
	mov	ax, [bp+arg_0]
	jmp	short loc_29C36
align 2
loc_29C34:
	sub	ax, ax
loc_29C36:
	mov	word_50066, ax
	mov	ax, word_4FF02
	mov	dx, word_4FF04
	mov	word ptr [bp+var_E], ax
	mov	word ptr [bp+var_E+2], dx
	cmp	word_4FEF8, 0
	jnz	short loc_29C7E
	cmp	[bp+var_2], 0
	jge	short loc_29C7E
	cmp	[bp+arg_0], 0Ah
	jnz	short loc_29C76
	les	bx, [bp+var_E]
	inc	word ptr [bp+var_E]
	mov	byte ptr es:[bx], 2Dh ;	'-'
	mov	ax, [bp+var_4]
	mov	dx, [bp+var_2]
	neg	ax
	adc	dx, 0
	neg	dx
	mov	[bp+var_4], ax
	mov	[bp+var_2], dx
loc_29C76:
	mov	[bp+var_A], 1
	jmp	short loc_29C83
align 2
loc_29C7E:
	mov	[bp+var_A], 0
loc_29C83:
	mov	ax, offset byte_4FEE2
	mov	word ptr [bp+var_8], ax
	mov	word ptr [bp+var_8+2], ds
	push	[bp+arg_0]
	push	ds
	push	ax
	push	[bp+var_2]
	push	[bp+var_4]
	call	sub_2A98A
	add	sp, 0Ah
	cmp	word_4FEF6, 0
	jz	short loc_29CD7
	push	word ptr [bp+var_8+2]
	push	word ptr [bp+var_8]
	call	_strlen
	add	sp, 4
	mov	cx, word_4FEFE
	sub	cx, ax
	mov	[bp+var_10], cx
	les	di, [bp+var_E]
	jmp	short loc_29CC7
loc_29CC2:
	mov	byte ptr es:[di], 30h ;	'0'
	inc	di
loc_29CC7:
	mov	ax, cx
	dec	cx
	or	ax, ax
	jg	short loc_29CC2
	mov	word ptr [bp+var_E], di
	mov	word ptr [bp+var_E+2], es
	mov	[bp+var_10], cx
loc_29CD7:
	mov	cx, word_4FEDC
	mov	[bp+var_12], ds
	lds	si, [bp+var_E]
loc_29CE1:
	les	bx, [bp+var_8]
	mov	al, es:[bx]
	mov	[si], al
	or	cx, cx
	jz	short loc_29CF4
	cmp	al, 61h	
	jl	short loc_29CF4
	sub	byte ptr [si], 20h 
loc_29CF4:
	inc	si
	inc	word ptr [bp+var_8]
	cmp	byte ptr es:[bx], 0
	jnz	short loc_29CE1
	mov	word ptr [bp+var_E], si
	mov	word ptr [bp+var_E+2], ds
	mov	ds, [bp+var_12]
	cmp	word_4FEF8, 0
	jnz	short loc_29D22
	mov	ax, word_4FEE0
	or	ax, word_4FEF4
	jz	short loc_29D22
	cmp	[bp+var_A], 0
	jnz	short loc_29D22
	mov	ax, 1
	jmp	short loc_29D24
loc_29D22:
	sub	ax, ax
loc_29D24:
	push	ax
	push	cs
	call	near ptr sub_2A040
	add	sp, 2
	pop	si
	pop	di
	mov	sp, bp
	pop	bp
	retf
sub_29BBC endp

; Attributes: bp-based frame

sub_29D32 proc far

	var_E= dword ptr -0Eh
	var_8= word ptr	-8
	var_6= word ptr	-6
	var_4= word ptr	-4
	arg_0= word ptr	 6

	push	bp
	mov	bp, sp
	sub	sp, 10h
	push	di
	push	si
	cmp	[bp+arg_0], 0
	jz	short loc_29D58
	mov	si, 1
	mov	ax, word ptr dword_4FEF0
	mov	dx, word ptr dword_4FEF0+2
	mov	[bp+var_8], ax
	mov	[bp+var_6], dx
	add	word ptr dword_4FEF0, 2
	jmp	loc_29DED
loc_29D58:
	cmp	word_4FEDE, 8
	jz	short loc_29D78
	les	bx, dword_4FEF0
	mov	ax, es:[bx]
	mov	dx, es:[bx+2]
	mov	[bp+var_8], ax
	mov	[bp+var_6], dx
	add	word ptr dword_4FEF0, 4
	jmp	short loc_29D8D
align 2
loc_29D78:
	les	bx, dword_4FEF0
	mov	ax, es:[bx]
	mov	[bp+var_4], ax
	mov	[bp+var_8], ax
	mov	[bp+var_6], ds
	add	word ptr dword_4FEF0, 2
loc_29D8D:
	cmp	word_4FEDE, 8
	jz	short loc_29DA2
	mov	ax, [bp+var_8]
	or	ax, [bp+var_6]
	jnz	short loc_29DB1
	mov	ax, offset aNull
	jmp	short loc_29DAB
align 2
loc_29DA2:
	cmp	[bp+var_4], 0
	jnz	short loc_29DB1
	mov	ax, offset aNull_0
loc_29DAB:
	mov	[bp+var_8], ax
	mov	[bp+var_6], ds
loc_29DB1:
	mov	ax, [bp+var_8]
	mov	dx, [bp+var_6]
	mov	word ptr [bp+var_E], ax
	mov	word ptr [bp+var_E+2], dx
	sub	si, si
	cmp	word_4FEF6, si
	jz	short loc_29DE1
	mov	cx, word_4FEFE
	jmp	short loc_29DD9
align 2
loc_29DCC:
	les	bx, [bp+var_E]
	inc	word ptr [bp+var_E]
	cmp	byte ptr es:[bx], 0
	jz	short loc_29DED
	inc	si
loc_29DD9:
	cmp	cx, si
	jle	short loc_29DED
	jmp	short loc_29DCC
align 2
loc_29DE0:
	inc	si
loc_29DE1:
	les	bx, [bp+var_E]
	inc	word ptr [bp+var_E]
	cmp	byte ptr es:[bx], 0
	jnz	short loc_29DE0
loc_29DED:
	mov	di, word_4FF06
	sub	di, si
	cmp	word_4FEEE, 0
	jnz	short loc_29E02
	push	di
	push	cs
	call	near ptr sub_29F5E
	add	sp, 2
loc_29E02:
	push	si
	push	[bp+var_6]
	push	[bp+var_8]
	push	cs
	call	near ptr sub_29FCA
	add	sp, 6
	cmp	word_4FEEE, 0
	jz	short loc_29E1F
	push	di
	push	cs
	call	near ptr sub_29F5E
	add	sp, 2
loc_29E1F:
	pop	si
	pop	di
	mov	sp, bp
	pop	bp
	retf
sub_29D32 endp

align 2
; Attributes: bp-based frame

sub_29E26 proc far

	var_6= byte ptr	-6
	var_4= word ptr	-4
	var_2= word ptr	-2
	arg_0= word ptr	 6

	push	bp
	mov	bp, sp
	sub	sp, 6
	mov	ax, word ptr dword_4FEF0
	mov	dx, word ptr dword_4FEF0+2
	mov	[bp+var_4], ax
	mov	[bp+var_2], dx
	cmp	[bp+arg_0], 67h	
	jz	short loc_29E45
	cmp	[bp+arg_0], 47h	
	jnz	short loc_29E4A
loc_29E45:
	mov	al, 1
	jmp	short loc_29E4C
align 2
loc_29E4A:
	sub	al, al
loc_29E4C:
	mov	[bp+var_6], al
	cmp	word_4FEF6, 0
	jnz	short loc_29E5C
	mov	word_4FEFE, 6
loc_29E5C:
	cmp	[bp+var_6], 0
	jz	short loc_29E6F
	cmp	word_4FEFE, 0
	jnz	short loc_29E6F
	mov	word_4FEFE, 1
loc_29E6F:
	push	word_4FEDC
	push	word_4FEFE
	push	[bp+arg_0]
	push	word_4FF04
	push	word_4FF02
	push	[bp+var_2]
	push	[bp+var_4]
	call	off_4F7E4
	add	sp, 0Eh
	cmp	[bp+var_6], 0
	jz	short loc_29EB5
	cmp	word_4FED4, 0
	jnz	short loc_29EB5
	push	word_4FF04
	push	word_4FF02
	call	off_4F7E8
	add	sp, 4
loc_29EB5:
	cmp	word_4FED4, 0
	jz	short loc_29ED7
	cmp	word_4FEFE, 0
	jnz	short loc_29ED7
	push	word_4FF04
	push	word_4FF02
	call	off_4F7F0
	add	sp, 4
loc_29ED7:
	add	word ptr dword_4FEF0, 8
	mov	word_50066, 0
	mov	ax, word_4FEE0
	or	ax, word_4FEF4
	jz	short loc_29F06
	push	[bp+var_2]
	push	[bp+var_4]
	call	off_4F7F4
	add	sp, 4
	or	ax, ax
	jz	short loc_29F06
	mov	ax, 1
	jmp	short loc_29F08
loc_29F06:
	sub	ax, ax
loc_29F08:
	push	ax
	push	cs
	call	near ptr sub_2A040
	mov	sp, bp
	pop	bp
	retf
sub_29E26 endp

align 2
; Attributes: bp-based frame

sub_29F12 proc far

	arg_0= byte ptr	 6

	push	bp
	mov	bp, sp
	push	si
	cmp	word_4FEFC, 0
	jnz	short loc_29F5A
	les	bx, dword_4FED6
	assume es:nothing
	dec	word ptr es:[bx+4]
	js	short loc_29F3C
	mov	al, [bp+arg_0]
	mov	si, es:[bx]
	inc	word ptr es:[bx]
	mov	es, word ptr es:[bx+2]
	mov	es:[si], al
	sub	ah, ah
	jmp	short loc_29F4C
align 2
loc_29F3C:
	push	word ptr dword_4FED6+2
	push	bx
	push	word ptr [bp+arg_0]
	call	sub_289E0
	add	sp, 6
loc_29F4C:
	inc	ax
	jnz	short loc_29F56
	inc	word_4FEFC
	jmp	short loc_29F5A
align 2
loc_29F56:
	inc	word_4FEFA
loc_29F5A:
	pop	si
	pop	bp
	retf
sub_29F12 endp

align 2
; Attributes: bp-based frame

sub_29F5E proc far

	arg_0= word ptr	 6

	push	bp
	mov	bp, sp
	sub	sp, 2
	push	di
	push	si
	cmp	word_4FEFC, 0
	jnz	short loc_29FC4
	mov	si, [bp+arg_0]
	or	si, si
	jle	short loc_29FC4
	jmp	short loc_29F91
loc_29F76:
	push	word ptr dword_4FED6+2
	push	word ptr dword_4FED6
	push	word_50068
	call	sub_289E0
	add	sp, 6
loc_29F8A:
	inc	ax
	jnz	short loc_29F91
	inc	word_4FEFC
loc_29F91:
	mov	ax, si
	dec	si
	or	ax, ax
	jle	short loc_29FB6
	les	bx, dword_4FED6
	dec	word ptr es:[bx+4]
	js	short loc_29F76
	mov	al, byte ptr word_50068
	mov	di, es:[bx]
	inc	word ptr es:[bx]
	mov	es, word ptr es:[bx+2]
	mov	es:[di], al
	sub	ah, ah
	jmp	short loc_29F8A
loc_29FB6:
	cmp	word_4FEFC, 0
	jnz	short loc_29FC4
	mov	ax, [bp+arg_0]
	add	word_4FEFA, ax
loc_29FC4:
	pop	si
	pop	di
	mov	sp, bp
	pop	bp
	retf
sub_29F5E endp

; Attributes: bp-based frame

sub_29FCA proc far

	arg_0= dword ptr  6
	arg_4= word ptr	 0Ah

	push	bp
	mov	bp, sp
	sub	sp, 2
	push	di
	push	si
	mov	si, [bp+arg_4]
	cmp	word_4FEFC, 0
	jnz	short loc_2A03A
	jmp	short loc_2A000
loc_29FDE:
	push	word ptr dword_4FED6+2
	push	word ptr dword_4FED6
	les	bx, [bp+arg_0]
	mov	al, es:[bx]
	cbw
	push	ax
	call	sub_289E0
	add	sp, 6
loc_29FF6:
	inc	ax
	jnz	short loc_29FFD
	inc	word_4FEFC
loc_29FFD:
	inc	word ptr [bp+arg_0]
loc_2A000:
	mov	ax, si
	dec	si
	or	ax, ax
	jz	short loc_2A02C
	les	bx, dword_4FED6
	dec	word ptr es:[bx+4]
	js	short loc_29FDE
	les	bx, [bp+arg_0]
	mov	al, es:[bx]
	les	bx, dword_4FED6
	mov	di, es:[bx]
	inc	word ptr es:[bx]
	mov	es, word ptr es:[bx+2]
	mov	es:[di], al
	sub	ah, ah
	jmp	short loc_29FF6
loc_2A02C:
	cmp	word_4FEFC, 0
	jnz	short loc_2A03A
	mov	ax, [bp+arg_4]
	add	word_4FEFA, ax
loc_2A03A:
	pop	si
	pop	di
	mov	sp, bp
	pop	bp
	retf
sub_29FCA endp

; Attributes: bp-based frame

sub_2A040 proc far

	var_C= dword ptr -0Ch
	var_8= word ptr	-8
	var_6= word ptr	-6
	var_4= word ptr	-4
	arg_0= word ptr	 6

	push	bp
	mov	bp, sp
	sub	sp, 0Ch
	push	si
	mov	ax, word_4FF02
	mov	dx, word_4FF04
	mov	word ptr [bp+var_C], ax
	mov	word ptr [bp+var_C+2], dx
	sub	ax, ax
	mov	[bp+var_4], ax
	mov	[bp+var_6], ax
	cmp	word_50068, 30h	
	jnz	short loc_2A07B
	cmp	word_4FEF6, ax
	jz	short loc_2A07B
	cmp	word_4FEDA, ax
	jz	short loc_2A075
	cmp	word_4FF00, ax
	jnz	short loc_2A07B
loc_2A075:
	mov	word_50068, 20h	
loc_2A07B:
	mov	si, word_4FF06
	push	word ptr [bp+var_C+2]
	push	word ptr [bp+var_C]
	call	_strlen
	add	sp, 4
	mov	[bp+var_8], ax
	sub	si, ax
	sub	si, [bp+arg_0]
	cmp	word_4FEEE, 0
	jnz	short loc_2A0BE
	les	bx, [bp+var_C]
	cmp	byte ptr es:[bx], 2Dh ;	'-'
	jnz	short loc_2A0BE
	cmp	word_50068, 30h	
	jnz	short loc_2A0BE
	inc	word ptr [bp+var_C]
	mov	al, es:[bx]
	cbw
	push	ax
	push	cs
	call	near ptr sub_29F12
	add	sp, 2
	dec	[bp+var_8]
loc_2A0BE:
	cmp	word_50068, 30h	
	jz	short loc_2A0D0
	or	si, si
	jle	short loc_2A0D0
	cmp	word_4FEEE, 0
	jz	short loc_2A0EB
loc_2A0D0:
	cmp	[bp+arg_0], 0
	jz	short loc_2A0DD
	inc	[bp+var_6]
	push	cs
	call	near ptr sub_2A146
loc_2A0DD:
	cmp	word_50066, 0
	jz	short loc_2A0EB
	inc	[bp+var_4]
	push	cs
	call	near ptr sub_2A15E
loc_2A0EB:
	cmp	word_4FEEE, 0
	jnz	short loc_2A11B
	push	si
	push	cs
	call	near ptr sub_29F5E
	add	sp, 2
	cmp	[bp+arg_0], 0
	jz	short loc_2A10A
	cmp	[bp+var_6], 0
	jnz	short loc_2A10A
	push	cs
	call	near ptr sub_2A146
loc_2A10A:
	cmp	word_50066, 0
	jz	short loc_2A11B
	cmp	[bp+var_4], 0
	jnz	short loc_2A11B
	push	cs
	call	near ptr sub_2A15E
loc_2A11B:
	push	[bp+var_8]
	push	word ptr [bp+var_C+2]
	push	word ptr [bp+var_C]
	push	cs
	call	near ptr sub_29FCA
	add	sp, 6
	cmp	word_4FEEE, 0
	jz	short loc_2A140
	mov	word_50068, 20h	
	push	si
	push	cs
	call	near ptr sub_29F5E
	add	sp, 2
loc_2A140:
	pop	si
	mov	sp, bp
	pop	bp
	retf
sub_2A040 endp

align 2

sub_2A146 proc far
	cmp	word_4FEE0, 0
	jz	short loc_2A152
	mov	ax, 2Bh	
	jmp	short loc_2A155
loc_2A152:
	mov	ax, 20h	
loc_2A155:
	push	ax
	push	cs
	call	near ptr sub_29F12
	add	sp, 2
	retf
sub_2A146 endp


sub_2A15E proc far
	mov	ax, 30h	
	push	ax
	push	cs
	call	near ptr sub_29F12
	add	sp, 2
	cmp	word_50066, 10h
	jnz	short locret_2A187
	cmp	word_4FEDC, 0
	jz	short loc_2A17C
	mov	ax, 58h	
	jmp	short loc_2A17F
loc_2A17C:
	mov	ax, 78h	
loc_2A17F:
	push	ax
	push	cs
	call	near ptr sub_29F12
	add	sp, 2
locret_2A187:
	retf
sub_2A15E endp

; Attributes: bp-based frame

sub_2A188 proc far

	var_6= byte ptr	-6
	var_2= word ptr	-2
	arg_0= dword ptr  6
	arg_4= dword ptr  0Ah

	push	bp
	mov	bp, sp
	sub	sp, 6
	push	di
	push	si
	mov	[bp+var_2], 1
	les	bx, [bp+arg_4]
	cmp	byte ptr es:[bx], 2Ah ;	'*'
	jnz	short loc_2A1B0
	les	bx, dword_4FEF0
	mov	si, es:[bx]
	add	word ptr dword_4FEF0, 2
	inc	word ptr [bp+arg_4]
	jmp	short loc_2A210
align 2
loc_2A1B0:
	les	bx, [bp+arg_4]
	cmp	byte ptr es:[bx], 2Dh ;	'-'
	jnz	short loc_2A1C1
	mov	[bp+var_2], 0FFFFh
	inc	word ptr [bp+arg_4]
loc_2A1C1:
	sub	si, si
	mov	bx, word ptr [bp+arg_4]
	mov	al, es:[bx]
	mov	[bp+var_6], al
	cmp	al, 30h	
	jl	short loc_2A210
	cmp	al, 39h	
	jg	short loc_2A210
	cmp	word_4FEF6, si
	jnz	short loc_2A1E4
	cmp	al, 30h	
	jnz	short loc_2A1E4
	mov	word_50068, 30h	
loc_2A1E4:
	mov	di, bx
	jmp	short loc_2A1EE
loc_2A1E8:
	cmp	byte ptr es:[di], 39h ;	'9'
	jg	short loc_2A20A
loc_2A1EE:
	mov	al, es:[di]
	cbw
	mov	cx, si
	shl	cx, 1
	shl	cx, 1
	add	cx, si
	shl	cx, 1
	add	cx, ax
	sub	cx, 30h	
	mov	si, cx
	inc	di
	cmp	byte ptr es:[di], 30h ;	'0'
	jge	short loc_2A1E8
loc_2A20A:
	mov	word ptr [bp+arg_4], di
	mov	word ptr [bp+arg_4+2], es
loc_2A210:
	mov	ax, [bp+var_2]
	imul	si
	mov	si, ax
	les	bx, [bp+arg_0]
	mov	es:[bx], si
	mov	ax, word ptr [bp+arg_4]
	mov	dx, word ptr [bp+arg_4+2]
	pop	si
	pop	di
	mov	sp, bp
	pop	bp
	retf
sub_2A188 endp

align 2
; Attributes: bp-based frame

sub_2A22A proc far

	var_4= dword ptr -4
	arg_0= byte ptr	 6

	push	bp
	mov	bp, sp
	sub	sp, 4
	push	di
	mov	ax, offset asc_4F7C8
	mov	word ptr [bp+var_4], ax
	mov	word ptr [bp+var_4+2], ds
	mov	cl, [bp+arg_0]
	les	di, [bp+var_4]
	jmp	short loc_2A243
loc_2A242:
	inc	di
loc_2A243:
	cmp	byte ptr es:[di], 0
	jz	short loc_2A25A
	cmp	es:[di], cl
	jnz	short loc_2A242
	mov	ax, 1
	mov	word ptr [bp+var_4], di
	mov	word ptr [bp+var_4+2], es
	jmp	short loc_2A262
align 2
loc_2A25A:
	mov	word ptr [bp+var_4], di
	mov	word ptr [bp+var_4+2], es
	sub	ax, ax
loc_2A262:
	pop	di
	mov	sp, bp
	pop	bp
	retf
sub_2A22A endp

align 2
; Attributes: bp-based frame

sscanf_segAdjust proc far

	arg_0= word ptr	 6
	arg_2= dword ptr  8

	push	bp
	mov	bp, sp
	push	si
	mov	si, [bp+arg_0]
	les	bx, [bp+arg_2]
	test	byte ptr es:[bx+0Ah], 1
	jz	short loc_2A27E
	cmp	si, 0FFFFh
	jnz	short loc_2A284
loc_2A27E:
	mov	ax, 0FFFFh
	jmp	short loc_2A2F3
align 2
loc_2A284:
	les	bx, [bp+arg_2]
	mov	ax, es:[bx+6]
	or	ax, es:[bx+8]
	jnz	short loc_2A299
	push	es
	push	bx
	call	sub_28B9E
	add	sp, 4
loc_2A299:
	les	bx, [bp+arg_2]
	mov	ax, es:[bx]
	mov	dx, es:[bx+2]
	cmp	es:[bx+6], ax
	jnz	short loc_2A2B9
	cmp	es:[bx+8], dx
	jnz	short loc_2A2B9
	cmp	word ptr es:[bx+4], 0
	jnz	short loc_2A27E
	inc	word ptr es:[bx]
loc_2A2B9:
	inc	word ptr es:[bx+4]
	dec	word ptr es:[bx]
	les	bx, es:[bx]
	mov	ax, si
	mov	es:[bx], al
	les	bx, [bp+arg_2]
	and	byte ptr es:[bx+0Ah], 0EFh
	test	byte ptr es:[bx+0Ah], 40h
	jnz	short loc_2A2EF
	mov	ax, bx
	sub	ax, offset off_4F64C
	cwd
	mov	cx, 0Ch
	idiv	cx
	mov	bx, ax
	shl	bx, 1
	add	bx, ax
	shl	bx, 1
	or	byte_4F73C[bx], 4
loc_2A2EF:
	mov	ax, si
	sub	ah, ah
loc_2A2F3:
	pop	si
	pop	bp
	retf
sscanf_segAdjust endp

; Attributes: bp-based frame

sub_2A2F6 proc far

	var_4= word ptr	-4
	var_2= word ptr	-2
	arg_2= word ptr	 6
	arg_4= word ptr	 8
	arg_6= word ptr	 0Ah
	arg_8= word ptr	 0Ch

; FUNCTION CHUNK AT 13D5 SIZE 0000000D BYTES
	push	bp
	mov	bp, sp
	sub	sp, 4
	mov	bx, [bp+arg_2]
	cmp	bx, word_4EFFA
	jb	short loc_2A30A
	mov	ax, 900h
	jmp	short loc_2A334
loc_2A30A:
	test	[bp+arg_6], 8000h
	jz	short loc_2A359
	cmp	[bp+arg_8], 0
	jz	short loc_2A331
	xor	cx, cx
	mov	dx, cx
	mov	ax, 4201h
	int	21h		; DOS -	2+ - MOVE FILE CALL(read)/CALL(write) POINTER (LSEEK)
			; AL = method: offset from present location
	jb	short loc_2A36D
	test	[bp+arg_8], 2
	jnz	short loc_2A337
	add	ax, [bp+arg_4]
	adc	dx, [bp+arg_6]
	jns	short loc_2A359
loc_2A331:
	mov	ax, 1600h
loc_2A334:
	stc
	jmp	short loc_2A36D
loc_2A337:
	mov	[bp+var_2], dx
	mov	[bp+var_4], ax
	mov	dx, cx
	mov	ax, 4202h
	int	21h		; DOS -	2+ - MOVE FILE CALL(read)/CALL(write) POINTER (LSEEK)
			; AL = method: offset from end of file
	add	ax, [bp+arg_4]
	adc	dx, [bp+arg_6]
	jns	short loc_2A359
	mov	cx, [bp+var_2]
	mov	dx, [bp+var_4]
	mov	ax, 4200h
	int	21h		; DOS -	2+ - MOVE FILE CALL(read)/CALL(write) POINTER (LSEEK)
			; AL = method: offset from beginning of	file
	jmp	short loc_2A331
loc_2A359:
	mov	dx, [bp+arg_4]
	mov	cx, [bp+arg_6]
	mov	al, byte ptr [bp+arg_8]
	mov	ah, 42h
	int	21h		; DOS -	2+ - MOVE FILE CALL(read)/CALL(write) POINTER (LSEEK)
			; AL = method:
			; 0-from beginnig,1-from current,2-from	end
	jb	short loc_2A36D
	and	byte_4EFFC[bx], 0FDh
loc_2A36D:
	jmp	loc_28805
sub_2A2F6 endp

; Attributes: bp-based frame

sub_2A370 proc far

	var_1= word ptr	-1
	arg_2= word ptr	 6
	arg_4= dword ptr  8
	arg_8= word ptr	 0Ch

	push	bp
	mov	bp, sp
	sub	sp, 2
	mov	bx, [bp+arg_2]
	cmp	bx, word_4EFFA
	jb	short loc_2A385
	stc
	mov	ax, 900h
	jmp	short loc_2A3EC
loc_2A385:
	xor	ax, ax
	mov	cx, [bp+arg_8]
	jcxz	short loc_2A3EC
	test	byte_4EFFC[bx],	2
	jnz	short loc_2A3EC
	mov	cx, [bp+arg_8]
	push	ds
	lds	dx, [bp+arg_4]
	mov	ah, 3Fh
	int	21h		; DOS -	2+ - CALL(read) FROM FILE WITH HANDLE
			; BX = file handle, CX = number	of bytes to read
			; DS:DX	-> buffer
	pop	ds
	jnb	short loc_2A3A5
	mov	ah, 9
	jmp	short loc_2A3EC
loc_2A3A5:
	test	byte_4EFFC[bx],	80h
	jz	short loc_2A3EC
	and	byte_4EFFC[bx],	0FBh
	push	si
	push	di
	push	ds
	pop	es
	assume es:dseg
	mov	ds, word ptr [bp+arg_4+2]
	cld
	mov	si, dx
	mov	di, dx
	mov	cx, ax
	jcxz	short loc_2A3E8
	mov	ah, 0Dh
	cmp	byte ptr [si], 0Ah
	jnz	short loc_2A3CE
	or	es:byte_4EFFC[bx], 4
loc_2A3CE:
	lodsb
	cmp	al, ah
	jz	short loc_2A3EF
	cmp	al, 1Ah
	jnz	short loc_2A3DF
	or	es:byte_4EFFC[bx],	2
	jmp	short loc_2A3E4
loc_2A3DF:
	mov	[di], al
	inc	di
loc_2A3E2:
	loop	loc_2A3CE
loc_2A3E4:
	mov	ax, di
	sub	ax, dx
loc_2A3E8:
	push	es
	pop	ds
loc_2A3EA:
	pop	di
	pop	si
loc_2A3EC:
	jmp	loc_28805
loc_2A3EF:
	cmp	cx, 1
	jz	short loc_2A3FB
	cmp	byte ptr [si], 0Ah
	jz	short loc_2A3E2
	jmp	short loc_2A3DF
loc_2A3FB:
	push	es
	pop	ds
	test	byte_4EFFC[bx],	40h
	jz	short loc_2A41C
	mov	ax, 4400h
	int	21h		; DOS -	2+ - IOCTL - GET DEVICE	INFORMATION
			; BX = file or device handle
	test	dx, 20h
	jnz	short loc_2A418
	lea	dx, [bp-1]
	mov	ah, 3Fh
	int	21h		; DOS -	2+ - CALL(read) FROM FILE WITH HANDLE
			; BX = file handle, CX = number	of bytes to read
			; DS:DX	-> buffer
	jb	short loc_2A3EA
loc_2A418:
	mov	al, 0Ah
	jmp	short loc_2A448
loc_2A41C:
	mov	byte ptr [bp+var_1], 0
	lea	dx, [bp+var_1]
	mov	ah, 3Fh
	int	21h		; DOS -	2+ - CALL(read) FROM FILE WITH HANDLE
			; BX = file handle, CX = number	of bytes to read
			; DS:DX	-> buffer
	jb	short loc_2A3EA
	or	ax, ax
	jz	short loc_2A446
	cmp	[bp+arg_8], 1
	jz	short loc_2A452
loc_2A433:
	mov	cx, 0FFFFh
	mov	dx, cx
	mov	ax, 4201h
	int	21h		; DOS -	2+ - MOVE FILE CALL(read)/CALL(write) POINTER (LSEEK)
			; AL = method: offset from present location
	mov	cx, 1
	cmp	byte ptr [bp+var_1], 0Ah
	jz	short loc_2A44D
loc_2A446:
	mov	al, 0Dh
loc_2A448:
	lds	dx, [bp+arg_4]
	jmp	short loc_2A3DF
loc_2A44D:
	lds	dx, [bp+arg_4]
	jmp	short loc_2A3E2
loc_2A452:
	cmp	byte ptr [bp+var_1], 0Ah
	jnz	short loc_2A433
	jmp	short loc_2A418
sub_2A370 endp

; Attributes: bp-based frame

sub_2A45A proc far

	var_8= word ptr	-8
	var_6= word ptr	-6
	var_4= word ptr	-4
	var_2= word ptr	-2
	arg_2= word ptr	 6
	arg_4= word ptr	 0Ah
	arg_6= word ptr	 0Ch

; FUNCTION CHUNK AT 313A SIZE 00000039 BYTES
	push	bp
	mov	bp, sp
	sub	sp, 8
	mov	bx, [bp+arg_2]
	cmp	bx, word_4EFFA
	jb	short loc_2A470
	mov	ax, 900h
	stc
loc_2A46D:
	jmp	loc_28805
loc_2A470:
	test	byte_4EFFC[bx], 20h
	jz	short loc_2A482
	mov	ax, 4202h
	xor	cx, cx
	mov	dx, cx
	int	21h		; DOS -	2+ - MOVE FILE CALL(read)/CALL(write) POINTER (LSEEK)
			; AL = method: offset from end of file
	jb	short loc_2A46D
loc_2A482:
	test	byte_4EFFC[bx], 80h
	jz	short loc_2A505
	mov	[bp+var_6], ds
	mov	es, [bp+arg_4]
	assume es:nothing
	lds	dx, [bp+8]
	xor	ax, ax
	mov	[bp+var_2], ax
	mov	[bp+var_4], ax
	cld
	push	di
	push	si
	mov	di, dx
	mov	si, dx
	mov	[bp+var_8], sp
	mov	cx, [bp+arg_6]
	jcxz	short loc_2A507
	mov	al, 0Ah
	repne scasb
	jnz	short loc_2A500
	push	ds
	mov	ds, [bp+var_6]
	call	sub_2A5A4
	pop	ds
	cmp	ax, 0A8h 
	jbe	short loc_2A509
	sub	sp, 2
	mov	bx, sp
	mov	dx, 200h
	cmp	ax, 228h
	jnb	short loc_2A4CE
	mov	dx, 80h
loc_2A4CE:
	sub	sp, dx
	mov	dx, sp
	mov	di, dx
	push	ss
	pop	es
	assume es:dseg
	mov	cx, [bp+arg_6]
loc_2A4D9:
	lodsb
	cmp	al, 0Ah
	jz	short loc_2A4EA
loc_2A4DE:
	cmp	di, bx
	jz	short loc_2A4FB
loc_2A4E2:
	stosb
	loop	loc_2A4D9
	call	near ptr sub_2A50E
	jmp	short loc_2A559
loc_2A4EA:
	mov	al, 0Dh
	cmp	di, bx
	jnz	short loc_2A4F3
	call	near ptr sub_2A50E
loc_2A4F3:
	stosb
	mov	al, 0Ah
	inc	[bp+var_4]
	jmp	short loc_2A4DE
loc_2A4FB:
	call	near ptr sub_2A50E
	jmp	short loc_2A4E2
loc_2A500:
	pop	si
	pop	di
	mov	ds, [bp+var_6]
loc_2A505:
	jmp	short loc_2A56A
loc_2A507:
	jmp	short loc_2A559
loc_2A509:
	xor	ax, ax
	jmp	loc_2834B
sub_2A45A endp


sub_2A50E proc far
	push	ax
	push	bx
	push	cx
	push	ds
	push	es
	pop	ds
	mov	cx, di
	sub	cx, dx
	jcxz	short loc_2A52A
	mov	bx, [bp+6]
	mov	ah, 40h
	int	21h		; DOS -	2+ - CALL(write) TO FILE WITH	HANDLE
			; BX = file handle, CX = number	of bytes to write, DS:DX -> buffer
	jb	short loc_2A531
	add	[bp-2],	ax
	or	ax, ax
	jz	short loc_2A531
loc_2A52A:
	pop	ds
	pop	cx
	pop	bx
	pop	ax
	mov	di, dx
	retn
loc_2A531:
	pop	ds
	add	sp, 8
	jnb	short loc_2A53B
	mov	ah, 9
	jmp	short loc_2A55F
loc_2A53B:
	mov	ds, word ptr [bp-2]
	test	byte_4EFFC[bx], 40h
	jz	short loc_2A553
	mov	ds, word ptr [bp+0Ah]
	mov	bx, [bp+8]
	cmp	byte ptr [bx], 1Ah
	jnz	short loc_2A553
	clc
	jmp	short loc_2A55F
loc_2A553:
	stc
	mov	ax, 1C00h
	jmp	short loc_2A55F
loc_2A559::
	mov	ax, [bp-2]
	sub	ax, [bp-4]
loc_2A55F:
	mov	sp, [bp-8]
	pop	si
	pop	di
	mov	ds, word ptr [bp-6]
loc_2A567::
	jmp	loc_28805
sub_2A50E endp

; START	OF FUNCTION CHUNK FOR sub_2A45A
loc_2A56A:
	mov	cx, [bp+arg_6]
	or	cx, cx
	jnz	short loc_2A576
	mov	ax, cx
	jmp	loc_28805
loc_2A576:
	push	ds
	lds	dx, [bp+8]
	mov	ah, 40h
	int	21h		; DOS -	2+ - CALL(write) TO FILE WITH	HANDLE
			; BX = file handle, CX = number	of bytes to write, DS:DX -> buffer
	push	ds
	pop	es
	pop	ds
	jnb	short loc_2A587
	mov	ah, 9
	jmp	short loc_2A567
loc_2A587:
	or	ax, ax
	jnz	short loc_2A567
	test	byte_4EFFC[bx], 40h
	jz	short loc_2A59D
	mov	bx, dx
	cmp	byte ptr es:[bx], 1Ah
	jnz	short loc_2A59D
	clc
	jmp	short loc_2A567
loc_2A59D:
	stc
	mov	ax, 1C00h
	jmp	short loc_2A567
; END OF FUNCTION CHUNK	FOR sub_2A45A
align 2

sub_2A5A4 proc far
	pop	cx
	pop	dx
	mov	ax, word_4F030
	cmp	ax, sp
	jnb	short loc_2A5B4
	sub	ax, sp
	neg	ax
loc_2A5B1:
	push	dx
	push	cx
	retf
loc_2A5B4:
	xor	ax, ax
	jmp	short loc_2A5B1
sub_2A5A4 endp

	push	bp
	mov	bp, sp
	mov	bx, [bp+6]
	or	bx, bx
	jz	short loc_2A5C6
	or	byte ptr [bx-2], 1
loc_2A5C6:
	mov	sp, bp
	pop	bp
	retf
; Attributes: bp-based frame

sub_2A5CA proc far

	arg_0= word ptr	 6

	push	bp
	mov	bp, sp
	push	si
	push	di
	mov	bx, offset word_4F7CE
	cmp	word ptr [bx], 0
	jnz	short loc_2A600
	push	ds
	pop	es
	mov	ax, 5
	call	sub_2A82C
	jnz	short loc_2A5E6
	xor	ax, ax
	cwd
	jmp	short loc_2A60A
loc_2A5E6:
	inc	ax
	and	al, 0FEh
	mov	word_4F7CE, ax
	mov	word_4F7D0, ax
	xchg	ax, si
	mov	word ptr [si], 1
	add	si, 4
	mov	word ptr [si-2], 0FFFEh
	mov	word_4F7D4, si
loc_2A600:
	mov	cx, [bp+arg_0]
	mov	ax, ds
	mov	es, ax
	call	sub_2A6ED
loc_2A60A:
	pop	di
	pop	si
	mov	sp, bp
	pop	bp
	retf
sub_2A5CA endp

; Attributes: bp-based frame
_freeMaybe proc	far

	arg_0= dword ptr  6

	push	bp
	mov	bp, sp
	les	bx, [bp+arg_0]
	assume es:nothing
	mov	ax, es
	or	ax, bx
	jz	short loc_2A621
	or	byte ptr es:[bx-2], 1
loc_2A621:
	mov	sp, bp
	pop	bp
	retf
_freeMaybe endp

; Attributes: bp-based frame

_mallocMaybe proc far

	arg_0= word ptr	 6

	push	bp
	mov	bp, sp
	sub	sp, 2
	push	si
	push	di
	mov	ax, [bp+arg_0]
	cmp	ax, 0FFF1h
	jnb	short loc_2A653
	cmp	word_4F7D8, 0
	jnz	short loc_2A644
	call	sub_2A664
	jz	short loc_2A653
	mov	word_4F7D8, ax
loc_2A644:
	call	sub_2A6D2
	jnz	short loc_2A65E
	call	sub_2A664
	jz	short loc_2A653
	call	sub_2A6D2
	jnz	short loc_2A65E
loc_2A653:
	push	[bp+arg_0]
	call	sub_2A5CA
	add	sp, 2
loc_2A65E:
	pop	di
	pop	si
	mov	sp, bp
	pop	bp
	retf
_mallocMaybe endp

sub_2A664 proc near
	mov	bx, 0F0h 
	cmp	[bp+6],	bx
	jbe	short loc_2A673
	mov	bx, [bp+6]
	inc	bx
	and	bx, 0FFFEh
loc_2A673:
	mov	[bp-2],	bx
	xor	ax, ax
	push	ds
	push	ax
	push	ax
	lea	cx, [bx+0Eh]
	push	cx
	mov	al, 2
	push	ax
	call	sub_2A84E
	add	sp, 8
	cmp	dx, 0FFFFh
	jz	short loc_2A6D0
	mov	ax, dx
	xchg	dx, word_4F7DA
	mov	word_4F7DC, ax
	cmp	ax, word_4F7E0
	jbe	short loc_2A6A1
	mov	word_4F7E0, ax
loc_2A6A1:
	or	dx, dx
	jz	short loc_2A6AA
	mov	ds, dx
	assume ds:nothing
	mov	ds:8,	ax
loc_2A6AA:
	mov	bx, [bp-2]
	mov	ds, ax
	assume ds:nothing
	xor	ax, ax
	mov	ds:8,	ax
	dec	ax
	dec	ax
	mov	[bx+0Ch], ax
	mov	ax, 0Ah
	mov	ds:0, ax
	mov	ds:2, ax
	lea	ax, [bx+1]
	mov	ds:0Ah, ax
	add	ax, 0Dh
	mov	ds:6, ax
	mov	ax, ds
loc_2A6D0:
	pop	ds
	retn
sub_2A664 endp

sub_2A6D2 proc near
	mov	ax, ds
	mov	es, ax
	assume es:dseg
	mov	cx, [bp+6]
	xor	bx, bx
	mov	ds, word_4F7DC
	call	sub_2A6ED
	or	dx, dx
	mov	cx, es
	mov	ds, cx
	retn
sub_2A6D2 endp

align 2
; START	OF FUNCTION CHUNK FOR sub_2A6ED
loc_2A6EA:
	jmp	loc_2A7BB
; END OF FUNCTION CHUNK	FOR sub_2A6ED
sub_2A6ED proc near
; FUNCTION CHUNK AT 32BA SIZE 00000003 BYTES
	inc	cx
	jz	short loc_2A6EA
	and	cl, 0FEh
	cmp	cx, 0FFEEh
	jnb	short loc_2A6EA
	mov	si, [bx+2]
	cld
	lodsw
	mov	di, si
	test	al, 1
	jz	short loc_2A745
loc_2A703:
	dec	ax
	cmp	ax, cx
	jnb	short loc_2A71D
	mov	dx, ax
	add	si, ax
	lodsw
	test	al, 1
	jz	short loc_2A745
	add	ax, dx
	add	ax, 2
	mov	si, di
	mov	[si-2],	ax
	jmp	short loc_2A703
loc_2A71D:
	mov	di, si
	jz	short loc_2A72D
	add	di, cx
	mov	[si-2],	cx
	sub	ax, cx
	dec	ax
	mov	[di], ax
	jmp	short loc_2A732
loc_2A72D:
	add	di, cx
	dec	byte ptr [si-2]
loc_2A732:
	mov	ax, si
	mov	dx, ds
	mov	cx, ss
	cmp	dx, cx
	jz	short loc_2A741
	mov	es:word_4F7DC, ds
loc_2A741:
	mov	[bx+2],	di
	retn
loc_2A745:
	mov	es:byte_4F7E2, 2
loc_2A74B:
	cmp	ax, 0FFFEh
	jz	short loc_2A775
	mov	di, si
	add	si, ax
loc_2A754:
	lodsw
	test	al, 1
	jz	short loc_2A74B
	mov	di, si
loc_2A75B:
	dec	ax
	cmp	ax, cx
	jnb	short loc_2A71D
	mov	dx, ax
	add	si, ax
	lodsw
	test	al, 1
	jz	short loc_2A74B
	add	ax, dx
	add	ax, 2
	mov	si, di
	mov	[si-2],	ax
	jmp	short loc_2A75B
loc_2A775:
	mov	ax, [bx+8]
	or	ax, ax
	jz	short loc_2A780
	mov	ds, ax
	jmp	short loc_2A794
loc_2A780:
	dec	es:byte_4F7E2
	jz	short loc_2A798
	mov	ax, ds
	mov	di, ss
	cmp	ax, di
	jz	short loc_2A794
	mov	ds, es:word_4F7D8
loc_2A794:
	mov	si, [bx]
	jmp	short loc_2A754
loc_2A798:
	mov	si, [bx+6]
	xor	ax, ax
	call	sub_2A80A
	cmp	ax, si
	jz	short loc_2A7B1
	and	al, 1
	inc	ax
	inc	ax
	cbw
	call	sub_2A80A
	jz	short loc_2A7BB
	dec	byte ptr [di-2]
loc_2A7B1:
	call	sub_2A7D0
	jz	short loc_2A7BB
	xchg	ax, si
	dec	si
	dec	si
	jmp	short loc_2A754
loc_2A7BB::
	mov	ax, ds
	mov	cx, ss
	cmp	ax, cx
	jz	short loc_2A7C7
	mov	es:word_4F7DC, ax
loc_2A7C7:
	mov	ax, [bx]
	mov	[bx+2],	ax
	xor	ax, ax
	cwd
	retn
sub_2A6ED endp

sub_2A7D0 proc near
	push	cx
	mov	ax, [di-2]
	test	al, 1
	jz	short loc_2A7DB
	sub	cx, ax
	dec	cx
loc_2A7DB:
	inc	cx
	inc	cx
	mov	dx, 7FFFh
loc_2A7E0:
	cmp	dx, es:word_4F7DE
	jbe	short loc_2A7EB
	shr	dx, 1
	jnz	short loc_2A7E0
loc_2A7EB:
	mov	ax, cx
	add	ax, si
	jb	short loc_2A806
	add	ax, dx
	jb	short loc_2A802
	not	dx
	and	ax, dx
	sub	ax, si
	call	sub_2A80A
	jnz	short loc_2A808
	not	dx
loc_2A802:
	shr	dx, 1
	jnz	short loc_2A7EB
loc_2A806:
	xor	ax, ax
loc_2A808:
	pop	cx
	retn
sub_2A7D0 endp

sub_2A80A proc near
	push	dx
	push	cx
	call	sub_2A82C
	jz	short loc_2A829
	push	di
	mov	di, si
	mov	si, ax
	add	si, dx
	mov	word ptr [si-2], 0FFFEh
	mov	[bx+6],	si
	mov	dx, si
	sub	dx, di
	dec	dx
	mov	[di-2],	dx
	pop	ax
loc_2A829:
	pop	cx
	pop	dx
	retn
sub_2A80A endp

sub_2A82C proc near
	push	bx
	push	ax
	xor	dx, dx
	push	ds
	push	dx
	push	dx
	push	ax
	mov	ax, 1
	push	ax
	push	es
	pop	ds
	call	sub_2A84E
	add	sp, 8
	cmp	dx, 0FFFFh
	pop	ds
	pop	dx
	pop	bx
	jz	short locret_2A84C
	or	dx, dx
locret_2A84C:
	retn
sub_2A82C endp

align 2
; Attributes: bp-based frame

sub_2A84E proc far

	arg_0= word ptr	 6
	arg_2= word ptr	 8
	arg_4= word ptr	 0Ah
	arg_8= word ptr	 0Eh

	push	bp
	mov	bp, sp
	push	si
	push	di
	push	es
	cmp	[bp+arg_4], 0
	jnz	short loc_2A892
	mov	di, offset word_4EF82
	mov	dx, [bp+arg_2]
	mov	ax, [bp+arg_0]
	dec	ax
	jnz	short loc_2A86D
	call	sub_2A8BC
	jb	short loc_2A892
	jmp	short loc_2A8B5
loc_2A86D:
	mov	si, off_4EFD2
	dec	ax
	jz	short loc_2A885
	cmp	si, di
	jz	short loc_2A885
	mov	ax, [si+2]
	mov	[bp+arg_8], ax
	push	si
	call	sub_2A8BC
	pop	si
	jnb	short loc_2A8B5
loc_2A885:
	add	si, 4
	cmp	si, offset off_4EFD2
	jnb	short loc_2A892
	or	dx, dx
	jnz	short loc_2A898
loc_2A892:
	mov	ax, 0FFFFh
	cwd
	jmp	short loc_2A8B5
loc_2A898:
	mov	bx, dx
	add	bx, 0Fh
	rcr	bx, 1
	mov	cl, 3
	shr	bx, cl
	mov	ah, 48h
	int	21h		; DOS -	2+ - ALLOCATE MEMORY
			; BX = number of 16-byte paragraphs desired
	jb	short loc_2A892
	xchg	ax, dx
	mov	[si], ax
	mov	[si+2],	dx
	mov	off_4EFD2, si
	xor	ax, ax
loc_2A8B5:
	pop	es
	assume es:nothing
	pop	di
	pop	si
	mov	sp, bp
	pop	bp
	retf
sub_2A84E endp

sub_2A8BC proc near
	mov	cx, [bp+0Eh]
	mov	si, di
loc_2A8C1:
	cmp	[si+2],	cx
	jz	short loc_2A8D2
	add	si, 4
	cmp	si, off_4EFD2
	jnz	short loc_2A8C1
	stc
	jmp	short locret_2A911
loc_2A8D2:
	mov	bx, dx
	add	bx, [si]
	jb	short locret_2A911
	mov	dx, bx
	mov	es, cx
	cmp	si, di
	jnz	short loc_2A8E6
	cmp	word_4EF7C, bx
	jnb	short loc_2A90C
loc_2A8E6:
	add	bx, 0Fh
	rcr	bx, 1
	shr	bx, 1
	shr	bx, 1
	shr	bx, 1
	cmp	si, di
	jnz	short loc_2A8FE
	add	bx, cx
	mov	ax, word_4EFF3
	sub	bx, ax
	mov	es, ax
loc_2A8FE:
	mov	ah, 4Ah
	int	21h		; DOS -	2+ - ADJUST MEMORY BLOCK SIZE (SETBLOCK)
			; ES = segment address of block	to change
			; BX = new size	in paragraphs
	jb	short locret_2A911
	cmp	si, di
	jnz	short loc_2A90C
	mov	word_4EF7C, dx
loc_2A90C:
	xchg	ax, dx
	xchg	ax, [si]
	mov	dx, cx
locret_2A911:
	retn
sub_2A8BC endp

; Attributes: bp-based frame

_strcpy proc far

	destString= dword ptr  6
	srcString= dword ptr  0Ah

	push	bp
	mov	bp, sp
	mov	dx, di
	mov	bx, si
	push	ds
	lds	si, [bp+srcString]
	mov	di, si
	mov	ax, ds
	mov	es, ax
	assume es:dseg

	xor	ax, ax
	mov	cx, 0FFFFh
	repne scasb			; scan srcString for '\0' 
	not	cx			; cx has the index of '\0'
	les	di, [bp+destString]
	assume es:nothing
	mov	ax, di
	test	al, 1
	jz	short loc_2A937
	movsb
	dec	cx
loc_2A937:
	shr	cx, 1
	rep movsw
	adc	cx, cx
	rep movsb
	mov	si, bx
	mov	di, dx
	pop	ds
	mov	dx, es
	pop	bp
	retf
_strcpy endp

; Attributes: bp-based frame

strcmp	proc far

	arg_0= dword ptr  6
	arg_4= dword ptr  0Ah

	push	bp
	mov	bp, sp
	mov	dx, di
	mov	bx, si
	push	ds
	lds	si, [bp+arg_0]
	les	di, [bp+arg_4]
	xor	ax, ax
	mov	cx, 0FFFFh
	repne scasb
	not	cx
	sub	di, cx
	repe cmpsb
	jz	short loc_2A96A
	sbb	ax, ax
	sbb	ax, 0FFFFh
loc_2A96A:
	pop	ds
	mov	si, bx
	mov	di, dx
	pop	bp
	retf
strcmp	endp

align 2
; Attributes: bp-based frame

_strlen	proc far

	arg_0= dword ptr  6

	push	bp
	mov	bp, sp
	mov	dx, di
	les	di, [bp+arg_0]
	xor	ax, ax
	mov	cx, 0FFFFh
	repne scasb
	not	cx
	dec	cx
	xchg	ax, cx
	mov	di, dx
	pop	bp
	retf
_strlen	endp

align 2
; Attributes: bp-based frame
; Attributes: bp-based frame

toUpper	proc far
arg_0= word ptr	 6
	push	bp
	mov	bp, sp
	mov	bx, [bp+arg_0]
	test	sscanf_charFlags[bx],	2
	jz	short loc_2A9A8
	mov	ax, bx
	sub	ax, 20h	
	jmp	short loc_2A9AA
loc_2A9A8:
	mov	ax, bx
loc_2A9AA:
	pop	bp
	retf
toUpper	endp

; Attributes: bp-based frame

sub_2A9AC proc far
arg_0= word ptr	 6
	push	bp
	mov	bp, sp
	mov	bx, [bp+arg_0]
	cmp	bx, word_4EFFA
	jge	short loc_2A9C9
	cmp	bx, 0
	jl	short loc_2A9C9
	test	byte_4EFFC[bx],	40h
	jz	short loc_2A9C9
	mov	ax, 1
	jmp	short loc_2A9CB
loc_2A9C9:
	xor	ax, ax
loc_2A9CB:
	mov	sp, bp
	pop	bp
	retf
sub_2A9AC endp

align 2
	mov	dh, 1
	jmp	short loc_2A9D6

sub_2A9D4 proc far
	mov	dh, 8
loc_2A9D6::
	mov	ax, word_4F900
	or	ah, ah
	jnz	short loc_2A9E5
	mov	word_4F900, 0FFFFh
	jmp	short locret_2A9EA
loc_2A9E5:
	xchg	ax, dx
	int	21h		; DOS -
	mov	ah, 0
locret_2A9EA:
	retf
sub_2A9D4 endp

align 2
; Attributes: bp-based frame

sscanf proc far
var_14=	word ptr -14h
var_8= dword ptr -8
var_4= word ptr	-4
var_2= word ptr	-2
arg_0= word ptr	 6
arg_2= word ptr	 8
arg_4= word ptr	 0Ah
arg_6= word ptr	 0Ch
arg_8= word ptr	 0Eh
	push	bp
	mov	bp, sp
	sub	sp, 14h
	lea	ax, [bp+var_14]
	mov	word ptr [bp+var_8], ax
	mov	word ptr [bp+var_8+2], ss
	lea	ax, [bp+arg_8]
	mov	[bp+var_4], ax
	mov	[bp+var_2], ss
	les	bx, [bp+var_8]
	mov	byte ptr es:[bx+0Ah], 49h 
	mov	ax, [bp+arg_0]
	mov	dx, [bp+arg_2]
	mov	es:[bx+6], ax
	mov	es:[bx+8], dx
	mov	es:[bx], ax
	mov	es:[bx+2], dx
	push	dx
	push	ax
	call	_strlen
	add	sp, 4
	les	bx, [bp+var_8]
	mov	es:[bx+4], ax
	push	[bp+var_2]
	push	[bp+var_4]
	push	[bp+arg_6]
	push	[bp+arg_4]
	push	es
	push	bx
	call	_sscanf
	mov	sp, bp
	pop	bp
	retf
sscanf endp

align 2
; Attributes: bp-based frame

memcpy	proc far
arg_0= dword ptr  6
arg_4= dword ptr  0Ah
arg_8= word ptr	 0Eh
	push	bp
	mov	bp, sp
	mov	cx, [bp+arg_8]
	jcxz	short loc_2AAA0
	push	ds
	push	di
	push	si
	lds	si, [bp+arg_4]
	les	di, [bp+arg_0]
loc_2AA5B:
	mov	ax, cx
	dec	ax
	mov	dx, di
	not	dx
	sub	ax, dx
	sbb	bx, bx
	and	ax, bx
	add	ax, dx
	mov	dx, si
	not	dx
	sub	ax, dx
	sbb	bx, bx
	and	ax, bx
	add	ax, dx
	inc	ax
	xchg	ax, cx
	sub	ax, cx
	shr	cx, 1
	rep movsw
	adc	cx, cx
	rep movsb
	xchg	ax, cx
	jcxz	short loc_2AA9D
	or	si, si
	jnz	short loc_2AA90
	mov	ax, ds
	add	ax, 1000h
	mov	ds, ax
	assume ds:nothing
loc_2AA90:
	or	di, di
	jnz	short loc_2AA5B
	mov	ax, es
	add	ax, 1000h
	mov	es, ax
	assume es:nothing
	jmp	short loc_2AA5B
loc_2AA9D:
	pop	si
	pop	di
	pop	ds
	assume ds:dseg
loc_2AAA0:
	mov	ax, word ptr [bp+arg_0]
	mov	dx, word ptr [bp+arg_0+2]
	pop	bp
	retf
memcpy	endp

; Attributes: bp-based frame

memset	proc far
_ptr= dword ptr	 6
_c= word ptr  0Ah
_size= word ptr	 0Ch
	push	bp
	mov	bp, sp
	mov	cx, [bp+_size]
	jcxz	short loc_2AAE8
	push	di
	les	di, [bp+_ptr]
	assume es:nothing
	mov	dx, di
	neg	dx
	jz	short loc_2AAC6
	sub	dx, cx
	sbb	bx, bx
	and	dx, bx
	add	dx, cx
	xchg	dx, cx
	sub	dx, cx
loc_2AAC6:
	mov	ax, [bp+_c]
	mov	ah, al
	shr	cx, 1
	rep stosw
	adc	cx, cx
	rep stosb
	xchg	dx, cx
	jcxz	short loc_2AAE7
	mov	bx, es
	add	bx, 1000h
	mov	es, bx
	assume es:nothing
	shr	cx, 1
	rep stosw
	adc	cx, cx
	rep stosb
loc_2AAE7:
	pop	di
loc_2AAE8:
	mov	ax, word ptr [bp+_ptr]
	mov	dx, word ptr [bp+_ptr+2]
	pop	bp
	retf
memset	endp

; START	OF FUNCTION CHUNK FOR sub_2A98A

sub_2A98A proc far
arg_2= word ptr	 6
arg_4= word ptr	 8
arg_6= dword ptr  0Ah
arg_A= word ptr	 0Eh
; FUNCTION CHUNK AT 36C0 SIZE 00000063 BYTES
	push	bp
	mov	bp, sp
	push	si
	push	di
	mov	bl, 0
	jmp	loc_2AAF0
loc_2AAF0:
	mov	cx, [bp+arg_A]
	mov	ax, [bp+arg_2]
	mov	dx, [bp+arg_4]
	push	ds
	lds	di, [bp+arg_6]
	push	di
	push	ds
	pop	es
	assume es:dseg
	cld
	xchg	ax, bx
	or	al, al
	jz	short loc_2AB19
	cmp	cx, 0Ah
	jnz	short loc_2AB19
	or	dx, dx
	jns	short loc_2AB19
	mov	al, 2Dh	
	stosb
	neg	bx
	adc	dx, 0
	neg	dx
loc_2AB19:
	mov	si, di
loc_2AB1B:
	xchg	ax, dx
	xor	dx, dx
	or	ax, ax
	jz	short loc_2AB24
	div	cx
loc_2AB24:
	xchg	ax, bx
	div	cx
	xchg	ax, dx
	xchg	dx, bx
	add	al, 30h	
	cmp	al, 39h	
	jbe	short loc_2AB32
	add	al, 27h	
loc_2AB32:
	stosb
	mov	ax, dx
	or	ax, bx
	jnz	short loc_2AB1B
	mov	[di], al
loc_2AB3B:
	dec	di
	lodsb
	xchg	al, [di]
	mov	[si-1],	al
	lea	ax, [si+1]
	cmp	ax, di
	jb	short loc_2AB3B
	mov	dx, ds
	pop	ax
	pop	ds
	pop	di
	pop	si
	mov	sp, bp
	pop	bp
	retf
sub_2A98A endp

; END OF FUNCTION CHUNK	FOR sub_2A98A
align 2
; Attributes: bp-based frame

__32bitDivide proc far
arg_0= word ptr	 6
arg_2= word ptr	 8
arg_4= word ptr	 0Ah
arg_6= word ptr	 0Ch
	push	bp
	mov	bp, sp
	push	di
	push	si
	push	bx
	xor	di, di
	mov	ax, [bp+arg_2]
	or	ax, ax
	jge	short loc_2AB74
	inc	di
	mov	dx, [bp+arg_0]
	neg	ax
	neg	dx
	sbb	ax, 0
	mov	[bp+arg_2], ax
	mov	[bp+arg_0], dx
loc_2AB74:
	mov	ax, [bp+arg_6]
	or	ax, ax
	jge	short loc_2AB8C
	inc	di
	mov	dx, [bp+arg_4]
	neg	ax
	neg	dx
	sbb	ax, 0
	mov	[bp+arg_6], ax
	mov	[bp+arg_4], dx
loc_2AB8C:
	or	ax, ax
	jnz	short loc_2ABA5
	mov	cx, [bp+arg_4]
	mov	ax, [bp+arg_2]
	xor	dx, dx
	div	cx
	mov	bx, ax
	mov	ax, [bp+arg_0]
	div	cx
	mov	dx, bx
	jmp	short loc_2ABDD
loc_2ABA5:
	mov	bx, ax
	mov	cx, [bp+arg_4]
	mov	dx, [bp+arg_2]
	mov	ax, [bp+arg_0]
loc_2ABB0:
	shr	bx, 1
	rcr	cx, 1
	shr	dx, 1
	rcr	ax, 1
	or	bx, bx
	jnz	short loc_2ABB0
	div	cx
	mov	si, ax
	mul	[bp+arg_6]
	xchg	ax, cx
	mov	ax, [bp+arg_4]
	mul	si
	add	dx, cx
	jb	short loc_2ABD9
	cmp	dx, [bp+arg_2]
	ja	short loc_2ABD9
	jb	short loc_2ABDA
	cmp	ax, [bp+arg_0]
	jbe	short loc_2ABDA
loc_2ABD9:
	dec	si
loc_2ABDA:
	xor	dx, dx
	xchg	ax, si
loc_2ABDD:
	dec	di
	jnz	short loc_2ABE7
	neg	dx
	neg	ax
	sbb	dx, 0
loc_2ABE7:
	pop	bx
	pop	si
	pop	di
	mov	sp, bp
	pop	bp
	retf	8
__32bitDivide endp

; This function	multiplies the characters level
; times	a 32 bit number. The first argument is the
; character level. The second is the high word of the
; level	converted to a 32 bit double. This is always
; going	to be zero. The	third and fourth are the lo
; and hi words of the multiplicant
; Attributes: bp-based frame

_level32bitMult	proc far
level= word ptr	 6
zero= word ptr	8
numLo= word ptr	 0Ah
numHi= word ptr	 0Ch
	push	bp
	mov	bp, sp
	mov	ax, [bp+zero]
	mov	bx, [bp+numHi]
	or	bx, ax
	mov	bx, [bp+numLo]
	jnz	short loc_2AC0B
	mov	ax, [bp+level]
	mul	bx
	mov	sp, bp
	pop	bp
locret_2AC08:
	retf	8
loc_2AC0B:
	mul	bx
	mov	cx, ax
	mov	ax, [bp+level]
	mul	[bp+numHi]
	add	cx, ax
	mov	ax, [bp+level]
	mul	bx
	add	dx, cx
	mov	sp, bp
	pop	bp
	retf	8
_level32bitMult	endp

; Attributes: bp-based frame

_32bitMod proc far
arg_0= word ptr	 6
arg_2= word ptr	 8
arg_4= word ptr	 0Ah
arg_6= word ptr	 0Ch
	push	bp
	mov	bp, sp
	push	bx
	push	di
	xor	di, di
	mov	ax, [bp+arg_2]
	or	ax, ax
	jge	short loc_2AC43
	inc	di
	mov	dx, [bp+arg_0]
	neg	ax
	neg	dx
	sbb	ax, 0
	mov	[bp+arg_2], ax
	mov	[bp+arg_0], dx
loc_2AC43:
	mov	ax, [bp+arg_6]
	or	ax, ax
	jge	short loc_2AC5A
	mov	dx, [bp+arg_4]
	neg	ax
	neg	dx
	sbb	ax, 0
	mov	[bp+arg_6], ax
	mov	[bp+arg_4], dx
loc_2AC5A:
	or	ax, ax
	jnz	short loc_2AC76
	mov	cx, [bp+arg_4]
	mov	ax, [bp+arg_2]
	xor	dx, dx
	div	cx
	mov	ax, [bp+arg_0]
	div	cx
	mov	ax, dx
	xor	dx, dx
	dec	di
	jns	short loc_2ACB7
	jmp	short loc_2ACBE
loc_2AC76:
	mov	bx, ax
	mov	cx, [bp+arg_4]
	mov	dx, [bp+arg_2]
	mov	ax, [bp+arg_0]
loc_2AC81:
	shr	bx, 1
	rcr	cx, 1
	shr	dx, 1
	rcr	ax, 1
	or	bx, bx
	jnz	short loc_2AC81
	div	cx
	mov	cx, ax
	mul	[bp+arg_6]
	xchg	ax, cx
	mul	[bp+arg_4]
	add	dx, cx
	jb	short loc_2ACA8
	cmp	dx, [bp+arg_2]
	ja	short loc_2ACA8
	jb	short loc_2ACAE
	cmp	ax, [bp+arg_0]
	jbe	short loc_2ACAE
loc_2ACA8:
	sub	ax, [bp+arg_4]
	sbb	dx, [bp+arg_6]
loc_2ACAE:
	sub	ax, [bp+arg_0]
	sbb	dx, [bp+arg_2]
	dec	di
	jns	short loc_2ACBE
loc_2ACB7:
	neg	dx
	neg	ax
	sbb	dx, 0
loc_2ACBE:
	pop	di
	pop	bx
	mov	sp, bp
	pop	bp
	retf	8
_32bitMod endp


sub_2ACC6 proc far
	xor	ch, ch
	jcxz	short locret_2ACD0
loc_2ACCA:
	shl	ax, 1
	rcl	dx, 1
	loop	loc_2ACCA
locret_2ACD0:
	retf
sub_2ACC6 endp

align 2
; Attributes: bp-based frame

_32bitDivide proc far
arg_0= word ptr	 6
arg_2= word ptr	 8
arg_4= word ptr	 0Ah
	push	bp
	mov	bp, sp
	mov	bx, [bp+arg_0]
	push	[bp+arg_4]
	push	[bp+arg_2]
	push	word ptr [bx+2]
	push	word ptr [bx]
	call	__32bitDivide
	mov	bx, [bp+arg_0]
	mov	[bx+2],	dx
	mov	[bx], ax
	mov	sp, bp
	pop	bp
	retf	6
_32bitDivide endp

; Attributes: bp-based frame

sub_2ACF6 proc far
arg_0= word ptr	 6
arg_2= word ptr	 8
	push	bp
	mov	bp, sp
	mov	bx, [bp+arg_0]
	mov	ax, [bx]
	mov	dx, [bx+2]
	mov	cx, [bp+arg_2]
	call	sub_2ACC6
	mov	bx, [bp+arg_0]
	mov	[bx], ax
	mov	[bx+2],	dx
	mov	sp, bp
	pop	bp
locret_2AD14:
	retf	4
sub_2ACF6 endp



seg019 ends

; Segment type: Regular
seg020 segment word public 'DATA' use16
        assume cs:seg020
;org 7
        assume es:nothing, ss:nothing, ds:dseg, fs:nothing, gs:nothing
algn_2AD17:
align 2

huf_dataSize		dd 0
huf_nodeListTail	dw 0
huf_fileHandle		dw 0
huf_fileBuffer		db 200h dup(0)
huf_fileBufferIndex	dw 0
huf_bitMask		db 0
huf_currentByte		db 0
huf_treeData		db 0F05h dup(0)
huf_bufferP		dw 0
huf_flateSize		dw 0
huf_flateByteCount	dw 0


seg020 ends

include seg021.asm
include seg022.asm
; Segment type:	Regular
seg023 segment para public 'DATA' use16
	assume cs:seg023
	assume es:nothing, ss:nothing, ds:dseg,	fs:nothing, gs:nothing

graphicsBuf db 4A38h dup(0) 

monsterBuf db 480h dup(0)	   ; 0
byte_3BA68 db 11C4h dup(0)	   ; 0
iconLight db 474h dup(0)	  ; 0
iconCompass db 820h dup(0)	    ; 0
iconAreaEnchant	db 550h	dup(0)		; 0
iconShield db 1E0h dup(0)	   ; 0
iconLevitation db 640h dup(0)	       ; 0

characterBitmasks db	0,	0,	0,	0,	0,	0,	0,	0	; 0  
		db	60h,	0F0h,	0F0h,	60h,	60h,	0,	60h,	0	; 1	!
		;	01100000
		;	11110000
		;	11110000
		;	01100000
		;	00000000
		;	01100000
		;	00000000
		db	0D8h,	0D8h,	0D8h,	0,	0,	0,	0,	0	; 2  
		db	6Ch,	6Ch,	0FEh,	6Ch,	0FEh,	6Ch,	6Ch,	0	; 3  
		db	30h,	7Ch,	0C0h,	78h,	0Ch,	0F8h,	30h,	0	; 4  
		db	0,	0C6h,	0CCh,	18h,	30h,	66h,	0C6h,	0	; 5  
		db	38h,	6Ch,	38h,	76h,	0DCh,	0CCh,	76h,	0	; 6  
		db	60h,	60h,	0C0h,	0,	0,	0,	0,	0	; 7  
		db	30h,	60h,	0C0h,	0C0h,	0C0h,	60h,	30h,	0	; 8  
		db	0C0h,	60h,	30h,	30h,	30h,	60h,	0C0h,	0	; 9  
		db	0,	0CCh,	78h,	0FCh,	78h,	0CCh,	0,	0	; 10 
		db	0,	30h,	30h,	0FCh,	30h,	30h,	0,	0	; 11 
		db	0,	0,	0,	0,	0,	60h,	60h,	0C0h	; 12 
		db	0,	0,	0,	0F8h,	0,	0,	0,	0	; 13 
		db	0,	0,	0,	0,	0,	60h,	60h,	0	; 14 
		db	0,	0Ch,	18h,	30h,	60h,	0C0h,	80h,	0	; 15 
		db	7Ch,	0C6h,	0CEh,	0DEh,	0F6h,	0E6h,	7Ch,	0	; 16 
		db	30h,	70h,	30h,	30h,	30h,	30h,	0FCh,	0	; 17 
		db	78h,	0CCh,	0Ch,	38h,	60h,	0CCh,	0FCh,	0	; 18 
		db	78h,	0CCh,	0Ch,	38h,	0Ch,	0CCh,	78h,	0	; 19 
		db	1Ch,	3Ch,	6Ch,	0CCh,	0FEh,	0Ch,	1Eh,	0	; 20 
		db	0FCh,	0C0h,	0F8h,	0Ch,	0Ch,	0CCh,	78h,	0	; 21 
		db	38h,	60h,	0C0h,	0F8h,	0CCh,	0CCh,	78h,	0	; 22 
		db	0FCh,	0CCh,	0Ch,	18h,	30h,	30h,	30h,	0	; 23 
		db	78h,	0CCh,	0CCh,	78h,	0CCh,	0CCh,	78h,	0	; 24 
		db	78h,	0CCh,	0CCh,	7Ch,	0Ch,	18h,	70h,	0	; 25 
		db	0,	0C0h,	0C0h,	0,	0,	0C0h,	0C0h,	0	; 26 
		db	0,	60h,	60h,	0,	0,	60h,	60h,	0C0h	; 27 
		db	18h,	30h,	60h,	0C0h,	60h,	30h,	18h,	0	; 28 
		db	0,	0,	0F8h,	0,	0,	0F8h,	0,	0	; 29 
		db	0C0h,	60h,	30h,	18h,	30h,	60h,	0C0h,	0	; 30 
		db	78h,	0CCh,	0Ch,	18h,	30h,	0,	30h,	0	; 31 
		db	7Ch,	0C6h,	0DEh,	0DEh,	0DEh,	0C0h,	78h,	0	; 32 
		db	30h,	78h,	0CCh,	0CCh,	0FCh,	0CCh,	0CCh,	0	; 33 
		db	0FCh,	66h,	66h,	7Ch,	66h,	66h,	0FCh,	0	; 34 
		db	3Ch,	66h,	0C0h,	0C0h,	0C0h,	66h,	3Ch,	0	; 35 
		db	0F8h,	6Ch,	66h,	66h,	66h,	6Ch,	0F8h,	0	; 36 
		db	0FEh,	62h,	68h,	78h,	68h,	62h,	0FEh,	0	; 37 
		db	0FEh,	62h,	68h,	78h,	68h,	60h,	0F0h,	0	; 38 
		db	3Ch,	66h,	0C0h,	0C0h,	0CEh,	66h,	3Eh,	0	; 39 
		db	0CCh,	0CCh,	0CCh,	0FCh,	0CCh,	0CCh,	0CCh,	0	; 40 
		db	78h,	30h,	30h,	30h,	30h,	30h,	78h,	0	; 41 
		db	1Eh,	0Ch,	0Ch,	0Ch,	0CCh,	0CCh,	78h,	0	; 42 
		db	0E6h,	66h,	6Ch,	78h,	6Ch,	66h,	0E6h,	0	; 43 
		db	0F0h,	60h,	60h,	60h,	62h,	66h,	0FEh,	0	; 44 
		db	0C6h,	0EEh,	0FEh,	0FEh,	0D6h,	0C6h,	0C6h,	0	; 45 
		db	0C6h,	0E6h,	0F6h,	0DEh,	0CEh,	0C6h,	0C6h,	0	; 46 
		db	38h,	6Ch,	0C6h,	0C6h,	0C6h,	6Ch,	38h,	0	; 47 
		db	0FCh,	66h,	66h,	7Ch,	60h,	60h,	0F0h,	0	; 48 
		db	78h,	0CCh,	0CCh,	0CCh,	0DCh,	78h,	1Ch,	0	; 49 
		db	0FCh,	66h,	66h,	7Ch,	6Ch,	66h,	0E6h,	0	; 50 
		db	78h,	0CCh,	0E0h,	70h,	1Ch,	0CCh,	78h,	0	; 51 
		db	0FCh,	0B4h,	30h,	30h,	30h,	30h,	78h,	0	; 52 
		db	0CCh,	0CCh,	0CCh,	0CCh,	0CCh,	0CCh,	0FCh,	0	; 53 
		db	0CCh,	0CCh,	0CCh,	0CCh,	0CCh,	78h,	30h,	0	; 54 
		db	0C6h,	0C6h,	0C6h,	0D6h,	0FEh,	0EEh,	0C6h,	0	; 55 
		db	0C6h,	0C6h,	6Ch,	38h,	38h,	6Ch,	0C6h,	0	; 56 
		db	0CCh,	0CCh,	0CCh,	78h,	30h,	30h,	78h,	0	; 57 
		db	0FEh,	0C6h,	8Ch,	18h,	32h,	66h,	0FEh,	0	; 58 
		db	0F0h,	0C0h,	0C0h,	0C0h,	0C0h,	0C0h,	0F0h,	0	; 59 
		db	0,	0C0h,	60h,	30h,	18h,	0Ch,	4,	0	; 60 
		db	0F0h,	30h,	30h,	30h,	30h,	30h,	0F0h,	0	; 61 
		db	10h,	38h,	6Ch,	0C6h,	0,	0,	0,	0	; 62 
		db	0,	0,	0,	0,	0,	0,	0,	0FFh	; 63 
		db	0C0h,	0C0h,	60h,	0,	0,	0,	0,	0	; 64 
		db	0,	0,	0F0h,	18h,	0F8h,	98h,	0E8h,	0	; 65 
		db	0C0h,	0C0h,	0C0h,	0F0h,	0D8h,	0D8h,	0F0h,	0	; 66 
		db	0,	0,	0F0h,	0D0h,	0C0h,	0D0h,	0F0h,	0	; 67 
		db	38h,	18h,	18h,	78h,	0D8h,	0D8h,	78h,	0	; 68 
		db	0,	0,	70h,	0D8h,	0F8h,	0C0h,	70h,	0	; 69 
		db	38h,	68h,	60h,	0F0h,	60h,	60h,	0F0h,	0	; 70 
		db	0,	0,	68h,	0D8h,	0D8h,	0F8h,	18h,	0F0h	; 71 
		db	0C0h,	0C0h,	0C0h,	0F0h,	0D8h,	0D8h,	0D8h,	0	; 72 
		db	0C0h,	0,	0C0h,	0C0h,	0C0h,	0C0h,	0C0h,	0	; 73 
		db	18h,	0,	18h,	18h,	18h,	0D8h,	0D8h,	0F0h	; 74 
		db	0C0h,	0C0h,	0C8h,	0D8h,	0F0h,	0D8h,	0C8h,	0	; 75 
		db	0E0h,	60h,	60h,	60h,	60h,	60h,	0F0h,	0	; 76 
		db	0,	0,	0CCh,	0FEh,	0FEh,	0D6h,	0C6h,	0	; 77 
		db	0,	0,	0F0h,	0D8h,	0D8h,	0D8h,	0D8h,	0	; 78 
		db	0,	0,	70h,	0D8h,	0D8h,	0D8h,	70h,	0	; 79 - o
		; 00000000
		; 00000000
		; 01110000
		; 11011000
		; 11011000
		; 11011000
		; 01110000
		db	0,	0,	70h,	0D8h,	0D8h,	0F0h,	0C0h,	0C0h	; 80 - p
		; 00000000
		; 00000000
		; 01110000
		; 11011000
		; 11011000
		; 11110000
		; 11000000
		; 11000000
		db	0,	0,	78h,	0D8h,	0D8h,	78h,	18h,	38h	; 81 
		db	0,	0,	70h,	0D8h,	0C0h,	0C0h,	0E0h,	0	; 82 
		db	0,	0,	78h,	0C0h,	70h,	18h,	0F0h,	0	; 83 
		db	20h,	60h,	0F8h,	60h,	60h,	68h,	30h,	0	; 84 
		db	0,	0,	0D8h,	0D8h,	0D8h,	0D8h,	0F8h,	0	; 85 
		db	0,	0,	0D8h,	0D8h,	0D8h,	70h,	20h,	0	; 86 
		db	0,	0,	88h,	0A8h,	0A8h,	0A8h,	0F8h,	0	; 87 
		db	0,	0,	88h,	0D8h,	70h,	0D8h,	88h,	0	; 88 
		db	0,	0,	0D8h,	0D8h,	0D8h,	0F8h,	18h,	0F0h	; 89 
		db	0,	0,	0F8h,	30h,	60h,	0C8h,	0F8h,	0	; 90 
		db	38h,	60h,	60h,	0C0h,	60h,	60h,	38h,	0	; 91 
		db	0C0h,	0C0h,	0C0h,	0,	0C0h,	0C0h,	0C0h,	0	; 92 
		db	0E0h,	30h,	30h,	18h,	30h,	30h,	0E0h,	0	; 93 
		db	76h,	0DCh,	0,	0,	0,	0,	0,	0	; 94 
		db	0FFh,	0FFh,	0FFh,	0FFh,	0FFh,	0FFh,	0FFh,	0FFh	; 95 
		; 11111111
		; 11111111
		; 11111111
		; 11111111
		; 11111111
		; 11111111
		; 11111111
		; 11111111
		db	7Eh,	42h,	42h,	42h,	42h,	42h,	42h,	7Eh	; 96 
		; 01111110
		; 01000010
		; 01000010
		; 01000010
		; 01000010
		; 01000010
		; 01000010
		; 01111110
		db	18h,	3Ch,	7Eh,	0FFh,	18h,	18h,	18h,	18h	; 97 
		db	18h,	18h,	18h,	18h,	0FFh,	7Eh,	3Ch,	18h	; 98 


minimap_squareToDraw db 8, 8, 8, 89h, 8, 8, 8, 8;	0
seg023 ends

include seg024.asm
include seg025.asm
include seg026.asm
include seg027.asm

; Segment type: Pure data
dseg segment para public 'DATA' use16
        assume cs:dseg

word_42670	dw 0
word_42672	dw 0
byte_42674	db 0
byte_42675	db 0
word_42676	dw 0
aMsRunTimeLibraryCopy db 'MS Run-Time Library - Copyright (c) 1988, Microsoft Corp'
		db  11h
byte_426B1	db 0
aComp		db 'comp',0
aRgb		db	'rgb',0
aEga		db	'ega',0
aTdy		db	'tdy',0
s_thiefCfg	db 'thief.cfg',0
s_firstTitle		db 'tit0',0
s_titleScreen		db 'title',0
s_musicAll	db 'music.all',0
s_stuckEllipsis	db 'Stuck....',0
graphicsDrivers	dd aComp, aRgb,	aEga, aTdy; 0
s_facing		db 'facing ',0
byte_42716	db 0, 2, 20h, 22h
aEarlyMorning_	db 'early morning.',0
aMidMorning_	db	'mid morning.',0
aNoon_		db 'noon.',0
aAfternoon_	db 'afternoon.',0
aDusk_		db 'dusk.',0
aEvening_	db 'evening.',0
aMidnight_	db 'midnight.',0
aAfterMidnight_	db 'after midnight.',0
aRefugeeCampOfS	db ' refugee camp of Skara Brae.',0
aCityGates_	db ' city gates.',0
aEntranceToTheC	db ' entrance to the city.',0
aGreatIceKeep_	db ' great ice keep.',0
aEntranceOfTheF	db ' entrance of the forest.',0
s_pausing	db 'pausing',0
		db    0
s_whoToDrop db 'Who will you drop?',0
		db    0
s_cantDropCharacter db 'You can',27h,'t drop a party member.',0
		db    0
s_youreIn db 'You',27h,'re in ',0
		db    0
s_spAndsp		db ' and ',0
		db    0
s_itsNow		db 0Ah,0Ah, 'It',27h,'s now ',0
timeOfDay	dd aEarlyMorning_, aMidMorning_, aNoon_, aAfternoon_,	aDusk_,	aEvening_, aMidnight_, aAfterMidnight_
s_ofAtThe	db ' /of\at\ the',0
		db    0
locationString	dd aRefugeeCampOfS, aCityGates_,	aEntranceToTheC, aGreatIceKeep_, aEntranceOfTheF; 0
byte_428A6	db 0Ch, 0Ah,	7, 0Fh,	6, 6, 7, 9; 0
		db 0Ah,	0Fh		; 8
byte_428B0	db 0Fh, 0, 6, 8, 0Ah, 9, 0, 8; 0
		db 5, 1			; 8
byte_428BA	db 0, 1, 2, 1, 3, 2,	1, 2; 0
		db 4, 1			; 8
byte_428C4	db 7, 7, 7, 7, 0, 0,	0, 1; 0
		db 1, 1, 1, 2, 2, 2, 3,	3; 8
		db 4, 4, 4, 5, 5, 5, 6,	6; 16
s_whoUsesItem db 'Who will use an item?',0
s_UseOn		db 'Use on ',0
s_powerless	db 'Powerless.',0
		db    0
s_confirmRestore db 'Do you wish to restore your last saved game?',0
		db    0
s_confirmSave db 'Do you wish to save your game?',0
		db    0
s_savingTheGame	db 'Saving the game.',0
		db    0
s_gameHasBeenSaved	db 'Your game has been saved to disk.',0Ah, 0Ah
			db 'Do you wish to exit to DOS?',0
s_helpMessage1	db 'HELP for those in need:',0Ah, 0Ah
			db '1-7 = Player info',0Ah
			db 'Arrows = Move, turn',0Ah
			db '? = Where are we',0Ah
			db 'N = New march order',0Ah
			db 'S = Save the game',0Ah
			db 'T = Time out',0Ah
			db 'V = Sound on/off',0Ah,0
s_helpMessage2	db 'More HELP:',0Ah, 0Ah
			db 'B = Play a Bard tune',0Ah
			db 'C = Cast a spell',0Ah
			db 'F1-F7 = Cast a spell',0Ah
			db 'E = Ascend portal',0Ah
			db 'W = Descend portal',0Ah
			db 'P = Party combat',0Ah
			db 'D = Drop special party member',0Ah
			db 'U = Use an item',0Ah,0
s_newOrder	db 'New Order:',0Ah,0Ah,0
		db    0
s_gtChar		db '>'
byte_42AF5	db 78h				; XXX - Doesn't seem to be used
		db 20h
		db 0
s_useThisOrder	db 0Ah,'Use this order?',0
s_gameSav	db 'game.sav',0
s_cantOpenGameSave	db 'Can',27h,'t open game save file',0
			db    0
g_soundActiveFlag	dw 1
s_confirmQuit	db 'Quit the game?',0
s_loseProgressConfirm	db 'You will lose your game status.',0Ah
		db 0Ah, 0Ah, 0Ah
		db '  Do you wish to quit?',0
align 2
aWarrior	db 'Warrior',0
aWizard		db 'Wizard',0
aSorcerer	db 'Sorcerer',0
aConjurer	db 'Conjurer',0
aMagician	db 'Magician',0
aRogue		db 'Rogue',0
aBard		db 'Bard',0
aPaladin	db 'Paladin',0
aHunter		db 'Hunter',0
aMonk		db 'Monk',0
aArchmage	db 'Archmage',0
aChronomancer	db 'Chronomancer',0
aGeomancer	db 'Geomancer',0
aMonster	db 'Monster',0
aIllusion	db 'Illusion',0
s_campMenuString	db 'Thou art in the Camp of Skara Brae.'
		db 0Ah
		db 0Ah
		db '@Add a member',0Ah
		db '@Remove a member',0Ah
		db '@Rename a member',0Ah
		db '@Create a member',0Ah
		db '@Transfer characters',0Ah
		db '@Delete a member',0Ah
		db '@Save the party',0Ah
		db '@Leave the game',0Ah
		db '@Enter wilderness',0
s_saveAndExit	db 'Press <RETURN> to save off all char'
		db 'acters and end game play. Or press '
		db 'ESC to go back.',0
s_genderOptions	db 'Do you wish your character to be',0Ah
		db 'Male or',0Ah
		db 'Female?',0
align 2
s_raceOptions	db 'Select a race for your new character:',0Ah,0Ah
		db '1) Human',0Ah
		db '2) Elf',0Ah
		db '3) Dwarf',0Ah
		db '4) Hobbit',0Ah
		db '5) Half-Elf',0Ah
		db '6) Half-Orc',0Ah
		db '7) Gnome',0
align 2
s_nameYourCharacter	db 'Name your new character --',0
align 2
s_whichPartyMemberToRemove	db 'Select which party member to remove or...',0
s_removeAll	db 'Remove them all!',0
align 2
s_askPartyName	db 'Name to save party under?',0
s_deleteWho	db 'Delete Who?',0
s_currentlyInParty	db ' is currently in the party. Remove from the party first.',0
align 2
s_confirmDelete	db 'Are you sure you want to delete ',0
align 2
s_noCharsOnDisk	db 'There are no characters on this disk.',0
s_whoJoins	db 'Who shall join?',0
s_alreadyInParty	db ' is already in the party.',0
s_nameAlreadyExists	db 'There is already a character with that name in the party.',0
align 2
s_rosterIsFull	db 'The roster is full.',0
s_noOneHereNamedThat	db 'There',27h,'s no one here named that!',0
s_renameWho	db 'Rename Who?',0
aYouCanTRenameA	db 'You can',27h,'t rename a party list!',0
align 2
s_whatIs		db 'What is ',0
align 2
s_newName	db 27h,'s new name?',0
align 2
; Class bigpic index. The pictures are in male, female pairs
g_classPictureNumber	db 33, 48
			db 54, 79
			db 54, 79
			db 54, 79
			db 54, 79
			db 33, 48
			db 33, 48
			db 33, 48
			db 33, 48
			db 33, 48
			db 54, 79
baseAttributes	startingAttrBase <10, 6,	8, 8, 5, 10, 6, 8, 8,	5>
		startingAttrBase <8, 9,	9, 6, 6, 8, 9, 9, 6, 6>
		startingAttrBase <12, 6, 7, 10,	3, 12, 6, 7, 10, 3>
		startingAttrBase <4, 6,	12, 5, 10, 4, 6, 12, 5, 10>
		startingAttrBase <9, 8,	9, 7, 6, 9, 8, 9, 7, 6>
		startingAttrBase <11, 3, 8, 11,	4, 11, 3, 8, 11, 4>
		startingAttrBase <9, 10, 7, 3, 4, 9, 10, 7, 3, 4>
startingClasses	startingClass_t	<1, 0, 0, 1, 1,	1, 1, 1, 1, 1>	; 0
		startingClass_t	<1, 0, 0, 1, 1,	1, 1, 1, 0, 1>	; 1
		startingClass_t	<1, 0, 0, 0, 0,	1, 1, 1, 1, 1>	; 2
		startingClass_t	2 dup(<1, 0, 0,	1, 1, 1, 1, 0, 0, 1>); 3
		startingClass_t	<1, 0, 0, 1, 1,	1, 0, 0, 1, 0>	; 5
		startingClass_t	<1, 0, 0, 1, 1,	1, 0, 0, 1, 1>	; 6
byte_4302E	db 6, 42, 42, 42, 42, 32, 0,	6, 6, 22, 2Ah
		db    0
startingInventory	db 1,	14h, 0FFh, 4, 76h, 0Ah,	1, 3, 0FFh, 1, 0Eh; 0
			db 0FFh, 1, 0Ah, 0FFh, 1, 11h, 0FFh, 1,	12h, 0FFh, 0FEh; 11
			db 1, 4, 0FFh, 1, 0Ch, 0FFh, 0,	7Dh, 0Ah, 0FEh,	1; 22
			db 4, 0FFh, 1, 0Ch, 0FFh, 1, 0Ah, 0FFh,	0FEh, 1, 10h; 33
			db 0FFh, 1, 9, 0FFh, 1,	2, 1, 0FEh; 44
g_classString	dd aWarrior		    ; 0
		dd aWizard		; 1
		dd aSorcerer		; 2
		dd aConjurer		; 3
		dd aMagician		; 4
		dd aRogue		; 5
		dd aBard		; 6
		dd aPaladin		; 7
		dd aHunter		; 8
		dd aMonk		; 9
		dd aArchmage		; 10
		dd aChronomancer	; 11
		dd aGeomancer		; 12
		dd aMonster		; 13
		dd aIllusion		; 14
s_ruinTitle	db 'The Ruin',0
g_campActionFunctions	dd camp_addMember
		dd camp_removeMember
		dd camp_renameMember
		dd camp_createMember
		dd transferCharacter
		dd camp_deleteMember
		dd camp_saveParty
		dd camp_saveAndExit
		dd camp_exit
s_thievesInf	db	'thieves.inf',0
s_partiesInf	db	'parties.inf',0

s_tavernGreeting	db 'Hail, travelers! Step to the bar and I',27h,'ll draw you a tankard.',0Ah
			db 'You can:',0Ah
			db 'Order a drink',0Ah
			db 'Talk to barkeep',0Ah
			db 'Exit the tavern',0
align 2

s_whoWillOrder		db 'Who will order a drink?',0

s_seatThyself		db 'Seat thyself,',0Ah,0
align 2

s_drinkOptions		db 'What',27h,'ll it be?',0Ah
			db 'Ale',0Ah
			db 'Beer',0Ah
			db 'Mead',0Ah
			db 'Foul spirits',0Ah
			db 'Ginger Ale',0
align 2

s_cantOrder		db 'Thou are in no condition to order anything.',0

s_partyIsDisgrace	db 'In fact, thy party is a disgrace..',0Ah
			db 'Bouncers!!!',0
align 2

s_hereOrToGo		db 'Will you have it...',0Ah
			db 'Here or',0Ah
			db 'To go?',0
align 2
s_burpNotBad		db '(Burp!) Not too bad.',0
align 2
s_goodStuff		db 'My goodness, that',27h,'s good stuff.',0
s_thirstQuencher	db 'Now that',27h,'s a real thirst quencher!',0
align 2

s_littleLightheaded	db 'But you feel a little light-headed.', 0
s_startHiccuping	db 'You start hiccuping',0
s_beginToSing		db 'You begin to sing 99 bottles of beer on the wall.',0
s_hardTimeOnBarstool	db 'You seem to have a hard time staying on the bar stool.',0
align 2
s_collapseOnFloor	db 'You collapse on the floor.',0
align 2

s_sorryBut		db 'Sorry but ',0
align 2
s_cantCarryAnyMore	db ' can',27h,'t carry any more items.',0
align 2
s_barkeepFillsWineskin	db 'The bartender fills a wineskin with your order and hands it to you.',0
s_whoTalksToBarkeep	db 'Who will talk to the barkeep?',0
s_noConditionToTalk	db 'You are in no condition to talk.',0
align 2
s_talkAintCheap		db '"Talk ain',27h,'t cheap,',0
align 2
s_beerBreath		db ' Beer Breath',0
align 2
s_barkeepSays		db '" the barkeep says.',0
s_howMuchWillTip	db 'How much will you tip him?',0
align 2
s_moneyTalks		db '"Money talks, friend," he says.',0
s_sayingStash		db '"There',27h,'s a building in Skara Brae where some of the survivors stashed their goods. It may be helpful," smiles the bartender',0
s_sayingHarmonicGems	db '"Be on the lookout for the magic gems, your spellcasters will need them."',0
s_sayingAnotherBar	db '"There lies another bar in Celaria Bree, seek it. It exists only in the dimension called Lucencia."',0
s_sayingReviewBoard	db '"Seek out the old man in the Review Board. He keeps watch over everything."',0
s_sayingBardsHall	db '"Go to the bard',27h,'s hall and listen to the songs they sing. They contain useful information."',0
s_sayingViolet		db '"There is said to be a key existing in the Violet Mountains, this will gain access to Cyanis',27h,'s Tower."', 0
align 2
s_sayingAck		db '"Ack! It',27h,'s not just a word, but a state of mind."',0
s_sayingFindLock		db '"The key to finding Sceadu is finding the lock."',0
align 2
s_sayingSceadu		db '"Sceadu can be found in the middle of Nowhere."',0
s_sayingWerra		db '"Seek Werra in Tarmitia."',0
s_notEnoughGold		db 'Not enough gold.',0
align 2

barkeepSayings		dd s_sayingStash	; 0
			dd s_sayingHarmonicGems	; 1
			dd s_sayingAnotherBar	; 2
			dd s_sayingReviewBoard	; 3
			dd s_sayingReviewBoard	; 4
			dd s_sayingAck		; 5
			dd s_sayingHarmonicGems	; 6
			dd s_sayingAnotherBar	; 7
			dd s_sayingBardsHall	; 8
			dd s_sayingViolet	; 9
			dd s_sayingHarmonicGems	; 10
			dd s_sayingReviewBoard	; 11
			dd s_sayingWerra	; 12
			dd s_sayingFindLock	; 13
			dd s_sayingSceadu	; 14
s_drinkOptionKeys	db 'ABMFG',0
g_drinkPriceList	db 3, 2, 4, 6, 1, 3	   ; 0
nullDrunkValue		dw 0
drunkString		dd nullDrunkValue	    ; 0
			dd nullDrunkValue	; 1
			dd nullDrunkValue	; 2
			dd nullDrunkValue	; 3
			dd s_littleLightheaded	; 4
			dd s_littleLightheaded	; 5
			dd s_startHiccuping	; 6
			dd s_startHiccuping	; 7
			dd s_beginToSing	; 8
			dd s_hardTimeOnBarstool	; 9
			dd s_hardTimeOnBarstool	; 10
			dd s_collapseOnFloor	; 11
			dd s_collapseOnFloor	; 12

tavern_drinkStrength	db 1, 2, 3, 4, 0, 0	  ; 0

s_scrapwood		db 'Scrapwood',0
s_staggerInn		db 'Stagger Inn',0
s_hicHaven		db 'Hic Haven',0
s_cheers		db 'Cheers',0
s_tavern		db 'Tavern',0

g_tavernData		tavernLoc_t <12, 17, 0, 0, 0>; 0
			tavernLoc_t <7,	12, 3, 2, 5>; 1
			tavernLoc_t <2,	3, 3, 4, 5>; 2
			tavernLoc_t <13, 7, 6, 6, 5>; 3
			tavernLoc_t <99, 99, 99, 8, 10>; 4
			db    0

tavernNames		dd s_scrapwood	    ; 0
			dd s_staggerInn		; 1
			dd s_hicHaven		; 2
			dd s_cheers		; 3
			dd s_tavern		; 4

g_tavernSayingCost	dw 0, 50, 250, 500, 1000 ; 0
			db    0


s_templeGreeting	db 'Welcome, oh weary ones, to our humble temple.',0Ah
			db 'Dost thou wish to...',0Ah
			db 'Heal a character',0Ah
			db 'Pool thy gold',0Ah
			db 'Exit temple',0
s_whomGathersGold	db 'Whom shall gather thy gold?',0
s_hathAllTheGold	db ' now hath all the gold.',0
s_whoNeedsHealing	db 'Who needeth healing?',0
			db    0
s_isInBadShape	db	' is in bad shape, indeed. ',0
			db    0
s_templeGoldForfeit	db ' in gold. Who will forfeit the gold?',0
			db    0
s_sorryButWithoutProper	db 'Sorry, but without proper sacrifice the prayer will fail.',0
s_layHands	db 'The priests lay hands on ',0
s_elipsis		db '...',0
s_elipsisAnd		db '...and ',0
s_isHealed		db ' is healed!',0
s_drainedOfLife	db ' hath been drained of life force. ',0
			db    0
s_thouMustSacrifice	db	'Thou must sacrifice ',0
			db    0
s_dontNeedHealing	db ' does not require any healing.',0
			db    0
s_hasWounds	db ' has wounds which need tending. ',0
			db    0
s_donationWillBe	db 'The donation will be ',0
temple_healPrice	dw 0, 400, 300, 900, 1120, 220, 500, 600, 900			; 8
aHe		db 'he',0
aShe		db 'she',0
aIt		db 'it',0
aHim		db 'him',0
aHer		db 'her',0
aHis		db 'his',0
aIts		db 'its',0
pronounString	dd aHe, aShe, aIt, aHim, aHer, aIt, aHis, aHer, aIts		; 7
s_shrine		db 'Shrine',0
s_forestLawn	db 'Forest Lawn',0
s_alliria	db 'Alliria',0
s_twilightTemple	db 'Twilight Tmp',0
templeLoc	templeLoc_t <8, 1, 0,	0>; 0
		templeLoc_t <10, 4, 3, 2>; 1
		templeLoc_t <2,	7, 6, 4>; 2
		templeLoc_t <255, 255, 255, 6>;	3
templeTitles	dd s_shrine, s_forestLawn, s_alliria,	s_twilightTemple; 0
templeStatusBitmasks	db 2, 1, 10h, 40h, 20h, 8, 4, 0; 0
templeHealPriceIndex	db 2, 1, 5, 7, 6, 4,	3, 0; 0
statusHealMask	db 0FFh,	0FEh, 0FDh, 3, 3, 0EFh,	0DFh, 0BFh, 0FFh, 0		; 8
fgtrXPReq	dd 2000, 4000, 7000, 10000, 15000, 20000; 0
		dd 30000, 50000, 80000,	110000,	150000,	200000;	6
wizdXPReq	dd 20000, 50000, 80000, 120000, 160000, 200000; 0
		dd 250000, 300000, 400000, 600000, 900000; 6
		dd 1300000		; 11
sorcXPReq	dd 7000, 15000, 25000, 40000,	60000, 80000; 0
		dd 100000, 130000, 170000, 220000, 300000; 6
		dd 400000		; 11
magiXPReq	dd 1800, 4000, 6000, 10000, 14000, 19000; 0
		dd 29000, 50000, 90000,	120000,	170000,	230000;	6
archXPReq	dd 70000, 140000, 240000, 340000, 540000; 0
		dd 740000, 1000000, 1400000, 1800000, 2200000; 5
		dd 2600000, 3000000	; 10
geomXPReq	dd 100000, 225000, 400000, 650000, 950000; 0
		dd 1400000, 1800000, 2200000, 2600000, 3000000;	5
		dd 3400000, 3800000	; 10
classXPReqs	dd fgtrXPReq, wizdXPReq, sorcXPReq,	magiXPReq; 0
		dd magiXPReq, fgtrXPReq, fgtrXPReq, fgtrXPReq; 4
		dd fgtrXPReq, magiXPReq, archXPReq, archXPReq; 8
		dd geomXPReq		; 12
s_emptyBuilding	db 'You are in an empty building.',0
s_building	db 'Building',0
align 2
s_storageMenu	db 'The party is inside a storage building.',0Ah
		db 'Who wishes to inspect?',0Ah
		db 0Ah, 0Ah, 0Ah
		db 'ESC to exit building',0
align 2
s_would		db 'Would ',0
align 2
s_likeToPickup	db ' like to pickup...',0
align 2
s_buildingIsEmpty	db 'The building is empty.',0
align 2
aPickUp___	db 'Pick up...',0
align 2
s_allFull	db 'All full!',0
s_youPickUpItem	db 'You pick up the item.',0

a_inventoryStf	db 'inventor.stf',0
align 2
aWildwal_grp	db	'wildwal.grp',0
aSkara_grp	db 'skara.grp',0
aGdung_grp	db 'gdung.grp',0
aDisk1		db 'Disk 1',0
s_diskTwo		db 'Disk 2',0
aDisk3		db 'Disk 3',0
aMaps_lo	db 'maps.lo',0
aMaps_hi	db 'maps.hi',0
aMonsterl	db 'monsterl',0
aMonsterh	db 'monsterh',0
aLow_pic	db 'low.pic',0
aHi_pic		db 'hi.pic',0
align 2
s_insertDisk	db 'Please insert disk ',0
minimap_bitmaskOffsetList	db 0FFh, 0, 4, 8, 4, 0, 0, 4; 0
		db 0, 0, 4, 8, 4, 0, 0,	4; 8
s_statusAbbreviations	db 'Old PsndNutsPossParaDeadSton',0
			db    0
statusBitmaskList	db stat_old, stat_poisoned, stat_nuts, stat_possessed; 0
		db stat_paralyzed, stat_dead, stat_stoned, 0; 4
classAbbreviations	db 'WaWiSoCoMaRoBaPaHuMoArChGeMnIl',0
			db    0
word_43F12	dw 0
mouseBoxes	mouseBox_t < 0Fh,  0Ah,  6Ah,  7Ah>	; Bigpic Window
		mouseBox_t <   6, 0A8h,  66h, 132h>	; Text Window
		mouseBox_t < 90h,  0Ch, 0C7h, 132h>	; Roster Area
		db    0
		db    0
map_graphicsTable	dd aWildwal_grp, aSkara_grp; 0
		dd aSkara_grp, aGdung_grp; 2
		dd aGdung_grp, aGdung_grp; 4
byte_43F4A	db 8 dup(0)
disk1		dw offset aDisk1
dseg_0		dw seg dseg
disk2		dd s_diskTwo
disk3		dd aDisk3
mapFiles	dd aMaps_lo, aMaps_hi
monsterFiles	dd	aMonsterl, aMonsterh
levelPathTable	levelFile_t	<lev_monsterl, 0>; 0
		levelFile_t <lev_monsterl, 1>;	1
		levelFile_t <lev_monsterl, 2>;	2
		levelFile_t <lev_monsterl, 3>;	3
		levelFile_t <lev_monsterl, 4>;	4
		levelFile_t <lev_monsterh, 0>;	5
		levelFile_t <lev_monsterh, 1>;	6
		levelFile_t <lev_monsterh, 2>;	7
		levelFile_t <lev_monsterh, 3>;	8
		levelFile_t <lev_monsterh, 4>;	9
		levelFile_t <lev_monsterl, 5>;	10
		levelFile_t <lev_monsterl, 6>;	11
		levelFile_t <lev_monsterl, 7>;	12
		levelFile_t <lev_monsterl, 8>;	13
		levelFile_t <lev_monsterl, 9>;	14
		levelFile_t <lev_monsterl, 10>; 15
		levelFile_t <lev_monsterl, 11>; 16
		levelFile_t <lev_monsterl, 12>; 17
		levelFile_t <lev_monsterl, 13>; 18
		levelFile_t <lev_monsterl, 14>; 19
		levelFile_t <lev_monsterl, 15>; 20
		levelFile_t <lev_monsterl, 16>; 21
		levelFile_t <lev_monsterl, 17>; 22
		levelFile_t <lev_monsterl, 18>; 23
		levelFile_t <lev_monsterl, 19>; 24
		levelFile_t <lev_monsterl, 20>; 25
		levelFile_t <lev_monsterl, 21>; 26
		levelFile_t <lev_monsterl, 22>; 27
		levelFile_t <lev_monsterl, 23>; 28
		levelFile_t <lev_monsterl, 24>; 29
		levelFile_t <lev_monsterl, 25>; 30
		levelFile_t <lev_monsterl, 26>; 31
		levelFile_t <lev_monsterl, 27>; 32
		levelFile_t <lev_monsterl, 28>; 33
		levelFile_t <lev_monsterh, 5>;	34
		levelFile_t <lev_monsterh, 6>;	35
		levelFile_t <lev_monsterh, 7>;	36
		levelFile_t <lev_monsterh, 8>;	37
		levelFile_t <lev_monsterh, 9>;	38
		levelFile_t <lev_monsterh, 10>; 39
		levelFile_t <lev_monsterh, 11>; 40
		levelFile_t <lev_monsterh, 12>; 41
		levelFile_t <lev_monsterh, 13>; 42
		levelFile_t <lev_monsterh, 14>; 43
		levelFile_t <lev_monsterh, 15>; 44
		levelFile_t <lev_monsterh, 16>; 45
		levelFile_t <lev_monsterh, 17>; 46
		levelFile_t <lev_monsterh, 18>; 47
		levelFile_t <lev_monsterh, 19>; 48
		levelFile_t <lev_monsterh, 20>; 49
		levelFile_t <lev_monsterl, 29>; 50
		levelFile_t <lev_monsterl, 30>; 51
		levelFile_t <lev_monsterh, 21>; 52
		levelFile_t <lev_monsterh, 22>; 53
		levelFile_t <lev_monsterh, 23>; 54
		levelFile_t <lev_monsterh, 24>; 55
		levelFile_t <lev_monsterh, 25>; 56
		levelFile_t <lev_monsterh, 26>; 57
		levelFile_t <lev_monsterh, 27>; 58
		levelFile_t <lev_monsterh, 28>; 59
		levelFile_t <lev_monsterh, 29>; 60
		levelFile_t <lev_monsterh, 30>; 61
		levelFile_t <lev_monsterl, 31>; 62
		levelFile_t <lev_monsterl, 32>; 63
		levelFile_t <lev_monsterl, 33>; 64
		levelFile_t <lev_monsterl, 34>; 65
		levelFile_t <lev_monsterh, 31>; 66
		levelFile_t <lev_monsterh, 32>; 67
		levelFile_t <lev_monsterh, 33>; 68
		levelFile_t <lev_monsterh, 34>; 69
		levelFile_t <lev_monsterh, 35>; 70
lowPic		dd aLow_pic
		dd aHi_pic
bigpicIndex	db 0, 1, 2, 3	    ; 0
		db 4, 5, 6, 7		; 4
		db 8, 9, 10, 11		; 8
		db 12, 13, 14, 15	; 12
		db 16, 17, 18, 19	; 16
		db 20, 21, 255,	255	; 20
		db 22, 255, 23,	255	; 24
		db 255,	24, 25,	255	; 28
		db 26, 27, 255,	255	; 32
		db 255,	255, 28, 29	; 36
		db 255,	255, 255, 30	; 40
		db 255,	255, 31, 32	; 44
		db 33, 34, 35, 36	; 48
		db 37, 38, 39, 40	; 52
		db 41, 42, 43, 44	; 56
		db 255,	45, 255, 46	; 60
		db 255,	255, 255, 255	; 64
		db 255,	47, 48,	49	; 68
		db 255,	255, 50, 255	; 72
		db 255,	255, 51, 52	; 76
		db 255,	255, 255, 53	; 80
		db 255,	255, 255, 255	; 84
		db 255,	255, 255, 0	; 88
		db 255,	1, 255,	2	; 92
		db 255,	3, 4, 255	; 96
		db 255,	255, 5,	6	; 100
		db 255,	255, 255, 255	; 104
		db 255,	7, 8, 9		; 108
		db 255,	10, 255, 255	; 112
		db 11, 255, 255, 12	; 116
		db 13, 255, 14,	15	; 120
		db 16, 17, 18, 255	; 124
		db 19, 20, 21, 255	; 128
		db 22, 23, 255,	255	; 132
		db 24, 255, 255, 25	; 136
		db 26, 27, 28, 29	; 140
		db 255,	255, 255, 255	; 144
		db 30, 31, 32, 255	; 148
		db 33, 34, 35, 36	; 152
		db 37, 255, 255, 255	; 156
		db 38, 39, 255,	40	; 160
		db 41, 42, 43, 44	; 164
		db 45, 255, 46,	255	; 168
		db 47, 48, 255,	49	; 172
s_yesNo		db 'Yes',0Ah,'No',0
		db    0
word_440BC	dw 0
_str_Loalphabet	db ' ', 'a', 'b', 'c', 'd', 'e', 'f', 'g'; 0
		db 'h', 'i', 'k', 'l', 'm', 'n', 'o', 'p'; 8
		db 'r', 's', 't', 'u', 'v', 'w', 'y', '.'; 16
		db '"', 27h, ',', '!', 0Ah, 0; 24
_str_Hialphabet	db 'j', 'q', 'x', 'z', '0', '1', '2', '3'; 0
		db '4', '5', '6', '7', '8', '9', '0', '1'; 8
		db '2', '3', '4', '5', '6', '7', '8', '9'; 16
		db 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H'; 24
		db 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P'; 32
		db 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X'; 40
		db 'Y', 'Z', '(', ')', '/', '\', '#', '*'; 48
		db '?', '<', '>', ':', ';', '-', '%', 0; 56
s_esc		db 'ESC',0
s_u		db '%U',0
s_victory		db 'vict',0
s_bardscr	db 'bardscr',0
s_iconFilePath	db 'icons.bin',0
s_getPictureError	db 'picture get error',0
bigpicIndexMultiplier	dw 2
word_4414E	dw 0FFh
aNorth		db 'north',0
aEast		db 'east',0
aSouth		db 'south',0
aWest		db 'west',0
g_printPartyFlag	dw 1
bitMask16bit	dw 1		; 0
		dw 2		; 1
		dw 4		; 2
		dw 8		; 3
		dw 10h		; 4
		dw 20h		; 5
		dw 40h		; 6
		dw 80h		; 7
		dw 100h		; 8
		dw 200h		; 9
		dw 400h		; 10
		dw 800h		; 11
		dw 1000h	; 12
		dw 2000h	; 13
		dw 4000h	; 14
		dw 8000h	; 15
byteMaskList	db 80h, 40h, 20h, 10h   ; 0
		db 8, 4, 2, 1		; 4
flagMaskList	db 7Fh, 0BFh, 0DFh, 0EFh; 0
		db 0F7h, 0FBh, 0FDh, 0FEh; 4
diceMaskList	db 1, 3		     ; 0
		db 7, 15		; 2
		db 31, 63		; 4
		db 127,	255		; 6
dirStringList	dd aNorth, aEast, aSouth,	aWest
dirDeltaN	dw 0FFFFh, 0,	1, 0	  ; 0
dirDeltaE	dw 0,	1, 0, 0FFFFh	  ; 0
northDelta	viewStruct <253, 3>	   ; 0
		viewStruct <254, 3>	; 1
		viewStruct <255, 3>	; 2
		viewStruct <0, 3>	; 3
		viewStruct <1, 3>	; 4
		viewStruct <2, 3>	; 5
		viewStruct <3, 3>	; 6
		viewStruct <253, 2>	; 7
		viewStruct <254, 2>	; 8
		viewStruct <255, 2>	; 9
		viewStruct <0, 2>	; 10
		viewStruct <1, 2>	; 11
		viewStruct <2, 2>	; 12
		viewStruct <3, 2>	; 13
		viewStruct <254, 1>	; 14
		viewStruct <255, 1>	; 15
		viewStruct <0, 1>	; 16
		viewStruct <1, 1>	; 17
		viewStruct <2, 1>	; 18
		viewStruct <255, 0>	; 19
		viewStruct <1, 0>	; 20
southDelta	viewStruct <3, 253>	   ; 0
		viewStruct <2, 253>	; 1
		viewStruct <1, 253>	; 2
		viewStruct <0, 253>	; 3
		viewStruct <255, 253>	; 4
		viewStruct <254, 253>	; 5
		viewStruct <253, 253>	; 6
		viewStruct <3, 254>	; 7
		viewStruct <2, 254>	; 8
		viewStruct <1, 254>	; 9
		viewStruct <0, 254>	; 10
		viewStruct <255, 254>	; 11
		viewStruct <254, 254>	; 12
		viewStruct <253, 254>	; 13
		viewStruct <2, 255>	; 14
		viewStruct <1, 255>	; 15
		viewStruct <0, 255>	; 16
		viewStruct <255, 255>	; 17
		viewStruct <254, 255>	; 18
		viewStruct <1, 0>	; 19
		viewStruct <255, 0>	; 20
eastDelta	viewStruct <3, 3>	  ; 0
		viewStruct <3, 2>	; 1
		viewStruct <3, 1>	; 2
		viewStruct <3, 0>	; 3
		viewStruct <3, 255>	; 4
		viewStruct <3, 254>	; 5
		viewStruct <3, 253>	; 6
		viewStruct <2, 3>	; 7
		viewStruct <2, 2>	; 8
		viewStruct <2, 1>	; 9
		viewStruct <2, 0>	; 10
		viewStruct <2, 255>	; 11
		viewStruct <2, 254>	; 12
		viewStruct <2, 253>	; 13
		viewStruct <1, 2>	; 14
		viewStruct <1, 1>	; 15
		viewStruct <1, 0>	; 16
		viewStruct <1, 255>	; 17
		viewStruct <1, 254>	; 18
		viewStruct <0, 1>	; 19
		viewStruct <0, 255>	; 20
westDelta	viewStruct <253, 253>	  ; 0
		viewStruct <253, 254>	; 1
		viewStruct <253, 255>	; 2
		viewStruct <253, 0>	; 3
		viewStruct <253, 1>	; 4
		viewStruct <253, 2>	; 5
		viewStruct <253, 3>	; 6
		viewStruct <254, 253>	; 7
		viewStruct <254, 254>	; 8
		viewStruct <254, 255>	; 9
		viewStruct <254, 0>	; 10
		viewStruct <254, 1>	; 11
		viewStruct <254, 2>	; 12
		viewStruct <254, 3>	; 13
		viewStruct <255, 254>	; 14
		viewStruct <255, 255>	; 15
		viewStruct <255, 0>	; 16
		viewStruct <255, 1>	; 17
		viewStruct <255, 2>	; 18
		viewStruct <0, 255>	; 19
		viewStruct <0, 1>	; 20
g_wild_deltaList	dd northDelta, eastDelta, southDelta,	westDelta; 0
g_tile_quadrantWidthList	db 3, 3, 3, 3, 3, 3,	3, 1, 1, 1; 0
		db 1, 1, 1, 6, 6, 6, 6,	6, 6, 6; 10
		db 10, 10, 10, 10, 10, 10, 2, 2, 2, 2; 20
		db 10, 10, 10, 10, 10, 10, 10, 10, 10, 10; 30
		db 10, 3, 3, 3,	3, 18, 18, 18, 10, 10; 40
		db 10, 10, 10, 10, 6, 6, 32, 32, 32, 11; 50
		db 11, 0		; 60
g_tile_quadrantScaleFactor	db 6, 6, 6, 6, 6, 6,	6, 6
		db 6, 6, 6, 6, 6, 12, 12, 12
		db 12, 12, 12, 12, 64, 64, 64, 64
		db 64, 64, 14, 14, 14, 14, 20, 20
		db 20, 20, 20, 64, 64, 64, 64, 64
		db 64, 20, 20, 20, 20, 36, 36, 36
		db 64, 64, 64, 64, 64, 64, 36, 36
		db 64, 64, 64, 64, 64, 0
g_tile_quadrantAspectOffsetList	db 2, 2, 2, 2, 2 	; 0
		db 2, 2, 0, 0, 0 	; 5
		db 0, 0, 0, 2, 2	; 10
		db 2, 2, 2, 2, 2	; 15
		db 0, 0, 0, 2, 2	; 20
		db 2, 0, 0, 0, 0	; 25
		db 2, 2, 2, 2, 2	; 30
		db 0, 0, 0, 2, 2	; 35
		db 2, 0, 0, 0, 0	; 40
		db 2, 2, 2, 0, 0	; 45
		db 0, 2, 2, 2, 0	; 50
		db 0, 2, 2, 2, 0	; 55
		db 0, 0			; 60
g_wild_viewSquareIndexList	db 1, 2, 3, 4
		db 5, 9, 11, 9
		db 10, 11, 15, 17
		db 15, 16, 17, 19
		db 20, 0
byte_44344	db 0, 255, 1, 1	   ; 0
		db 2, 255, 255,	1	; 4
		db 3, 255, 1, 1		; 8
		db 2, 255, 255,	1	; 12
byte_44354	db 0, 0FFh, 0FFh, 0FFh  ; 0
		db 0FFh, 0, 0FFh, 0FFh	; 4
		db 0FFh, 0FFh, 0FFh, 0FFh; 8
		db 0FFh, 0, 0FFh, 0FFh	; 12
dun_deltaNorth	viewStruct <253,	4>     ; 0
		viewStruct <254, 4>	; 1
		viewStruct <255, 4>	; 2
		viewStruct <0, 4>	; 3
		viewStruct <1, 4>	; 4
		viewStruct <2, 4>	; 5
		viewStruct <3, 4>	; 6
		viewStruct <253, 3>	; 7
		viewStruct <254, 3>	; 8
		viewStruct <255, 3>	; 9
		viewStruct <0, 3>	; 10
		viewStruct <1, 3>	; 11
		viewStruct <2, 3>	; 12
		viewStruct <3, 3>	; 13
		viewStruct <254, 2>	; 14
		viewStruct <255, 2>	; 15
		viewStruct <0, 2>	; 16
		viewStruct <1, 2>	; 17
		viewStruct <2, 2>	; 18
		viewStruct <255, 1>	; 19
		viewStruct <0, 1>	; 20
		viewStruct <1, 1>	; 21
		viewStruct <255, 0>	; 22
		viewStruct <0, 0>	; 23
		viewStruct <1, 0>	; 24
		viewStruct <255, 3>	; 25
		viewStruct <0, 3>	; 26
		viewStruct <1, 3>	; 27
		viewStruct <255, 2>	; 28
		viewStruct <0, 2>	; 29
		viewStruct <1, 2>	; 30
		viewStruct <255, 1>	; 31
		viewStruct <0, 1>	; 32
		viewStruct <1, 1>	; 33
dun_deltaSouth	viewStruct <3, 252>     ; 0
		viewStruct <2, 252>	; 1
		viewStruct <1, 252>	; 2
		viewStruct <0, 252>	; 3
		viewStruct <255, 252>	; 4
		viewStruct <254, 252>	; 5
		viewStruct <253, 252>	; 6
		viewStruct <3, 253>	; 7
		viewStruct <2, 253>	; 8
		viewStruct <1, 253>	; 9
		viewStruct <0, 253>	; 10
		viewStruct <255, 253>	; 11
		viewStruct <254, 253>	; 12
		viewStruct <253, 253>	; 13
		viewStruct <2, 254>	; 14
		viewStruct <1, 254>	; 15
		viewStruct <0, 254>	; 16
		viewStruct <255, 254>	; 17
		viewStruct <254, 254>	; 18
		viewStruct <1, 255>	; 19
		viewStruct <0, 255>	; 20
		viewStruct <255, 255>	; 21
		viewStruct <1, 0>	; 22
		viewStruct <0, 0>	; 23
		viewStruct <255, 0>	; 24
		viewStruct <1, 253>	; 25
		viewStruct <0, 253>	; 26
		viewStruct <255, 253>	; 27
		viewStruct <1, 254>	; 28
		viewStruct <0, 254>	; 29
		viewStruct <255, 254>	; 30
		viewStruct <1, 255>	; 31
		viewStruct <0, 255>	; 32
		viewStruct <255, 255>	; 33
dun_deltaEast	viewStruct <4, 3>	      ;	0
		viewStruct <4, 2>	; 1
		viewStruct <4, 1>	; 2
		viewStruct <4, 0>	; 3
		viewStruct <4, 255>	; 4
		viewStruct <4, 254>	; 5
		viewStruct <4, 253>	; 6
		viewStruct <3, 3>	; 7
		viewStruct <3, 2>	; 8
		viewStruct <3, 1>	; 9
		viewStruct <3, 0>	; 10
		viewStruct <3, 255>	; 11
		viewStruct <3, 254>	; 12
		viewStruct <3, 253>	; 13
		viewStruct <2, 2>	; 14
		viewStruct <2, 1>	; 15
		viewStruct <2, 0>	; 16
		viewStruct <2, 255>	; 17
		viewStruct <2, 254>	; 18
		viewStruct <1, 1>	; 19
		viewStruct <1, 0>	; 20
		viewStruct <1, 255>	; 21
		viewStruct <0, 1>	; 22
		viewStruct <0, 0>	; 23
		viewStruct <0, 255>	; 24
		viewStruct <3, 1>	; 25
		viewStruct <3, 0>	; 26
		viewStruct <3, 255>	; 27
		viewStruct <2, 1>	; 28
		viewStruct <2, 0>	; 29
		viewStruct <2, 255>	; 30
		viewStruct <1, 1>	; 31
		viewStruct <1, 0>	; 32
		viewStruct <1, 255>	; 33
dun_deltaWest	viewStruct <252, 253>   ;	0
		viewStruct <252, 254>	; 1
		viewStruct <252, 255>	; 2
		viewStruct <252, 0>	; 3
		viewStruct <252, 1>	; 4
		viewStruct <252, 2>	; 5
		viewStruct <252, 3>	; 6
		viewStruct <253, 253>	; 7
		viewStruct <253, 254>	; 8
		viewStruct <253, 255>	; 9
		viewStruct <253, 0>	; 10
		viewStruct <253, 1>	; 11
		viewStruct <253, 2>	; 12
		viewStruct <253, 3>	; 13
		viewStruct <254, 254>	; 14
		viewStruct <254, 255>	; 15
		viewStruct <254, 0>	; 16
		viewStruct <254, 1>	; 17
		viewStruct <254, 2>	; 18
		viewStruct <255, 255>	; 19
		viewStruct <255, 0>	; 20
		viewStruct <255, 1>	; 21
		viewStruct <0, 255>	; 22
		viewStruct <0, 0>	; 23
		viewStruct <0, 1>	; 24
		viewStruct <253, 255>	; 25
		viewStruct <253, 0>	; 26
		viewStruct <253, 1>	; 27
		viewStruct <254, 255>	; 28
		viewStruct <254, 0>	; 29
		viewStruct <254, 1>	; 30
		viewStruct <255, 255>	; 31
		viewStruct <255, 0>	; 32
		viewStruct <255, 1>	; 33
g_dun_deltaList	dd dun_deltaNorth, dun_deltaEast, dun_deltaSouth, dun_deltaWest	; 3
byte_44484	db 0, 1, 2, 2, 2, 0,	3, 4; 0
		db 3, 3, 4, 4, 4, 0, 3,	4; 8
byte_44494	db 3Dh, 38h,	2Dh, 1Eh, 0Dh, 0, 2, 2,	2, 2; 0
		db 2, 2, 2, 16h, 16h, 4, 4, 16h, 16h, 6; 10
		db 6, 6, 6, 6, 6, 6, 2Ch, 2Ah, 2Ch, 38h; 20
		db 36h,	38h, 18h, 8, 8,	18h, 0Ah, 0Ah, 0Ah; 30
		db 0Ah,	0Ah, 30h, 2Eh, 30h, 3Ch, 3Ah, 3Ch; 39
		db 0Ch,	0Ch, 0Ch, 0Ch, 0Eh, 0Eh, 0Eh, 34h; 47
		db 32h,	34h, 40h, 3Eh, 40h, 10h, 10h, 12h; 55
		db 12h,	12h, 14h, 14h, 0; 63
g_quadrantRightFlagList	db 0, 0, 0, 0	   ; 0
		db 0, 0, 0, 0		; 4
		db 0, 0, -1, -1		; 8
		db -1, 0, 0, 0		; 12
		db 0, 0, 0, 0		; 16
		db 0, 0, -1, 0		; 20
		db 0, -1, 0, 0		; 24
		db -1, -1, 0, 0		; 28
		db 0, 0, 0, 0		; 32
		db 0, -1, 0, 0		; 36
		db -1, 0, 0, -1		; 40
		db -1, 0, 0, 0		; 44
		db 0, 0, -1, 0		; 48
		db 0, -1, 0, -1		; 52
		db 0, 0, 0, 0		; 56
		db -1, 0		; 60
byte_44516	db 0, 1, 2, 3, 4, 5,	6, 1, 2, 3, 3, 4, 5; 0
		db 7, 8, 9, 0Ah, 0Bh, 0Ch, 0Dh,	19h, 1Ah; 13
		db 1Bh,	19h, 1Ah, 1Bh, 9, 0Ah, 0Ah, 0Bh; 22
		db 0Eh,	0Fh, 10h, 11h, 12h, 1Ch, 1Dh, 1Eh; 30
		db 1Ch,	1Dh, 1Eh, 0Fh, 10h, 10h, 11h, 13h; 38
		db 14h,	15h, 1Fh, 20h, 21h, 1Fh, 20h, 21h; 46
		db 14h,	14h, 16h, 17h, 18h, 17h, 17h, 0; 54
byte_44554	db 4, 4, 4, 4, 4, 4, 4, 8, 8, 8, 0, 0, 0; 0
		db 4, 4, 4, 4, 4, 4, 4,	4, 4, 4, 0, 0, 0; 13
		db 8, 8, 0, 0, 4, 4, 4,	4, 4, 4, 4, 4, 0; 26
		db 0, 0, 8, 8, 0, 0, 4,	4, 4, 4, 4, 4, 0; 39
		db 0, 0, 8, 0, 4, 4, 4,	8, 0, 0; 52
g_tile_quadrantCoordinates	coordinate_t <12, 42>	   ; 0
		coordinate_t <15, 42>	; 1
		coordinate_t <18, 42>	; 2
		coordinate_t <21, 42>	; 3
		coordinate_t <24, 42>	; 4
		coordinate_t <27, 42>	; 5
		coordinate_t <30, 42>	; 6
		coordinate_t <5, 38>	; 7
		coordinate_t <12, 38>	; 8
		coordinate_t <26, 38>	; 9
		coordinate_t <29, 38>	; 10
		coordinate_t <31, 38>	; 11
		coordinate_t <39, 38>	; 12
		coordinate_t <254, 38>	; 13
		coordinate_t <5, 38>	; 14
		coordinate_t <17, 44>	; 15
		coordinate_t <24, 44>	; 16
		coordinate_t <31, 44>	; 17
		coordinate_t <33, 38>	; 18
		coordinate_t <40, 38>	; 19
		coordinate_t <13, 33>	; 20
		coordinate_t <21, 33>	; 21
		coordinate_t <31, 33>	; 22
		coordinate_t <13, 55>	; 23
		coordinate_t <21, 55>	; 24
		coordinate_t <31, 55>	; 25
		coordinate_t <255,	38>	; 26
		coordinate_t <23, 38>	; 27
		coordinate_t <31, 38>	; 28
		coordinate_t <42, 38>	; 29
		coordinate_t <2, 42>	; 30
		coordinate_t <12, 42>	; 31
		coordinate_t <23, 42>	; 32
		coordinate_t <34, 42>	; 33
		coordinate_t <45, 42>	; 34
		coordinate_t <4, 21>	; 35
		coordinate_t <20, 21>	; 36
		coordinate_t <34, 21>	; 37
		coordinate_t <4, 63>	; 38
		coordinate_t <20, 63>	; 39
		coordinate_t <34, 63>	; 40
		coordinate_t <3, 35>	; 41
		coordinate_t <19, 35>	; 42
		coordinate_t <33, 35>	; 43
		coordinate_t <48, 35>	; 44
		coordinate_t <0, 35>	; 45
		coordinate_t <18, 35>	; 46
		coordinate_t <37, 35>	; 47
		coordinate_t <0, 8>	; 48
		coordinate_t <17, 4>	; 49
		coordinate_t <44, 8>	; 50
		coordinate_t <0, 77>	; 51
		coordinate_t <17, 77>	; 52
		coordinate_t <44, 77>	; 53
		coordinate_t <12, 22>	; 54
		coordinate_t <37, 22>	; 55
		coordinate_t <235, 22>	; 56
		coordinate_t <11, 22>	; 57
		coordinate_t <43, 22>	; 58
		coordinate_t <0, 0>	; 59
		coordinate_t <44, 0>	; 60
byte_4460C	db 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0; 0
		db 0, 0, 0FFh, 0FFh, 0FFh, 0, 0, 0, 0, 0; 13
		db 0, 0, 0, 0, 0FFh, 0FFh, 0, 0, 0FFh, 0FFh; 23
		db 0FFh, 0, 0, 0, 0, 0,	0, 0, 0, 0FFh, 0FFh; 33
		db 0, 0FFh, 0FFh, 0FFh,	0, 0, 0, 0, 0, 0; 44
		db 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh; 54
		db 0			; 61
g_wild_squareTopologyIndex	db 30, 31, 32, 33
		db 34, 42, 43, 45
		db 46, 47, 54, 55
		db 56, 57, 58, 59
		db 60, 0
strg_inventory	db 0C3h, 0, 1, 0C3h, 0, 1, 0C3h, 0, 1, 0C3h; 0
		db 0, 1, 0Fh, 0, 0FFh, 0Fh, 0, 0FFh, 7,	0; 10
		db 0FFh, 7, 0, 0FFh, 8,	0, 0FFh, 8, 0, 0FFh; 20
		db 16h,	0, 18h,	16h, 0,	18h, 76h, 0, 0Ah; 30
		db 2, 0, 1, 2, 0, 1, 1Eh, 0, 50h, 0CAh,	0; 39
		db 5, 0DFh, 0, 0Ah, 7Bh, 0, 0FFh, 7Ch, 0; 50
		db 18h,	73h, 0,	0FFh, 74h, 0, 0FFh, 87h; 59
		db 0, 0FFh, 88h, 0, 0FFh, 98h, 0, 0FFh,	99h; 67
		db 0, 0FFh, 9Ch, 0, 0FFh, 9Dh, 0, 0FFh;	76
bigpicLightOffset dw 0,	460h, 818h, 9A0h, 8C0h;	0
bigpicLightSize	dw 1340h, 0A80h, 620h, 348h, 1C0h; 0
iconXOffset	db 80, 92, 108, 124, 136, 0; 0
iconHeight	db 19, 26, 17, 20, 16, 0; 0
iconWidth	db 12, 16, 16, 12, 20, 0; 0
iconDataList	dd	iconLight, iconCompass,	iconAreaEnchant, iconShield, iconLevitation; 0
word_4470E	dw 0E4h, 1A0h, 110h,	0F0h, 140h; 0
byte_44718	db 0, 0, 0, 0, 0, 0	   ; 0
iconAnimationDelay	db 2, 0, 4, 0, 3, 0	   ; 0
iconCurrentDelay db 0, 0, 0,	0, 0, 0	    ; 0
iconClearIndex	db 4, 4, 4, 1, 4, 0	   ; 0
iconCurrentCell	db 0, 0, 0, 0, 0, 0
aMafl		db 'MAFL',0
aMageFlame	db 'Mage Flame',0
aArfi		db 'ARFI',0
aArcFire	db 'Arc Fire',0
aTrzp		db 'TRZP',0
aTrapZap	db 'Trap Zap',0
aFrfo		db 'FRFO',0
aFreezeFoes	db 'Freeze Foes',0
aMaco		db 'MACO',0
aKielSCompass	db 'Kiel',27h,'s Compass',0
aWohl		db 'WOHL',0
aWordOfHealing	db 'Word of Healing',0
aLere		db 'LERE',0
aLesserRev_	db 'Lesser Rev.',0
aLevi		db 'LEVI',0
aLevitation	db 'Levitation',0
aWast		db 'WAST',0
aWarstrike	db 'Warstrike',0
aInwo		db 'INWO',0
aInstantWolf	db 'Instant Wolf',0
aFlre		db 'FLRE',0
aFleshRestore	db 'Flesh Restore',0
aGrre		db 'GRRE',0
aGreaterRev_	db 'Greater Rev.',0
aShsp		db 'SHSP',0
aShockSphere	db 'Shock-Sphere',0
aFlan		db 'FLAN',0
aFleshAnew	db 'Flesh Anew',0
aMale		db 'MALE',0
aMajorLev_	db 'Major Lev.',0
aRegn		db 'REGN',0
aRegeneration	db 'Regeneration',0
aApar		db 'APAR',0
aApportArcane	db 'Apport Arcane',0
aFafo		db 'FAFO',0
aFarFoe		db 'Far Foe',0
aInsl		db 'INSL',0
aInstantSlayer	db 'Instant Slayer',0
aVopl		db 'VOPL',0
aVorpalPlating	db 'Vorpal Plating',0
aQufi		db 'QUFI',0
aQuickFix	db 'Quick Fix',0
aScsi		db 'SCSI',0
aScrySight	db 'Scry Sight',0
aHowa		db 'HOWA',0
aHolyWater	db 'Holy Water',0
aMaga		db 'MAGA',0
aMageGauntlets	db 'Mage Gauntlets',0
aAren		db 'AREN',0
aAreaEnchant	db 'Area Enchant',0
aMysh		db 'MYSH',0
aMysticShield	db 'Mystic Shield',0
aOgst		db 'OGST',0
aOgreStrength	db 'Ogre Strength',0
aStfl		db 'STFL',0
aStarflare	db 'Starflare',0
aSpto		db 'SPTO',0
aSpectreTouch	db 'Spectre Touch',0
aDrbr		db 'DRBR',0
aDragonBreath	db 'Dragon Breath',0
aAnma		db 'ANMA',0
aAntiMagic	db 'Anti-Magic',0
aGist		db 'GIST',0
aGiantStrength	db 'Giant Strength',0
aPhdo		db 'PHDO',0
aPhaseDoor	db 'Phase Door',0
aYmca		db 'YMCA',0
aMysticalArmor	db 'Mystical Armor',0
aRest		db 'REST',0
aRestoration	db 'Restoration',0
aDest		db 'DEST',0
aDeathStrike	db 'Death Strike',0
aIces		db 'ICES',0
aIceStorm	db 'Ice Storm',0
aSton		db 'STON',0
aStoneToFlesh	db 'Stone to Flesh',0
aMija		db 'MIJA',0
aMindJab	db 'Mind Jab',0
aPhbl		db 'PHBL',0
aPhaseBlur	db 'Phase Blur',0
aLotr		db 'LOTR',0
aLocateTraps	db 'Locate Traps',0
aDisb		db 'DISB',0
aDisbelieve	db 'Disbelieve',0
aWiwa		db 'WIWA',0
aWindWarrior	db 'Wind Warrior',0
aFear		db 'FEAR',0
aWordOfFear	db 'Word of Fear',0
aWiog		db 'WIOG',0
aWindOgre	db 'Wind Ogre',0
aInvi		db 'INVI',0
aInvisibility	db 'Invisibility',0
aSesi		db 'SESI',0
aSecondSight	db 'Second Sight',0
aCaey		db 'CAEY',0
aCatEyes	db 'Cat Eyes',0
aWidr		db 'WIDR',0
aWindDragon	db 'Wind Dragon',0
aDiil		db 'DIIL',0
aDisruptIll_	db 'Disrupt Ill.',0
aMibl		db 'MIBL',0
aMindBlade	db 'Mind Blade',0
aWigi		db 'WIGI',0
aWindGiant	db 'Wind Giant',0
aSosi		db 'SOSI',0
aSorcerorSight	db 'Sorceror Sight',0
aRime		db 'RIME',0
aRimefang	db 'Rimefang',0
aWihe		db 'WIHE',0
aWindHero	db 'Wind Hero',0
aMagm		db 'MAGM',0
aMageMaelstrom	db 'Mage Maelstrom',0
aPrec		db 'PREC',0
aPreclusion	db 'Preclusion',0
aSuel		db 'SUEL',0
aSummonElementa	db 'Summon Elemental',0
aFofo		db 'FOFO',0
aForceFocus	db 'Force Focus',0
aPrsu		db 'PRSU',0
aPrimeSummoning	db 'Prime Summoning',0
aDeba		db 'DEBA',0
aDemonBane	db 'Demon Bane',0
aFlco		db 'FLCO',0
aFlameColumn	db 'Flame Column',0
aDisp		db 'DISP',0
aDispossess	db 'Dispossess',0
aHerb		db 'HERB',0
aSummonHerb	db 'Summon Herb',0
aAnde		db 'ANDE',0
aAnimateDead	db 'Animate Dead',0
aSpbi		db 'SPBI',0
aSpellBind	db 'Spell Bind',0
aSowh		db 'SOWH',0
aSoulWhip	db 'Soul Whip',0
aGrsu		db 'GRSU',0
aGreaterSummon	db 'Greater Summon',0
aBede		db 'BEDE',0
aBeyondDeath	db 'Beyond Death',0
aWizw		db 'WIZW',0
aWizardWar	db 'Wizard War',0
aDmst		db 'DMST',0
aDemonStrike	db 'Demon Strike',0
aHafo		db 'HAFO',0
aHaltfoe	db 'Haltfoe',0
aMeme		db 'MEME',0
aMeleeMen	db 'Melee Men',0
aBasp		db 'BASP',0
aBatchspell	db 'Batchspell',0
aCamr		db 'CAMR',0
aCamaraderie	db 'Camaraderie',0
aNila		db 'NILA',0
aNightLance	db 'Night Lance',0
aHeal		db 'HEAL',0
aHealAll	db 'Heal All',0
aBrkr		db 'BRKR',0
aKringleBros_	db 'Kringle Bros.',0
aMama		db 'MAMA',0
aMangarSMallet	db 'Mangar',27h,'s Mallet',0
aVitl		db 'VITL',0
aVitality	db 'Vitality',0
aArbo		db 'ARBO',0
aArbo_0		db 'Arbo',0
aEnik		db 'ENIK',0
aEnik_0		db 'Enik',0
aWifi		db 'WIFI',0
aWitherfist	db 'Witherfist',0
aCold		db 'COLD',0
aFrostForce	db 'Frost Force',0
aGeli		db 'GELI',0
aGeli_0		db 'Geli',0
aEcul		db 'ECUL',0
aEcul_0		db 'Ecul',0
aGofi		db 'GOFI',0
aGodFire	db 'God Fire',0
aStun		db 'STUN',0
aStunForce	db 'Stun Force',0
aLuce		db 'LUCE',0
aLuce_0		db 'Luce',0
aIleg		db 'ILEG',0
aIleg_0		db 'Ileg',0
aLuck		db 'LUCK',0
aLuckChant	db 'Luck Chant',0
aFade		db 'FADE',0
aFarDeath	db 'Far Death',0
aKine		db 'KINE',0
aKine_0		db 'Kine',0
aObra		db 'OBRA',0
aObra_0		db 'Obra',0
aWhat		db 'WHAT',0
aIdentify	db 'Identify',0
aOlay		db 'OLAY',0
aYouth		db 'Youth',0
aOluk		db 'OLUK',0
aOluk_0		db 'Oluk',0
aEcea		db 'ECEA',0
aEcea_0		db 'Ecea',0
aGrro		db 'GRRO',0
aGraveRobber	db 'Grave Robber',0
aFota		db 'FOTA',0
aForceOfTarjan	db 'Force of Tarjan',0
aAece		db 'AECE',0
aAece_0		db 'Aece',0
aKulo		db 'KULO',0
aKulo_0		db 'Kulo',0
aShsh		db 'SHSH',0
aShadowShield	db 'Shadow Shield',0
aFafi		db 'FAFI',0
aFatalFist	db 'Fatal Fist',0
aEvil		db 'EVIL',0
aEvil_0		db 'Evil',0
aLive		db 'LIVE',0
aLive_0		db 'Live',0
aEada		db 'EADA',0
aEarthDagger	db 'Earth Dagger',0
aEaso		db 'EASO',0
aEarthSong	db 'Earth Song',0
aEawa		db 'EAWA',0
aEarthWard	db 'Earth Ward',0
aTreb		db 'TREB',0
aTrebuchet	db 'Trebuchet',0
aEael		db 'EAEL',0
aEarthElemental	db 'Earth Elemental',0
aWawa		db 'WAWA',0
aWallWarp	db 'Wall Warp',0
aRock		db 'ROCK',0
aPetrify	db 'Petrify',0
aRoal		db 'ROAL',0
aRoscoeSAlert	db 'Roscoe',27h,'s Alert',0
aSuso		db 'SUSO',0
aSuccorSong	db 'Succor Song',0
aSast		db 'SAST',0
aSandstorm	db 'Sandstorm',0
aSant		db 'SANT',0
aSanctuary	db 'Sanctuary',0
aGlst		db 'GLST',0
aGlacierStrike	db 'Glacier Strike',0
aPath		db 'PATH',0
aPathfinder	db 'Pathfinder',0
aMaba		db 'MABA',0
aMagmaBlast	db 'Magma Blast',0
aJobo		db 'JOBO',0
aJoltBolt	db 'Jolt Bolt',0
aEama		db 'EAMA',0
aEarthMaw	db 'Earth Maw',0
aGill		db 'GILL',0
aGillesGills	db 'Gilles Gills',0
aDiva		db 'DIVA',0
aDivineInt_	db 'Divine Int.',0
aNuke		db 'NUKE',0
aGotterdamurung	db 'Gotterdamurung',0
aItem		db 'Item',0
aWeapon		db 'Weapon',0
aShield		db 'Shield',0
aArmor		db 'Armor',0
aHelm		db 'Helm',0
aGloves		db 'Gloves',0
aInstrument	db 'Instrument',0
aFigurine	db 'Figurine',0
aRing		db 'Ring',0
aWand		db 'Wand',0
aBow		db 'Bow',0
aQuiver		db 'Quiver',0
aContainer	db 'Container',0
aNothing	db 'Nothing',0
aTorch		db 'Torch',0
aLamp		db 'Lamp',0
aBroadsword	db 'Broadsword',0
aShortSword	db 'Short Sword',0
aDagger		db 'Dagger',0
aWarAxe		db 'War Axe',0
aHalbard	db 'Halbard',0
aLongBow	db 'Long Bow',0
aStaff		db 'Staff',0
aBuckler	db 'Buckler',0
aTowerShield	db 'Tower Shield',0
aLeatherArmor	db 'Leather Armor',0
aChainMail	db 'Chain Mail',0
aScaleArmor	db 'Scale Armor',0
aPlateArmor	db 'Plate Armor',0
aRobes		db 'Robes',0
aLeatherGloves	db 'Leather Gloves',0
aGauntlets	db 'Gauntlets',0
aMandolin	db 'Mandolin',0
aSpear		db 'Spear',0
aArrows		db 'Arrows',0
aMthrSword	db 'Mthr Sword',0
aMthrShield	db 'Mthr Shield',0
aMthrChain	db 'Mthr Chain',0
aMthrScale	db 'Mthr Scale',0
aGiantFgn	db 'Giant Fgn',0
aMthrBracers	db 'Mthr Bracers',0
aBardsword	db 'Bardsword',0
aFireHorn	db 'Fire Horn',0
aLitewand	db 'Litewand',0
aMthrDagger	db 'Mthr Dagger',0
aMthrHelm	db 'Mthr Helm',0
aMthrGloves	db 'Mthr Gloves',0
aMthrAxe	db 'Mthr Axe',0
aShuriken	db 'Shuriken',0
aMthrPlate	db 'Mthr Plate',0
aMoltenFgn	db 'Molten Fgn',0
aSpellSpear	db 'Spell Spear',0
aShieldRing	db 'Shield Ring',0
aFinSFlute	db 'Fin',27h,'s Flute',0
aKaelSAxe	db 'Kael',27h,'s Axe',0
aMthrArrows	db 'Mthr Arrows',0
aDayblade	db 'Dayblade',0
aShieldStaff	db 'Shield Staff',0
aElfCloak	db 'Elf Cloak',0
aHawkblade	db 'Hawkblade',0
aAdmtSword	db 'Admt Sword',0
aAdmtShield	db 'Admt Shield',0
aAdmtHelm	db 'Admt Helm',0
aAdmtGloves	db 'Admt Gloves',0
aPureblade	db 'Pureblade',0
aBoomerang	db 'Boomerang',0
aAliSCarpet	db 'Ali',27h,'s Carpet',0
aLuckshield	db 'Luckshield',0
aDozerFgn	db 'Dozer Fgn',0
aAdmtChain	db 'Admt Chain',0
aDeathStars	db 'Death Stars',0
aAdmtPlate	db 'Admt Plate',0
aAdmtBracers	db 'Admt Bracers',0
aSlayerFgn	db 'Slayer Fgn',0
aPureShield	db 'Pure Shield',0
aMageStaff	db 'Mage Staff',0
aWarStaff	db 'War Staff',0
aThiefDagger	db 'Thief Dagger',0
aSoulMace	db 'Soul Mace',0
aOgrewand	db 'Ogrewand',0
aKatoSBracer	db 'Kato',27h,'s bracer',0
aSorcerstaff	db 'Sorcerstaff',0
aGaltSFlute	db 'Galt',27h,'s Flute',0
aFrostHorn	db 'Frost Horn',0
aAgSArrows	db 'Ag',27h,'s Arrows',0
aDmndShield	db 'Dmnd Shield',0
aBardBow	db 'Bard Bow',0
aDmndHelm	db 'Dmnd Helm',0
aElfBoots	db 'Elf Boots',0
aVanquisherFgn	db 'Vanquisher Fgn',0
aConjurstaff	db 'Conjurstaff',0
aStaffOfLor	db 'Staff of Lor',0
aFlameSword	db 'Flame Sword',0
aPowerstaff	db 'Powerstaff',0
aBreathRing 	db 'Breath Ring',0
aDragonshield	db 'Dragonshield',0
aDmndPlate	db 'Dmnd Plate',0
aWargloves	db 'Wargloves',0
aWizhelm	db 'Wizhelm',0
aDragonwand	db 'Dragonwand',0
aDeathring	db 'Deathring',0
aCrystalSword	db 'Crystal Sword',0
aSpeedboots	db 'Speedboots',0
aFlameHorn	db 'Flame Horn',0
aZenArrows	db 'Zen Arrows',0
aDeathdrum	db 'Deathdrum',0
aPipesOfPan	db 'Pipes of Pan',0
aPowerRing	db 'Power Ring',0
aSongAxe	db 'Song Axe',0
aTrickBrick	db 'Trick Brick',0
aDragonFgn	db 'Dragon Fgn',0
aMageFgn	db 'Mage Fgn',0
aTrollRing	db 'Troll Ring',0
aAramSKnife	db 'Aram',27h,'s Knife',0
aAngraSEye	db 'Angra',27h,'s Eye',0
aHerbFgn	db 'Herb Fgn',0
aMasterWand	db 'Master Wand',0
aBrothersFgn	db 'Brothers Fgn',0
aDynamite	db 'Dynamite',0
aThorSHammer	db 'Thor',27h,'s Hammer',0
aStoneblade	db 'Stoneblade',0
aHolyHandgrenad	db 'Holy Handgrenade',0
aMasterkey	db 'Masterkey',0
aNospinRing	db 'Nospin Ring',0
aCrystalLens	db 'Crystal Lens',0
aSmokeyLens	db 'Smokey Lens',0
aBlackLens	db 'Black Lens',0
aSphereOfLanati	db 'Sphere of Lanatir',0
aWandOfPower	db 'Wand of Power',0
aAcorn		db 'Acorn',0
aWineskin	db 'Wineskin',0
aNightspear	db 'Nightspear',0
aTslothaSHead	db 'Tslotha',27h,'s Head',0
aTslothaSHeart	db 'Tslotha',27h,'s Heart',0
aArefolia	db 'Arefolia',0
aValarianSBow	db 'Valarian',27h,'s Bow',0
aArwsOfLife	db 'Arws of Life',0
aCanteen	db 'Canteen',0
aTitanPlate	db 'Titan Plate',0
aTitanShield	db 'Titan Shield',0
aTitanHelm	db 'Titan Helm',0
aFireSpear	db 'Fire Spear',0
aWillowFlute	db 'Willow Flute',0
aFirebrand	db 'Firebrand',0
aHolySword	db 'Holy Sword',0
aWandOfFury	db 'Wand of Fury',0
aLightstar	db 'Lightstar',0
aCrownOfTruth	db 'Crown of Truth',0
aBeltOfAlliria	db 'Belt of Alliria',0
aCrystalKey	db 'Crystal Key',0
aTaoRing	db 'Tao Ring',0
aStealthArrows	db 'Stealth Arrows',0
aYellowStaff	db 'Yellow Staff',0
aSteadyEye	db 'Steady Eye',0
aDivineHalbard	db 'Divine Halbard',0
aIncense	db 'Incense',0
aIChing		db 'I-ching',0
aWhiteRose	db 'White Rose',0
aBlueRose	db 'Blue Rose',0
aRedRose	db 'Red Rose',0
aYellowRose	db 'Yellow Rose',0
aRainbowRose	db 'Rainbow Rose',0
aMagicTriangle	db 'Magic Triangle',0
aXChar		db 'x', 0
aHammerOfWrath	db 'Hammer of Wrath',0
aFerofistSHelm	db 'Ferofist',27h,'s Helm',0
aHelmOfJustice	db 'Helm of Justice',0
aSceaduSCloak	db 'Sceadu',27h,'s Cloak',0
aShadelance	db 'Shadelance',0
aBlackArrows	db 'Black Arrows',0
aWerraSShield	db 'Werra',27h,'s Shield',0
aStrifespear	db 'Strifespear',0
aSheetmusic	db 'Sheetmusic',0
aRightKey	db 'Right Key',0
aLeftKey	db 'Left Key',0
aLever		db 'Lever',0
aNut		db 'Nut',0
aBolt		db 'Bolt',0
aSpanner	db 'Spanner',0
aShadowLock	db 'Shadow Lock',0
aShadowDoor	db 'Shadow Door',0
aMisericorde	db 'Misericorde',0
aHolyAvenger	db 'Holy Avenger',0
aShadowshiv	db 'Shadowshiv',0
aKaliSGarrote	db 'Kali',27h,'s Garrote',0
aFlameKnife	db 'Flame Knife',0
aRedSStiletto	db 'Red',27h,'s Stiletto',0
aHeartseeker	db 'Heartseeker',0
aDmndScale	db 'Dmnd Scale',0
aHolyTnt	db 'Holy TNT',0
aEternalTorch	db 'Eternal Torch',0
aOsconSStaff	db 'Oscon',27h,'s Staff',0
aAngelSRing	db 'Angel',27h,'s Ring',0
aDeathhorn	db 'Deathhorn',0
aStaffOfMangar	db 'Staff of Mangar',0
aTeslaRing	db 'Tesla Ring',0
aDmndBracers	db 'Dmnd Bracers',0
aDeathFgn	db 'Death Fgn',0
aThunderSword	db 'Thunder Sword',0
aPoisonDagger	db 'Poison Dagger',0
aSparkBlade	db 'Spark Blade',0
aGalvanicOboe	db 'Galvanic Oboe',0
aHarmonicGem	db 'Harmonic Gem',0
aTungShield	db 'Tung Shield',0
aTungPlate	db 'Tung Plate',0
aMinstrelsGlove	db 'Minstrels Glove',0
aHuntersCloak	db 'Hunters Cloak',0
aDeathHammer	db 'Death Hammer',0
aBloodMeshRobe	db 'Blood Mesh Robe',0
aSoothingBalm	db 'Soothing Balm',0
aMagesCloak	db 'Mages Cloak',0
aFamiliarFgn	db 'Familiar Fgn',0
aHourglass	db 'Hourglass',0
aThievesHood	db 'Thieves Hood',0
aSurehandAmulet	db 'Surehand Amulet',0
aThievesDart	db 'Thieves Dart',0
aShrillFlute	db 'Shrill Flute',0
aAngelSHarp	db 'Angel',27h,'s Harp',0
aTheBook	db 'The Book',0
aTrothLance	db 'Troth Lance',0
aDmndSuit	db 'Dmnd Suit',0
aDmndFlail	db 'Dmnd Flail',0
aPurpleHeart	db 'Purple Heart',0
aTitanBracers	db 'Titan Bracers',0
aEelskinTunic	db 'Eelskin Tunic',0
aSorcererSHood	db 'Sorcerer',27h,'s Hood',0
aDmndStaff	db 'Dmnd Staff',0
aCrystalGem	db 'Crystal Gem',0
aWandOfForce	db 'Wand of Force',0
aCliLyre	db 'Cli Lyre',0
aYouthPotion	db 'Youth Potion',0
aMthrSuit	db 'Mthr Suit',0
aTitanSuit	db 'Titan Suit',0
aMagesGlove	db 'Mages Glove',0
aFlareCrystal	db 'Flare Crystal',0
aHolyMissile	db 'Holy Missile',0
aGodsBlade	db 'Gods',27h,' Blade',0
aHunterBlade	db 'Hunter Blade',0
aStaffOfGods	db 'Staff of Gods',0
aHornOfGods	db 'Horn of Gods',0
aWater		db 'Water',0
aSpirits	db 'Spirits',0
aWaterOfLife	db 'Water of Life',0
aDragonBlood	db 'Dragon Blood',0
aMoltenTar	db 'Molten Tar',0
aHuman		db 'Human',0
aElf		db 'Elf',0
aDwarf		db 'Dwarf',0
aHobbit		db 'Hobbit',0
aHalfElf	db 'Half-Elf',0
aHalfOrc	db 'Half-Orc',0
aGnome		db 'Gnome',0
aMale_0		db 'Male',0
aFemale		db 'Female',0
nullStr		db 0
		db    0
spellString 	spellString_t <aMafl, aMageFlame>; 0
		spellString_t <aArfi, aArcFire>; 1
		spellString_t <aTrzp, aTrapZap>; 2
		spellString_t <aFrfo, aFreezeFoes>; 3
		spellString_t <aMaco, aKielSCompass>; 4
		spellString_t <aWohl, aWordOfHealing>; 5
		spellString_t <aLere, aLesserRev_>; 6
		spellString_t <aLevi, aLevitation>; 7
		spellString_t <aWast, aWarstrike>; 8
		spellString_t <aInwo, aInstantWolf>; 9
		spellString_t <aFlre, aFleshRestore>; 10
		spellString_t <aGrre, aGreaterRev_>; 11
		spellString_t <aShsp, aShockSphere>; 12
		spellString_t <aFlan, aFleshAnew>; 13
		spellString_t <aMale, aMajorLev_>; 14
		spellString_t <aRegn, aRegeneration>; 15
		spellString_t <aApar, aApportArcane>; 16
		spellString_t <aFafo, aFarFoe>;	17
		spellString_t <aInsl, aInstantSlayer>; 18
		spellString_t <aVopl, aVorpalPlating>; 19
		spellString_t <aQufi, aQuickFix>; 20
		spellString_t <aScsi, aScrySight>; 21
		spellString_t <aHowa, aHolyWater>; 22
		spellString_t <aMaga, aMageGauntlets>; 23
		spellString_t <aAren, aAreaEnchant>; 24
		spellString_t <aMysh, aMysticShield>; 25
		spellString_t <aOgst, aOgreStrength>; 26
		spellString_t <aStfl, aStarflare>; 27
		spellString_t <aSpto, aSpectreTouch>; 28
		spellString_t <aDrbr, aDragonBreath>; 29
		spellString_t <aAnma, aAntiMagic>; 30
		spellString_t <aGist, aGiantStrength>; 31
		spellString_t <aPhdo, aPhaseDoor>; 32
		spellString_t <aYmca, aMysticalArmor>; 33
		spellString_t <aRest, aRestoration>; 34
		spellString_t <aDest, aDeathStrike>; 35
		spellString_t <aIces, aIceStorm>; 36
		spellString_t <aSton, aStoneToFlesh>; 37
		spellString_t <aMija, aMindJab>; 38
		spellString_t <aPhbl, aPhaseBlur>; 39
		spellString_t <aLotr, aLocateTraps>; 40
		spellString_t <aDisb, aDisbelieve>; 41
		spellString_t <aWiwa, aWindWarrior>; 42
		spellString_t <aFear, aWordOfFear>; 43
		spellString_t <aWiog, aWindOgre>; 44
		spellString_t <aInvi, aInvisibility>; 45
		spellString_t <aSesi, aSecondSight>; 46
		spellString_t <aCaey, aCatEyes>; 47
		spellString_t <aWidr, aWindDragon>; 48
		spellString_t <aDiil, aDisruptIll_>; 49
		spellString_t <aMibl, aMindBlade>; 50
		spellString_t <aWigi, aWindGiant>; 51
		spellString_t <aSosi, aSorcerorSight>; 52
		spellString_t <aRime, aRimefang>; 53
		spellString_t <aWihe, aWindHero>; 54
		spellString_t <aMagm, aMageMaelstrom>; 55
		spellString_t <aPrec, aPreclusion>; 56
		spellString_t <aSuel, aSummonElementa>;	57
		spellString_t <aFofo, aForceFocus>; 58
		spellString_t <aPrsu, aPrimeSummoning>;	59
		spellString_t <aDeba, aDemonBane>; 60
		spellString_t <aFlco, aFlameColumn>; 61
		spellString_t <aDisp, aDispossess>; 62
		spellString_t <aHerb, aSummonHerb>; 63
		spellString_t <aAnde, aAnimateDead>; 64
		spellString_t <aSpbi, aSpellBind>; 65
		spellString_t <aSowh, aSoulWhip>; 66
		spellString_t <aGrsu, aGreaterSummon>; 67
		spellString_t <aBede, aBeyondDeath>; 68
		spellString_t <aWizw, aWizardWar>; 69
		spellString_t <aDmst, aDemonStrike>; 70
		spellString_t <aHafo, aHaltfoe>; 71
		spellString_t <aMeme, aMeleeMen>; 72
		spellString_t <aBasp, aBatchspell>; 73
		spellString_t <aCamr, aCamaraderie>; 74
		spellString_t <aNila, aNightLance>; 75
		spellString_t <aHeal, aHealAll>; 76
		spellString_t <aBrkr, aKringleBros_>; 77
		spellString_t <aMama, aMangarSMallet>; 78
		spellString_t <aVitl, aVitality>; 79
		spellString_t <aArbo, aArbo_0>; 80
		spellString_t <aEnik, aEnik_0>; 81
		spellString_t <aWifi, aWitherfist>; 82
		spellString_t <aCold, aFrostForce>; 83
		spellString_t <aGeli, aGeli_0>; 84
		spellString_t <aEcul, aEcul_0>; 85
		spellString_t <aGofi, aGodFire>; 86
		spellString_t <aStun, aStunForce>; 87
		spellString_t <aLuce, aLuce_0>; 88
		spellString_t <aIleg, aIleg_0>; 89
		spellString_t <aLuck, aLuckChant>; 90
		spellString_t <aFade, aFarDeath>; 91
		spellString_t <aKine, aKine_0>; 92
		spellString_t <aObra, aObra_0>; 93
		spellString_t <aWhat, aIdentify>; 94
		spellString_t <aOlay, aYouth>; 95
		spellString_t <aOluk, aOluk_0>; 96
		spellString_t <aEcea, aEcea_0>; 97
		spellString_t <aGrro, aGraveRobber>; 98
		spellString_t <aFota, aForceOfTarjan>; 99
		spellString_t <aAece, aAece_0>; 100
		spellString_t <aKulo, aKulo_0>; 101
		spellString_t <aShsh, aShadowShield>; 102
		spellString_t <aFafi, aFatalFist>; 103
		spellString_t <aEvil, aEvil_0>; 104
		spellString_t <aLive, aLive_0>; 105
		spellString_t <aEada, aEarthDagger>; 106
		spellString_t <aEaso, aEarthSong>; 107
		spellString_t <aEawa, aEarthWard>; 108
		spellString_t <aTreb, aTrebuchet>; 109
		spellString_t <aEael, aEarthElemental>;	110
		spellString_t <aWawa, aWallWarp>; 111
		spellString_t <aRock, aPetrify>; 112
		spellString_t <aRoal, aRoscoeSAlert>; 113
		spellString_t <aSuso, aSuccorSong>; 114
		spellString_t <aSast, aSandstorm>; 115
		spellString_t <aSant, aSanctuary>; 116
		spellString_t <aGlst, aGlacierStrike>; 117
		spellString_t <aPath, aPathfinder>; 118
		spellString_t <aMaba, aMagmaBlast>; 119
		spellString_t <aJobo, aJoltBolt>; 120
		spellString_t <aEama, aEarthMaw>; 121
		spellString_t <aGill, aGillesGills>; 122
		spellString_t <aDiva, aDivineInt_>; 123
		spellString_t <aNuke, aGotterdamurung>;	124
s_spellPoints	db 'Spell Points:',0
s_expr		db 'Expr:',0
s_gold		db 'Gold:',0
s_poolGold	db 0Ah,0Ah
		db '     Pool  gold',0Ah
		db '     Trade gold',0
s_tradeGoldToWhom	db 'Trade gold to whom?',0
s_howMuchGoldToTrade	db 'How much gold will you trade?',0
align 2
s_done		db 'Done!',0
s_inventory	db 'Inventory',0
s_inventoryVarString	db ' Do you wish to:',0Ah
		db 0Ah,0Ah,0Ah
		db '@Trade the item',0Ah
		db '@Discard the item',0Ah
		db '@Equip the item',0Ah
		db '@Unequip the item',0Ah
		db '@Identify the item',0
align 2
s_itsFilledWith	db 'It',27h,'s filled with ',0
s_triesToIdentify	db ' tries to identify the item...',0Ah
		db 'and /succeed\fail\s!!',0
align 2
s_whoDoes	db 'Who does ',0
s_wantToGiveItTo	db ' want to give it to?',0
align 2
s_dontKnowAnySpells	db 'You don',27h,'t know any spells.',0
align 2
s_knownSpells	db 'Known spells',0
align 2
s_rogueAbilities	db 'Rogue abilities',0
s_disarmTraps	db 'Disarm traps ',0
s_identifyChest	db 'Identify chest ',0
s_identifyItem	db 'Identify item ',0
align 2
s_hideInShadows	db 'Hide in shadows ',0
align 2
s_criticalHit	db 'Critical hit ',0
s_bardAbilities	db 'Bard abilities',0
align 2
s_tunesLeft	db 'Number of tunes left: ',0
align 2
s_hunterAbilities	db 'Hunter abilities',0
align 2
s_pocketsAreEmpty db 'Your pockets are empty.',0
s_attributeAbbreviations	db 'StIQDxCnLkHP',0
align 2
g_itemGenericStringList	dd aItem, aWeapon, aShield, aArmor, aHelm, aGloves, aInstrument, aFigurine; 0
		dd aRing, aWand, aItem, aBow,	aQuiver, aContainer, aArmor; 8
g_itemStringList		dd aNothing, aTorch, aLamp, aBroadsword; 0
		dd aShortSword,	aDagger, aWarAxe, aHalbard; 4
		dd aLongBow, aStaff, aBuckler, aTowerShield; 8
		dd aLeatherArmor, aChainMail, aScaleArmor, aPlateArmor;	12
		dd aRobes, aHelm, aLeatherGloves, aGauntlets;	16
		dd aMandolin, aSpear, aArrows, aMthrSword; 20
		dd aMthrShield,	aMthrChain, aMthrScale,	aGiantFgn; 24
		dd aMthrBracers, aBardsword, aFireHorn,	aLitewand; 28
		dd aMthrDagger,	aMthrHelm, aMthrGloves,	aMthrAxe; 32
		dd aShuriken, aMthrPlate, aMoltenFgn, aSpellSpear; 36
		dd aShieldRing,	aFinSFlute, aKaelSAxe, aMthrArrows; 40
		dd aDayblade, aShieldStaff, aElfCloak, aHawkblade; 44
		dd aAdmtSword, aAdmtShield, aAdmtHelm, aAdmtGloves; 48
		dd aPureblade, aBoomerang, aAliSCarpet,	aLuckshield; 52
		dd aDozerFgn, aAdmtChain, aDeathStars, aAdmtPlate; 56
		dd aAdmtBracers, aSlayerFgn, aPureShield, aMageStaff; 60
		dd aWarStaff, aThiefDagger, aSoulMace, aOgrewand; 64
		dd aKatoSBracer, aSorcerstaff, aGaltSFlute, aFrostHorn;	68
		dd aAgSArrows, aDmndShield, aBardBow, aDmndHelm; 72
		dd aElfBoots, aVanquisherFgn, aConjurstaff, aStaffOfLor; 76
		dd aFlameSword,	aPowerstaff, aBreathRing, aDragonshield; 80
		dd aDmndPlate, aWargloves, aWizhelm, aDragonwand; 84
		dd aDeathring, aCrystalSword, aSpeedboots, aFlameHorn; 88
		dd aZenArrows, aDeathdrum, aPipesOfPan,	aPowerRing; 92
		dd aSongAxe, aTrickBrick, aDragonFgn, aMageFgn;	96
		dd aTrollRing, aAramSKnife, aAngraSEye,	aHerbFgn; 100
		dd aMasterWand,	aBrothersFgn, aDynamite, aThorSHammer; 104
		dd aStoneblade,	aHolyHandgrenad, aMasterkey, aNospinRing; 108
		dd aCrystalLens, aSmokeyLens, aBlackLens, aSphereOfLanati; 112
		dd aWandOfPower, aAcorn, aWineskin, aNightspear; 116
		dd aTslothaSHead, aTslothaSHeart, aArefolia, aValarianSBow; 120
		dd aArwsOfLife,	aCanteen, aTitanPlate, aTitanShield; 124
		dd aTitanHelm, aFireSpear, aWillowFlute, aFirebrand; 128
		dd aHolySword, aWandOfFury, aLightstar,	aCrownOfTruth; 132
		dd aBeltOfAlliria, aCrystalKey,	aTaoRing, aStealthArrows; 136
		dd aYellowStaff, aSteadyEye, aDivineHalbard, aIncense; 140
		dd aIChing, aWhiteRose,	aBlueRose, aRedRose; 144
		dd aYellowRose,	aRainbowRose, aMagicTriangle, aXChar; 148
		dd aHammerOfWrath, aFerofistSHelm, aXChar, aXChar; 152
		dd aHelmOfJustice, aSceaduSCloak, aShadelance, aBlackArrows; 156
		dd aWerraSShield, aStrifespear,	aSheetmusic, aRightKey;	160
		dd aLeftKey, aLever, aNut, aBolt; 164
		dd aSpanner, aShadowLock, aShadowDoor, aMisericorde; 168
		dd aHolyAvenger, aShadowshiv, aKaliSGarrote, aFlameKnife; 172
		dd aRedSStiletto, aHeartseeker,	aXChar, aXChar; 176
		dd aXChar, aDmndScale, aHolyTnt, aEternalTorch; 180
		dd aOsconSStaff, aAngelSRing, aDeathhorn, aStaffOfMangar; 184
		dd aTeslaRing, aDmndBracers, aDeathFgn,	aThunderSword; 188
		dd aPoisonDagger, aSparkBlade, aGalvanicOboe, aHarmonicGem; 192
		dd aTungShield,	aTungPlate, aMinstrelsGlove, aHuntersCloak; 196
		dd aDeathHammer, aBloodMeshRobe, aSoothingBalm,	aMagesCloak; 200
		dd aFamiliarFgn, aHourglass, aThievesHood, aSurehandAmulet; 204
		dd aThievesDart, aShrillFlute, aAngelSHarp, aTheBook; 208
		dd aTrothLance,	aDmndSuit, aDmndFlail, aPurpleHeart; 212
		dd aTitanBracers, aEelskinTunic, aSorcererSHood, aDmndStaff; 216
		dd aCrystalGem,	aWandOfForce, aCliLyre,	aYouthPotion; 220
		dd aXChar, aXChar, aXChar, aXChar; 224
		dd aXChar, aXChar, aXChar, aXChar; 228
		dd aXChar, aXChar, aXChar, aXChar; 232
		dd aXChar, aXChar, aXChar, aXChar; 236
		dd aMthrSuit, aTitanSuit, aMagesGlove, aFlareCrystal; 240
		dd aHolyMissile, aGodsBlade, aHunterBlade, aStaffOfGods; 244
		dd aHornOfGods,	aXChar, aXChar, aXChar; 248
		dd aXChar, aXChar, aXChar, aXChar; 252
wineskinString	dd aWater	       ; 0
		dd aSpirits		; 1
		dd aWaterOfLife		; 2
		dd aDragonBlood		; 3
		dd aMoltenTar		; 4
g_itemBaseCount	db 0FFh, 1, 1, 0FFh, 0FFh, 0FFh, 1, 0FFh, 0FFh, 0FFh; 0
		db 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh; 10
		db 0FFh, 1, 18h, 0FFh, 0FFh, 0FFh, 0FFh, 1, 0FFh, 0FFh;	20
		db 32h,	50h, 0FFh, 0FFh, 0FFh, 1, 1, 0FFh, 1, 1; 30
		db 0FFh, 0FFh, 1, 0Ah, 50h, 0FFh, 0FFh,	0FFh, 0FFh, 0FFh; 40
		db 0FFh, 0FFh, 0FFh, 0FFh, 32h,	0FFh, 1, 0FFh, 4, 0FFh;	50
		db 0FFh, 1, 0FFh, 0FFh,	0FFh, 0FFh, 0FFh, 58h, 0FFh, 50h; 60
		db 58h,	41h, 0Ah, 0FFh,	0FFh, 0FFh, 0FFh, 1, 0FFh, 23h;	70
		db 0FFh, 33h, 0FFh, 14h, 0FFh, 0FFh, 19h, 23h, 40h, 0FFh; 80
		db 0FFh, 3Ch, 0Ah, 0Ah,	0FFh, 11h, 0FFh, 1Eh, 1, 1; 90
		db 0FFh, 1Eh, 7, 1, 0Bh, 1, 1, 0FFh, 0FFh, 1; 100
		db 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 1,	0Ah, 0FFh; 110
		db 0FFh, 0FFh, 1, 0FFh,	18h, 0Ah, 0FFh,	0FFh, 0FFh, 1; 120
		db 5, 0FFh, 0FFh, 0Ah, 1, 0FFh,	0FFh, 0FFh, 0FFh, 18h; 130
		db 0FFh, 0FFh, 0FFh, 3,	19h, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh; 140
		db 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 18h; 150
		db 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh; 160
		db 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 14h, 0FFh, 0FFh, 0FFh,	0FFh; 170
		db 0FFh, 0FFh, 2, 0FFh,	0Ah, 0FFh, 1Eh,	0FFh, 19h, 0FFh; 180
		db 1, 0FFh, 0FFh, 0FFh,	5, 1, 0FFh, 0FFh, 0FFh,	0FFh; 190
		db 0FFh, 0FFh, 5, 0Ah, 0FFh, 2,	0FFh, 0FFh, 1, 5; 200
		db 5, 4, 0FFh, 0FFh, 0FFh, 0Ah,	0FFh, 0FFh, 0FFh, 0FFh;	210
		db 3, 0Ah, 0Fh,	0Ah, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh; 220
		db 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh; 230
		db 0FFh, 0FFh, 0FFh, 5,	1, 0FFh, 0FFh, 0Ah, 19h, 0FFh; 240
		db 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh; 250
itemDamageDice	db 0, 0, 0, 33	       ; 0
		db 64, 0, 33, 96	; 4
		db 0, 64, 0, 0		; 8
		db 0, 0, 0, 0		; 12
		db 0, 0, 0, 0		; 16
		db 0, 64, 0, 33		; 20
		db 0, 0, 0, 0		; 24
		db 0, 65, 0, 0		; 28
		db 0, 0, 0, 33		; 32
		db 0, 0, 0, 96		; 36
		db 0, 0, 36, 0		; 40
		db 66, 96, 0, 66	; 44
		db 33, 0, 0, 0		; 48
		db 98, 0, 0, 0		; 52
		db 0, 0, 0, 0		; 56
		db 0, 0, 0, 66		; 60
		db 67, 52, 65, 0	; 64
		db 0, 34, 0, 0		; 68
		db 33, 0, 0, 0		; 72
		db 0, 0, 34, 36		; 76
		db 98, 66, 97, 0	; 80
		db 0, 0, 0, 0		; 84
		db 0, 98, 0, 0		; 88
		db 0, 0, 0, 0		; 92
		db 0, 0, 0, 0		; 96
		db 0, 33, 0, 0		; 100
		db 0, 0, 0, 99		; 104
		db 0, 0, 0, 0		; 108
		db 0, 0, 0, 0		; 112
		db 0, 0, 0, 100		; 116
		db 0, 0, 0, 0		; 120
		db 0, 0, 0, 0		; 124
		db 0, 99, 0, 72		; 128
		db 99, 0, 0, 0		; 132
		db 0, 0, 0, 0		; 136
		db 38, 0, 72, 0		; 140
		db 0, 0, 0, 0		; 144
		db 0, 0, 0, 0		; 148
		db 99, 0, 0, 0		; 152
		db 0, 0, 0, 0		; 156
		db 0, 0, 0, 0		; 160
		db 0, 0, 0, 0		; 164
		db 0, 0, 0, 165		; 168
		db 135,	98, 137, 105	; 172
		db 167,	32, 0, 0	; 176
		db 0, 0, 0, 0		; 180
		db 67, 0, 0, 99		; 184
		db 0, 0, 0, 99		; 188
		db 98, 99, 0, 0		; 192
		db 0, 0, 0, 0		; 196
		db 99, 0, 0, 0		; 200
		db 0, 0, 0, 0		; 204
		db 0, 0, 0, 0		; 208
		db 135,	0, 129,	0	; 212
		db 0, 0, 0, 39		; 216
		db 0, 99, 0, 0		; 220
		db 0, 0, 0, 0		; 224
		db 0, 0, 0, 0		; 228
		db 0, 0, 0, 0		; 232
		db 0, 0, 0, 0		; 236
		db 0, 0, 0, 0		; 240
		db 0, 137, 169,	41	; 244
		db 0, 0, 0, 0		; 248
		db 0, 0, 0, 0		; 252
item_acBonWeapDam db 0,	0, 0, 0		  ; 0
		db 0, 0, 0, 0		; 4
		db 0, 0, 1, 2		; 8
		db 2, 3, 4, 5		; 12
		db 1, 1, 1, 1		; 16
		db 0, 0, 0, 32		; 20
		db 3, 4, 5, 0		; 24
		db 4, 64, 0, 0		; 28
		db 32, 2, 2, 32		; 32
		db 0, 6, 0, 32		; 36
		db 2, 2, 32, 0		; 40
		db 16, 18, 3, 16	; 44
		db 64, 4, 3, 3		; 48
		db 0, 0, 2, 3		; 52
		db 0, 5, 0, 7		; 56
		db 6, 0, 5, 2		; 60
		db 0, 16, 48, 0		; 64
		db 0, 50, 0, 0		; 68
		db 96, 5, 2, 4		; 72
		db 0, 0, 34, 16		; 76
		db 17, 16, 16, 4	; 80
		db 8, 4, 3, 0		; 84
		db 1, 16, 0, 0		; 88
		db 0, 2, 2, 0		; 92
		db 3, 0, 0, 0		; 96
		db 0, 64, 0, 0		; 100
		db 0, 0, 0, 32		; 104
		db 48, 0, 0, 0		; 108
		db 0, 0, 0, 37		; 112
		db 51, 0, 0, 48		; 116
		db 0, 0, 0, 4		; 120
		db 32, 0, 10, 22	; 124
		db 5, 48, 2, 65		; 128
		db 66, 17, 0, 10	; 132
		db 0, 0, 37, 2		; 136
		db 36, 4, 49, 0		; 140
		db 0, 0, 0, 0		; 144
		db 0, 0, 0, 0		; 148
		db 0, 39, 0, 0		; 152
		db 9, 28, 0, 0		; 156
		db 8, 80, 0, 0		; 160
		db 0, 0, 0, 0		; 164
		db 0, 0, 0, 115		; 168
		db 84, 16, 49, 33	; 172
		db 66, 82, 0, 0		; 176
		db 0, 7, 0, 0		; 180
		db 51, 2, 0, 36		; 184
		db 2, 8, 0, 66		; 188
		db 49, 50, 0, 0		; 192
		db 23, 12, 7, 40	; 196
		db 81, 4, 0, 4		; 200
		db 0, 0, 4, 0		; 204
		db 0, 2, 2, 0		; 208
		db 81, 15, 80, 0	; 212
		db 10, 20, 3, 33	; 216
		db 0, 32, 5, 0		; 220
		db 0, 0, 0, 0		; 224
		db 0, 0, 0, 0		; 228
		db 0, 0, 0, 0		; 232
		db 0, 0, 0, 0		; 236
		db 10, 15, 4, 0		; 240
		db 0, 85, 83, 50	; 244
		db 0, 0, 0, 0		; 248
		db 0, 0, 0, 0		; 252
itemTypeList	db itType_item, itType_item, itType_item; 0
		db itType_weapon, itType_weapon, itType_weapon;	3
		db itType_weapon, itType_weapon, itType_bow; 6
		db itType_weapon, itType_shield, itType_shield;	9
		db itType_armor, itType_armor, itType_armor; 12
		db itType_armor, itType_armor, itType_helm; 15
		db itType_gloves, itType_gloves, itType_instrument; 18
		db itType_weapon, itType_quiver, itType_weapon;	21
		db itType_shield, itType_armor,	itType_armor; 24
		db itType_figurine, itType_armor, itType_weapon; 27
		db itType_instrument, itType_item0, itType_weapon; 30
		db itType_helm,	itType_gloves, itType_weapon; 33
		db itType_item0, itType_armor, itType_figurine;	36
		db itType_weapon, itType_ring, itType_instrument; 39
		db 11h,	itType_quiver, itType_weapon; 42
		db itType_weapon, itType_armor0, itType_weapon;	45
		db itType_weapon, itType_shield, itType_helm; 48
		db itType_gloves, itType_weapon, itType_item0; 51
		db itType_item0, itType_shield,	itType_figurine; 54
		db itType_armor, itType_weapon,	itType_armor; 57
		db itType_armor, itType_figurine, itType_shield; 60
		db itType_weapon, itType_weapon, itType_weapon;	63
		db 51h,	itType_wand, itType_item0; 66
		db itType_weapon, itType_instrument, itType_instrument;	69
		db itType_quiver, itType_shield, itType_bow; 72
		db itType_helm,	itType_item0, itType_figurine; 75
		db itType_weapon, itType_weapon, itType_weapon;	78
		db itType_weapon, itType_ring, itType_shield; 81
		db itType_armor, itType_gloves,	itType_helm; 84
		db itType_wand,	itType_ring, itType_weapon; 87
		db itType_item0, itType_instrument, itType_quiver; 90
		db itType_instrument, itType_instrument, itType_ring; 93
		db itType_weapon, itType_item0,	itType_figurine; 96
		db itType_figurine, itType_ring, itType_weapon;	99
		db itType_item0, itType_figurine, itType_wand; 102
		db itType_figurine, itType_item0, itType_weapon; 105
		db 61h,	itType_item0, itType_item0; 108
		db itType_ring,	itType_item, itType_item; 111
		db itType_item,	itType_item0, itType_wand; 114
		db itType_item0, itType_container, itType_weapon; 117
		db itType_item0, itType_item0, itType_item0; 120
		db itType_bow, itType_quiver, itType_container;	123
		db itType_armor, itType_shield,	itType_helm; 126
		db itType_weapon, itType_instrument, 51h; 129
		db itType_weapon, itType_wand, itType_item0; 132
		db itType_helm,	itType_item0, itType_item0; 135
		db itType_ring,	itType_quiver, itType_weapon; 138
		db itType_item0, itType_weapon,	itType_item0; 141
		db itType_item0, itType_item0, itType_item0; 144
		db itType_item0, itType_item0, itType_item0; 147
		db itType_item0, itType_item0, itType_weapon; 150
		db itType_helm,	itType_item0, itType_item0; 153
		db itType_helm,	itType_armor, itType_weapon; 156
		db itType_item0, itType_shield,	71h; 159
		db itType_item0, itType_item0, itType_item0; 162
		db itType_item0, itType_item0, itType_item0; 165
		db itType_item0, itType_item0, itType_item0; 168
		db itType_weapon, itType_weapon, itType_weapon;	171
		db itType_weapon, itType_weapon, itType_weapon;	174
		db 71h,	itType_item0, itType_item0; 177
		db itType_item0, itType_armor, itType_item0; 180
		db itType_item0, 11h, itType_ring; 183
		db itType_instrument, 51h, itType_ring;	186
		db itType_armor, itType_figurine, itType_weapon; 189
		db 11h,	itType_weapon, itType_instrument; 192
		db itType_item0, itType_shield,	itType_armor; 195
		db itType_gloves, itType_armor,	itType_weapon; 198
		db itType_armor, itType_item0, itType_armor; 201
		db itType_figurine, itType_item0, itType_helm; 204
		db itType_item0, itType_item0, itType_instrument; 207
		db itType_instrument, itType_item0, itType_weapon; 210
		db itType_armor0, itType_weapon, itType_item0; 213
		db itType_armor, itType_instrument, itType_helm; 216
		db itType_weapon, itType_item0,	itType_wand; 219
		db itType_instrument, itType_item0, itType_item0; 222
		db itType_item0, itType_item0, itType_item0; 225
		db itType_item0, itType_item0, itType_item0; 228
		db itType_item0, itType_item0, itType_item0; 231
		db itType_item0, itType_item0, itType_item0; 234
		db itType_item0, itType_item0, itType_item0; 237
		db itType_armor, itType_armor, itType_gloves; 240
		db itType_item0, itType_weapon,	itType_weapon; 243
		db itType_weapon, itType_weapon, itType_instrument; 246
		db itType_item0, itType_item0, itType_item0; 249
		db itType_item0, itType_item0, itType_item0; 252
		db itType_item0		; 255
classEquipMask	db 80h, 40h, 40h, 40h, 40h, 10h, 8, 4; 0
		db 2, 1, 20h, 60h, 0E0h, 0, 0, 0; 8
itemEquipMask	db 0, 0FFh, 0FFh, 8Fh, 9Fh, 0FFh, 8Fh, 87h; 0
		db 9Fh,	0FFh, 9Fh, 8Eh,	9Fh, 8Fh, 8Eh, 86h; 8
		db 0FFh, 9Fh, 0FFh, 86h, 8, 9Fh, 9Fh, 9Eh; 16
		db 9Eh,	8Fh, 9Eh, 0FFh,	70h, 8,	8, 60h;	24
		db 0FFh, 9Fh, 8Ch, 8Fh,	9Bh, 86h, 0FFh,	9Fh; 32
		db 0FFh, 8, 8Eh, 9Fh, 8Eh, 0FFh, 71h, 8Eh; 40
		db 9Eh,	9Eh, 9Eh, 84h, 4, 99h, 0FFh, 9Eh; 48
		db 0FFh, 8Eh, 2, 86h, 70h, 0FFh, 4, 60h; 56
		db 0FFh, 10h, 8Eh, 60h,	70h, 60h, 8, 8;	64
		db 86h,	8Eh, 8,	86h, 0FFh, 8, 60h, 61h;	72
		db 86h,	0FCh, 0FFh, 9Eh, 8Ch, 84h, 60h,	60h; 80
		db 86h,	8Eh, 9Fh, 8, 9Fh, 8, 8,	62h; 88
		db 8, 60h, 0FFh, 0FFh, 0FFh, 86h, 6Ch, 0FFh; 96
		db 60h,	0FFh, 0FFh, 84h, 86h, 0FFh, 0FFh, 0FFh;	104
		db 0FFh, 0FFh, 0FFh, 60h, 60h, 0FFh, 0FFh, 9Fh;	112
		db 0FFh, 0FFh, 0FFh, 9Fh, 9Fh, 0FFh, 84h, 8Ch; 120
		db 86h,	9Fh, 8,	9Eh, 4,	60h, 2,	86h; 128
		db 0FFh, 0FFh, 1, 2, 60h, 2, 87h, 1; 136
		db 1, 0FFh, 0FFh, 0FFh,	0FFh, 0FFh, 0FFh, 0FFh;	144
		db 84h,	86h, 0FFh, 0FFh, 10h, 10h, 86h,	9Fh; 152
		db 8Eh,	8Eh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh; 160
		db 0FFh, 0FFh, 0FFh, 10h, 4, 10h, 10h, 10h; 168
		db 10h,	10h, 0FFh, 0FFh, 0FFh, 8Eh, 0FFh, 0FFh;	176
		db 60h,	0FFh, 8, 20h, 60h, 70h,	0FFh, 8; 184
		db 10h,	80h, 8,	60h, 8Ch, 84h, 8, 2; 192
		db 80h,	60h, 0FFh, 20h,	20h, 60h, 10h, 10h; 200
		db 10h,	8, 8, 4, 86h, 84h, 84h,	0FFh; 208
		db 70h,	2, 60h,	20h, 60h, 60h, 8, 0FFh;	216
		db 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh; 224
		db 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh; 232
		db 86h,	80h, 60h, 60h, 9Fh, 84h, 2, 60h; 240
		db 8, 0FFh, 0FFh, 0FFh,	0FFh, 0FFh, 0FFh, 0FFh;	248
itemEffectList	db itemEff_none, itemEff_none, itemEff_none, itemEff_none; 0
		db itemEff_none, itemEff_none, itemEff_none, itemEff_none; 4
		db itemEff_none, itemEff_none, itemEff_none, itemEff_none; 8
		db itemEff_none, itemEff_none, itemEff_none, itemEff_none; 12
		db itemEff_none, itemEff_none, itemEff_none, itemEff_none; 16
		db itemEff_none, itemEff_none, itemEff_none, itemEff_none; 20
		db itemEff_none, itemEff_none, itemEff_none, itemEff_none; 24
		db itemEff_none, itemEff_freeSinging, itemEff_none, itemEff_none; 28
		db itemEff_none, itemEff_none, itemEff_none, itemEff_none; 32
		db itemEff_none, itemEff_none, itemEff_none, itemEff_none; 36
		db itemEff_none, itemEff_none, itemEff_none, itemEff_none; 40
		db itemEff_none, itemEff_none, itemEff_none, itemEff_none; 44
		db itemEff_none, itemEff_none, itemEff_none, itemEff_none; 48
		db itemEff_none, itemEff_none, itemEff_none, itemEff_alwaysHide; 52
		db itemEff_none, itemEff_none, itemEff_none, itemEff_none; 56
		db itemEff_none, itemEff_none, itemEff_none, itemEff_anotherSpptRegen; 60
		db itemEff_none, 8, itemEff_none, itemEff_none;	64
		db itemEff_calmMonster,	itemEff_none, itemEff_none, itemEff_none; 68
		db itemEff_none, itemEff_none, itemEff_none, itemEff_none; 72
		db itemEff_none, itemEff_none, itemEff_halfSpptUsage, itemEff_none; 76
		db itemEff_none, itemEff_none, itemEff_breathDefense, itemEff_none; 80
		db itemEff_none, itemEff_none, itemEff_none, itemEff_none; 84
		db itemEff_none, itemEff_none, itemEff_alwaysRunAway, itemEff_none; 88
		db itemEff_none, itemEff_none, itemEff_none, itemEff_none; 92
		db itemEff_freeSinging,	itemEff_none, itemEff_none, itemEff_none; 96
		db itemEff_regenHP, itemEff_none, itemEff_none,	itemEff_none; 100
		db itemEff_none, itemEff_none, itemEff_none, itemEff_regenHP; 104
		db itemEff_none, itemEff_none, 0Bh, itemEff_noSpin; 108
		db itemEff_none, itemEff_none, itemEff_none, itemEff_none; 112
		db itemEff_none, itemEff_none, itemEff_none, itemEff_none; 116
		db itemEff_none, itemEff_none, itemEff_none, itemEff_none; 120
		db itemEff_none, itemEff_none, itemEff_none, itemEff_none; 124
		db itemEff_none, itemEff_none, itemEff_none, itemEff_none; 128
		db itemEff_none, itemEff_none, itemEff_none, itemEff_none; 132
		db itemEff_none, itemEff_none, itemEff_none, itemEff_none; 136
		db itemEff_anotherSpptRegen, itemEff_none, itemEff_none, itemEff_none; 140
		db itemEff_none, itemEff_none, itemEff_none, itemEff_none; 144
		db itemEff_none, itemEff_none, itemEff_none, itemEff_none; 148
		db itemEff_none, itemEff_none, itemEff_none, itemEff_none; 152
		db 8, itemEff_none, itemEff_none, itemEff_none;	156
		db itemEff_breathDefense, itemEff_none,	itemEff_none, itemEff_none; 160
		db itemEff_none, itemEff_none, itemEff_none, itemEff_none; 164
		db itemEff_none, itemEff_none, itemEff_none, itemEff_none; 168
		db itemEff_none, itemEff_alwaysHide, 8,	itemEff_none; 172
		db itemEff_none, itemEff_breathDefense,	itemEff_none, itemEff_none; 176
		db itemEff_none, itemEff_none, itemEff_none, itemEff_none; 180
		db itemEff_regenSppt, itemEff_resurrect, itemEff_alwaysHide, itemEff_halfSpptUsage; 184
		db itemEff_none, itemEff_none, itemEff_none, itemEff_none; 188
		db itemEff_none, itemEff_none, itemEff_freeSinging, itemEff_none; 192
		db itemEff_none, itemEff_none, itemEff_none, itemEff_none; 196
		db itemEff_none, itemEff_none, itemEff_none, itemEff_none; 200
		db itemEff_regenSppt, itemEff_none, 8, itemEff_alwaysHide; 204
		db itemEff_none, itemEff_none, itemEff_none, itemEff_none; 208
		db itemEff_none, itemEff_none, itemEff_none, itemEff_none; 212
		db itemEff_none, itemEff_none, itemEff_resurrect, itemEff_regenSppt; 216
		db itemEff_none, itemEff_none, itemEff_none, itemEff_none; 220
		db itemEff_none, itemEff_none, itemEff_none, itemEff_none; 224
		db itemEff_none, itemEff_none, itemEff_none, itemEff_none; 228
		db itemEff_none, itemEff_none, itemEff_none, itemEff_none; 232
		db itemEff_none, itemEff_none, itemEff_none, itemEff_none; 236
		db itemEff_none, itemEff_none, itemEff_none, itemEff_none; 240
		db itemEff_none, itemEff_none, itemEff_none, itemEff_quaterSpptUse; 244
		db itemEff_none, itemEff_none, itemEff_none, itemEff_none; 248
		db itemEff_none, itemEff_none, itemEff_none, itemEff_none; 252
itemSpellNo	db 255, 126, 127, 255   ; 0	; This array holds the spell number to call when
		db 255,	255, 131, 255	; 4 ; using the	particular item
		db 255,	255, 255, 255	; 8
		db 255,	255, 255, 255	; 12
		db 255,	255, 255, 255	; 16
		db 255,	131, 131, 255	; 20
		db 255,	255, 255, 132	; 24
		db 255,	255, 133, 6	; 28
		db 255,	255, 255, 131	; 32
		db 131,	255, 132, 131	; 36
		db 255,	255, 131, 131	; 40
		db 6, 255, 255,	255	; 44
		db 255,	255, 255, 255	; 48
		db 255,	131, 14, 255	; 52
		db 132,	255, 131, 255	; 56
		db 255,	132, 255, 255	; 60
		db 255,	255, 255, 51	; 64
		db 255,	49, 54,	133	; 68
		db 131,	255, 255, 255	; 72
		db 255,	132, 255, 34	; 76
		db 255,	66, 255, 133	; 80
		db 255,	255, 69, 133	; 84
		db 64, 255, 255, 133	; 88
		db 131,	35, 11,	55	; 92
		db 131,	36, 132, 132	; 96
		db 255,	131, 73, 63	; 100
		db 75, 77, 78, 131	; 104
		db 255,	78, 255, 255	; 108
		db 130,	130, 130, 130	; 112
		db 67, 128, 129, 131	; 116
		db 255,	130, 122, 130	; 120
		db 131,	129, 255, 255	; 124
		db 255,	131, 69, 255	; 128
		db 11, 133, 131, 255	; 132
		db 130,	130, 7,	131	; 136
		db 255,	255, 255, 15	; 140
		db 21, 130, 130, 130	; 144
		db 130,	130, 130, 255	; 148
		db 130,	130, 255, 255	; 152
		db 255,	130, 75, 131	; 156
		db 130,	91, 130, 130	; 160
		db 130,	130, 130, 130	; 164
		db 130,	130, 130, 11	; 168
		db 11, 255, 255, 61	; 172
		db 71, 255, 255, 255	; 176
		db 255,	255, 78, 126	; 180
		db 37, 255, 133, 255	; 184
		db 69, 255, 132, 11	; 188
		db 255,	12, 69,	134	; 192
		db 255,	255, 255, 255	; 196
		db 255,	255, 15, 73	; 200
		db 132,	87, 45,	255	; 204
		db 133,	17, 15,	62	; 208
		db 255,	255, 255, 34	; 212
		db 255,	255, 55, 255	; 216
		db 134,	99, 133, 95	; 220
		db 255,	255, 255, 255	; 224
		db 255,	255, 255, 255	; 228
		db 255,	255, 255, 255	; 232
		db 255,	255, 255, 255	; 236
		db 255,	255, 255, 134	; 240
		db 131,	255, 255, 120	; 244
		db 133,	255, 255, 255	; 248
		db 255,	255, 255, 255	; 252
g_raceString	dd aHuman		   ; 0
		dd aElf			; 1
		dd aDwarf		; 2
		dd aHobbit		; 3
		dd aHalfElf		; 4
		dd aHalfOrc		; 5
		dd aGnome		; 6
s_genderString	dd aMale_0		     ; 0
		dd aFemale		; 1
		dd nullStr
		s_isAn db ' is a/n \ ',0
align 2
s_level		db 'Level',0
g_acDexterityBonus db 1, 1, 2, 2		 ; 0
		db 3, 3, 3, 4		; 4
		db 4, 4, 4, 4		; 8
		db 5, 5, 5, 5		; 12
		db 5, 0			; 16
g_itemFlagCharacters	db ' ', '|', '^', '?', 0, 0; 0 ; This is a list of characters used in the inventory
			; string for flags.
			
			
			
g_inventoryActionFunctions	dd inventory_trade, inventory_discard, inventory_equip, inventory_unequip, inventory_identify;	0
s_escToContinue	db 'ESC to continue',0
s_thereAreStairs	db 'There are stairs here, going /up\down\. ',0Ah
		db 'Do you wish to take them?',0
align 2
s_whoWantsToGetThe	db 'Who wants to get the ',0
align 2
s_gotThe		db ' got the ',0
s_youDontHaveEnoughGold	db 'You don',27h,'t have enough gold',0
s_zounds		db 'Zounds',0
s_percentD		db '%d',0
s_badOpcode	db 'bad opcode',0
vm_functionList	dd mfunc_downStairs ;	0
		dd mfunc_upStairs	; 1
		dd mfunc_utility		; 2
		dd mfunc_teleport	; 3
		dd mfunc_battle		; 4
		dd mfunc_clearPrintString ; 5
		dd mfunc_clearSpecial		; 6
		dd mfunc_drawBigpic	; 7
		dd mfunc_setTitle	; 8
		dd mfunc_waitForIo	; 9
		dd mfunc_clearText ; a
		dd mfunc_ifFlag		; b
		dd mfunc_ifNotFlag	; c
		dd mfunc_makeDoor		; d
		dd mfunc_setFlag	; e
		dd mfunc_clearFlag	; f
		dd mfunc_ifCurSpellEQ	; 10
		dd mfunc_setMapRval	; 11
		dd mfunc_printString	; 12
		dd mfunc_doNothing	; 13
		dd mfunc_ifLiquid	; 14
		dd mfunc_getItem	; 15
		dd mfunc_ifPartyHasItem	; 16
		dd mfunc_ifPartyNotHasItem	; 17
		dd mfunc_ifSameSquare	; 18
		dd mfunc_ifYesNo	; 19
		dd mfunc_goto		; 1a
		dd mfunc_battleNoCry	; 1b
		dd mfunc_setSameSquareFlag	; 1c
		dd mfunc_turnAround	; 1d
		dd mfunc_removeItem	; 1e
		dd mfunc_incrementRegister	; 1f
		dd mfunc_decrementRegister	; 20
		dd mfunc_ifRegisterClear	; 21
		dd mfunc_ifRegisterSet	; 22
		dd mfunc_drainHp	; 23
		dd mfunc_ifInBox	; 24
		dd mfunc_setLiquid	; 25
		dd mfunc_addToContainer	; 26
		dd mfunc_subtractFromContainer	; 27
		dd mfunc_addToRegister	; 28
		dd mfunc_subtractFromRegister ; 29
		dd mfunc_setDirection	; 2a
		dd mfunc_readString	; 2b
		dd mfunc_ifStringEquals	; 2c
		dd mfunc_parseNumber	; 2d
		dd mfunc_getCharacter	; 2e
		dd mfunc_ifGiveGold	; 2f
		dd mfunc_addGold		; 30
		dd mfunc_ifRegisterLt	; 31
		dd mfunc_ifRegisterEq	; 32
		dd mfunc_ifRegisterGe	; 33
		dd mfunc_learnSpell	; 34
		dd mfunc_setRegister	; 35
		dd mfunc_ifHasItem	; 36
		dd mfunc_packInventory	; 37
		dd mfunc_addMonster	; 38
		dd mfunc_ifMonsterInParty	; 39
		dd mfunc_clearPrintOffset ; 3a
		dd mfunc_ifIsNight	; 3b
		dd mfunc_removeMonster	; 3c
;		dd mfunc_buggedIfQuestFlagSet		; 3d
		dd mfunc_notImplemented		; 3d
		dd mfunc_ifQuestFlagNotSet		; 3e
		dd mfunc_setQuestFlag ; 3f
		dd mfunc_clearQuestFlag		; 40
		dd mfunc_partyUnderLevel		; 41
		dd mfunc_ifWildFace ; 42
		dd mfunc_setWildFace	; 43
		dd mfunc_ifIsClass	; 44
		dd mfunc_printOffset ; 45
		dd mfunc_clearTeleport	; 46
s_notImplemented	db 'this function is not implemented',0
align 2
aKilling	db ', killing ',0
aPoisoning	db ', poisoning ',0
aDraining	db ', draining ',0
aCrazing	db ', crazing ',0
aWithering	db ', withering ',0
aPossessing 	db ', possessing ',0
aStoning	db ', stoning ',0
aCriticallyHitt	db ', critically hitting ',0
aStealing	db ', stealing ',0
aPhazing	db ', phazing ',0
aSwingsAt	db 'swings at',0
aSlashesAt	db 'slashes at',0
aKicksAt	db 'kicks at',0
aPunchesAt	db 'punches at',0
aClawsAt	db 'claws at',0
aTearsAt	db 'tears at',0
aBitesAt	db 'bites at',0
aGnawsOn	db 'gnaws on',0
aStabsAt	db 'stabs at',0
aSlicesAt	db 'slices at',0
aSlams		db 'slams',0
aStrikesAt	db 'strikes at',0
aGropesAt	db 'gropes at',0
aReachesToward	db 'reaches toward',0
aPeersAt	db 'peers at',0
aStaresAt	db 'stares at',0
aDissentionInYo	db 'Dissention in your ranks...',0Ah
db 0Ah,0
aWillThereEverB	db '"Will there ever be an end to them?" you shout. You see ',0
aEnjoyYourNextL	db '"Enjoy your next life!" you snarl. You see ',0
aYourBattlecryI	db 'Your battlecry is heard by all as you face ',0
aYourOnslaughtI	db 'Your onslaught is greeted with laughter, you face ',0
aNotAgainYouMoa	db '"Not again!" you moan as you face ',0
aGimmeABreakWhe	db '"Gimme a break! Where do they come from?" You see ',0
align 2
specialAttString dd aKilling, aPoisoning, aDraining, aCrazing, aWithering; 0
		dd aPossessing,	aStoning, aCriticallyHitt, aStealing, aPhazing;	5
breathAttack	breathAtt_t <0, 0, 0, 0, 0, 41h, 1>; 0
		db    0
aYouStillFace	db 'You still face ',0
s_continueQuestion	db 'Do you wish to continue?',0Ah,0
s_butMisses	db ', but misses!',0Ah,0Ah,0
s_periodNlNl	db '.', 0Ah, 0Ah,0
s_exclBlankLine		db '!',0Ah, 0Ah,0
s_jumpsIntoShadows	db ' jumps into the shadows, ',0
s_andSucceeds	db 'and succeeds!',0Ah,0Ah,0
s_butIsDiscovered db 'but is discovered!',0Ah,0Ah,0
		db    0
s_summonsHelp	db ' summons help and ',0
		db    0
s_noneAppears	db 'none appears...',0Ah,0Ah,0
s_anotherJoins db	'another joins the fray!',0Ah,0Ah,0
s_the		db	'The ',0
		db    0
s_advances	db ' advance/s\!',0Ah,0Ah,0
		db    0
s_butMisses_0	db ', but misses',0
		db    0
aWillYourGallantBand db	'Will your gallant band choose to:',0Ah
		db '@Fight bravely',0Ah
		db '@Advance ahead',0Ah
		db '@Run away',0Ah,0
		db    0
aThePartyAdvances db 0Ah,0Ah,'The party advances!',0Ah,0Ah,0
aHasTheseOptionsThisBa db ' has these options this battle round:',0Ah,0Ah
		db '@Attack foes ',0
		db    0
byte_4724A	db 31h
		db  30h	; 0
		db  27h	
		db    0
a@defend@partyAttack@c db 0Ah
		db '@Defend',0Ah
		db '@Party attack',0Ah
		db '@Cast a spell',0Ah
		db '@Use an item',0Ah
		db '@Hide in shadows',0Ah
		db '@Bard Song',0Ah,0
		db    0
aSelectAnOption_ db 0Ah,0Ah,'Select an option.',0
s_nlUseOn	db 0Ah,'Use on ',0
		db    0
aYouCanTUseThatItem_ db	'You can',27h,'t use that item.',0
		db    0
s_attack	db 0Ah,'Attack ',0
		db    0
s_useTheseCommands? db 'Use these commands?',0Ah,0Ah,0
aAndHits	db ', and hits ',0
aTimesFor	db ' times for ',0
aAndHitsFor	db ', and hits for ',0
s_firesBreathes	db ' /fir\breath\es ',0
		db    0
s_lost		db ' lost ',0
		db    0
s_voice		db ' voice!',0Ah,0Ah,0
s_plays	db ' plays...',0Ah,0Ah,0
aHostilePartyMembers db	'hostile party members!',0Ah,0Ah,0
		db    0
asc_473AE	db ',',0
aAnd_1		db 'and ',0
		db 0
a__1		db '.',0Ah,0Ah,0
aParty		db 'Party',0
aSorryBud	db 'Sorry, Bud',0
		db    0
aAlasYourPartyHasExp db	'Alas, your party has expired, but gone to adventurer heaven.',0
		db    0
g_monkDamageDice	db 20h, 21h, 22h, 23h, 24h, 25h, 26h, 27h
			db 68h, 69h, 6Ah, 6Bh, 6Ch, 6Dh, 6Eh, 8Fh
monMeleeAttString dd aSwingsAt		  ; 0
		dd aSlashesAt		; 1
		dd aKicksAt		; 2
		dd aPunchesAt		; 3
		dd aClawsAt		; 4
		dd aTearsAt		; 5
		dd aBitesAt		; 6
		dd aGnawsOn		; 7
		dd aStabsAt		; 8
		dd aSlicesAt		; 9
		dd aSlams		; 10
		dd aStrikesAt		; 11
		dd aGropesAt		; 12
		dd aReachesToward	; 13
		dd aPeersAt		; 14
		dd aStaresAt		; 15
itemLevMask	db 0, 81h, 81h, 81h, 81h, 81h, 81h,	81h; 0
		db 81h,	81h, 81h, 81h, 81h, 81h, 81h, 81h; 8
		db 81h,	81h, 81h, 81h, 81h, 81h, 0C1h, 41h; 16
		db 41h,	41h, 41h, 41h, 41h, 41h, 41h, 41h; 24
		db 41h,	41h, 41h, 41h, 41h, 41h, 41h, 41h; 32
		db 41h,	41h, 41h, 41h, 41h, 41h, 41h, 31h; 40
		db 31h,	31h, 31h, 31h, 31h, 31h, 31h, 31h; 48
		db 31h,	31h, 31h, 31h, 31h, 31h, 31h, 31h; 56
		db 31h,	31h, 31h, 31h, 31h, 31h, 31h, 31h; 64
		db 31h,	19h, 19h, 19h, 19h, 19h, 19h, 19h; 72
		db 19h,	19h, 19h, 19h, 19h, 19h, 19h, 19h; 80
		db 19h,	19h, 19h, 19h, 19h, 19h, 19h, 19h; 88
		db 19h,	19h, 19h, 19h, 19h, 19h, 19h, 19h; 96
		db 19h,	19h, 19h, 19h, 19h, 19h, 19h, 19h; 104
		db 0, 0, 0, 0, 0, 0, 0FFh, 0; 112
		db 0, 0, 0, 0, 0, 0FFh,	9, 9; 120
		db 9, 9, 9, 9, 9, 9, 9,	0; 128
		db 0, 0, 9, 9, 9, 9, 9,	9; 136
		db 9, 0, 0, 0, 0, 0, 0,	0; 144
		db 0, 0, 0, 0, 0, 0, 5,	5; 152
		db 0, 0, 0, 0, 0, 9, 9,	9; 160
		db 9, 0, 0, 3, 3, 41h, 9, 11h; 168
		db 5, 1, 0, 0, 0, 9, 9,	9; 176
		db 9, 9, 9, 9, 9, 9, 9,	9; 184
		db 9, 9, 9, 7Fh, 5, 5, 5, 5; 192
		db 5, 5, 5, 5, 5, 5, 5,	5; 200
		db 5, 5, 5, 5, 5, 3, 3,	3; 208
		db 3, 3, 3, 3, 3, 3, 3,	1Dh; 216
		db 0, 0, 0, 0, 0, 0, 0,	0; 224
		db 0, 0, 0, 0, 0, 0, 0,	0; 232
		db 1, 1, 1, 1, 1, 1, 1,	1; 240
		db 1, 0, 0, 0, 0, 0, 0,	0; 248
battleCryString	dd aDissentionInYo	; 0
		dd aWillThereEverB	; 1
		dd aEnjoyYourNextL	; 2
		dd aYourBattlecryI	; 3
		dd aYourOnslaughtI	; 4
		dd aNotAgainYouMoa	; 5
		dd aGimmeABreakWhe	; 6
aMember17	db 'member #(1-7)',0
aMember1	db 'member #(1)',0
aOr		db ' or ',0
		db    0
vowelList	db 'A', 'E', 'I', 'O', 'U', 0               ; 4
byte_475AE	db 5, 7, 7, 3	   ; 0
		db 3, 0, 0, 5		; 4
		db 5, 0Ah, 0Fh,	0Fh	; 8
		db 16h			; 12
aBadDiceMaskRange db 'Bad dice mask range',0
		db    0
off_475D0	dd bat_partyFightAction
		dd bat_partyAdvanceAction
		dd bat_partyRunAction
off_475DC	dd bat_charAttackAction, bat_charDefendAction; 0
		dd bat_charPartyAttackAction, bat_charCastAction; 2
		dd bat_charUseAction, bat_charHideAction;	4
		dd bat_charSingAction		; 6
g_classToHitBonus	db 3, 1, 1, 1, 1, 0, 0, 3, 3, 4, 1, 1, 4, 0
g_monsterAcBonusList	db 3, 2, 0, 0FEh	   ; 0
g_monsterAdvanceSpeedAcBonusList	db 0FFh, 0FFh, 0FFh, 0, 0, 0, 0, 0, 1, 1
s_experiencePoinsForV db ' experience points for valor and battle knowledge, and ',0
aTheyDisbelieve	db 'They disbelieve!',0Ah,0Ah,0
		db    0
aInGold_	db ' in gold.',0Ah,0Ah,0
aFoundA		db ' found a ',0
aEachCharacterReceive db 'Each character receives ',0
		db    0
aThePartyDisbelieves_ db 'The party disbelieves...',0Ah,0Ah,0
		db    0

s_chestPrompt db 'There is a chest here. Will you:',0Ah,0Ah
		db '@Examine chest',0Ah
		db '@Open chest',0Ah
		db '@Disarm chest',0Ah
		db '@Trap Zap',0Ah
		db '@Leave chest',0
s_whoWillCastTrzp	db 'Who will cast a TRZP?',0
s_dontKnowThatSpell_	db 'You don',27h,'t know that spell.',0
		db    0
s_needTwoSpellPoints	db 'You need at least 2 spell points.',0
s_whoWillExamine	db 'Who will examine it?',0
		db    0
s_looksLike	db 'It looks like a ',0
		db    0
s_alreadyExamined	db 'That character has already checked.'
		db 0
s_foundNothing	db 'You found nothing.',0
		db    0
s_whoWillDisarm	db 'Who will disarm it?',0
s_enterTrapName	db 'Enter trap name:',0
		db    0
s_disarmFailed	db 'Disarm failed!',0
		db    0
s_youDisarmedIt	db 'You disarmed it!',0
		db    0
s_whoWillOpen	db 'Who will open it?',0
s_youSetOff	db 'You set off a ',0
		db    0


g_chestTrapFlags	db 1		; 0
			db 1		; 1
			db 0		; 2
			db 80h				; 3
			db 1		; 4
			db 1		; 5
			db 80h				; 6
			db 3	; 7
			db 1		; 8
			db 1		; 9
			db 80h				; 10
			db 9	; 11
			db 1 or 80h	; 12
			db 80h				; 13
			db 1 or 80h	; 14
			db 1 or 80h	; 15
			db 1		; 16
			db 3	; 17
			db 0		; 18
			db 6		; 19
			db 1 or 80h	; 20
			db 4    or 80h	; 21
			db 8	; 22
			db 80h				; 23
			db 1 or 80h	; 24
			db 1 or 80h	; 25
			db 1 or 80h	; 26
			db 1 or 80h	; 27
			db 1 or 80h	; 28
			db 1 or 80h	; 29
			db 1 or 80h	; 30
			db 1 or 80h	; 31

g_chestTrapDice	db 41h, 41h, 44h, 41h,	43h, 43h, 46h, 42h; 0
		db 45h,	45h, 47h, 46h, 47h, 48h, 47h, 47h; 8
		db 49h,	47h, 49h, 21h, 49h, 47h, 45h, 49h; 16
		db 49h,	49h, 49h, 49h, 49h, 49h, 49h, 49h; 24
g_chestTrapSaveData	saveStru 4 dup(<0Fh,	0Fh>); 0
		saveStru 4 dup(<13h, 13h>); 4
		saveStru 4 dup(<15h, 15h>); 8
		saveStru 4 dup(<18h, 18h>); 12
		saveStru 4 dup(<26h, 26h>); 16
		saveStru <27h, 27h>	; 20
		saveStru <28h, 28h>	; 21
		saveStru <27h, 27h>	; 22
		saveStru 9 dup(<28h, 28h>); 23
s_chest		db 'Chest!',0
		db    0
g_chestTrapIndexToName	db 0		;  0 - Poison needle
			db 1		;  1 - Poison blades
			db 2		;  2 - Blades
			db 3		;  3 - Shockwave
			db 0		;  4 - Poison needle
			db 1		;  5 - Poison blades
			db 3		;  6 - Shockwave
			db 4		;  7 - Crazy cloud
			db 0		;  8 - Poison needle
			db 1		;  9 - Poison blades
			db 6		; 10 - Shocks
			db 5		; 11 - Vortex
			db 7		; 12 - Poison darts
			db 8		; 13 - Acid burst
			db 9		; 14 - Gas cloud
			db 9		; 15 - Gas cloud
			db 0Ah		; 16 - Poison Spikes
			db 0Bh		; 17 - Mind blast
			db 0Ch		; 18 - Mind jab
			db 0Dh		; 19 - Basilisk snare
			db 0Eh		; 20 - Death blades
			db 0Fh		; 21 - Codger bomb
			db 10h		; 22 - Swindler
			db 11h		; 23 - Hammer
			db 0Eh		; 24 - Death blades
			db 0Eh		; 25 - Death blades
			db 0Eh		; 26 - Death blades
			db 0Eh		; 27 - Death blades
			db 0Eh		; 28 - Death blades
			db 0Eh		; 29 - Death blades
			db 0Eh		; 30 - Death blades
			db 0Eh		; 31 - Death blades

s_chestPoisonNeedle	db 'Poison Needle',0
s_chestPoisonBlades	db 'Poison Blades',0
s_chestBlades		db 'Blades',0
s_chestShockwave	db 'Shock Wave',0
s_chestCrazyCloud	db 'Crazycloud',0
s_chestVortex		db 'Vortex',0
s_chestShocks		db 'Shocks',0
s_chestPoisonDarts	db 'Poison Darts',0
s_chestAcidBurst	db 'Acid Burst',0
s_chestGasCloud		db 'Gas Cloud',0
s_chestPoisonSpikes	db 'Poison Spikes',0
s_chestMindBlast	db 'Mind Blast',0
s_chestMindJab		db 'Mind Jab',0
s_chestBasiliskSnare	db 'Basilisk Snare',0
s_chestDeathBlades	db 'Death Blades',0
s_chestCodgerBomb	db 'Codger Bomb',0
s_chestSwindler		db 'Swindler',0
s_chestHammer		db 'Hammer',0
			db    0
g_chestTrapName	dd s_chestPoisonNeedle		; 0
		dd s_chestPoisonBlades		; 1
		dd s_chestBlades		; 2
		dd s_chestShockwave		; 3
		dd s_chestCrazyCloud		; 4
		dd s_chestVortex		; 5
		dd s_chestShocks		; 6
		dd s_chestPoisonDarts		; 7
		dd s_chestAcidBurst		; 8
		dd s_chestGasCloud		; 9
		dd s_chestPoisonSpikes		; 10
		dd s_chestMindBlast		; 11
		dd s_chestMindJab		; 12
		dd s_chestBasiliskSnare		; 13
		dd s_chestDeathBlades		; 14
		dd s_chestCodgerBomb		; 15
		dd s_chestSwindler		; 16
		dd s_chestHammer		; 17
g_chestActionFunctions	dd chest_examine, chest_open,	chest_disarm, chest_trapZap, chest_returnOne


poisonDmg	db 1, 2, 4, 8, 0Ah, 10h, 14h, 18h; 0
aTreasure	db 'Treasure',0
aFried		db 'fried',0
aFrozen		db 'frozen',0
aShocked	db 'shocked',0
aDrained	db 'drained',0
aBurnt		db 'burnt',0
aChoked		db 'choked',0
aSteamed	db 'steamed',0
aBlasted	db 'blasted',0
aHit		db 'hit',0
aNuked		db 'nuked',0
aLessThirsty_	db 'less thirsty.',0Ah,0Ah,0
aHicHappier_	db '(hic) happier.',0Ah,0Ah,0
aRefreshed	db 'refreshed!',0Ah,0Ah,0
aTerrible_	db 'terrible.',0Ah,0Ah,0
aTheEntryStairs	db 'the entry stairs.',0
aTheEntryPortal	db 'the entry portal.',0
aTheEntryway_	db 'the entryway.',0
aTheBaseOfTheMo	db 'the base of the mountain.',0
aAVantagePoint_	db 'a vantage point.',0
aTheWayIn_	db 'the way in.',0
aTheExit_	db 'the exit.',0
align 2
aYouCanOnlyCast	db 'You can only cast that in combat',0Ah,0Ah,0
align 2
s_atTheParty	db 'at the party...',0Ah,0Ah,0
s_partyTooFarAway	db 'But the party was too far away!',0Ah,0Ah,0
s_at		db 'at ',0
s_some		db 'some ',0
s_elipsisNl	db '...',0Ah,0Ah,0
s_one		db 'One ',0
align 2
s_repelledAttack	db 'repelled the attack!',0Ah,0Ah,0
align 2
s_wasTooFarAway db 'was too far away!',0Ah,0Ah,0
s_is		db 'is ',0
a_for		db	' for ',0
aPointSOfDamage	db ' point/\s\ of damage',0
align 2
aAnd		db	'And ',0
align 2
s_partyFreezes	db 'and the party freezes',0
s_butItHadNoEffect	db 'but it had no effect!',0Ah,0Ah,0
s_closer		db 'closer',0
align 2
s_fartherAway	db 'farther away',0
align 2
s_andTheFoesAre	db 'and the foes are ',0
align 2
s_theParty	db 'the party!',0
align 2
s_earthSwallows	db 'and the earth swallows up ',0
align 2
s_whichItem	db 'Which item?',0
s_spellAborted	db 'Spell aborted.',0
align 2
s_itemIdentified	db 'Item has been identified!',0
s_dopplganger	db 'Dopplganger',0
s_ateIt		db 'ate it.',0Ah,0Ah,0
s_drinksAndFeels	db 'drinks and feels ',0
drinkStringList	dd aLessThirsty_, aHicHappier_, aRefreshed, aTerrible_, aTerrible_;	0
s_cantFindUse	db 'can',27h,'t seem to find a use for the item.',0Ah,0Ah,0
align 2
s_invokesFigurine	db 'invokes a figurine ',0
s_isReenergized	db 'is re-energized!',0Ah,0Ah,0
align 2
s_castsWeapon	db 'casts a weapon ',0
s_breathes	db 'breathes ',0
s_teleportMenu	db 'Teleport',0Ah
		db '<Use arrow keys and SPC to select>',0Ah
		db 'North:',0Ah
		db 'East :',0Ah,0
s_downUp		db '/Down\Up  \ :',0Ah,0
align 2
s_confirmTeleport	db 0Ah,'Teleport?',0Ah,0Ah,0
align 2
s_cancelTeleport	db 'Teleport cancelled!',0
s_failedTeleport	db 'Teleport failed!',0
align 2
s_successfulTeleport	db 'Teleport successful!',0
align 2
s_youFace	db 'You face ',0
s_levels		db ' level/\s',0
s_aboveBelow	db ' /above\below\',0
align 2
s_paces		db ' pace/\s',0
align 2
s_northSouth	db ' /north\south\',0
align 2
s_eastWest	db ' /east\west\',0
align 2
s_andAreAt	db ' and are at ',0
align 2
s_of		db ' of ',0
align 2
s_andAre		db ' and /\are \',0
align 2
scryBaseStringList dd aTheEntryStairs, aTheEntryPortal,	aTheEntryway_
		dd aTheBaseOfTheMo, aAVantagePoint_, aTheWayIn_
		dd aTheExit_
byte_47EDC	db 0, 0, 4, 2	   ; 0
		db 2, 2, 2, 9		; 4
		db 0, 0, 0, 0		; 8
		db 0, 0, 0, 0		; 12
		db 4, 4, 4, 4		; 16
		db 8, 8, 0, 0		; 20
		db 0, 0, 0, 0		; 24
		db 0, 6, 6, 0		; 28
		db 0, 0, 0, 0		; 32
		db 0, 0, 0, 0		; 36
		db 0, 0, 0, 0		; 40
		db 0, 0Eh, 0, 0Ah	; 44
		db 0, 0, 0, 3		; 48
		db 0, 0, 0, 0		; 52
		db 10h,	15h, 1,	1	; 56
		db 1, 0			; 60
byte_47F1A	db 0, 0, 0Eh, 0	   ; 0
		db 0, 0, 0, 0		; 4
		db 0, 0, 0, 0		; 8
		db 4, 4, 4, 4		; 12
		db 0, 0, 0, 0		; 16
		db 2, 2, 1, 1		; 20
		db 9, 9, 0, 0		; 24
		db 0, 0, 0, 0		; 28
		db 0, 0, 0, 0		; 32
		db 0, 0, 0, 0		; 36
		db 0, 0, 0Ah, 0Ah	; 40
		db 0Ah,	0Bh, 0,	0	; 44
		db 6, 6, 6, 0Ch		; 48
		db 0Eh,	0Eh, 0Eh, 0Eh	; 52
		db 0Ah,	3, 1, 1		; 56
		db 0, 0			; 60
byte_47F58	db 0, 0, 2, 0	   ; 0
		db 0, 0, 0, 2		; 4
		db 0, 0, 0, 0		; 8
		db 0, 0, 0, 0		; 12
		db 0, 0, 0, 0		; 16
		db 0, 0, 0, 0		; 20
		db 3, 3, 0, 0		; 24
		db 0, 0, 0, 4		; 28
		db 4, 4, 4, 4		; 32
		db 4, 4, 4, 4		; 36
		db 0, 0, 5, 5		; 40
		db 5, 6, 6, 6		; 44
		db 6, 6, 6, 1		; 48
		db 0, 0, 0, 0		; 52
		db 2, 2, 1, 2		; 56
spellCastFlags	db 1Ch		; 0
		db 0Bh		; 1
		db 14h		; 2
		db 0Ah		; 3
		db 1Ch		; 4
		db 38h		; 5
		db 1Ch		; 6
		db 1Ch		; 7
		db 0Ah		; 8
		db 1Ch		; 9
		db 38h		; 10
		db 1Ch		; 11
		db 0Ah		; 12
		db 3Ch		; 13
		db 1Ch		; 14
		db 38h		; 15
		db 14h		; 16
		db 0Ah		; 17
		db 1Ch		; 18
		db 28h		; 19
		db 38h		; 20
		db 14h		; 21
		db 0Bh		; 22
		db 28h		; 23
		db 1Ch		; 24
		db 1Ch		; 25
		db 28h		; 26
		db 0Ah		; 27
		db 0Bh		; 28
		db 0Ah		; 29
		db 0Ch		; 30
		db 2Ch		; 31
		db 14h		; 32
		db 1Ch		; 33
		db 3Ch		; 34
		db 0Bh		; 35
		db 0Ah		; 36
		db 38h		; 37
		db 0Bh		; 38
		db 0Ch		; 39
		db 1Ch		; 40
		db 0Ch		; 41
		db 1Ch		; 42
		db 0Ah		; 43
		db 1Ch		; 44
		db 0Ch		; 45
		db 1Ch		; 46
		db 1Ch		; 47
		db 1Ch		; 48
		db 0Ch		; 49
		db 0Ch		; 50
		db 1Ch		; 51
		db 1Ch		; 52
		db 0Ch		; 53
		db 1Ch		; 54
		db 0Ah		; 55
		db 0FCh		; 56
		db 1Ch		; 57
		db 0Ah		; 58
		db 1Ch		; 59
		db 0Bh		; 60
		db 0Ah		; 61
		db 38h		; 62
		db 1Ch		; 63
		db 8		; 64
		db 0Ah		; 65
		db 0Bh		; 66
		db 1Ch		; 67
		db 38h		; 68
		db 0Ah		; 69
		db 0Ah		; 70
		db 0Ch		; 71
		db 0Ah		; 72
		db 1Ch		; 73
		db 0Ch		; 74
		db 0Ah		; 75
		db 1Ch		; 76
		db 1Ch		; 77
		db 0Ch		; 78
		db 38h		; 79
		db 1Ch		; 80
		db 1Ch		; 81
		db 0Ah		; 82
		db 0Ah		; 83
		db 1Ch		; 84
		db 1Ch		; 85
		db 0Ah		; 86
		db 0Ch		; 87
		db 1Ch		; 88
		db 1Ch		; 89
		db 0Ch		; 90
		db 0Bh		; 91
		db 1Ch		; 92
		db 1Ch		; 93
		db 14h		; 94
		db 38h		; 95
		db 1Ch		; 96
		db 1Ch		; 97
		db 38h		; 98
		db 0Ah		; 99
		db 1Ch		; 100
		db 1Ch		; 101
		db 1Ch		; 102
		db 0Ch		; 103
		db 1Ch		; 104
		db 1Ch		; 105
		db 0Ah		; 106
		db 14h		; 107
		db 14h		; 108
		db 0Ch		; 109
		db 1Ch		; 110
		db 14h		; 111
		db 0Bh		; 112
		db 14h		; 113
		db 14h		; 114
		db 0Ah		; 115
		db 14h		; 116
		db 0Bh		; 117
		db 14h		; 118
		db 0Ah		; 119
		db 0Ch		; 120
		db 0Ah		; 121
		db 14h		; 122
		db 0FCh		; 123
		db 0Ch		; 124
		db 1Ch		; 125
		db 1Ch		; 126
		db 1Ch		; 127
		db 1Ch		; 128
		db 1Ch		; 129
		db 1Ch		; 130
		db 0Bh		; 131
		db 1Ch		; 132
		db 0Ah		; 133
		db 1Ch		; 134
		db 0Ch		; 135
spellEffectFlags db splf_mageflame	; 0 Mage Flame
		db 0B6h			; 1
		db 0			; 2
		db 2			; 3
		db 20h			; 4
		db 4			; 5
		db splf_lesserrev	; 6
		db 4			; 7
		db 2Ah			; 8
		db 0			; 9
		db 0Ah			; 10
		db splf_greaterrev	; 11
		db 31h			; 12
		db 0Ah			; 13
		db 0FFh			; 14
		db 0FDh			; 15
		db 0			; 16
		db 4			; 17
		db 1			; 18
		db 2			; 19
		db 0FEh			; 20
		db 0			; 21
		db 69h			; 22
		db 4			; 23
		db 4			; 24
		db 4			; 25
		db 7			; 26
		db 38h			; 27
		db 0A8h			; 28
		db 3Fh			; 29
		db 2			; 30
		db 0Ah			; 31
		db 0			; 32
		db 0FFh			; 33
		db 0FDh			; 34
		db 0AFh			; 35
		db 70h			; 36
		db 0			; 37
		db 0BDh			; 38
		db 1			; 39
		db 4			; 40
		db disb_disbelieve	; 41
		db 82h			; 42
		db 1			; 43
		db 83h			; 44
		db 4			; 45
		db 6			; 46
		db splf_cateyes		; 47
		db 84h,	disb_disruptill, 0,	85h	; 48
		db 0FFh, 15h, 86h, 77h	; 52
		db disb_nosummon,	7, 46h,	8	; 56
		db 0C4h, 4Dh, 0, 9	; 60
		db 0E0h, 0, 0CBh, 0Ah	; 64
		db 0, 54h, 7Eh,	0	; 68
		db 0, 0, 0, 5Bh		; 72
		db 0FDh, 0Bh, 7, 0FFh	; 76
		db 0, 0, 62h, 85h	; 80
		db 0, 0, 8Ch, 0EEh	; 84
		db 0, 0, 8, 0D2h	; 88
		db 0, 0, 0, 0		; 92
		db 0, 0, 6, 9		; 96
		db 0, 0, 0FFh, 1Ch	; 100
		db 0, 0, 93h, 6		; 104
		db 0, 0A1h, 0Ch, 80h	; 108
		db 0D9h, 8, 4, 6	; 112
		db 2, 0E7h, 0Ah, 9Ah	; 116
		db 0Eh,	0, 0, 5		; 120
		db 23h,	0, 4, 5		; 124
		db 0, 0, 0, 0		; 128
		db 0, 0, 0, 0		; 132
spellExtraFlags	db 0			; 0
		db 1			; 1
		db 0			; 2
		db 0Ah			; 3
		db 0			; 4
		db 0			; 5
		db 0			; 6
		db 0			; 7
		db 2			; 8
		db 0			; 9
		db 1			; 10
		db 0			; 11
		db 83h			; 12
		db 81h			; 13
		db 0			; 14
		db 1			; 15
		db 0, 0, 0, 0, 0, 0, 1,	0; 16
		db 1, 2, 0, 84h, 7, 83h, 0, 1; 24
		db 0, 2, 81h, 1, 5, 2, 84h, 0; 32
		db 0, 0, 0, 0, 0, 0, 2,	0; 40
		db 0, 0, 83h, 0, 2, 4, 0, 0Ah; 48
		db 0Ah,	0, 1, 0, 3, 3, 3, 0; 56
		db 0, 0, 7, 0, 4, 5, 85h, 0; 64
		db 0, 0, 0, 6, 86h, 0, 0Ah, 0; 72
		db 0, 0, 2, 8, 0, 0, 8,	5; 80
		db 0, 0, 0, 3, 0, 0, 0,	5; 88
		db 0, 0, 0, 0, 0, 0, 4,	0Ah; 96
		db 0, 0, 84h, 0, 0, 0Ah, 0, 0; 104
		db 6, 0, 0, 0, 0, 0Ah, 85h, 5; 112
		db 0Ah,	5, 0, 0Ah, 0Ah,	0, 1, 1; 120
		db 0, 0, 0, 0, 0, 0, 0,	0; 128
spptRequired	db 2, 3, 2, 3, 3, 4, 5, 4;	0
		db 5, 6, 6, 7, 7, 9, 8,	12; 8
		db 15, 18, 12, 3, 3, 2,	4, 5; 16
		db 5, 6, 6, 6, 8, 7, 8,	10; 24
		db 10, 10, 25, 16, 11, 20, 3, 2; 32
		db 2, 4, 5, 4, 6, 6, 6,	7; 40
		db 12, 8, 10, 11, 11, 20, 16, 40; 48
		db 50, 10, 11, 14, 11, 14, 12, 13; 56
		db 14, 16, 13, 22, 18, 16, 25, 15; 64
		db 20, 28, 26, 30, 50, 60, 80, 12; 72
		db 10, 10, 20, 20, 15, 15, 25, 30; 80
		db 20, 20, 45, 50, 25, 25, 60, 60; 88
		db 30, 30, 65, 70, 35, 35, 60, 100; 96
		db 50, 50, 5, 5, 8, 10,	15, 15;	104
		db 18, 20, 20, 25, 30, 40, 40, 50; 112
		db 60, 80, 10, 250, 150, 1; 120
breathEffectStr	dd aFried, aFrozen, aShocked, aDrained, aBurnt; 0
		dd aChoked, aSteamed, aBlasted, aHit, aNuked;	5
damageSpellData	breathAtt_t <0,	0Ch, 4,	0, 38h,	0C0h, 1>; 0
		breathAtt_t <0,	4, 0, 0, 38h, 0C0h, 8>;	1
		breathAtt_t <0,	0Ch, 4,	0, 38h,	0C0h, 10h>	; 2
		breathAtt_t <0,	14h, 2,	0, 58h,	0C0h, 1>; 3
		breathAtt_t <0,	4, 10h,	0, 3Dh,	0C0h, 0Dh>	; 4
		breathAtt_t <0,	4, 12h,	0, 5Fh,	0C0h, 10h>	; 5
		breathAtt_t <0,	0Ch, 4,	0, 24h,	40h, 1>; 6
		breathAtt_t <0,	0Ch, 4,	0, 2Eh,	40h, 1>; 7
		breathAtt_t <0,	0Ch, 4,	0, 29h,	40h, 1>; 8
		breathAtt_t <0,	84h, 8,	0, 47h,	40h, 1>; 9
		breathAtt_t <0,	4, 10h,	0, 38h,	40h, 1>; 10
		breathAtt_t <0,	84h, 8,	0, 35h,	40h, 1>; 11
		breathAtt_t <0,	0Ch, 4,	0, 38h,	40h, 2>; 12
		breathAtt_t <0,	14h, 2,	0, 38h,	40h, 4>; 13
		breathAtt_t <4,	4, 6, 0, 1Dh, 40h, 0Ah>; 14
		breathAtt_t <0,	24h, 6,	80h, 25h, 0, 1>; 15
		breathAtt_t <0,	14h, 2,	0, 33h,	40h, 1>; 16
		breathAtt_t <0,	4, 0Ah,	20h, 3Dh, 40h, 2>		; 17
		breathAtt_t <0,	4, 10h,	40h, 13h, 40h, 0Ah>	; 18
		breathAtt_t <0,	14h, 2,	0, 58h,	40h, 2>; 19
		breathAtt_t <0,	24h, 0Eh, 0, 2Bh, 40h, 5>		; 20
		breathAtt_t <0,	24h, 0,	0, 38h,	40h, 8>; 21
		breathAtt_t <0,	84h, 8,	0, 3Dh,	40h, 0Ah>	; 22
		breathAtt_t <0,	4, 0, 0, 2Eh, 0C0h, 0Ah>; 23
		breathAtt_t <4,	4, 6, 0, 2Eh, 0, 1>; 24
		breathAtt_t <7,	4, 10h,	0, 0, 0, 1>; 25
		breathAtt_t <0,	84h, 8,	0, 20h,	0, 0>; 26
		breathAtt_t <0,	0Ch, 4,	0, 21h,	0, 0>; 27
		breathAtt_t <0,	84h, 8,	40h, 38h, 0, 4>; 28
		breathAtt_t <0,	24h, 6,	0, 38h,	0, 2>; 29
		breathAtt_t <7,	4, 10h,	0, 0, 0, 1>; 30
		breathAtt_t <6,	4, 10h,	0, 0, 0, 1>; 31
		breathAtt_t <5,	4, 10h,	0, 0, 0, 1>; 32
		breathAtt_t <0,	14h, 2,	0, 38h,	0, 10h>; 33
		breathAtt_t <0,	0Ch, 4,	0, 38h,	0C0h, 2>; 34
		db    0
weaponDamageList	anotherBreathAtt_t <0, 1, 25h, 2, 1,	2>; 0
		anotherBreathAtt_t <0, 1, 24h, 2, 1, 2>; 1
		anotherBreathAtt_t <0, 1, 22h, 2, 1, 3>; 2
		anotherBreathAtt_t <0, 1, 26h, 2, 1, 3>; 3
		anotherBreathAtt_t <0, 1, 23h, 2, 1, 3>; 4
		anotherBreathAtt_t <0, 1, 27h, 2, 1, 4>; 5
		anotherBreathAtt_t <0, 1, 28h, 2, 1, 4>; 6
		anotherBreathAtt_t <0, 1, 28h, 2, 1, 5>; 7
		anotherBreathAtt_t <0, 1, 2Bh, 2, 1, 4>; 8
		anotherBreathAtt_t <0, 1, 2Fh, 2, 1, 6>; 9
		anotherBreathAtt_t <0, 1, 37h, 2, 1, 9>; 10
		anotherBreathAtt_t <0, 1, 33h, 2, 2, 7>; 11
		anotherBreathAtt_t <0, 1, 2Fh, 2, 4, 8>; 12
		anotherBreathAtt_t <0, 1, 2Fh, 2, 8, 9>; 13
		anotherBreathAtt_t <0, 1, 2Fh, 2, 2, 7>; 14
		anotherBreathAtt_t <0, 1, 33h, 2, 2, 7>; 15
		anotherBreathAtt_t <0, 1, 38h, 2, 8, 5>; 16
		anotherBreathAtt_t 2 dup(<0, 80h, 38h, 2, 4,	6>); 17
		anotherBreathAtt_t <0, 1, 38h, 2, 8, 6>; 19
		anotherBreathAtt_t <0, 1, 38h, 42h, 8, 9>	; 20
		anotherBreathAtt_t <7, 1, 20h, 2, 1, 3>; 21
		anotherBreathAtt_t <0, 20h, 2Fh, 2, 10h, 8>	; 22
		anotherBreathAtt_t <0, 80h, 29h, 42h, 1, 3>	; 23
		anotherBreathAtt_t <0, 10h, 37h, 42h, 1, 4>	; 24
		anotherBreathAtt_t <0, 80h, 2Fh, 42h, 2, 6>	; 25
		anotherBreathAtt_t <0, 80h, 2Fh, 42h, 6, 6>	; 26
		anotherBreathAtt_t <0, 80h, 2Fh, 42h, 8, 5>	; 27
		anotherBreathAtt_t <7, 8, 2Fh, 42h, 10h, 6>	; 28
		anotherBreathAtt_t <0, 0, 31h, 42h, 0Ah, 7>	; 29
		anotherBreathAtt_t <0, 20h, 2Fh, 42h, 20h, 7>; 30
		anotherBreathAtt_t <0, 1, 25h, 2, 1, 2>; 0

byte_48382	db 6, 15h, 16h, 23h, 24h, 27h, 2Ah, 2Bh; 0
		db 35h,	3Ah, 48h, 5Ch, 60h, 65h, 6Bh, 77h; 8
		db 7Ch,	81h, 86h, 8Bh, 9Fh, 0D0h, 0F4h,	1Eh; 16
		db 47h,	53h, 57h, 5Bh, 0BAh, 0DEh; 24
		db 0F8h, 85h
		db    0
figurineItemNo	db 27, 38	       ; 0
		db 56, 61		; 2
		db 77, 98		; 4
		db 99, 190		; 6
		db 204,	0		; 8
byte_483AC	db 0Dh, 0Eh		   ; 0
		db 0Fh,	1		; 2
		db 10h,	11h		; 4
		db 12h,	13h		; 6
		db 14h,	0		; 8
s_castAt		db 'Cast at ',0
		db    0
s_whoWillCast	db 'Who will cast a spell?',0
		db    0
s_dontKnowThatSpell db 'You don',27h,'t know that spell!',0
		db    0
s_noSpellByThatName	db 'No spell by that name.', 0
s_notEnoughSppt	db 'Not enough spell points!',0
		db    0
s_spellToCast db	'Spell to cast:',0
		db    0
aWhichMagicArtShallYou db 'Which magic art shall you invoke?',0
		db ') ',0
		db    0
s_castsASpell	db 'casts a spell',0
s_butItFizzled	db 'but it fizzled!',0
s_butItFizzledNl	db 'but it fizzled!',0Ah,0Ah,0
s_makesLight	db 'makes a light',0
mageSpellIndex	db 255, 42, 28, 0       ; 0 ; This array	is an index into another array for
		db 14, 255, 255, 255	; 4 ; determining the spells that a magic user has.
		db 255,	255, 56, 70	; 8
		db 84, 255, 255, 0	; 12
s_notSpellcaster	db 'Thou art not a spellcaster',0
		db    0
lightDistList	db 3			;0 splf_mageflame
		db 4			;1 splf_lesserrev
		db 5			;2 splf_greaterrev
		db 5			;3 splf_cateyes
		db 2			;4
		db 2			;5

; This is a holdover from previous games. A value of 0xFF indicates
; that secret doors are visible.
lightDetectList	db 0			;0 splf_mageflame
		db 0FFh			;1 splf_lesserrev
		db 0FFh			;2 splf_greaterrev
		db 0			;3 splf_cateyes
		db 0			;4
		db 0			;5

lightDurList	db 4			;0 splf_mageflame
		db 0Ch			;1 splf_lesserrev
		db 10h			;2 splf_greaterrev
		db 0FFh			;3 splf_cateyes
		db 4
		db 8			;0
classSavingBonus	db 0, 0Ah, 0Ah, 5	   ; 0
		db 5, 0, 0, 5		; 4
		db 0, 0, 11h, 11h	; 8
		db 16h,	0		; 12
word_484CC	dw 1Eh
		db  1Eh
		db    0
		db    7
		db    0
batchSpellList	db 0Bh
		db  21h	; !
		db  34h	; 4
		db  0Eh
		db    4
		db    0
		db  44h	; D
		db  0Fh
		db    0
		db 0D2h	; 
unk_484DC	db  73h ; s
		db    0
geoSpMasks	geomanSp_t <3, 20h>	   ; 0
		geomanSp_t <4, 40h>	; 1
		geomanSp_t <3, 4>	; 2
		geomanSp_t <3, 2>	; 3
geoSpList	dd spGeo_removeTrap	; 0 ;	0: Earth Ward. Remove all traps	from level
		dd dun_revealSpSquare	; 1 ; 1: Sanctuary. Reveal all mage regeneration squares
		dd dun_revealSpSquare	; 2 ; 2: Succor	Song. Reveal party heal	squares
		dd dun_revealSpSquare	; 3 ; 3: Roscoe's Alert. Reveal all anti-magic squares
		dd dun_revealSpSquare	; 4 ; 4: Earth song. Reveal all	drain HP squares
		dd spGeo_revealSquare	; 5 ; 5:
spellFuncList	dd sp_lightSpell	      ;	0
		dd sp_damageSpell	; 1
		dd sp_trapZap		; 2
		dd sp_freezeFoes	; 3
		dd sp_compassSpell	; 4
		dd sp_healSpell		; 5
		dd sp_lightSpell	; 6
		dd sp_levitation	; 7
		dd sp_damageSpell	; 8
		dd sp_summonSpell	; 9
		dd sp_healSpell		; 10
		dd sp_lightSpell	; 11
		dd sp_damageSpell	; 12
		dd sp_healSpell		; 13
		dd sp_levitation	; 14
		dd sp_healSpell		; 15
		dd sp_teleport		; 16
		dd sp_farFoes		; 17
		dd sp_summonSpell	; 18
		dd sp_vorpalPlating	; 19
		dd sp_healSpell		; 20
		dd sp_scrySight		; 21
		dd sp_damageSpell	; 22
		dd sp_vorpalPlating	; 23
		dd sp_areaEnchant	; 24
		dd sp_shieldSpell	; 25
		dd sp_strengthBonus	; 26
		dd sp_damageSpell	; 27
		dd sp_damageSpell	; 28
		dd sp_damageSpell	; 29
		dd sp_antiMagic		; 30
		dd sp_strengthBonus	; 31
		dd sp_phaseDoor		; 32
		dd sp_shieldSpell	; 33
		dd sp_healSpell		; 34
		dd sp_damageSpell	; 35
		dd sp_damageSpell	; 36
		dd sp_healSpell		; 37
		dd sp_damageSpell	; 38
		dd sp_acBonus		; 39
		dd sp_areaEnchant	; 40
		dd sp_disbelieve	; 41
		dd sp_summonSpell	; 42
		dd sp_wordOfFear	; 43
		dd sp_summonSpell	; 44
		dd sp_acBonus		; 45
		dd sp_areaEnchant	; 46
		dd sp_lightSpell	; 47
		dd sp_summonSpell	; 48
		dd sp_disbelieve	; 49
		dd sp_damageSpell	; 50
		dd sp_summonSpell	; 51
		dd sp_areaEnchant	; 52
		dd sp_damageSpell	; 53
		dd sp_summonSpell	; 54
		dd sp_damageSpell	; 55
		dd sp_disbelieve	; 56
		dd sp_summonSpell	; 57
		dd sp_damageSpell	; 58
		dd sp_summonSpell	; 59
		dd sp_damageSpell	; 60
		dd sp_damageSpell	; 61
		dd sp_healSpell		; 62
		dd sp_summonSpell	; 63
		dd sp_possessChar	; 64
		dd sp_spellbind		; 65
		dd sp_damageSpell	; 66
		dd sp_summonSpell	; 67
		dd sp_healSpell		; 68
		dd sp_damageSpell	; 69
		dd sp_damageSpell	; 70
		dd sp_haltFoe		; 71
		dd sp_meleeMen		; 72
		dd sp_batchspell	; 73
		dd sp_camaraderie	; 74
		dd sp_damageSpell	; 75
		dd sp_healSpell		; 76
		dd sp_summonSpell	; 77
		dd sp_damageSpell	; 78
		dd sp_healSpell		; 79
		dd printSpellFizzled	; 80
		dd printSpellFizzled	; 81
		dd sp_damageSpell	; 82
		dd sp_damageSpell	; 83
		dd printSpellFizzled	; 84
		dd printSpellFizzled	; 85
		dd sp_damageSpell	; 86
		dd sp_damageSpell	; 87
		dd printSpellFizzled	; 88
		dd printSpellFizzled	; 89
		dd sp_luckSpell		; 90
		dd sp_damageSpell	; 91
		dd printSpellFizzled	; 92
		dd printSpellFizzled	; 93
		dd sp_identifySpell	; 94
		dd sp_healSpell		; 95
		dd printSpellFizzled	; 96
		dd printSpellFizzled	; 97
		dd sp_batchspell	; 98
		dd sp_batchspell	; 99
		dd printSpellFizzled	; 100
		dd printSpellFizzled	; 101
		dd sp_shieldSpell	; 102
		dd sp_damageSpell	; 103
		dd printSpellFizzled	; 104
		dd printSpellFizzled	; 105
		dd sp_damageSpell	; 106
		dd sp_geomancerSpell	; 107
		dd sp_geomancerSpell	; 108
		dd sp_damageSpell	; 109
		dd sp_summonSpell	; 110
		dd sp_phaseDoor		; 111
		dd sp_damageSpell	; 112
		dd sp_geomancerSpell	; 113
		dd sp_geomancerSpell	; 114
		dd sp_farFoes		; 115
		dd sp_geomancerSpell	; 116
		dd sp_damageSpell	; 117
		dd sp_geomancerSpell	; 118
		dd sp_damageSpell	; 119
		dd sp_damageSpell	; 120
		dd sp_earthMaw		; 121
		dd printNoEffect	; 122
		dd sp_divineIntervention; 123
		dd sp_damageSpell	; 124
		dd printNoEffect	; 125
		dd _sp_useLightObj	; 126
		dd _sp_useLightObj	; 127
		dd _sp_useAcorn		; 128
		dd _sp_useWineskin	; 129
		dd printCantFindUse	; 130
		dd _sp_useWeapon	; 131
		dd _sp_useFigurine	; 132
		dd _sp_useWeapon	; 133
		dd _sp_reenergizeMage	; 134
aSirRobinSTune	db 'Sir Robin',27h,'s Tune',0
aSafetySong	db 'Safety Song',0
aSanctuaryScore	db 'Sanctuary Score',0
aBringaroundBal	db 'Bringaround Ballad',0
aRhymeOfDuotime	db 'Rhyme of Duotime',0
aWatchwoodMelod	db 'Watchwood Melody',0
aKielSOverture	db 'Kiel',27h,'s Overture',0
aMinstrelShield	db 'Minstrel Shield',0
s_whoWillPlay	db 'Who will play?',0
align 2
s_notBard	db 'Not a bard!',0
s_notUsingInstrument	db 'You aren',27h,'t using an instrument!',0
s_dryThroat	db 'Your throat is dry!',0
songNames	dd aSirRobinSTune, aSafetySong, aSanctuaryScore, aBringaroundBal; 0
		dd aRhymeOfDuotime, aWatchwoodMelod, aKielSOverture, aMinstrelShield; 4
s_stopPlayingSong	db 'Stop playing a song',0
g_instrumentType	db 14h dup(0), 1, 14h dup(0), 2, 0Ch dup(0), 2, 16h dup(0), 1
		db 34h dup(0), 2, 4Eh dup(0), 2, 3, 6 dup(0), 1, 4 dup(0)
		db 3, 21h dup(0)
aGillesGillsFor	db 'Gilles Gills for ',0
aDivineInterven	db 'Divine Intervention for ',0
aGotterdamuru_0	db 'Gotterdamurung for ',0
aStrength_	db 'strength.',0
aIntelligence_	db 'intelligence.',0
aDexterity_	db 'dexterity.',0
aConstitution_	db 'constitution.',0
aLuck_		db 'luck.',0
aWizard_0	db 'Wizard',0Ah,0
aSorcerer_0	db 'Sorcerer',0Ah,0
aConjurer_0	db 'Conjurer',0Ah,0
aMagician_0	db 'Magician',0Ah,0
aArchmage_0	db 'Archmage',0Ah,0
aChronomancer_0	db 'Chronomancer',0Ah,0
spellLevelCost	dw 100, 1000, 2000, 4000, 7000, 10000, 20000; 0
g_spellLevelData	spellAdvance <0, 3>	   ; 0
		spellAdvance <3, 3>	; 1
		spellAdvance <6, 3>	; 2
		spellAdvance <9, 2>	; 3
		spellAdvance <11, 2>	; 4
		spellAdvance <13, 2>	; 5
		spellAdvance <15, 4>	; 6
		spellAdvance <19, 3>	; 7
		spellAdvance <22, 3>	; 8
		spellAdvance <25, 3>	; 9
		spellAdvance <28, 2>	; 10
		spellAdvance <30, 2>	; 11
		spellAdvance <32, 2>	; 12
		spellAdvance <34, 4>	; 13
		spellAdvance <38, 3>	; 14
		spellAdvance <41, 3>	; 15
		spellAdvance <44, 3>	; 16
		spellAdvance <47, 2>	; 17
		spellAdvance <49, 2>	; 18
		spellAdvance <51, 2>	; 19
		spellAdvance <53, 4>	; 20
		spellAdvance <57, 2>	; 21
		spellAdvance <59, 2>	; 22
		spellAdvance <61, 2>	; 23
		spellAdvance <63, 2>	; 24
		spellAdvance <65, 2>	; 25
		spellAdvance <67, 2>	; 26
		spellAdvance <69, 2>	; 27
		spellAdvance <71, 2>	; 28
		spellAdvance <73, 1>	; 29
		spellAdvance <74, 1>	; 30
		spellAdvance <75, 1>	; 31
		spellAdvance <76, 1>	; 32
		spellAdvance <77, 1>	; 33
		spellAdvance <78, 1>	; 34
		spellAdvance <79, 3>	; 35
		spellAdvance <82, 2>	; 36
		spellAdvance <86, 2>	; 37
		spellAdvance <90, 2>	; 38
		spellAdvance <94, 2>	; 39
		spellAdvance <98, 2>	; 40
		spellAdvance <102, 2>	; 41
		spellAdvance <106, 3>	; 42
		spellAdvance <109, 3>	; 43
		spellAdvance <112, 2>	; 44
		spellAdvance <114, 2>	; 45
		spellAdvance <116, 2>	; 46
		spellAdvance <118, 2>	; 47
		spellAdvance <120, 2>	; 48
g_spellsForSalePrice	dd 10000, 50000, 50000	 ; 0
s_hallOfWizards	db	'Thou art in the hall of wizards. Would thou like...',0Ah,0Ah
		db 'Advancement',0Ah
		db 'Spell Acquiring',0Ah
		db 'Buy a new spell',0Ah
		db 'Exit the hall',0
		db    0
aTheGuildEldersPrepare	db 'The Guild elders prepare to weigh thy merits.',0Ah,0Ah
		db 'Who shall be reviewed?',0
aTheGuildEldersDeemTha	db 'The Guild elders deem that ',0
s_cannotBeRaisedLevels_	db ' cannot be raised levels.',0
s_eldersTeachLore	db 'The Elders teach you the lore.',0
		db    0
s_buySpellPrompt	db 'Who seeks the special knowledge of the mystic arts?',0
s_thouMayLearn	db 'Thou may learn ',0
g_spellsForSaleList	dd aGillesGillsFor, aDivineInterven; 0
			dd aGotterdamuru_0	; 2
s_inGoldWhoWillPay	db ' in gold. Who will pay?',0
s_lastOfTheGuildElders	db 'The last of the guild elders is here. Would you like...',0Ah,0Ah
		db 'Advancement',0Ah
		db 'Spell Acquiring',0Ah
		db 'Class Change',0Ah
		db 'Talk to the elder',0Ah
		db 'Exit the guild',0
align 2
s_elderWeighsMerits	db 'The Guild elder prepares to weigh your merits.',0Ah,0Ah
		db 'Who shall be reviewed?',0
align 2
s_elderDeadCharacter	db '"Hmmm... Should I make you into a zombie perhaps?!?"',0
align 2
s_guildElderDeems	db 'The Guild elder deems that ',0
s_cannotBeRaised	db ' cannot be raised levels.',0
s_stillNeedeth	db ' still needeth ',0
s_experiencePoints	db ' experience points prior to advancement.',0
align 2
s_hathEarnedLevel	db ' hath earned a level of advancement...',0
align 2
s_plusOneTo		db	'+1 to ',0
align 2
fullAttributeString	dd aStrength_, aIntelligence_, aDexterity_;	0
			dd aConstitution_, aLuck_; 3
s_whoSeeksKnowledge	db 'Who seeks knowledge of the mystic arts?',0
s_learnedAllSpells	db 'Thou hath learned all the spells in thy art.',0
align 2
s_cannotAcquireNewSpells	db 'Thou cannot acquire new spells yet.'
		db 0
s_spellLevel	db ' spell level ',0
s_willCost	db ' will cost ',0
s_notEnoughGoldNl	db 'Not enough gold.',0Ah,0
s_elderTeachersLore	db 'The Elder teaches you the lore.',0
s_whichMageSeeksChange	db 'Which mage seeks to change classes?'
		db 0
s_cannotChangeClass	db 'Thou cannot change class.',0
s_mustKnowThreeSpellLevels	db 'You must know at least 3 spell levels in your present art first.',0
align 2
s_doesntQualifyForNewClass	db 'Thee doesn',27h,'t qualify for any new class.',0
s_newClassPrompt	db 0Ah,'Which class shall thee become?',0
s_convertChronomancerPrompt	db 'Thee understands the sacrifice, dost thou not? Thee will be stripped of all thy spells and knowledge thereof. Thee will be more powerful than ever before, but more vulnerable as well.',0
s_dostThouAccept	db 'Dost thou accept this sacrifice?',0Ah,0Ah,0
align 2
s_arboriaSpellText	db '"Know this, the spell to enter Arboria is invoked by uttering ARBO and the spell to return is ENIK. Be wary, for the spells only work in one place in the land."',0
align 2
s_arboriaSpellLocation	db '"There is a large grove of trees just south of Skara Brae. The spell will work there."',0
align 2
s_beginsNewProfession	db 'Now thou begins thy new profession.'
		db 0
s_desertedReviewBoard	db 'The old review board is deserted.',0
magicUserString	dd aWizard_0, aSorcerer_0, aConjurer_0,	aMagician_0; 0
		dd aArchmage_0,	aChronomancer_0; 4
s_thouArtNotASpellcaster	db 'Thou art not a spell caster!',0
align 2
s_whoSpeaksToElder	db 'Who wishs to speak with the elder?',0
align 2
s_gelidiaSpellText	db '"Gelidia, the land of cold, is entered by uttering GELI and the spell to return is ECUL."',0
s_gelidiaSpellLocation	db 'To the north is Cold Peak, your passage to Gelidia is there.',0
align 2
s_lucenciaSpellText	db '"Lucencia is entered by uttering LUCE and the spell to return is ILEG."',0
s_lucenciaSpellLocation	db 'To the east is a crystal spring, your passage to Lucencia is there.',0
s_kinestiaSpellText	db '"Kinestia, the dimension of machines, is reached by casting KINE. OBRA will bring you back."',0
align 2
s_kinestiaSpellLocation	db '"To the south-west is an old mine, you may reach Kinestia from there."'
db 0
align 2
s_tenebrosiaSpellText	db '"Tenebrosia can be reached by uttering OLUK and the spell to return is ECEA."',0
s_tenebrosiaSpellLocation	db '"To the southeast is Shadow Rock, your passage to Tenebrosia is there."',0
s_tarmitiaSpellText	db '"Tarmitia is entered by uttering AECE and the spell to return is KULO."',0
s_tarmitiaSpellLocation	db '"To the south is a vale, your passage to Tarmitia is there."',0
align 2
s_timeIsRunningOut	db '"Hurry! Time is running out!"',0
s_teachOnlyChronomancer	db '"I',27h,'ll teach only a Chronomancer the special magic that you need to journey on your quest."',0
align 2
s_seekOutBrilhasti	db '"Seek out Brilhasti ap Tarj!"',0
align 2
s_questAwardXp_1	db 'The old man awards each member 600000 experience points.',0
align 2
s_questAwardXp_2	db 'With a wave of his hand, the old man re-energizes all magic users.',0
align 2
s_questBrilhasti_1	db 'The old man in the Review Board scratches his head. "Yes, you are the prophesied ones, but you have come too early. No matter."',0
s_questBrilhasti_2	db '"Beneath Skara Brae you will find one of Tarjan',27h,'s devotees. Brilhasti ap Tarj is a foul Necromancer, and his life impedes my efforts to stave off disaster."',0
align 2
s_questBrilhasti_3	db '"You may enter the Catacombs under the Mad God',27h,'s Temple by uttering his master',27h,'s name... ',27h,'Tarjan"',0
align 2
s_questBrilhasti_4	db '"Destroy Brilhasti ap Tarj, then return to me for your true quest."',0
s_questValarian_1	db '"Welcome ye children of the prophecy. Upon your shoulders falls a great weight, for you must embark on what will be your greatest adventure ever."',0
align 2
s_questValarian_2	db '"That which has laid waste to Skara Brae is an ancient evil recently released. It threatens to destroy all reality and time as it has wrought havoc on Skara Brae."',0
s_questValarian_3	db '"If you cannot stop it, it will consume the universe. If you do stop it, you will be rewarded beyond all your dreams."',0
align 2
s_questValarian_4	db '"Prepare thyselves, and hasten to the place of trees, for it is most like the first dimension you must sojourn in to blunt the evil."',0
s_questValarian_5	db '"Aboria, the home of Valarian the bold, is reached through using powerful magic that only a Chronomancer can control."',0
align 2
s_questValarian_6	db '"Bring to me Valarian',27h,'s Bow and The Arrows of Life if Valarian will not return here with you."',0
align 2
s_questValarian_7	db '"Yes, and be on the lookout for an ally, for you are not the first I have sent on this quest. Though your paths are different, they may cross, and you will do well together."',0
align 2
s_questLanatir_1	db 'The old man takes the news of Valarian',27h,'s death hard, but he summons a smile to his lips and breathes deeply.',0
align 2
s_questLanatir_2	db '"You have done well, children, and I take well the news that Hawkslayer has survived this long. Now you are bound for a place far distant."',0
s_questLanatir_3	db '"It is the dimension of magic. It is known as Gelidia and if your Chronomancer is able, I will share the spells to get you there and back again."',0
s_questLanatir_4	db '"Bring Lanatir with you, or, if you cannot convince him to come, coax from him the Wand of Power and the Sphere of Lanatir."',0
align 2
s_questAlliria_1	db 'The old man appears visibly shaken by the news of Lanatir',27h,'s death. After a long silence he stares off into space and mumbles, "Is it to be that way then?"',0
align 2
s_questAlliria_2	db 'His eyes focus upon you again, and a grim look washes over his features. "Now you are bound for Lucencia."',0
align 2
s_questAlliria_3	db '"I dare not hope Alliria lives, so I want you to recover the Crown of Truth and the Belt of Alliria. Beware, for she had a jealous consort, and he will protect her as best he can."',0
algn_49F1F:
align 2
s_questFerofist_1	db 'The old man',27h,'s look of grim determination withstands news of Alliria',27h,'s death, but the information saps some of his strength.',0
s_questFerofist_2	db '"Quickly then, my children, to distant Kinestia!"',0
s_questFerofist_3	db '"You must return here with The Hammer of Wrath and Ferofist',27h,'s Helm. I know Ferofist yet lives, but I cannot be sure of how long he will survive."',0
s_questFerofist_4	db '"Hurry, the pace quickens, and the outlook is horrible if you fail!"',0
align 2
s_questSceadu_1	db 'The old man',27h,'s eyes narrow as you tell of Ferofist',27h,'s end. "An alliance with the dark one, did he say? It is well he realized his folly in the end."',0
align 2
s_questSceadu_2	db 'He pauses a second, and you see utter weariness send a tremor through him. "Now to Tenebrosia for all of you."',0
align 2
s_questSceadu_3	db '"Remember, in the land where night is day and day is night, nothing is as you know it to be. Paradox lives there - trust no one but yourselves."',0
align 2
s_questSceadu_4	db '"From there I require the Helm of Justice and Sceadu',27h,'s Cloak."',0
align 2
s_questWerra_1	db '"No!" the old man cries out, "not Sceadu as well. The dark one is utterly mad. Still," the old man smiles, "he burns the chaff while I sow the seed."',0
s_questWerra_2	db '"Off with you to Tarmitia, the land of unceasing warfare. A myriad of ages meld together there, and your success depends upon your ability to adapt."',0
s_questWerra_3	db '"Bring me Werra',27h,'s Shield and the Strifespear."',0
align 2
s_questWerra_4	db 'His eyes lose their focus. "It is almost done, the circle is almost joined."',0
align 2
s_questTarjan_1	db '"I know," the old man gurgles, "Werra lies dead." Blood bubbles up on his lips and joins the dark stains on the rest of his clothing. "I, too, have been slain by the Mad One."',0
s_questTarjan_2	db '"Gather up the prizes you have won, the special ones, those I requested. Hawkslayer has already ventured into Malefia, the land of EVIL."',0
s_questTarjan_3	db '"I have placed the prizes in the storage building near the entrance of Skara Brae."',0
s_questTarjan_4	db '"Get yourselves hence and help him. Destroy the Mad God Tarjan before he destroys all reality!!"',0
align 2
s_questTarjan_5	db 'With those final words, the old man slumps over, and his body dissolves into a mist that a slight breeze stirs and blows away.',0
align 2
hpLevelBonusMask db 0Fh, 7, 7, 3, 3, 7,	0Fh, 0Fh, 0Fh, 7; 0 ; This array holds the mask	for bonus hit points for
		db 7, 7, 7, 0		; 10 ; each class at level-up time.
g_mageConversionCheckFunctions	dd mage_convertWizardCheck, mage_convertSorcererCheck; 0
		dd mage_convertConjurorCheck, mage_convertMagicianCheck; 2
		dd mage_convertArchmageCheck, mage_convertChronomancerCheck; 4

; Conversion table for key input to class for review_changeMageClass
g_convertListToMageClass	db 1, 2, 3, 4, 0Ah, 0Bh ; 0
s_reviewBoard	db 'Review Board',0
		db    0
questFuncs	dd review_questBrilhasti, review_questValarian; 0
		dd review_questLanatir, review_questAlliria; 2
		dd review_questFerofist,	review_questSceadu; 4
		dd review_questWerra, review_questTarjan;	6
g_questMaskList	db 0, 1, 40h, 10h, 4, 1, 40h, 10h; 0
g_questByteList	db 1, 1, 0, 0, 0, 0,	1, 1; 0
s_guild		db 'Guild',0
s_victoryMessage_1	db '"Welcome, brave heroes. You have succeeded in destroying the threat to all reality. As you know, to do this, you slipped the bonds of time, and traveled forbidden routes'
		db 'through that which has forever been. You pressed your struggle forward despite danger and death, and you accomplished that which the gods themselves were unable to do."'
		db 0Ah,0Ah
		db 'His praise washes over you like a warm ocean wave, and you feel strength infuse your body.',0
s_victoryMessage_2	db '"In doing what you have done, you have proved youself worthy of nothing less than the ultimate reward." He closes his eyes and raises his hands. '
		db '"The death of the gods tore reality asunder, but you bound it up again. The gods of old are dead, therefore I accept you as my new children. You shall be gods yourselves!"'
		db 0Ah,0Ah,0
s_victoryMessage_3	db 'His eyes open again and you look up on infinity. At once you see Skara Brae restored to its former beauty. You see beyond it and the Six cities of the Plains. '
		db 'You see the whole world and each of its cultures, and you realize all of it is now your domain.',0Ah,0Ah,0
s_victoryMessage_4	db '"And so it came to pass that eight new stars burned in the night sky. The least of these, the Companion star, was named Hawkslayer after a hero of legend. '
		db 'The other seven, together known as the Company of Heroes, are each named for one of the New Gods. Each night they can be seen is betokened a good night, and '
		db 'adventurers know these gods smile especially upon them..."',0Ah,'-- excerpt from The Gospel of the New Gods (Chap I, Verses 5-9)',0Ah,0Ah,0Ah,0
s_victoryMessage_5	db 'Your party will now alter time back to the refugee camp.',0Ah
		db 'Who knows what new challenges await you in the future!',0
aATrapIsNear	db 'A trap is near!',0
aThereAreStai_0	db 'There are stairs near...',0
aSomethingSpeci	db 'Something special is near...',0
aASpinnerIsNear	db 'A spinner is near...',0
aYourSpellsWave	db 'Your spells waver...',0
aSomethingAhead	db 'Something ahead...',0
aOdd___		db 'Odd...',0
aAwfullyQuietAh	db 'Awfully quiet ahead...',0
s_stoneBlockTrap	db 'stone block!',0
s_tripwireTrap	db 'tripwire!',0
s_pitTrap		db 'pit!',0
s_spikedPitTrap	db 'spiked pit!',0
s_poisonGasTrap	db 'poison gas cloud!',0
s_punjiStakeTrap	db 'punji stakes!',0
s_crossbowTrap	db 'crossbow bolts!',0
s_shockwaveTrap	db 'shock wave!',0
s_acidBathTrap	db 'acid bath!',0
s_mindZapTrap	db 'mind zap!',0
s_poisonSprayTrap	db 'poison spray!',0
s_poisonSpikedPitTrap	db 'poison spiked pit!',0
s_mageZapTrap	db 'mage zap!',0
s_decapitatorTrap	db 'decapitator!',0
s_timedWarstrikeTrap	db 'timed warstrike!',0
s_shockSphereTrap	db 'shock sphere!',0
s_crushingWallsTrap	db 'crushing walls!',0
s_rollingBallTrap	db 'rolling ball!',0
s_basiliskSnareTrap	db 'basilisk snare!',0
s_witherStrikeTrap	db 'wither strike!',0
s_sledgehammerTrap	db 'sledgehammer!',0
s_earthquakeTrap	db 'earthquake!',0
s_deathstrikeTrap	db 'deathstrike!',0
s_bonkersTrap	db 'bonkers!',0
s_wandererText	db 'A wandering creature offers to join your party. You can:'
		db 0Ah,0Ah
		db '@Allow it to join',0Ah
		db '@Fight it',0Ah
		db '@Leave in peace',0
s_titleText db 'Come hear the tale of Skara Brae - A god returned to have his way. Creatures of darkness, spawn of night, The Mad One',27h,'s kin destroyed the'
		db ' site. Defenders fell, their bane come true, Garth, Roscoe, Kylearan too! As doom approached, the helpless fled. It did no good, the streets'
		db ' ran red. Survivors few, they sit and mope, with but one final ray of hope: ',27h,'Cross time and space, the legends say, Heroes, at last! To steal the day! ',0
		db    0
victoryMessageList	dd s_victoryMessage_1	; 0
		dd s_victoryMessage_2	; 1
		dd s_victoryMessage_3	; 2
		dd s_victoryMessage_4	; 3
		dd s_victoryMessage_5	; 4
align 2
s_explosion	db 0Ah,'An explosion!',0
align 2
s_darkness	db 0Ah,'Darkness!',0
align 2
s_portalAbove	db 0Ah,'There is a portal above you.',0
s_portalBelow	db 0Ah,'There is a portal below.',0
s_soundOfSilence	db 0Ah,'The sound of silence...',0
align 2
detectMessages	dd aATrapIsNear	       ; 0
		dd aThereAreStai_0	; 1
		dd aSomethingSpeci	; 2
		dd aASpinnerIsNear	; 3
		dd aYourSpellsWave	; 4
		dd aSomethingAhead	; 5
		dd aOdd___		; 6
		dd aAwfullyQuietAh	; 7
s_hitTrap	db 'TRAP! You',27h,'ve hit a ',0
trapTypeString	dd s_stoneBlockTrap, s_tripwireTrap, s_pitTrap
		dd s_spikedPitTrap, s_poisonGasTrap, s_punjiStakeTrap
		dd s_crossbowTrap, s_shockwaveTrap, s_acidBathTrap
		dd s_mindZapTrap, s_poisonSprayTrap, s_poisonSpikedPitTrap
		dd s_mageZapTrap, s_decapitatorTrap,  s_timedWarstrikeTrap
		dd s_shockSphereTrap, s_crushingWallsTrap, s_rollingBallTrap
		dd s_basiliskSnareTrap, s_witherStrikeTrap, s_sledgehammerTrap
		dd s_earthquakeTrap, s_deathstrikeTrap, s_bonkersTrap
trapSpecialAttackValue	db 0, 0, 0, 0	   ; 0
		db 0, 1, 0, 0		; 4
		db 0, 0, 0, 0		; 8
		db 3, 1, 1, 0		; 12
		db 0, 0, 0, 0		; 16
		db 0, 0, 0, 0		; 20
		db 6, 4, 0, 0		; 24
		db 0, 7, 4, 0		; 28
byte_4B258	db 20h dup(0)

; Trap indices by (dungeon level & 7). 0-3 = dungeon level 1, 4-7 = 2, etc
;
g_trapIndexByLevel	db 0, 1, 2, 0	   ; 0
			db 3, 4, 5, 0		; 4
			db 6, 7, 8, 0		; 8
			db 9, 10, 11, 0		; 12
			db 12, 13, 14, 0	; 16
			db 15, 16, 17, 0	; 20
			db 18, 19, 20, 0	; 24
			db 21, 22, 23, 0	; 28
trapSaveList	trapSave_t < 0Fh, 0Fh	>
		trapSave_t < 0Eh, 0	>
		trapSave_t < 13h, 13h	>
		trapSave_t < 13h, 0	>
		trapSave_t < 15h, 14h	>
		trapSave_t < 14h, 0	>
		trapSave_t < 18h, 18h	>
		trapSave_t < 17h, 0	>
		trapSave_t < 26h, 26h	>
		trapSave_t < 28h, 0	>
		trapSave_t < 27h, 28h	>
		trapSave_t < 28h, 0	>
		trapSave_t < 2Ah, 29h	>
		trapSave_t < 2Ah, 0	>
		trapSave_t < 2Bh, 2Eh	>
		trapSave_t < 2Bh, 0	>
detectByteStartList	db 0, 2, 4, 0		; This array has the starting index into the detectByte
						; array for the detect spell type
detectByte	db 0, 0FFh, 0, 0FFh	   ; 0 ; This array holds the flag byte	to detect certain
		db 0, 0, 0, 1		; 4 ; types of squares
		db 1, 1, 1, 1		; 8
		db 1, 0FFh		; 12
detectMask	db 10h, 0, 1, 0	   ; 0 ; This array holds the bitmasks to detect certain
		db 10h,	1, 4, 1		; 4 ; types of squares
		db 2, 4, 8, 10h		; 8
		db 20h,	0		; 12
detectMsgIndex	db 0, 0, 1, 0	       ; 0
		db 0, 1, 2, 3		; 4
		db 4, 5, 6, 7		; 8
		db 5, 0			; 12
specialSquareFunctionList	dd dunsq_battleCheck,	dunsq_doTrap, dunsq_doDarkness;	0
		dd dunsq_doSpinner, dunsq_antiMagic, dunsq_drainHp; 3
		dd dunsq_somethingOdd, dunsq_doSilence,	dunsq_regenSppt; 6
		dd dunsq_drainSppt, dunsq_monHostile, dunsq_doStuck; 9
		dd dunsq_regenHP, dunsq_explosion, dunsq_portalAbove; 12
		dd dunsq_portalBelow
specialSquareByteIndexList	db 0, 0, 0		   ; 0
		db 1, 1, 1		; 3
		db 1, 1, 1		; 6
		db 1, 1, 2		; 9
		db 2, 2, 0		; 12
		db 0			; 15
specialSquareMaskList	db 80h, 10h, 8	   ; 0
		db 1, 2, 4		; 3
		db 8, 10h, 20h		; 6
		db 40h,	80h, 80h	; 9
		db 40h,	10h, 40h	; 12
		db 20h			; 15
g_wandererFunctionTable	dd wanderer_join
		dd wanderer_fight
		dd wanderer_leave
aDragonDragonWh	db 'Dragon, dragon,',0Ah
		db 'Why do you lair?',0Ah
		db 'Unfurl your wings, Take to the air!',0Ah
		db 'Soar high above, Far away fly,',0Ah
		db 'Or is that where, You wish to die?',0
aHawkslayerHawk	db 'Hawkslayer, Hawkslayer,',0Ah
		db 'Why do you ask? Killing me is a difficult task. My claws are sharp, my fangs sharper yet, And my breath flames, let us not forget.',0
aDragonDragonTh	db 'Dragon, dragon,',0Ah
		db 'Thou art quite strong. Your scales are bright and talons are long, But a duty I have and it is clear: Whatever it takes, I will drive you from here.',0
aHawkslayerHa_0	db 'Hawkslayer, Hawkslayer,',0Ah
		db 'Such a brief life. Have you no wish to again see your wife? Imagine her tears and grief and despair, Walk away from this fight, you have not a prayer.',0
aDragonDragonHo	db 'Dragon, dragon,',0Ah
		db 'How wise thou art.',0Ah
		db 'A massive beast with such a kind heart.',0Ah
		db 'I do wish to kiss my wife and my heir,',0Ah
		db '"Pray, fly to the mountains and await me there.',0
aHawkslayerHa_1	db 'Hawkslayer, Hawkslayer,',0Ah
		db 'I thought you were brave. Here I await you, deep in this cave. Come, little man, and I',27h,'ll eat your brain, Then ravage Lucencia again and again.',0
aDragonDragonGr	db 'Dragon, dragon,',0Ah
		db 'Great is your heart. Massive your body, but you are not smart. The rumble you hear and the dust in the air? I',27h,'ve closed the cave off and trapped you in there.',0
aHawkslayerHa_2	db 'Hawkslayer, Hawkslayer,',0Ah
		db 'Others will come.',0Ah
		db 'I will wait but I will not succumb.',0Ah
		db 'Hero you are, and incredibly sly,',0Ah
		db 'But the future I know and a hero you',27h,'ll die...',0
aHeWasBornWithT	db 'He was born with the red, red rose, Sign of his blood, was the link to the past.',0
aInBattleHeWonT	db 'In battle, he won the blue, blue rose, Blossom of his valor, his weapons were cast.',0
aSheWasForHimTh	db 'She was for him the yellow, yellow rose, Her spirit divine, his love would always last.',0
aHisPledgeHeMad	db 'His pledge he made o',27h,'er the white, white rose, And she accepted it as sooth, and remained his steadfast.',0
aSoHeMadeForHer	db 'So he made for her the rainbow rose, Like Alliria',27h,'s beauty, a blossom unsurpassed.',0
aMadGodBadGodTh	db 'Mad god, bad god,',0Ah
		db 'Thrust from the sky,',0Ah
		db 'Foolish god, ghoulish god.',0Ah
		db 'We can',27h,'t hear you cry.',0
aRudeGodCrudeGo	db 'Rude god, crude god,',0Ah
		db 'Why must you terrify?',0Ah
		db 'Error god, terror god,',0Ah
		db 'Do not your future scry.',0
aCleverGodNever	db 'Clever god, never god,',0Ah
		db 'Your time is nigh.',0Ah
		db 'Dire god, liar god,',0Ah
		db 'Why won',27h,'t you just die?',0
aInTheLandOfNoT	db 'In the land of no time,',0Ah
		db 'The Clock within burns like a flame,',0
aLockingEachInH	db 'Locking each in his own crime:',0Ah
		db 'One can only leave when he came.',0
s_bardHallGreeting	db 'Welcome and be happy o',27h,' weary travelers! Step to the stage and listen to my tales.',0Ah,0Ah
		db 'You can:',0Ah,0Ah
		db 'Listen to the bard',0Ah
		db 'Exit the hall',0
align 2
s_songTitleList	db 'These are the songs I know...',0Ah,0Ah
		db '@Dragon Song',0Ah
		db '@Flower Ballad',0Ah
		db '@Kiel',27h,'s Overture',0Ah
		db '@Gale of Gods',0Ah
		db '@Evil',27h,'s Bane',0Ah
		db '@Minstrel Shield',0
off_4BC98	dd aDragonDragonWh
		dd aHawkslayerHawk
		dd aDragonDragonTh
		dd aHawkslayerHa_0
		dd aDragonDragonHo
		dd aHawkslayerHa_1
		dd aDragonDragonGr
		dd aHawkslayerHa_2
off_4BCB8	dd aHeWasBornWithT
		dd aInBattleHeWonT
		dd aSheWasForHimTh
		dd aHisPledgeHeMad
		dd aSoHeMadeForHer
off_4BCCC	dd aMadGodBadGodTh
		dd aRudeGodCrudeGo
		dd aCleverGodNever
off_4BCD8	dd aInTheLandOfNoT
		dd aLockingEachInH
s_bardSmiles	db 'The bard smiles and says, "That one will cost thee for your bards will learn the magic of my song."',0
s_itWillCostYou	db '"It will cost you ',0
align 2
s_bardPlaysSong	db 'The bard plays the song and you memorize the lines.',0
s_bardsHall	db 'Bard',27h,'s Hall',0
bardSongLineCount	dw 8, 5, 0, 3, 2, 0    ; 0
bardSongLyrics	dd off_4BC98	       ; 0
		dd off_4BCB8		; 1
		dd offset word_42670	; 2
		dd off_4BCCC		; 3
		dd off_4BCD8		; 4
align 8
bardSongPrice	dd 30000, 60000       ;	0
byte_4BDF0	db 1, 2     ; 0
s_noRoomForSummon db 'but no room for a summoning!',0Ah,0Ah,0
		db    0
s_andA		db 'and a ',0
		db    0
s_appears	db ' appears!',0Ah,0Ah,0
summonData      db 'Wol/f\ves',0,0,0,0,0,0,0; _name
summonHpDice    db 0A1h                 ; [0].hpDice
                dw 0Ah                  ; [0].hpBase
                db 11h                  ; [0].distance
                db 8Ch                  ; [0].packedGenAc
                db 0                    ; [0].groupSize
                db 0F0h                 ; [0].attackType._type
                db 23h                  ; [0].attackType.damage
                db 0F0h                 ; [0].attackType._type
                db 23h                  ; [0].attackType.damage
                db 0F0h                 ; [0].attackType._type
                db 23h                  ; [0].attackType.damage
                db 0F0h                 ; [0].attackType._type
                db 23h                  ; [0].attackType.damage
                db 0                    ; [0].breathFlag
                db 0                    ; [0].breathRange
                db 4                    ; [0].picIndex
                db 64h                  ; [0].rewardLo
                db 0                    ; [0].rewardMid
                db 0                    ; [0].rewardHi
                db 43h                  ; [0].flags
                db 12h                  ; [0].breathSaveLo
                db 19h                  ; [0].breathSaveHi
                db 37h                  ; [0].oppPriorityLo
                db 41h                  ; [0].oppPriorityHi
                db 0                    ; [0].strongElement
                db 0                    ; [0].weakElement
                db 8                    ; [0].repelFlags
                db 0Fh                  ; [0].toHitLo
                db 19h                  ; [0].toHitHi
                db 17h                  ; [0].spellSaveLo
                db 1Ch                  ; [0].spellSaveHi
                db 'Slayer/\s',0,0,0,0,0,0,0; _name
                db 81h                  ; [1].hpDice
                dw 40h                  ; [1].hpBase
                db 11h                  ; [1].distance
                db 17h                  ; [1].packedGenAc
                db 0                    ; [1].groupSize
                db 0F7h                 ; [1].attackType._type
                db 81h                  ; [1].attackType.damage
                db 0F7h                 ; [1].attackType._type
                db 81h                  ; [1].attackType.damage
                db 0F7h                 ; [1].attackType._type
                db 81h                  ; [1].attackType.damage
                db 0F7h                 ; [1].attackType._type
                db 81h                  ; [1].attackType.damage
                db 0                    ; [1].breathFlag
                db 0                    ; [1].breathRange
                db 21h                  ; [1].picIndex
                db 64h                  ; [1].rewardLo
                db 0                    ; [1].rewardMid
                db 0                    ; [1].rewardHi
                db 80h                  ; [1].flags
                db 12h                  ; [1].breathSaveLo
                db 19h                  ; [1].breathSaveHi
                db 37h                  ; [1].oppPriorityLo
                db 3Dh                  ; [1].oppPriorityHi
                db 8                    ; [1].strongElement
                db 0                    ; [1].weakElement
                db 4                    ; [1].repelFlags
                db 0Fh                  ; [1].toHitLo
                db 19h                  ; [1].toHitHi
                db 19h                  ; [1].spellSaveLo
                db 23h                  ; [1].spellSaveHi
                db 'Wind Warrior/\s',0  ; _name
                db 81h                  ; [2].hpDice
                dw 14h                  ; [2].hpBase
                db 11h                  ; [2].distance
                db 17h                  ; [2].packedGenAc
                db 0                    ; [2].groupSize
                db 0F0h                 ; [2].attackType._type
                db 62h                  ; [2].attackType.damage
                db 0F0h                 ; [2].attackType._type
                db 62h                  ; [2].attackType.damage
                db 0F0h                 ; [2].attackType._type
                db 62h                  ; [2].attackType.damage
                db 0F0h                 ; [2].attackType._type
                db 62h                  ; [2].attackType.damage
                db 0                    ; [2].breathFlag
                db 0                    ; [2].breathRange
                db 14h                  ; [2].picIndex
                db 64h                  ; [2].rewardLo
                db 0                    ; [2].rewardMid
                db 0                    ; [2].rewardHi
                db 94h                  ; [2].flags
                db 12h                  ; [2].breathSaveLo
                db 19h                  ; [2].breathSaveHi
                db 37h                  ; [2].oppPriorityLo
                db 3Dh                  ; [2].oppPriorityHi
                db 0                    ; [2].strongElement
                db 0                    ; [2].weakElement
                db 0                    ; [2].repelFlags
                db 0Fh                  ; [2].toHitLo
                db 19h                  ; [2].toHitHi
                db 19h                  ; [2].spellSaveLo
                db 23h                  ; [2].spellSaveHi
                db 'Wind Ogre/\s',0,0,0,0; _name
                db 0A1h                 ; [3].hpDice
                dw 0Ah                  ; [3].hpBase
                db 11h                  ; [3].distance
                db 97h                  ; [3].packedGenAc
                db 0                    ; [3].groupSize
                db 0F0h                 ; [3].attackType._type
                db 64h                  ; [3].attackType.damage
                db 0F0h                 ; [3].attackType._type
                db 64h                  ; [3].attackType.damage
                db 0FFh                 ; [3].attackType._type
                db 0                    ; [3].attackType.damage
                db 0FFh                 ; [3].attackType._type
                db 0                    ; [3].attackType.damage
                db 0                    ; [3].breathFlag
                db 0                    ; [3].breathRange
                db 33h                  ; [3].picIndex
                db 64h                  ; [3].rewardLo
                db 0                    ; [3].rewardMid
                db 0                    ; [3].rewardHi
                db 95h                  ; [3].flags
                db 12h                  ; [3].breathSaveLo
                db 19h                  ; [3].breathSaveHi
                db 37h                  ; [3].oppPriorityLo
                db 3Dh                  ; [3].oppPriorityHi
                db 0                    ; [3].strongElement
                db 0                    ; [3].weakElement
                db 0                    ; [3].repelFlags
                db 0Fh                  ; [3].toHitLo
                db 19h                  ; [3].toHitHi
                db 19h                  ; [3].spellSaveLo
                db 23h                  ; [3].spellSaveHi
                db 'Wind Dragon/\s',0,0 ; _name
                db 0A2h                 ; [4].hpDice
                dw 28h                  ; [4].hpBase
                db 11h                  ; [4].distance
                db 99h                  ; [4].packedGenAc
                db 0                    ; [4].groupSize
                db 80h                  ; [4].attackType._type
                db 69h                  ; [4].attackType.damage
                db 80h                  ; [4].attackType._type
                db 69h                  ; [4].attackType.damage
                db 0F0h                 ; [4].attackType._type
                db 69h                  ; [4].attackType.damage
                db 80h                  ; [4].attackType._type
                db 44h                  ; [4].attackType.damage
                db 0                    ; [4].breathFlag
                db 3                    ; [4].breathRange
                db 3Dh                  ; [4].picIndex
                db 64h                  ; [4].rewardLo
                db 0                    ; [4].rewardMid
                db 0                    ; [4].rewardHi
                db 0D2h                 ; [4].flags
                db 13h                  ; [4].breathSaveLo
                db 1Eh                  ; [4].breathSaveHi
                db 28h                  ; [4].oppPriorityLo
                db 46h                  ; [4].oppPriorityHi
                db 80h                  ; [4].strongElement
                db 10h                  ; [4].weakElement
                db 1                    ; [4].repelFlags
                db 14h                  ; [4].toHitLo
                db 1Eh                  ; [4].toHitHi
                db 0Ah                  ; [4].spellSaveLo
                db 64h                  ; [4].spellSaveHi
                db 'Wind Giant/\s',0,0,0; _name
                db 0A3h                 ; [5].hpDice
                dw 0Fh                  ; [5].hpBase
                db 11h                  ; [5].distance
                db 19h                  ; [5].packedGenAc
                db 0                    ; [5].groupSize
                db 80h                  ; [5].attackType._type
                db 6Bh                  ; [5].attackType.damage
                db 0F0h                 ; [5].attackType._type
                db 6Bh                  ; [5].attackType.damage
                db 0F0h                 ; [5].attackType._type
                db 6Bh                  ; [5].attackType.damage
                db 23h                  ; [5].attackType._type
                db 32h                  ; [5].attackType.damage
                db 2                    ; [5].breathFlag
                db 4                    ; [5].breathRange
                db 33h                  ; [5].picIndex
                db 64h                  ; [5].rewardLo
                db 0                    ; [5].rewardMid
                db 0                    ; [5].rewardHi
                db 0D5h                 ; [5].flags
                db 15h                  ; [5].breathSaveLo
                db 20h                  ; [5].breathSaveHi
                db 1Eh                  ; [5].oppPriorityLo
                db 3Ch                  ; [5].oppPriorityHi
                db 0                    ; [5].strongElement
                db 0                    ; [5].weakElement
                db 0                    ; [5].repelFlags
                db 19h                  ; [5].toHitLo
                db 23h                  ; [5].toHitHi
                db 0Ah                  ; [5].spellSaveLo
                db 1Eh                  ; [5].spellSaveHi
                db 'Wind Her/o\oes',0,0 ; _name
                db 0A4h                 ; [6].hpDice
                dw 14h                  ; [6].hpBase
                db 11h                  ; [6].distance
                db 1Bh                  ; [6].packedGenAc
                db 20h                  ; [6].groupSize
                db 0F0h                 ; [6].attackType._type
                db 6Ch                  ; [6].attackType.damage
                db 0F0h                 ; [6].attackType._type
                db 6Ch                  ; [6].attackType.damage
                db 0F0h                 ; [6].attackType._type
                db 8Ch                  ; [6].attackType.damage
                db 0F0h                 ; [6].attackType._type
                db 6Ch                  ; [6].attackType.damage
                db 0                    ; [6].breathFlag
                db 0                    ; [6].breathRange
                db 0Ah                  ; [6].picIndex
                db 64h                  ; [6].rewardLo
                db 0                    ; [6].rewardMid
                db 0                    ; [6].rewardHi
                db 94h                  ; [6].flags
                db 16h                  ; [6].breathSaveLo
                db 21h                  ; [6].breathSaveHi
                db 2Ah                  ; [6].oppPriorityLo
                db 48h                  ; [6].oppPriorityHi
                db 0                    ; [6].strongElement
                db 0                    ; [6].weakElement
                db 0                    ; [6].repelFlags
                db 19h                  ; [6].toHitLo
                db 23h                  ; [6].toHitHi
                db 0Ah                  ; [6].spellSaveLo
                db 64h                  ; [6].spellSaveHi
                db 'Fire Elemental/',0  ; _name
                db 81h                  ; [7].hpDice
                dw 0Ah                  ; [7].hpBase
                db 11h                  ; [7].distance
                db 97h                  ; [7].packedGenAc
                db 0                    ; [7].groupSize
                db 0F0h                 ; [7].attackType._type
                db 64h                  ; [7].attackType.damage
                db 0F0h                 ; [7].attackType._type
                db 64h                  ; [7].attackType.damage
                db 0F0h                 ; [7].attackType._type
                db 64h                  ; [7].attackType.damage
                db 0F0h                 ; [7].attackType._type
                db 64h                  ; [7].attackType.damage
                db 0                    ; [7].breathFlag
                db 0                    ; [7].breathRange
                db 5                    ; [7].picIndex
                db 64h                  ; [7].rewardLo
                db 0                    ; [7].rewardMid
                db 0                    ; [7].rewardHi
                db 85h                  ; [7].flags
                db 12h                  ; [7].breathSaveLo
                db 19h                  ; [7].breathSaveHi
                db 37h                  ; [7].oppPriorityLo
                db 3Dh                  ; [7].oppPriorityHi
                db 80h                  ; [7].strongElement
                db 10h                  ; [7].weakElement
                db 0                    ; [7].repelFlags
                db 0Fh                  ; [7].toHitLo
                db 19h                  ; [7].toHitHi
                db 19h                  ; [7].spellSaveLo
                db 23h                  ; [7].spellSaveHi
                db 'Demon/\s',0,0,0,0,0,0,0,0; _name
                db 0A2h                 ; [8].hpDice
                dw 0Ch                  ; [8].hpBase
                db 11h                  ; [8].distance
                db 94h                  ; [8].packedGenAc
                db 0                    ; [8].groupSize
                db 80h                  ; [8].attackType._type
                db 44h                  ; [8].attackType.damage
                db 80h                  ; [8].attackType._type
                db 44h                  ; [8].attackType.damage
                db 0F0h                 ; [8].attackType._type
                db 64h                  ; [8].attackType.damage
                db 0F0h                 ; [8].attackType._type
                db 64h                  ; [8].attackType.damage
                db 0                    ; [8].breathFlag
                db 4                    ; [8].breathRange
                db 17h                  ; [8].picIndex
                db 64h                  ; [8].rewardLo
                db 0                    ; [8].rewardMid
                db 0                    ; [8].rewardHi
                db 80h                  ; [8].flags
                db 12h                  ; [8].breathSaveLo
                db 19h                  ; [8].breathSaveHi
                db 37h                  ; [8].oppPriorityLo
                db 3Dh                  ; [8].oppPriorityHi
                db 0                    ; [8].strongElement
                db 20h                  ; [8].weakElement
                db 40h                  ; [8].repelFlags
                db 0Fh                  ; [8].toHitLo
                db 19h                  ; [8].toHitHi
                db 19h                  ; [8].spellSaveLo
                db 23h                  ; [8].spellSaveHi
                db 'Herb/\s',0,0,0,0,0,0,0,0,0; _name
                db 0E0h                 ; [9].hpDice
                dw 28h                  ; [9].hpBase
                db 11h                  ; [9].distance
                db 16h                  ; [9].packedGenAc
                db 0                    ; [9].groupSize
                db 0F0h                 ; [9].attackType._type
                db 69h                  ; [9].attackType.damage
                db 0F0h                 ; [9].attackType._type
                db 69h                  ; [9].attackType.damage
                db 0F0h                 ; [9].attackType._type
                db 69h                  ; [9].attackType.damage
                db 42h                  ; [9].attackType._type
                db 20h                  ; [9].attackType.damage
                db 0                    ; [9].breathFlag
                db 0                    ; [9].breathRange
                db 5                    ; [9].picIndex
                db 64h                  ; [9].rewardLo
                db 0                    ; [9].rewardMid
                db 0                    ; [9].rewardHi
                db 82h                  ; [9].flags
                db 13h                  ; [9].breathSaveLo
                db 1Eh                  ; [9].breathSaveHi
                db 28h                  ; [9].oppPriorityLo
                db 46h                  ; [9].oppPriorityHi
                db 0                    ; [9].strongElement
                db 0                    ; [9].weakElement
                db 0                    ; [9].repelFlags
                db 14h                  ; [9].toHitLo
                db 1Eh                  ; [9].toHitHi
                db 0Ah                  ; [9].spellSaveLo
                db 64h                  ; [9].spellSaveHi
                db 'Greater Demon',0,0,0; _name
                db 0E1h                 ; [10].hpDice
                dw 0Ah                  ; [10].hpBase
                db 11h                  ; [10].distance
                db 9Ch                  ; [10].packedGenAc
                db 0                    ; [10].groupSize
                db 0F0h                 ; [10].attackType._type
                db 6Ch                  ; [10].attackType.damage
                db 0F0h                 ; [10].attackType._type
                db 6Ch                  ; [10].attackType.damage
                db 80h                  ; [10].attackType._type
                db 69h                  ; [10].attackType.damage
                db 80h                  ; [10].attackType._type
                db 69h                  ; [10].attackType.damage
                db 2                    ; [10].breathFlag
                db 5                    ; [10].breathRange
                db 5                    ; [10].picIndex
                db 64h                  ; [10].rewardLo
                db 0                    ; [10].rewardMid
                db 0                    ; [10].rewardHi
                db 0C5h                 ; [10].flags
                db 16h                  ; [10].breathSaveLo
                db 23h                  ; [10].breathSaveHi
                db 20h                  ; [10].oppPriorityLo
                db 48h                  ; [10].oppPriorityHi
                db 0                    ; [10].strongElement
                db 20h                  ; [10].weakElement
                db 40h                  ; [10].repelFlags
                db 19h                  ; [10].toHitLo
                db 25h                  ; [10].toHitHi
                db 0Fh                  ; [10].spellSaveLo
                db 64h                  ; [10].spellSaveHi
                db 'Kringle Bro',27h,0,0,0,0; _name
                db 0E1h                 ; [11].hpDice
                dw 0C8h                 ; [11].hpBase
                db 11h                  ; [11].distance
                db 1Eh                  ; [11].packedGenAc
                db 0                    ; [11].groupSize
                db 0F0h                 ; [11].attackType._type
                db 73h                  ; [11].attackType.damage
                db 0F0h                 ; [11].attackType._type
                db 73h                  ; [11].attackType.damage
                db 0F0h                 ; [11].attackType._type
                db 73h                  ; [11].attackType.damage
                db 4Bh                  ; [11].attackType._type
                db 19h                  ; [11].attackType.damage
                db 0                    ; [11].breathFlag
                db 0                    ; [11].breathRange
                db 0Ah                  ; [11].picIndex
                db 64h                  ; [11].rewardLo
                db 0                    ; [11].rewardMid
                db 0                    ; [11].rewardHi
                db 85h                  ; [11].flags
                db 16h                  ; [11].breathSaveLo
                db 23h                  ; [11].breathSaveHi
                db 32h                  ; [11].oppPriorityLo
                db 50h                  ; [11].oppPriorityHi
                db 0                    ; [11].strongElement
                db 0                    ; [11].weakElement
                db 0                    ; [11].repelFlags
                db 23h                  ; [11].toHitLo
                db 2Dh                  ; [11].toHitHi
                db 0Ah                  ; [11].spellSaveLo
                db 64h                  ; [11].spellSaveHi
                db 'Earth Elemental',0  ; _name
                db 0E2h                 ; [12].hpDice
                dw 12Ch                 ; [12].hpBase
                db 11h                  ; [12].distance
                db 9Fh                  ; [12].packedGenAc
                db 0                    ; [12].groupSize
                db 0F0h                 ; [12].attackType._type
                db 8Eh                  ; [12].attackType.damage
                db 0F0h                 ; [12].attackType._type
                db 8Eh                  ; [12].attackType.damage
                db 0F0h                 ; [12].attackType._type
                db 8Eh                  ; [12].attackType.damage
                db 6Eh                  ; [12].attackType._type
                db 32h                  ; [12].attackType.damage
                db 0                    ; [12].breathFlag
                db 0                    ; [12].breathRange
                db 5                    ; [12].picIndex
                db 64h                  ; [12].rewardLo
                db 0                    ; [12].rewardMid
                db 0                    ; [12].rewardHi
                db 0C5h                 ; [12].flags
                db 16h                  ; [12].breathSaveLo
                db 23h                  ; [12].breathSaveHi
                db 32h                  ; [12].oppPriorityLo
                db 50h                  ; [12].oppPriorityHi
                db 0                    ; [12].strongElement
                db 0                    ; [12].weakElement
                db 0                    ; [12].repelFlags
                db 23h                  ; [12].toHitLo
                db 2Dh                  ; [12].toHitHi
                db 0Ah                  ; [12].spellSaveLo
                db 64h                  ; [12].spellSaveHi
                db 'Frost Giant/\s',0,0 ; _name
                db 0A1h                 ; [13].hpDice
                dw 14h                  ; [13].hpBase
                db 11h                  ; [13].distance
                db 17h                  ; [13].packedGenAc
                db 0                    ; [13].groupSize
                db 0F0h                 ; [13].attackType._type
                db 64h                  ; [13].attackType.damage
                db 0F0h                 ; [13].attackType._type
                db 64h                  ; [13].attackType.damage
                db 0F0h                 ; [13].attackType._type
                db 64h                  ; [13].attackType.damage
                db 0FFh                 ; [13].attackType._type
                db 0                    ; [13].attackType.damage
                db 0                    ; [13].breathFlag
                db 0                    ; [13].breathRange
                db 33h                  ; [13].picIndex
                db 64h                  ; [13].rewardLo
                db 0                    ; [13].rewardMid
                db 0                    ; [13].rewardHi
                db 0C5h                 ; [13].flags
                db 12h                  ; [13].breathSaveLo
                db 19h                  ; [13].breathSaveHi
                db 37h                  ; [13].oppPriorityLo
                db 3Dh                  ; [13].oppPriorityHi
                db 10h                  ; [13].strongElement
                db 80h                  ; [13].weakElement
                db 0                    ; [13].repelFlags
                db 0Fh                  ; [13].toHitLo
                db 19h                  ; [13].toHitHi
                db 19h                  ; [13].spellSaveLo
                db 23h                  ; [13].spellSaveHi
                db 'Molten M/an\en',0,0 ; _name
                db 0C0h                 ; [14].hpDice
                dw 32h                  ; [14].hpBase
                db 11h                  ; [14].distance
                db 94h                  ; [14].packedGenAc
                db 0                    ; [14].groupSize
                db 80h                  ; [14].attackType._type
                db 62h                  ; [14].attackType.damage
                db 80h                  ; [14].attackType._type
                db 62h                  ; [14].attackType.damage
                db 0F0h                 ; [14].attackType._type
                db 64h                  ; [14].attackType.damage
                db 0F0h                 ; [14].attackType._type
                db 64h                  ; [14].attackType.damage
                db 4                    ; [14].breathFlag
                db 4                    ; [14].breathRange
                db 5                    ; [14].picIndex
                db 64h                  ; [14].rewardLo
                db 0                    ; [14].rewardMid
                db 0                    ; [14].rewardHi
                db 80h                  ; [14].flags
                db 13h                  ; [14].breathSaveLo
                db 1Ah                  ; [14].breathSaveHi
                db 38h                  ; [14].oppPriorityLo
                db 3Eh                  ; [14].oppPriorityHi
                db 80h                  ; [14].strongElement
                db 10h                  ; [14].weakElement
                db 0                    ; [14].repelFlags
                db 10h                  ; [14].toHitLo
                db 1Ah                  ; [14].toHitHi
                db 19h                  ; [14].spellSaveLo
                db 24h                  ; [14].spellSaveHi
                db 'Bulldozer/\s',0,0,0,0; _name
                db 0E0h                 ; [15].hpDice
                dw 30h                  ; [15].hpBase
                db 1                    ; [15].distance
                db 98h                  ; [15].packedGenAc
                db 0                    ; [15].groupSize
                db 0F0h                 ; [15].attackType._type
                db 69h                  ; [15].attackType.damage
                db 0F0h                 ; [15].attackType._type
                db 69h                  ; [15].attackType.damage
                db 0F0h                 ; [15].attackType._type
                db 6Bh                  ; [15].attackType.damage
                db 0F0h                 ; [15].attackType._type
                db 6Bh                  ; [15].attackType.damage
                db 0                    ; [15].breathFlag
                db 0                    ; [15].breathRange
                db 0Bh                  ; [15].picIndex
                db 64h                  ; [15].rewardLo
                db 0                    ; [15].rewardMid
                db 0                    ; [15].rewardHi
                db 0C0h                 ; [15].flags
                db 13h                  ; [15].breathSaveLo
                db 1Eh                  ; [15].breathSaveHi
                db 28h                  ; [15].oppPriorityLo
                db 46h                  ; [15].oppPriorityHi
                db 0                    ; [15].strongElement
                db 0                    ; [15].weakElement
                db 0                    ; [15].repelFlags
                db 14h                  ; [15].toHitLo
                db 1Eh                  ; [15].toHitHi
                db 0Ah                  ; [15].spellSaveLo
                db 64h                  ; [15].spellSaveHi
                db 'Vanquisher/\s',0,0,0; _name
                db 0E1h                 ; [16].hpDice
                dw 40h                  ; [16].hpBase
                db 11h                  ; [16].distance
                db 9Dh                  ; [16].packedGenAc
                db 0                    ; [16].groupSize
                db 32h                  ; [16].attackType._type
                db 1Eh                  ; [16].attackType.damage
                db 3Dh                  ; [16].attackType._type
                db 1Eh                  ; [16].attackType.damage
                db 32h                  ; [16].attackType._type
                db 1Eh                  ; [16].attackType.damage
                db 42h                  ; [16].attackType._type
                db 1Eh                  ; [16].attackType.damage
                db 0                    ; [16].breathFlag
                db 0                    ; [16].breathRange
                db 36h                  ; [16].picIndex
                db 64h                  ; [16].rewardLo
                db 0                    ; [16].rewardMid
                db 0                    ; [16].rewardHi
                db 82h                  ; [16].flags
                db 16h                  ; [16].breathSaveLo
                db 23h                  ; [16].breathSaveHi
                db 32h                  ; [16].oppPriorityLo
                db 50h                  ; [16].oppPriorityHi
                db 0                    ; [16].strongElement
                db 0                    ; [16].weakElement
                db 0                    ; [16].repelFlags
                db 23h                  ; [16].toHitLo
                db 2Dh                  ; [16].toHitHi
                db 0Ah                  ; [16].spellSaveLo
                db 64h                  ; [16].spellSaveHi
                db 'Blast Dragon/\s',0  ; _name
                db 0E3h                 ; [17].hpDice
                dw 20h                  ; [17].hpBase
                db 11h                  ; [17].distance
                db 9Dh                  ; [17].packedGenAc
                db 0                    ; [17].groupSize
                db 0F0h                 ; [17].attackType._type
                db 6Eh                  ; [17].attackType.damage
                db 80h                  ; [17].attackType._type
                db 6Eh                  ; [17].attackType.damage
                db 80h                  ; [17].attackType._type
                db 6Eh                  ; [17].attackType.damage
                db 0F0h                 ; [17].attackType._type
                db 6Eh                  ; [17].attackType.damage
                db 2                    ; [17].breathFlag
                db 5                    ; [17].breathRange
                db 3Dh                  ; [17].picIndex
                db 64h                  ; [17].rewardLo
                db 0                    ; [17].rewardMid
                db 0                    ; [17].rewardHi
                db 0C2h                 ; [17].flags
                db 17h                  ; [17].breathSaveLo
                db 24h                  ; [17].breathSaveHi
                db 34h                  ; [17].oppPriorityLo
                db 52h                  ; [17].oppPriorityHi
                db 80h                  ; [17].strongElement
                db 0                    ; [17].weakElement
                db 1                    ; [17].repelFlags
                db 24h                  ; [17].toHitLo
                db 2Eh                  ; [17].toHitHi
                db 0Ah                  ; [17].spellSaveLo
                db 64h                  ; [17].spellSaveHi
                db 'One-eyed Angra',0,0 ; _name
                db 0E2h                 ; [18].hpDice
                dw 82h                  ; [18].hpBase
                db 11h                  ; [18].distance
                db 0DAh                 ; [18].packedGenAc
                db 0                    ; [18].groupSize
                db 48h                  ; [18].attackType._type
                db 20h                  ; [18].attackType.damage
                db 4Bh                  ; [18].attackType._type
                db 23h                  ; [18].attackType.damage
                db 4Bh                  ; [18].attackType._type
                db 23h                  ; [18].attackType.damage
                db 2Dh                  ; [18].attackType._type
                db 23h                  ; [18].attackType.damage
                db 0                    ; [18].breathFlag
                db 0                    ; [18].breathRange
                db 36h                  ; [18].picIndex
                db 64h                  ; [18].rewardLo
                db 0                    ; [18].rewardMid
                db 0                    ; [18].rewardHi
                db 80h                  ; [18].flags
                db 19h                  ; [18].breathSaveLo
                db 28h                  ; [18].breathSaveHi
                db 28h                  ; [18].oppPriorityLo
                db 46h                  ; [18].oppPriorityHi
                db 0                    ; [18].strongElement
                db 0                    ; [18].weakElement
                db 0                    ; [18].repelFlags
                db 22h                  ; [18].toHitLo
                db 2Eh                  ; [18].toHitHi
                db 0Ah                  ; [18].spellSaveLo
                db 5Ah                  ; [18].spellSaveHi
                db 'Black Death',0,0,0,0,0; _name
                db 0E9h                 ; [19].hpDice
                dw 64h                  ; [19].hpBase
                db 11h                  ; [19].distance
                db 0A0h                 ; [19].packedGenAc
                db 20h                  ; [19].groupSize
                db 0F7h                 ; [19].attackType._type
                db 0C9h                 ; [19].attackType.damage
                db 0F7h                 ; [19].attackType._type
                db 0E9h                 ; [19].attackType.damage
                db 5Bh                  ; [19].attackType._type
                db 28h                  ; [19].attackType.damage
                db 63h                  ; [19].attackType._type
                db 0                    ; [19].attackType.damage
                db 0                    ; [19].breathFlag
                db 0                    ; [19].breathRange
                db 24h                  ; [19].picIndex
                db 64h                  ; [19].rewardLo
                db 0                    ; [19].rewardMid
                db 0                    ; [19].rewardHi
                db 80h                  ; [19].flags
                db 1Eh                  ; [19].breathSaveLo
                db 28h                  ; [19].breathSaveHi
                db 3Ch                  ; [19].oppPriorityLo
                db 5Ah                  ; [19].oppPriorityHi
                db 0                    ; [19].strongElement
                db 20h                  ; [19].weakElement
                db 0                    ; [19].repelFlags
                db 28h                  ; [19].toHitLo
                db 2Fh                  ; [19].toHitHi
                db 14h                  ; [19].spellSaveLo
                db 64h                  ; [19].spellSaveHi
                db 'Familiar/\s',0,0,0,0,0; _name
                db 49h                  ; [20].hpDice
                dw 32h                  ; [20].hpBase
                db 11h                  ; [20].distance
                db 99h                  ; [20].packedGenAc
                db 0                    ; [20].groupSize
                db 4Ch                  ; [20].attackType._type
                db 32h                  ; [20].attackType.damage
                db 22h                  ; [20].attackType._type
                db 32h                  ; [20].attackType.damage
                db 2Dh                  ; [20].attackType._type
                db 32h                  ; [20].attackType.damage
                db 5Ah                  ; [20].attackType._type
                db 32h                  ; [20].attackType.damage
                db 0                    ; [20].breathFlag
                db 0                    ; [20].breathRange
                db 12h                  ; [20].picIndex
                db 64h                  ; [20].rewardLo
                db 0                    ; [20].rewardMid
                db 0                    ; [20].rewardHi
                db 3                    ; [20].flags
                db 1Eh                  ; [20].breathSaveLo
                db 28h                  ; [20].breathSaveHi
                db 0Ah                  ; [20].oppPriorityLo
                db 14h                  ; [20].oppPriorityHi
                db 4                    ; [20].strongElement
                db 0                    ; [20].weakElement
                db 0                    ; [20].repelFlags
                db 0Ah                  ; [20].toHitLo
                db 0Ah                  ; [20].toHitHi
                db 0Ah                  ; [20].spellSaveLo
                db 0Ah                  ; [20].spellSaveHi
                db 'Black Slayer/\s',0  ; _name
                db 0                    ; [21].hpDice
                dw 0FA0h                ; [21].hpBase
                db 12h                  ; [21].distance
                db 0A7h                 ; [21].packedGenAc
                db 23h                  ; [21].groupSize
                db 0F7h                 ; [21].attackType._type
                db 64h                  ; [21].attackType.damage
                db 0F7h                 ; [21].attackType._type
                db 84h                  ; [21].attackType.damage
                db 0F7h                 ; [21].attackType._type
                db 85h                  ; [21].attackType.damage
                db 0F7h                 ; [21].attackType._type
                db 65h                  ; [21].attackType.damage
                db 0                    ; [21].breathFlag
                db 0                    ; [21].breathRange
                db 41h                  ; [21].picIndex
                db 50h                  ; [21].rewardLo
                db 0C3h                 ; [21].rewardMid
                db 0                    ; [21].rewardHi
                db 80h                  ; [21].flags
                db 28h                  ; [21].breathSaveLo
                db 32h                  ; [21].breathSaveHi
                db 5Ah                  ; [21].oppPriorityLo
                db 78h                  ; [21].oppPriorityHi
                db 0                    ; [21].strongElement
                db 20h                  ; [21].weakElement
                db 10h                  ; [21].repelFlags
                db 28h                  ; [21].toHitLo
                db 3Ch                  ; [21].toHitHi
                db 28h                  ; [21].spellSaveLo
                db 46h                  ; [21].spellSaveHi
s_nl	db  0Ah
		db    0
s_displayQuestion	db 'What type of display do you wish to use?',0
s_videoOption1	db 0Ah,0Ah
		db '1) Composite or TV monitor.',0
s_videoOption2	db 0Ah,'2) RGB monitor.',0
s_videoOption3	db 0Ah,'3) EGA monitor.',0
s_videoOption4	db 0Ah,'4) Tandy computer with RGB monitor.',0
s_videoQuestion	db 0Ah,0Ah
		db 'Please enter the appropriate number for your system type:',0
s_soundQuestion db 'What type of sound output device do you wish to use?',0
s_soundOption1		db 0Ah,0Ah,'1) MT32.',0
s_soundOption2	db 0Ah,'2) Ad Lib.',0
s_soundOption3 db 0Ah,'3) Internal IBM speaker.',0
s_soundOption4	db 0Ah,'4) Tandy.',0
s_soundOption5		db 0Ah,'5) PS/1',0
s_soundPrompt db 0Ah,0Ah,'Please enter the appropriate number for your system type:',0
s_diskToTransferFrom	db 'Disk to transfer characters from?',0
s_whoShallTransfer	db 'Who shall transfer?',0
s_characterAlreadyExists	db 'This character already exists',0
s_noCharactersFoundOn	db 'No characters found on',0
		db    0
s_noPartiesFoundOn	db 'No parties found on',0
s_transferVersionPrompt	db 'Transfer characters from:',0Ah
		db '1) Bards I',0Ah
		db '2) Bards II',0Ah
		db '3) Bards III',0Ah
		db 'E) Exit',0
bi_inventoryMap	db 0, 1, 2, 3, 4, 5, 6,	7, 6, 9; 0
		db 0Ah,	0Bh, 0Ch, 0Dh, 0Eh, 0Fh, 10h, 11h, 12h,	13h; 10
		db 14h,	14h, 14h, 17h, 18h, 19h, 1Ah, 0, 1Ch, 1Dh; 20
		db 1Eh,	1Fh, 20h, 21h, 22h, 23h, 0, 25h, 0, 0; 30
		db 28h,	0, 29h,	2Ah, 0,	2Ch, 2Dh, 2Eh, 2Fh, 30h; 40
		db 31h,	0, 32h,	33h, 0,	0, 34h,	0, 36h,	0; 50
		db 37h,	1Bh, 39h, 0, 3Bh, 3Ch, 0, 3Eh, 3Fh, 40h; 60
		db 41h,	42h, 0,	45h, 0,	0, 46h,	47h, 59h, 49h; 70
		db 0, 4Bh, 0, 0, 4Eh, 0, 4Fh, 51h, 0, 53h; 80
		db 54h,	55h, 0,	57h, 0,	5Ah, 5Bh, 0, 0,	5Eh; 90
		db 5Fh,	58h, 0,	0, 0, 0, 43h, 0, 62h, 0; 100
		db 64h,	64h, 0,	59h, 6Ch, 0, 0,	0, 0, 0; 110
		db 0, 0, 0, 0, 0, 0, 0,	0; 120
bii_inventoryMap db 0, 1, 2, 3,	4, 5, 6, 7, 8, 9; 0
		db 10, 11, 12, 13, 14, 15, 16, 17, 18, 19; 10
		db 20, 21, 22, 23, 24, 25, 26, 27, 28, 29; 20
		db 30, 31, 32, 33, 34, 35, 36, 37, 38, 39; 30
		db 40, 41, 42, 43, 44, 45, 46, 47, 48, 49; 40
		db 50, 51, 52, 53, 54, 55, 56, 57, 58, 59; 50
		db 60, 61, 62, 63, 64, 65, 66, 67, 68, 69; 60
		db 70, 71, 72, 73, 74, 75, 76, 77, 78, 79; 70
		db 80, 81, 82, 83, 84, 85, 86, 87, 88, 89; 80
		db 90, 91, 92, 93, 94, 95, 96, 97, 98, 99; 90
		db 100,	101, 102, 103, 104, 105, 106, 107, 108,	109; 100
		db 110,	111, 0,	0, 0, 0, 0, 0, 0, 0; 110
		db 0, 0, 0, 0, 0, 0, 0,	0; 120
bii_classMap	db 0, 7, 5, 6, 8, 9, 3, 4,	2, 1, 0Ah; 0
		db 0Dh,	0Eh		; 11
s_tpw		db '*.tpw',0
s_tw		db '*.tw',0
oldCharFilters	dd s_tpw, s_tw	       ; 0
aAcorns		db 'Acorns',0
aArrowsOfLife	db 'Arrows of Life',0
aMalefia	db 'Malefia',0
aValarian	db 'Valarian',0
aLanatir	db 'Lanatir',0
aFerofist	db 'Ferofist',0
aSceadu		db 'Sceadu',0
aWerra		db 'Werra',0
aTarjan		db 'Tarjan',0
aSkaraBrae	db 'Skara Brae',0
s_unterbrae	db 'UnterBrae',0
aArboria	db 'Arboria',0
aGelidia	db 'Gelidia',0
aLucencia	db 'Lucencia',0
aKinestia	db 'Kinestia',0
aTenebrosia	db 'Tenebrosia',0
aTarmitia	db 'Tarmitia',0
aCieraBrannia	db 'Ciera Brannia',0
aCelariaBree	db 'Celaria Bree',0
aBlackScar	db 'Black Scar',0
aDarkCopse	db 'Dark Copse',0
aNowhere	db 'Nowhere',0
aFesteringPit	db 'Festering Pit',0
aSacredGrove	db 'Sacred Grove',0
aIceKeep	db 'Ice Keep',0
aShadowCanyon	db 'Shadow Canyon',0
aTarQuarry	db 'Tar Quarry',0
aColdPeak	db 'Cold Peak',0
aCrystalSpring	db 'Crystal Spring',0
aOldDwarfMine	db 'Old Dwarf Mine',0
aShadowRock	db 'Shadow Rock',0
aSulphurSprings	db 'Sulphur Springs',0
aWarriorsVale	db 'Warriors Vale',0
aBrilhasti	db 'Brilhasti',0
s_urmech		db 'Urmech',0
aTslotha	db 'Tslotha',0
aCyanis		db 'Cyanis',0
aTheOldMan	db 'The Old Man',0
aHawkslayer	db 'Hawkslayer',0
aVioletMountain	db 'Violet Mountains',0
aCrystalPalace	db 'Crystal Palace',0
aCatacombs	db 'Catacombs',0
aTunnels	db 'Tunnels',0
aWorkshop	db 'Workshop',0
aWizardSGuild	db 'Wizard',27h,'s Guild',0
align 2
s_copyProtectIntro	db 'To traverse time and space, you must first recite the alignment value of ',0
s_commaAnd		db ', and ',0
align 2
s_commaSpace	db ', ',0
align 2
s_period		db '.',0
aYouHaveFailedT	db 'You have failed to recite the proper alignment pattern!',0
g_cpLocationFour	dd aArefolia, aAcorns ; 0
		dd aArrowsOfLife, aCrystalKey; 2
		dd aCrownOfTruth, aStrifespear; 4
		dd aRainbowRose, aCrystalLens; 6
		dd aSmokeyLens, aBlackLens;	8
		dd aShadowDoor, aShadowLock; 10
		dd aWineskin,	aNightspear; 12
		dd aHammerOfWrath, aWandOfPower; 14
g_cpLocationOne	dd aMalefia, aValarian  ; 0
		dd aLanatir, s_alliria	; 2
		dd aFerofist, aSceadu	; 4
		dd aWerra, aTarjan	; 6
		dd aSkaraBrae, s_unterbrae; 8
		dd aArboria, aGelidia	; 10
		dd aLucencia, aKinestia	; 12
		dd aTenebrosia,	aTarmitia; 14
g_cpLocationTwo	dd aCieraBrannia, aCelariaBree; 0
		dd aBlackScar, aDarkCopse; 2
		dd aNowhere, aFesteringPit; 4
		dd aSacredGrove, aIceKeep; 6
		dd aShadowCanyon, aTarQuarry; 8
		dd aColdPeak, aCrystalSpring; 10
		dd aOldDwarfMine, aShadowRock; 12
		dd aSulphurSprings, aWarriorsVale; 14
g_cpLocationThree	dd aBrilhasti, s_urmech  ; 0
		dd aTslotha, aCyanis	; 2
		dd aTheOldMan, aHawkslayer; 4
		dd s_scrapwood, s_bardsHall; 6
		dd s_staggerInn, s_hicHaven; 8
		dd aVioletMountain, aCrystalPalace; 10
		dd aCatacombs, aTunnels	; 12
		dd aWorkshop, aWizardSGuild; 14
byte_4CA18	db 0, 4		   ; 0
		db 18,	23		; 2
		db 37,	49		; 4
		db 51,	70		; 6
		db 84,	98		; 8
		db 102,	112		; 10
		db 131,	133		; 12
		db 145,	151		; 14
byte_4CA28	db 0Dh			; 0
		db 7			; 1
		db    0			; 2
		db    2			; 3
		db    6			; 4
		db    9			; 5
		db  0Fh			; 6
		db    3			; 7
		db    5			; 8
		db  0Ch			; 9
		db  0Ah			; 10
		db    1			; 11
		db  0Eh			; 12
		db    8			; 13
		db    4			; 14
		db  0Bh			; 15
byte_4CA38	db 1
		db  0Fh
		db  7Fh
		db 0FFh
		db    0
		db    0
		db    0

byte_4CA3F	db 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3
		db 3, 3, 3, 3, 3, 3, 3,	3, 3, 3, 3, 3, 3, 3, 3,	3
		db 4, 4, 4, 4, 4, 4, 4,	4, 4, 4, 4, 4, 4, 4, 4,	4
		db 4, 4, 4, 4, 4, 4, 4,	4, 4, 4, 4, 4, 4, 4, 4,	4
		db 4, 4, 4, 4, 4, 4, 4,	4, 4, 4, 4, 4, 4, 4, 4,	4
		db 5, 5, 5, 5, 5, 5, 5,	5, 5, 5, 5, 5, 5, 5, 5,	5
		db 5, 5, 5, 5, 5, 5, 5,	5, 5, 5, 5, 5, 5, 5, 5,	5
		db 5, 5, 5, 5, 5, 5, 5,	5, 5, 5, 5, 5, 5, 5, 5,	5
		db 5, 5, 5, 5, 5, 5, 5,	5, 5, 5, 5, 5, 5, 5, 5,	5
		db 6, 6, 6, 6, 6, 6, 6,	6, 6, 6, 6, 6, 6, 6, 6,	6
		db 6, 6, 6, 6, 6, 6, 6,	6, 6, 6, 6, 6, 6, 6, 6,	6
		db 6, 6, 6, 6, 6, 6, 6,	6, 6, 6, 6, 6, 6, 6, 6,	6
		db 7, 7, 7, 7, 7, 7, 7,	7, 7, 7, 7, 7, 7, 7, 7,	7
		db 7, 7, 7, 7, 7, 7, 7,	7, 7, 7, 7, 7, 7, 7, 7,	7
		db 7, 7, 7, 7, 7, 7, 7,	7, 7, 7, 7, 7, 7, 7, 7,	7
		db 8, 8, 8, 8, 8, 8, 8,	8, 8, 8, 8, 8, 8, 8, 8,	8
byte_4CB3F	db 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0; 0
		db 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0; 16
		db 1, 1, 1, 1, 1, 1, 1,	1, 1, 1, 1, 1, 1, 1, 1,	1; 32
		db 2, 2, 2, 2, 2, 2, 2,	2, 2, 2, 2, 2, 2, 2, 2,	2; 48
		db 3, 3, 3, 3, 3, 3, 3,	3, 3, 3, 3, 3, 3, 3, 3,	3; 64
		db 4, 4, 4, 4, 4, 4, 4,	4, 5, 5, 5, 5, 5, 5, 5,	5; 80
		db 6, 6, 6, 6, 6, 6, 6,	6, 7, 7, 7, 7, 7, 7, 7,	7; 96
		db 8, 8, 8, 8, 8, 8, 8,	8, 9, 9, 9, 9, 9, 9, 9,	9; 112
		db 0Ah,	0Ah, 0Ah, 0Ah, 0Ah, 0Ah, 0Ah, 0Ah, 0Bh,	0Bh, 0Bh, 0Bh, 0Bh, 0Bh, 0Bh, 0Bh; 128
		db 0Ch,	0Ch, 0Ch, 0Ch, 0Dh, 0Dh, 0Dh, 0Dh, 0Eh,	0Eh, 0Eh, 0Eh, 0Fh, 0Fh, 0Fh, 0Fh; 144
		db 10h,	10h, 10h, 10h, 11h, 11h, 11h, 11h, 12h,	12h, 12h, 12h, 13h, 13h, 13h, 13h; 160
		db 14h,	14h, 14h, 14h, 15h, 15h, 15h, 15h, 16h,	16h, 16h, 16h, 17h, 17h, 17h, 17h; 176
		db 18h,	18h, 19h, 19h, 1Ah, 1Ah, 1Bh, 1Bh, 1Ch,	1Ch, 1Dh, 1Dh, 1Eh, 1Eh, 1Fh, 1Fh; 192
		db 20h,	20h, 21h, 21h, 22h, 22h, 23h, 23h, 24h,	24h, 25h, 25h, 26h, 26h, 27h, 27h; 208
		db 28h,	28h, 29h, 29h, 2Ah, 2Ah, 2Bh, 2Bh, 2Ch,	2Ch, 2Dh, 2Dh, 2Eh, 2Eh, 2Fh, 2Fh; 224
		db 30h,	31h, 32h, 33h, 34h, 35h, 36h, 37h, 38h,	39h, 3Ah, 3Bh, 3Ch, 3Dh, 3Eh, 3Fh; 240
_d3cmp_baseAddr	dw 0
d3cmp_repeatCount	dw 0
_d3cmp_offset	dw 0
countMaybe	dd 0
		db 0
		db 0
word_4CC4B	dw 272h dup(0)
word_4D12F	dw 0
word_4D131	dw 0
word_4D133	dw 272h dup(0)
word_4D617	dw 0
word_4D619	dw 13Ah dup(0)
word_4D88D	dw 272h dup(0)
word_4DD71	dw 0
dataHeader	dd 0
		db    0
		db    0
		db    0
		db    0
d3comp_outputBuffer	db 103Bh dup(20h)	   ; 0
d3cmp_workBuf	dw 40h dup(0)		; 0
		db    0
		db    0
d3cmp_workBufIndex	dw	0
d3cmp_srcP	dd 0
		db    0
		db    0
		db    0
		db    0
d3cmp_destP	dd	0
word_4EE46	dw 0
word_4EE48	dw 0
word_4EE4A	dw 0
word_4EE4C	dw 0
word_4EE4E	dw 0
word_4EE50	dw 0


randomSeed	dw 0
g_locationNumber dw	0
dunLevelIndex	dw 0
g_dunLevelNum	dw 0
sq_north	dw 0
sq_east		dw 0
g_direction	dw 0
inDungeonMaybe	dw 0
g_mapRval dw 0
g_sameSquareFlag	dw 0
g_curSpellNumber	dw 0
g_gameProgressFlags	db 7 dup(0)     ; 0
byte_4EE71	db 0
		db    0
		db    0
		db    0
		db    0
		db    0
		db    0
		db    0
		db    0
g_vm_registers	dw 20h dup(0)	    ; 0
g_currentHour	db 0
lightDistance	db 0
g_songDuration	db 0
lightDuration		db 0
compassDuration		db 0
detectDuration		db 0
shieldDuration		db 0
levitationDuration	db 0
g_detectType		db 0
g_levelNumber	db 0
g_levelFlags	db 0
g_dunWidth	db 0
g_dunHeight	db 0
g_monsterGroupCount	db 0
g_partyAttackFlag	db 0
shieldAcBonus	db 0
byte_4EECC	db 0
minimapWallBitmasks db	0FFh,	0,	0,	0,	0,	0,	0,	0	; 0
		; 11111111
		; 00000000
		; 00000000
		; 00000000
		; 00000000
		; 00000000
		; 00000000
		; 00000000
		db	1,	1,	1,	1,	1,	1,	1,	1	; 1
		; 00000001
		; 00000001
		; 00000001
		; 00000001
		; 00000001
		; 00000001
		; 00000001
		; 00000001
		db	0,	0,	0,	0,	0,	0,	0,	0FFh	; 2
		; 00000000
		; 00000000
		; 00000000
		; 00000000
		; 00000000
		; 00000000
		; 00000000
		; 11111111
		db	80h,	80h,	80h,	80h,	80h,	80h,	80h,	80h	; 3
		; 10000000
		; 10000000
		; 10000000
		; 10000000
		; 10000000
		; 10000000
		; 10000000
		; 10000000
		db	6Bh,	8,	0,	0,	0,	0,	0,	0	; 4
		; 01101011
		; 00001000
		; 00000000
		; 00000000
		; 00000000
		; 00000000
		; 00000000
		; 00000000
		db	1,	1,	0,	6,	6,	0,	1,	1	; 5
		; 00000001
		; 00000001
		; 00000000
		; 00000110
		; 00000110
		; 00000000
		; 00000001
		; 00000001
		db	0,	0,	0,	0,	0,	0,	8,	6Bh	; 6
		; 00000000
		; 00000000
		; 00000000
		; 00000000
		; 00000000
		; 00000000
		; 00001000
		; 01101011
		db	80h,	80h,	0, 	30h,	30h,	0,	80h,	80h	; 7
		; 10000000
		; 10000000
		; 00000000
		; 00110000
		; 00110000
		; 00000000
		; 10000000
		; 10000000
		db	55h,	0,	0,	0,	0,	0,	0,	0	; 8
		; 01010101
		; 00000000
		; 00000000
		; 00000000
		; 00000000
		; 00000000
		; 00000000
		; 00000000
		db	1,	1,	0,	1,	1,	0,	1,	1	; 9
		; 00000001
		; 00000001
		; 00000000
		; 00000001
		; 00000001
		; 00000000
		; 00000001
		; 00000001
		db	0,	0,	0,	0,	0,	0,	0,	55h	; 10
		; 00000000
		; 00000000
		; 00000000
		; 00000000
		; 00000000
		; 00000000
		; 00000000
		; 01010101
		db	80h,	80h,	0,	80h,	80h,	0,	80h,	80h	; 11
		; 10000000
		; 10000000
		; 00000000
		; 10000000
		; 10000000
		; 00000000
		; 10000000
		; 10000000
		db	0,	0,	8,	1Ch,	1Ch,	8,	0,	0	; 12
		; 00000000
		; 00000000
		; 00001000
		; 00011100
		; 00011100
		; 00001000
		; 00000000
		; 00000000
		db 0, 66h, 3Ch, 18h, 18h, 3Ch, 66h, 0; 13 - minimap_X
		; 00000000
		; 01100110
		; 00111100
		; 00011000
		; 00011000
		; 00111100
		; 01100110
		; 00000000
		db 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh ; 14
		; 11111111
		; 11111111
		; 11111111
		; 11111111
		; 11111111
		; 11111111
		; 11111111
		; 11111111
		db 0, 0
s_faster		db 0Ah,'<Faster...>',0Ah,0
s_slower		db 0Ah,'<Slower...>',0Ah,0
txtDelayTable	db 1, 4, 7, 0Bh, 0Eh, 11h, 14h, 17h, 1Ah, 1Dh
txtDelayIndex	db 7
_clockTicks	dw 0
word_4EF49	dw 0
byte_4EF4B	db 0
byte_4EF4C	db 0
byte_4EF4D	db 0
align 4
byte_4EF50	db 0
byte_4EF51	db 0
byte_4EF52	db 0
byte_4EF53	db 0
spell_mouseClicked	db 0
mouse_moved	db 0
mouse_x		dw 0DCh
mouse_y		dw 0
word_4EF59	dw 0
word_4EF5B	dw 0
byte_4EF5D	db 0
byte_4EF5E	db 0
		db    0
		db    0
		db    0
		db    0
		db    0
		db    0
		db    0
		db    0
		db    0
		db    0
		db  0Ah
		db    0
		db    0
		db    0
		db    0
		db    0
word_4EF6F	dw 3F8h
		db    4
		db    0
		db    0
		db 0B8h	; 
		db    1
		db    0
		db    0
		db    0
byte_4EF79	db 1
byte_4EF7A	db 0
align 2
word_4EF7C	dw 0
word_4EF7E	dw 0
off_4EF80	dw offset sub_2843B
word_4EF82	dw 0
		dw seg dseg
		db 4Ch dup(0)
off_4EFD2	dw offset word_4EF82
aC_file_info	db ';C_FILE_INFO',0
dword_4EFE1	dd 0
		db 8 dup(0)
word_4EFED	dw 0
		db 4 dup(0)
word_4EFF3	dw 0
word_4EFF5	dw 0
		db 0
byte_4EFF8	db 0
align 2
word_4EFFA	dw 14h
byte_4EFFC	db 3 dup(81h), 2 dup(1), 0Fh dup(0)
word_4F010	dw 0
word_4F012	dw 0
word_4F014	dw 0
word_4F016	dw 0
word_4F018	dw 0
off_4F01A	dd unk_4F01E
unk_4F01E	db  43h	; C
		db    0
		db    0
		db    0
byte_4F022	db 0
byte_4F023	db 0
dword_4F024	dd 0
unk_4F028	db	0
		db    0
word_4F02A	dw 0
dword_4F02C	dd 0FFFFFFFFh
word_4F030	dw (offset dseg_end+102h)
dword_4F032	dd 0
byte_4F036	db 0, 16h, 2 dup(2), 18h
		db 0Dh, 9, 3 dup(0Ch), 7; 5
		db 8, 2 dup(16h), 0FFh, 12h; 11
		db 0Dh, 12h, 2, 0FFh    ; 16
word_4F04A	dw 0
byte_4F04C	db 200h dup(0)
byte_4F24C	db 200h dup(0)
byte_4F44C	db 200h dup(0)
off_4F64C	dw offset byte_4F04C
		dw seg dseg
		db    0
		db    0
		dd byte_4F04C
		db    1
		db    0
byte_4F658	db 0Ah dup(0), 2, 1
byte_4F664	db 0Ah dup(0), 2 dup(2), 0Ah dup(0), 84h, 3, 0Ah dup(0), 2, 4
		db 0A8h dup(0)
byte_4F730	db 0Ch dup(0)
byte_4F73C	db 1, 2 dup(0), 2, 74h dup(0)
word_4F7B4	dw offset byte_4F730
seg_4F7B6	dw seg dseg
word_4F7B8	dw 0
aNull		db '(null)',0
aNull_0		db '(null)',0
asc_4F7C8	db '+- #',0
align 2
word_4F7CE	dw 0
word_4F7D0	dw 0
align 4
word_4F7D4	dw 0
align 4
word_4F7D8	dw 0
word_4F7DA	dw 0
word_4F7DC	dw 0
word_4F7DE	dw 2000h
word_4F7E0	dw 0
byte_4F7E2	db 0
align 2
off_4F7E4	dd sub_284E6
off_4F7E8	dd sub_284E6
off_4F7EC	dd sub_284E6
off_4F7F0	dd sub_284E6
off_4F7F4	dd sub_284E6
		db    0
		db    0
		db    0
		db    0
		db    1
		db    1
		db    0
sscanf_charFlags	db 32, 32, 32, 32, 32, 32, 32, 32
		db 32, 40, 40, 40, 40, 40, 32, 32
		db 32, 32, 32, 32, 32, 32, 32, 32
		db 32, 32, 32, 32, 32, 32, 32, 32
		db 72, 16, 16, 16, 16, 16, 16, 16
		db 16, 16, 16, 16, 16, 16, 16, 16
		db 132,	132, 132, 132, 132, 132, 132, 132
		db 132,	132, 16, 16, 16, 16, 16, 16
		db 16, 129, 129, 129, 129, 129,	129, 1
		db 1, 1, 1, 1, 1, 1, 1,	1
		db 1, 1, 1, 1, 1, 1, 1,	1
		db 1, 1, 1, 16,	16, 16,	16, 16
		db 16, 130, 130, 130, 130, 130,	130, 2
		db 2, 2, 2, 2, 2, 2, 2,	2
		db 2, 2, 2, 2, 2, 2, 2,	2
		db 2, 2, 2, 16,	16, 16,	16, 32
		db 0, 0, 0, 0, 0, 0, 0,	0
		db 0, 0, 0, 0, 0, 0, 0,	0
		db 0, 0, 0, 0, 0, 0, 0,	0
		db 0, 0, 0, 0, 0, 0, 0,	0
		db 0, 0, 0, 0, 0, 0, 0,	0
		db 0, 0, 0, 0, 0, 0, 0,	0
		db 0, 0, 0, 0, 0, 0, 0,	0
		db 0, 0, 0, 0, 0, 0, 0,	0
		db 0, 0, 0, 0, 0, 0, 0,	0
		db 0, 0, 0, 0, 0, 0, 0,	0
		db 0, 0, 0, 0, 0, 0, 0,	0
		db 0, 0, 0, 0, 0, 0, 0,	0
		db 0, 0, 0, 0, 0, 0, 0,	0
		db 0, 0, 0, 0, 0, 0, 0,	0
		db 0, 0, 0, 0, 0, 0, 0,	0
		db 0, 0, 0, 0, 0, 0, 0,	0
		db 0
word_4F900	dw 0FFFFh
align 4
unk_4F904	db	0
db    0
word_4F906	dw 0
dword_4F908	dd 0
dword_4F90C	dd 0
off_4F910	dd sub_28846
seg027_41	dw seg seg027
dseg_x		dw seg dseg
seg027_x	dw seg	seg027
seg022_x	dw seg	seg022
seg023_x	dw seg seg023
aNmsg		db '<<NMSG>>',0
align 2
aR6000StackOver	db 'R6000',0Dh,0Ah
		db '- stack overflow',0Dh,0Ah,0
		db    3
		db    0
		db  52h	; R
		db  36h	; 6
		db  30h	; 0
		db  30h	; 0
		db  33h	; 3
		db  0Dh
		db  0Ah
		db  2Dh	; -
		db  20h
		db  69h	; i
		db  6Eh	; n
		db  74h	; t
		db  65h	; e
		db  67h	; g
		db  65h	; e
		db  72h	; r
		db  20h
		db  64h	; d
		db  69h	; i
		db  76h	; v
		db  69h	; i
		db  64h	; d
		db  65h	; e
		db  20h
		db  62h	; b
		db  79h	; y
		db  20h
		db  30h	; 0
		db  0Dh
		db  0Ah
		db    0
		db    9
		db    0
		db  52h	; R
		db  36h	; 6
		db  30h	; 0
		db  30h	; 0
		db  39h	; 9
		db  0Dh
		db  0Ah
		db  2Dh	; -
		db  20h
		db  6Eh	; n
		db  6Fh	; o
		db  74h	; t
		db  20h
		db  65h	; e
		db  6Eh	; n
		db  6Fh	; o
		db  75h	; u
		db  67h	; g
		db  68h	; h
		db  20h
		db  73h	; s
		db  70h	; p
		db  61h	; a
		db  63h	; c
		db  65h	; e
		db  20h
		db  66h	; f
		db  6Fh	; o
		db  72h	; r
		db  20h
		db  65h	; e
		db  6Eh	; n
		db  76h	; v
		db  69h	; i
		db  72h	; r
		db  6Fh	; o
		db  6Eh	; n
		db  6Dh	; m
		db  65h	; e
		db  6Eh	; n
		db  74h	; t
		db  0Dh
		db  0Ah
		db    0
		db 0FCh	; 
		db    0
		db  0Dh
		db  0Ah
		db    0
		db 0FFh
		db    0
		db  72h	; r
		db  75h	; u
		db  6Eh	; n
		db  2Dh	; -
		db  74h	; t
		db  69h	; i
		db  6Dh	; m
		db  65h	; e
		db  20h
		db  65h	; e
		db  72h	; r
		db  72h	; r
		db  6Fh	; o
		db  72h	; r
		db  20h
		db    0
		db    2
		db    0
		db  52h	; R
		db  36h	; 6
		db  30h	; 0
		db  30h	; 0
		db  32h	; 2
		db  0Dh
		db  0Ah
		db  2Dh	; -
		db  20h
		db  66h	; f
		db  6Ch	; l
		db  6Fh	; o
		db  61h	; a
		db  74h	; t
		db  69h	; i
		db  6Eh	; n
		db  67h	; g
		db  20h
		db  70h	; p
		db  6Fh	; o
		db  69h	; i
		db  6Eh	; n
		db  74h	; t
		db  20h
		db  6Eh	; n
		db  6Fh	; o
		db  74h	; t
		db  20h
		db  6Ch	; l
		db  6Fh	; o
		db  61h	; a
		db  64h	; d
		db  65h	; e
		db  64h	; d
		db  0Dh
		db  0Ah
		db    0
		db    1
		db    0
		db  52h	; R
		db  36h	; 6
		db  30h	; 0
		db  30h	; 0
		db  31h	; 1
		db  0Dh
		db  0Ah
		db  2Dh	; -
		db  20h
		db  6Eh	; n
		db  75h	; u
		db  6Ch	; l
		db  6Ch	; l
		db  20h
		db  70h	; p
		db  6Fh	; o
		db  69h	; i
		db  6Eh	; n
		db  74h	; t
		db  65h	; e
		db  72h	; r
		db  20h
		db  61h	; a
		db  73h	; s
		db  73h	; s
		db  69h	; i
		db  67h	; g
		db  6Eh	; n
		db  6Dh	; m
		db  65h	; e
		db  6Eh	; n
		db  74h	; t
		db  0Dh
		db  0Ah
		db    0
		db 0FFh
		db 0FFh
		db 0FFh
		db    0
g_tavernSayingBase	dw 0
tav_drunkLevel	db 8 dup(0)	       ; 0
curStrByte	db ?
align 2
dataBufOff	dw ?
dataBufSeg	dw ?
bitsLeft	dw ?
_str_capFlag	dw	?
align 4
word_4FD6C	dw ?
sscanf_structP	dd ?
word_4FD72	dw ?
word_4FD74	dw ?
sscanf_argSizeFlag	dw ?
sscanf_charListFlag	dw ?
word_4FD7A	dw ?
dword_4FD7C	dd ?
sscanf_bufp	dd ?
word_4FD84	dw ?
sscanf_buf	db 100h dup(?)
sscanf_minWidth dw ?
sscanf_noAssign dw ?
word_4FE8A	dw ?
word_4FE8C	dw ?
_sscanf_floatBuf	db 42h dup(?)
word_4FED0	dw ?
word_4FED2	dw ?
word_4FED4	dw ?
dword_4FED6	dd ?
word_4FEDA	dw ?
word_4FEDC	dw ?
word_4FEDE	dw ?
word_4FEE0	dw ?
byte_4FEE2	db 0Ch dup(?)
word_4FEEE	dw ?
dword_4FEF0	dd ?
word_4FEF4	dw ?
word_4FEF6	dw ?
word_4FEF8	dw ?
word_4FEFA	dw ?
word_4FEFC	dw ?
word_4FEFE	dw ?
word_4FF00	dw ?
word_4FF02	dw ?
word_4FF04	dw ?
word_4FF06	dw ?
byte_4FF08	db 15Eh dup(?)
word_50066	dw ?
word_50068	dw ?
byte_5006A	db 4 dup(?)
dseg_end	db ?
		db ?
align 8


dseg ends

; Segment type: Uninitialized
seg029 segment word stack 'STACK' use16
        assume cs:seg029
        assume es:nothing, ss:nothing, ds:dseg, fs:nothing, gs:nothing
byte_50070 db 0FA0h dup(?)
seg029 ends

end start
